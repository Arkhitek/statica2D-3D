// Êú®ÊùêÂü∫Ê∫ñÂº∑Â∫¶„Éá„Éº„Çø (N/mm¬≤)
const WOOD_BASE_STRENGTH_DATA = {
    "Matsu_Group": { name: "„ÅÇ„Åã„Åæ„Å§„ÄÅ„Åè„Çç„Åæ„Å§„ÄÅ„Åπ„ÅÑ„Åæ„Å§", fc: 22.2, ft: 17.7, fb: 28.2, fs: 2.4 },
    "Hinoki_Group": { name: "„Åã„Çâ„Åæ„Å§„ÄÅ„Å≤„Å∞„ÄÅ„Å≤„ÅÆ„Åç„ÄÅ„Åπ„ÅÑ„Å≤", fc: 20.7, ft: 16.2, fb: 26.7, fs: 2.1 },
    "Tsuga_Group": { name: "„Å§„Åå„ÄÅ„Åπ„ÅÑ„Å§„Åå", fc: 19.2, ft: 14.7, fb: 25.2, fs: 2.1 },
    "Sugi_Group": { name: "„ÇÇ„Åø„ÄÅ„Åà„Åû„Åæ„Å§„ÄÅ„Åô„Åé„ÄÅ„Åπ„ÅÑ„Åô„ÅéÁ≠â", fc: 17.7, ft: 13.5, fb: 22.2, fs: 1.8 },
    "Kashi": { name: "„Åã„Åó", fc: 20.7, ft: 16.2, fb: 26.7, fs: 4.2 },
    "Keyaki_Group": { name: "„Åè„Çä„ÄÅ„Å™„Çâ„ÄÅ„Å∂„Å™„ÄÅ„Åë„ÇÑ„Åç", fc: 19.2, ft: 14.7, fb: 25.2, fs: 3.0 }
};

// ÊùêÊñôÂØÜÂ∫¶„Éá„Éº„Çø (kg/m¬≥)
const MATERIAL_DENSITY_DATA = {
    // ÈáëÂ±ûÊùêÊñô
    "205000": 7850,    // „Çπ„ÉÅ„Éº„É´
    "193000": 7900,    // „Çπ„ÉÜ„É≥„É¨„Çπ
    "70000": 2700,     // „Ç¢„É´„Éü„Éã„Ç¶„É†
    
    // Êú®Êùê
    "7000": 400,       // ËªüÊùêÔºàÊùâ„ÄÅ„ÇÇ„ÅøÁ≠âÔºâ
    "8000": 500,       // ‰∏≠Á°¨ÊùêÔºàÊùæÈ°û„ÄÅ„Å§„ÅåÁ≠âÔºâ
    "9000": 550,       // „ÇÑ„ÇÑÁ°¨ÊùêÔºà„Ç´„É©„Éû„ÉÑ„ÄÅÊ™úÁ≠âÔºâ
    "10000": 800,      // Á°¨ÊùêÔºàÊ®´Ôºâ
    
    // „Éá„Éï„Ç©„É´„ÉàÂÄ§
    "custom": 7850     // ‰ªªÊÑèÂÖ•ÂäõÊôÇ„ÅÆ„Éá„Éï„Ç©„É´„ÉàÔºà„Çπ„ÉÅ„Éº„É´Áõ∏ÂΩìÔºâ
};

// Ë®≠ÂÆö„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà
const CONFIG = {
    validation: {
        minPositiveValue: 0.001,
        maxDimension: 10000,
        maxMemberCount: 1000,
        maxNodeCount: 1000
    },
    ui: {
        animationDuration: 200,
        errorDisplayTime: 300
    }
};

// Âçò‰Ωç„ÉªÂÆöÊï∞Â§âÊèõ„ÉÜ„Éº„Éñ„É´
const UNIT_CONVERSION = {
    // „Çª„É≥„ÉÅ„É°„Éº„Éà„É´ ‚Üí „Éü„É™„É°„Éº„Éà„É´ / „É°„Éº„Éà„É´ „ÅÆÁ∞°ÊòìÂ§âÊèõ
    CM_TO_M: 0.01,
    CM2_TO_M2: 1e-4,
    CM3_TO_M3: 1e-6,
    CM4_TO_M4: 1e-8,

    // cm ‚Üí mm Á≥ª
    CM2_TO_MM2: 1e2,
    CM3_TO_MM3: 1e3,
    CM4_TO_MM4: 1e4,

    // ÊùêÊñôÂÆöÊï∞Ôºà‰ª£Ë°®ÂÄ§Ôºâ
    // „É¶„Éº„Ç∂„Éá„Éº„Çø„Å´‰æùÂ≠ò„Åô„ÇãÂ†¥Âêà„ÅØ‰∏äÊõ∏„Åç„Åï„Çå„Çã„Åå„ÄÅ„Éá„Éï„Ç©„É´„ÉàÂÄ§„Å®„Åó„Å¶Áî®„ÅÑ„Çã
    E_STEEL: 205000, // N/mm¬≤ (205 GPa)
    // „Éù„Ç¢„ÇΩ„É≥ÊØî ŒΩ = 0.3 „Çí‰ªÆÂÆö„Åó„Å¶„Åõ„ÇìÊñ≠ÂºæÊÄß‰øÇÊï∞ G „ÇíË®≠ÂÆö
    G_STEEL: 205000 / (2 * (1 + 0.3)) // ‚âí 79,230 N/mm¬≤
};

// ‚ñº‚ñº‚ñº‚ñº‚ñº ËøΩÂä†: Ëá™ÈáçË®àÁÆó„É≠„Ç∏„ÉÉ„ÇØ (calculateSelfWeight)
const calculateSelfWeight = {
    calculateAllSelfWeights: (nodes, members, checkbox, tbody) => {
        const memberSelfWeights = [];
        const nodeSelfWeights = [];

        if (!checkbox || !checkbox.checked) {
            return { memberSelfWeights, nodeSelfWeights };
        }

        members.forEach((member, index) => {
            const A = member.A;
            if (!A || A <= 0) return;

            let density = 7850;
            if (tbody && tbody.rows[index]) {
                const row = tbody.rows[index];
                const densityInput = row.querySelector('.density-cell input');
                if (densityInput) {
                    const v = parseFloat(densityInput.value);
                    if (!isNaN(v)) density = v;
                } else {
                    const eValue = member.E ? (member.E / 1000).toString() : null;
                    if (eValue && MATERIAL_DENSITY_DATA[eValue]) {
                        density = MATERIAL_DENSITY_DATA[eValue];
                    }
                }
            }
            if (isNaN(density)) density = 7850;

            const g = 9.80665;
            const weightPerMeter = -(A * density * g) / 1000;

            const n1 = nodes[member.i];
            const n2 = nodes[member.j];
            if (!n1 || !n2) return;
            const dx = n2.x - n1.x;
            const dy = n2.y - n1.y;
            const length = Math.sqrt(dx * dx + dy * dy);
            if (length === 0) return;

            if (Math.abs(dy) < 1e-6) {
                // Ê∞¥Âπ≥ÈÉ®ÊùêÔºö„ÇΩ„É´„Éê„Éº„ÅÆÊ∏õÁÆó„É≠„Ç∏„ÉÉ„ÇØ„Å´Âêà„Çè„Åõ„ÄÅ‰∏ãÂêë„Åç„ÇíÊ≠£„Åó„ÅÑÊñπÂêë„Å´‰ΩúÁî®„Åï„Åõ„Çã„Åü„ÇÅÁ¨¶Âè∑„ÇíÂèçËª¢„Åó„Å¶Ê∏°„Åô
                memberSelfWeights.push({ memberIndex: index, w: -weightPerMeter, loadType: 'distributed' });
            } else if (Math.abs(dx) < 1e-6) {
                // ÂûÇÁõ¥ÈÉ®ÊùêÔºöÁØÄÁÇπËç∑Èáç„Å®„Åó„Å¶Âä†ÁÆó„Åô„ÇãÂá¶ÁêÜÂÅ¥„ÅåË≤†„ÅÆÂÄ§„ÇíÊúüÂæÖ„Åó„Å¶„ÅÑ„Çã„Åü„ÇÅ„ÄÅÊó¢Â≠ò„ÅÆ„Åæ„Åæ
                const totalWeight = weightPerMeter * length;
                nodeSelfWeights.push({ nodeIndex: member.i, px: 0, py: totalWeight / 2, mz: 0 });
                nodeSelfWeights.push({ nodeIndex: member.j, px: 0, py: totalWeight / 2, mz: 0 });
                memberSelfWeights.push({ memberIndex: index, w: 0, totalWeight: Math.abs(totalWeight), loadType: 'concentrated' });
            } else {
                // Êñú„ÇÅÈÉ®ÊùêÔºöÂûÇÁõ¥ÊàêÂàÜ„ÅÆ„Åø„ÇíÁ≠âÂàÜÂ∏ÉËç∑Èáç„Å®„Åó„Å¶Êâ±„ÅÜ„Åü„ÇÅÁ¨¶Âè∑„ÇíÂèçËª¢„Åó„Å¶Ê∏°„Åô
                const wy = -weightPerMeter * (Math.abs(dx) / length);
                memberSelfWeights.push({ memberIndex: index, w: wy, loadType: 'mixed', horizontalComponent: 0 });
            }
        });

        return { memberSelfWeights, nodeSelfWeights };
    }
};

// parseInputs „Çí„Éà„ÉÉ„Éó„É¨„Éô„É´„ÅÆÈñ¢Êï∞„Å®„Åó„Å¶ÂÆöÁæ©ÔºàCONFIG ÂÜÖ„Å´Âüã„ÇÅËæº„Åæ„Çå„Å¶„ÅÑ„Åü„ÇÇ„ÅÆ„ÇíÂàá„ÇäÂá∫„ÅóÔºâ
const parseInputs = () => {
    // console.log('üîç parseInputs called'); // „Éá„Éê„ÉÉ„Ç∞Áî®

    if (window.isLoadingPreset) {
        return { nodes: [], members: [], nodeLoads: [], memberLoads: [], memberSelfWeights: [], nodeSelfWeights: [] };
    }

    // ÁØÄÁÇπ„Éá„Éº„Çø„ÅÆË™≠„ÅøÂèñ„ÇäÔºàÂ§âÊõ¥„Å™„ÅóÔºâ
    const nodes = Array.from(elements.nodesTable.rows).map((row, i) => {
        const xInput = row.cells[1]?.querySelector('input');
        const yInput = row.cells[2]?.querySelector('input');
        const supportSelect = row.cells[3]?.querySelector('select');

        if (!xInput || !yInput || !supportSelect) throw new Error(`ÁØÄÁÇπ ${i + 1}: ÂÖ•Âäõ„Éï„Ç£„Éº„É´„Éâ„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì`);

        const dx_forced_mm = parseFloat(row.cells[4]?.querySelector('input')?.value) || 0;
        const dy_forced_mm = parseFloat(row.cells[5]?.querySelector('input')?.value) || 0;
        const r_forced_rad = parseFloat(row.cells[6]?.querySelector('input')?.value) || 0;

        return {
            id: i + 1,
            x: parseFloat(xInput.value),
            y: parseFloat(yInput.value),
            support: supportSelect.value,
            dx_forced: dx_forced_mm / 1000,
            dy_forced: dy_forced_mm / 1000,
            r_forced: r_forced_rad
        };
    });

    // ÈÉ®Êùê„Éá„Éº„Çø„ÅÆË™≠„ÅøÂèñ„Çä
    const members = Array.from(elements.membersTable.rows).map((row, index) => {
        // Âü∫Êú¨ÊÉÖÂ†±„ÅÆÂèñÂæó
        const iNodeInput = row.cells[1]?.querySelector('input');
        const jNodeInput = row.cells[2]?.querySelector('input');

        if (!iNodeInput || !jNodeInput) throw new Error(`ÈÉ®Êùê ${index + 1}: ÁØÄÁÇπÁï™Âè∑ÂÖ•Âäõ„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì`);

        const i = parseInt(iNodeInput.value) - 1;
        const j = parseInt(jNodeInput.value) - 1;

        // ÂºæÊÄß‰øÇÊï∞
        const e_select = row.cells[3]?.querySelector('select');
        const e_input = row.cells[3]?.querySelector('input[type="number"]');
        let E = (e_select.value === 'custom' ? parseFloat(e_input?.value || 0) : parseFloat(e_select.value)) * 1000;

        // ÊùêÊñôÂêç
        const getMaterialName = (sel) => {
            if(!sel || sel.selectedIndex < 0) return '‰∏çÊòé„Å™ÊùêÊñô';
            const opt = sel.options[sel.selectedIndex];
            if(opt.value === 'custom') {
                const ev = parseFloat(e_input?.value||0);
                return `‰ªªÊÑèÊùêÊñô(E=${(ev/1000).toLocaleString()}GPa)`;
            }
            return opt.textContent || '‰∏çÊòé„Å™ÊùêÊñô';
        };
        const material = getMaterialName(e_select);

        // Âº∑Â∫¶
        const strengthContainer = row.cells[4].firstElementChild;
        let strengthProps = { type: strengthContainer?.dataset.strengthType || 'unknown' };
        // ... (Âº∑Â∫¶Ë™≠„ÅøÂèñ„Çä„É≠„Ç∏„ÉÉ„ÇØ„ÅØÊó¢Â≠ò„ÅÆ„Åæ„Åæ) ...
        if (strengthProps.type === 'wood-type') {
            const presetSelect = strengthContainer.querySelector('select');
            if(presetSelect) {
                strengthProps.preset = presetSelect.value;
                if(presetSelect.value === 'custom') {
                    // „Ç´„Çπ„Çø„É†ÂÄ§„ÅÆË™≠„ÅøÂèñ„ÇäÂá¶ÁêÜ...
                    const inputs = strengthContainer.querySelectorAll('input');
                    if(inputs.length >= 4) {
                        strengthProps.baseStrengths = {
                            ft: parseFloat(inputs[0].value),
                            fc: parseFloat(inputs[1].value),
                            fb: parseFloat(inputs[2].value),
                            fs: parseFloat(inputs[3].value)
                        };
                    }
                }
            }
        } else {
            const sInput = strengthContainer.querySelector('input');
            if(sInput) strengthProps.value = parseFloat(sInput.value);
        }

        // Êñ≠Èù¢ÊÄßËÉΩ (I, A, Z) + ‰ΩéÊ∏õ‰øÇÊï∞
        const iMomentInput = row.cells[5]?.querySelector('.section-I-input');
        const iMomentFactorInput = row.cells[5]?.querySelector('.section-I-factor');
        const aAreaInput = row.cells[6]?.querySelector('.section-A-input');
        const aAreaFactorInput = row.cells[6]?.querySelector('.section-A-factor');
        const zSectionInput = row.cells[7]?.querySelector('.section-Z-input');
        const zSectionFactorInput = row.cells[7]?.querySelector('.section-Z-factor');

        const safeFactor = (el) => {
            const v = parseFloat(el?.value);
            return Number.isFinite(v) ? v : 1.0;
        };

        const I = (parseFloat(iMomentInput?.value) * safeFactor(iMomentFactorInput)) * 1e-8;
        const A = (parseFloat(aAreaInput?.value) * safeFactor(aAreaFactorInput)) * 1e-4;
        const Z = (parseFloat(zSectionInput?.value) * safeFactor(zSectionFactorInput)) * 1e-6;

        // Â∫ßÂ±à‰øÇÊï∞K („ÇØ„É©„ÇπÂêç„ÅßÂèñÂæó)
        let bucklingK = null;
        const kEl = row.querySelector('.buckling-k-input');
        if (kEl && kEl.value !== '') bucklingK = parseFloat(kEl.value);

        // Êé•ÂêàÊù°‰ª∂ („ÇØ„É©„ÇπÂêç„ÅßÂèñÂæó)
        const connSelects = row.querySelectorAll('.conn-select');
        const iConnSelect = connSelects[0];
        const jConnSelect = connSelects[1];
        const i_conn = iConnSelect ? iConnSelect.value : 'rigid';
        const j_conn = jConnSelect ? jConnSelect.value : 'rigid';

        // „Äê‰øÆÊ≠£ÁÆáÊâÄ„ÄëÊñ≠Èù¢ÂêçÁß∞„ÉªËª∏ÊÉÖÂ†±„ÅÆÂèñÂæóÔºà„ÇØ„É©„ÇπÂêç„Çí‰ΩøÁî®Ôºâ
        const sectionNameSpan = row.querySelector('.section-name-cell');
        const sectionAxisSpan = row.querySelector('.section-axis-cell');
        const sectionName = sectionNameSpan ? sectionNameSpan.textContent : '';
        const sectionAxisText = sectionAxisSpan ? sectionAxisSpan.textContent : '';

        // Êñ≠Èù¢Ë©≥Á¥∞ÊÉÖÂ†± (dataset„Åã„ÇâÂèñÂæó)
        let sectionInfo = null;
        let sectionAxis = null;
        if (row.dataset.sectionInfo) {
            try {
                const raw = row.dataset.sectionInfo;
                // raw „ÅØ encodeURIComponent(JSON.stringify(...)) „ÅÆÂèØËÉΩÊÄß„ÇÑ„ÄÅ
                // „Åù„ÅÆ„Åæ„Åæ JSON ÊñáÂ≠óÂàó„ÅÆÂèØËÉΩÊÄß„Åå„ÅÇ„Çã„Åü„ÇÅÈ†Ü„Å´Ë©¶„Åô
                let parsed = null;
                try {
                    // „Åæ„Åö„Éá„Ç≥„Éº„Éâ„Åó„Å¶ JSON.parse „ÇíË©¶„Åô
                    const dec = decodeURIComponent(raw);
                    parsed = JSON.parse(dec);
                } catch (_) {
                    try {
                        // „Éá„Ç≥„Éº„ÉâÂ§±Êïó„Åæ„Åü„ÅØ dec „Åå JSON „Åß„Å™„ÅÑÂ†¥Âêà„ÄÅÁîü„ÅÆ raw „ÇíÁõ¥Êé•„Éë„Éº„Çπ
                        parsed = JSON.parse(raw);
                    } catch (__){
                        parsed = null;
                    }
                }
                sectionInfo = parsed;
            } catch (e) {
                console.warn(`ÈÉ®Êùê ${index+1}: sectionInfo„Éë„Éº„ÇπÂ§±Êïó`, e);
            }
        }

        // Ëª∏ÊÉÖÂ†±„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÅÆÊßãÁØâ
        if (row.dataset.sectionAxisKey) {
            sectionAxis = {
                key: row.dataset.sectionAxisKey,
                mode: row.dataset.sectionAxisMode,
                label: row.dataset.sectionAxisLabel || sectionAxisText
            };
        }

        // „Åù„ÅÆ‰ªñ„ÅÆdatasetÂ±ûÊÄß
        const Zx = parseFloat(row.dataset.zx) * 1e-6;
        const Zy = parseFloat(row.dataset.zy) * 1e-6;

        // Ê®™Â∫ßÂ±àÁ≠â„Å´‰Ωø„ÅÜÊñ≠Èù¢ÁâπÊÄßÔºàÈãºÊùêDBÁî±Êù•ÊÉ≥ÂÆöÔºâ
        // dataset„ÅØÂü∫Êú¨ÁöÑ„Å´„ÄåcmÁ≥ª„Äç(Ix/Iy/J: cm^4, Iw: cm^6) „Çí‰øùÊåÅ„Åô„ÇãÂâçÊèê
        const Ix = (row.dataset.ixMom !== undefined && row.dataset.ixMom !== '') ? (parseFloat(row.dataset.ixMom) * 1e-8) : undefined; // m^4
        const Iy = (row.dataset.iyMom !== undefined && row.dataset.iyMom !== '') ? (parseFloat(row.dataset.iyMom) * 1e-8) : undefined; // m^4
        const J = (row.dataset.j !== undefined && row.dataset.j !== '') ? (parseFloat(row.dataset.j) * 1e-8) : undefined; // m^4
        const Iw = (row.dataset.iw !== undefined && row.dataset.iw !== '') ? (parseFloat(row.dataset.iw) * 1e-12) : undefined; // m^6
        let ix = parseFloat(row.dataset.ix);
        let iy = parseFloat(row.dataset.iy);

        if (isNaN(ix)) ix = Math.sqrt(I/A) * 100; // cmÊé®ÂÆö
        if (isNaN(iy)) iy = ix;

        ix *= 1e-2; // m
        iy *= 1e-2; // m

        // Êñ≠Èù¢2Ê¨°ÂçäÂæÑ i_radius „ÇíÂàùÊúüÂåñÔºàm Âçò‰ΩçÔºâ ‚Äî ix/iy „ÅÆÊúÄÂ∞èÂÄ§„ÇíÂà©Áî®
        let i_radius = null;
        if (!isNaN(ix) && !isNaN(iy)) {
            i_radius = Math.min(ix, iy);
        } else if (!isNaN(ix)) {
            i_radius = ix;
        } else if (!isNaN(iy)) {
            i_radius = iy;
        }

        // „Éê„ÉçÂÆöÊï∞„ÅÆË™≠„ÅøÂèñ„Çä
        const EPS_SPRING = 1e-9;
        const readSpring = (cell) => {
            if (!cell) return null;
            const container = cell.querySelector('.spring-inputs');
            if (!container) return null;
            const kx = parseFloat(container.querySelector('.spring-kx')?.value || 0);
            const ky = parseFloat(container.querySelector('.spring-ky')?.value || 0);
            const kr = parseFloat(container.querySelector('.spring-kr')?.value || 0);
            const rKx = container.querySelector('.spring-rigid-kx')?.checked;
            const rKy = container.querySelector('.spring-rigid-ky')?.checked;
            const rKr = container.querySelector('.spring-rigid-kr')?.checked;

            const Kx_val = kx * 1000; // kN/m
            const Ky_val = ky * 1000;
            const Kr_val = kr * 1e-3; // kN¬∑m

            if (!rKx && !rKy && Kx_val===0 && Ky_val===0) {
                return { Kx: EPS_SPRING, Ky: EPS_SPRING, Kr: Kr_val, rigidKx:rKx, rigidKy:rKy, rigidKr:rKr };
            }
            return { Kx: Kx_val, Ky: Ky_val, Kr: Kr_val, rigidKx:rKx, rigidKy:rKy, rigidKr:rKr };
        };

        const iConnCell = iConnSelect ? iConnSelect.closest('.conn-cell') : null;
        const jConnCell = jConnSelect ? jConnSelect.closest('.conn-cell') : null;

        let spring_i = (i_conn === 'spring') ? (readSpring(iConnCell) || {Kx:0,Ky:0,Kr:0}) : {Kx:0,Ky:0,Kr:0};
        let spring_j = (j_conn === 'spring') ? (readSpring(jConnCell) || {Kx:0,Ky:0,Kr:0}) : {Kx:0,Ky:0,Kr:0};

        // Â∫ßÊ®ôË®àÁÆó
        const ni = nodes[i];
        const nj = nodes[j];
        if(!ni || !nj) return null;

        const dx = nj.x - ni.x;
        const dy = nj.y - ni.y;
        const L = Math.sqrt(dx*dx + dy*dy);
        const c = dx/L;
        const s = dy/L;
        const T = [[c,s,0,0,0,0], [-s,c,0,0,0,0], [0,0,1,0,0,0], [0,0,0,c,s,0], [0,0,0,-s,c,0], [0,0,0,0,0,1]];

        // ÂâõÊÄß„Éû„Éà„É™„ÉÉ„ÇØ„ÇπË®àÁÆó„ÅØÊó¢Â≠ò„É≠„Ç∏„ÉÉ„ÇØ„ÇíÂà©Áî® („Åì„Åì„Åß„ÅØÁúÅÁï•„ÄÅÊó¢Â≠ò„Ç≥„Éº„Éâ„Åå„Åù„ÅÆ„Åæ„ÅæÂãï„Åè„ÅØ„Åö„Åß„Åô)
        // ... k_localË®àÁÆó ...

        return {
            i, j, E, strengthProps, I, A, Z, Zx, Zy, i_radius, ix, iy, length: L, c, s, T, 
            i_conn, j_conn, spring_i, spring_j, bucklingK,
            material, sectionName, sectionAxis: sectionAxisText, // „ÉÜ„Ç≠„Çπ„ÉàÊÉÖÂ†±„ÇÇ‰øùÂ≠ò
            sectionInfo, sectionAxis, // „Ç™„Éñ„Ç∏„Çß„ÇØ„ÉàÊÉÖÂ†±„ÇÇ‰øùÂ≠ò
            Ix, Iy, J, Iw
        };
    }).filter(m => m !== null);

    // Ëç∑Èáç„Éá„Éº„Çø„ÅÆË™≠„ÅøÂèñ„ÇäÔºàÂ§âÊõ¥„Å™„ÅóÔºâ
    const nodeLoads = Array.from(elements.nodeLoadsTable.rows).map((r) => { 
        const n = parseInt(r.cells[0].querySelector('input').value) - 1; 
        if (n < 0 || n >= nodes.length) return null;
        return { 
            nodeIndex: n, 
            px: parseFloat(r.cells[1].querySelector('input').value)||0, 
            py: parseFloat(r.cells[2].querySelector('input').value)||0, 
            mz: parseFloat(r.cells[3].querySelector('input').value)||0 
        }; 
    }).filter(l => l !== null);

    const memberLoads = Array.from(elements.memberLoadsTable.rows).map((r) => { 
        const m = parseInt(r.cells[0].querySelector('input').value) - 1; 
        if (m < 0 || m >= members.length) return null;
        return { memberIndex: m, w: parseFloat(r.cells[1].querySelector('input').value)||0 }; 
    }).filter(l => l !== null);

    // Ëá™ÈáçË®àÁÆóÂëº„Å≥Âá∫„Åó
    const considerSelfWeightCheckbox = document.getElementById('consider-self-weight-checkbox');
    const membersTableBody = document.getElementById('members-table').getElementsByTagName('tbody')[0];
    const { memberSelfWeights, nodeSelfWeights } = calculateSelfWeight.calculateAllSelfWeights(
        nodes, members, considerSelfWeightCheckbox, membersTableBody
    );

    return { nodes, members, nodeLoads, memberLoads, memberSelfWeights, nodeSelfWeights };
};

// Êñ≠Èù¢ÊÄßËÉΩ„ÅÆÂçò‰ΩçÂ§âÊèõÈñ¢Êï∞

// Ë§áÊï∞ÈÅ∏Êäû„Çí„ÇØ„É™„Ç¢„Åô„ÇãÈñ¢Êï∞
function clearMultiSelection() {
    console.log('Ë§áÊï∞ÈÅ∏Êäû„Çí„ÇØ„É™„Ç¢ - ‰ª•Ââç„ÅÆÁä∂ÊÖã:', {
        selectedNodes: Array.from(selectedNodes),
        selectedMembers: Array.from(selectedMembers)
    });
    selectedNodes.clear();
    selectedMembers.clear();
    isMultiSelecting = false;
    if (typeof drawOnCanvas === 'function') {
        drawOnCanvas();
    }
    console.log('Ë§áÊï∞ÈÅ∏Êäû„ÇØ„É™„Ç¢ÂÆå‰∫Ü');
}

// „Éá„Éê„ÉÉ„Ç∞Ë£úÂä©: ÂÖ®ÈÉ®Êùê„ÅÆ ix/iy „Çí‰∏ÄË¶ßË°®Á§∫„Åó„Å¶Ê¨†ËêΩ„Éª‰∏çÊï¥Âêà„ÇíÂ†±Âëä„Åô„ÇãÈñ¢Êï∞
window.checkSectionRadii = function() {
    try {
        const tbl = (typeof elements !== 'undefined' && elements.membersTable) ? elements.membersTable : (document.getElementById('members-table') || document.querySelector('table'));
        if (!tbl || !tbl.rows) {
            console.error('members table not found (elements.membersTable or #members-table)');
            return;
        }

        const rows = Array.from(tbl.rows);
        const report = [];
        rows.forEach((row, idx) => {
            // „ÉÜ„Éº„Éñ„É´Âàó„ÅÆ‰ΩçÁΩÆ„ÅØ„Ç≥„Éº„Éâ„Éô„Éº„Çπ„Å´‰æùÂ≠ò: 5:I,6:A,7:Z
            const Iui = row.cells[5]?.querySelector('input')?.value;
            const Aui = row.cells[6]?.querySelector('input')?.value;
            const name = row.querySelector('.section-name-cell')?.textContent?.trim() || `member#${idx+1}`;
            const dsix = row.dataset.ix;
            const dsiy = row.dataset.iy;

            const Ival = Iui ? parseFloat(Iui) : NaN; // I in cm^4
            const Aval = Aui ? parseFloat(Aui) : NaN; // A in cm^2

            let ix_cm = dsix !== undefined ? (dsix === '' ? NaN : parseFloat(dsix)) : NaN; // cm
            let iy_cm = dsiy !== undefined ? (dsiy === '' ? NaN : parseFloat(dsiy)) : NaN; // cm

            let ix_est_cm = NaN;
            if (!isNaN(Ival) && !isNaN(Aval) && Aval !== 0) {
                // I(cm^4)/A(cm^2) -> cm^2 -> sqrt -> cm
                ix_est_cm = Math.sqrt(Ival / Aval);
            }

            const entry = {
                index: idx+1,
                name: name,
                I_cm4: isNaN(Ival) ? null : Ival,
                A_cm2: isNaN(Aval) ? null : Aval,
                dataset_ix: dsix ?? null,
                dataset_iy: dsiy ?? null,
                ix_est_cm: isNaN(ix_est_cm) ? null : Number(ix_est_cm.toFixed(3)),
                ix_cm: isNaN(ix_cm) ? null : Number(ix_cm.toFixed(3)),
                iy_cm: isNaN(iy_cm) ? null : Number(iy_cm.toFixed(3)),
                warnings: []
            };

            // Ë≠¶ÂëäÊù°‰ª∂
            if (entry.dataset_ix === null && entry.dataset_iy === null) {
                entry.warnings.push('ix/iy „Åå dataset „Å´Êú™Ë®≠ÂÆöÔºàËá™ÂãïÊé®ÂÆö„Åå‰Ωø„Çè„Çå„Åæ„ÅôÔºâ');
            }
            if (entry.dataset_iy === undefined || entry.dataset_iy === '') {
                // ÈÉ®ÊùêÂêç„Å´ H/I „ÅåÂê´„Åæ„Çå„Å¶„ÅÑ„ÇãÂ†¥Âêà„ÅØÊ≥®ÊÑèÂñöËµ∑
                if (/\b(H|I)\b/.test(name) || /HÂΩ¢|IÂΩ¢/.test(name)) {
                    entry.warnings.push('Êñ≠Èù¢Âêç„Å´ H/I „ÅåÂê´„Åæ„Çå„ÇãÂèØËÉΩÊÄß„ÄÇiy „ÅåÊú™Ë®≠ÂÆö„Å†„Å®Âº±Ëª∏„ÅåÈÅéÂ§ßË©ï‰æ°„Åï„Çå„ÇãÂèØËÉΩÊÄß„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ');
                }
            }
            // ix/iy „ÅåÂÖ•Âäõ„Åï„Çå„Å¶„ÅÑ„Çã„ÅåÊé®ÂÆöÂÄ§„Å®Â§ß„Åç„ÅèÈÅï„ÅÜÂ†¥Âêà„ÅÆÊ≥®ÊÑè
            if (entry.ix_est_cm !== null && entry.ix_cm !== null) {
                const ratio = entry.ix_cm / entry.ix_est_cm;
                if (ratio > 2 || ratio < 0.5) {
                    entry.warnings.push(`ÂÖ•Âäõ ix „Åå I/A „Åã„ÇâÊé®ÂÆö„Åï„Çå„ÇãÂÄ§„Å®Â§ßÂπÖ„Å´Áï∞„Å™„Çä„Åæ„Åô (ratio=${ratio.toFixed(2)})`);
                }
            }
            if (entry.iy_cm !== null && entry.ix_cm !== null) {
                if (entry.iy_cm > entry.ix_cm) {
                    entry.warnings.push('iy > ix „Åß„Åô„ÄÇÂº±Ëª∏„ÅåÂº∑Ëª∏„Çà„ÇäÂ§ß„Åç„ÅèË®≠ÂÆö„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ');
                }
                if (entry.iy_cm === entry.ix_cm && entry.dataset_iy === undefined) {
                    entry.warnings.push('iy „ÅåÊú™Ë®≠ÂÆö„ÅÆ„Åü„ÇÅ ix „Å®Âêå„ÅòÂÄ§„Åå‰Ωø„Çè„Çå„Åæ„ÅôÔºàËá™ÂãïÔºâ„ÄÇHÂΩ¢Èãº„Åß„ÅØË¶ÅÁ¢∫Ë™ç„ÄÇ');
                }
            }

            report.push(entry);
        });

        // Âá∫Âäõ: „ÉÜ„Éº„Éñ„É´„Å®„Åó„Å¶Ë¶ã„ÇÑ„Åô„ÅèË°®Á§∫
        console.table(report.map(r => ({
            '#': r.index,
            name: r.name,
            I_cm4: r.I_cm4,
            A_cm2: r.A_cm2,
            dataset_ix: r.dataset_ix,
            dataset_iy: r.dataset_iy,
            ix_est_cm: r.ix_est_cm,
            ix_cm: r.ix_cm,
            iy_cm: r.iy_cm,
            warnings: r.warnings.length ? r.warnings.join(' | ') : ''
        })));

        // ËøΩÂä†: ÈáçÂ§ß„Å™Ë≠¶Âëä„Åå„ÅÇ„ÇãË°å„ÇíÂÄãÂà•„Å´„É≠„Ç∞
        report.forEach(r => {
            if (r.warnings.length) {
                console.warn(`ÈÉ®Êùê ${r.index} (${r.name}) „ÅÆË≠¶Âëä:`, r.warnings.join(' ; '));
            }
        });

        return report;
    } catch (e) {
        console.error('checkSectionRadii ÂÆüË°å‰∏≠„Å´„Ç®„É©„Éº', e);
    }
};

// ======================================================================
// Test harness: Ëá™Âãï„ÉÜ„Çπ„ÉàÁî®„ÅÆÁü≠Ê¢Å„ÉªÈï∑Ê¢Å„Ç±„Éº„Çπ„Çí„Éö„Éº„Ç∏‰∏ä„ÅßÂæ©ÂÖÉ„ÅóËß£Êûê„ÇíÂÆüË°å„Åó„Åæ„Åô
// ‰Ωø„ÅÑÊñπ: „Éñ„É©„Ç¶„Ç∂„Åß„Éö„Éº„Ç∏„ÇíÈñã„Åç„ÄÅ„Ç≥„É≥„ÇΩ„Éº„É´„Åß `runAutoTestCases()` „ÇíÂëº„Çì„Åß„Åè„Å†„Åï„ÅÑ„ÄÇ
// ======================================================================
window.runAutoTestCases = function() {
    try {
        console.log('runAutoTestCases: starting automated tests');

        // --- Áü≠Ê¢Å„Ç±„Éº„Çπ: Èï∑„Åï 1 m, Âõ∫ÂÆö-„Éî„É≥, Á≠âÂàÜÂ∏ÉËç∑Èáç w=5 kN/m ---
        const shortState = {
            nodes: [
                { x: 0, y: 0, support: 'fixed', dx_forced: 0, dy_forced: 0, r_forced: 0 },
                { x: 1, y: 0, support: 'pinned', dx_forced: 0, dy_forced: 0, r_forced: 0 }
            ],
            members: [
                { i: 0, j: 1, E: '205000', I: 8.333e-6, A: 1e-3, Z: 1e-3, i_conn: 'rigid', j_conn: 'rigid' }
            ],
            nodeLoads: [],
            memberLoads: [ { member: 1, w: 5 } ]
        };

        console.log('runAutoTestCases: restoring short beam state and running analysis');
        if (typeof restoreState === 'function') restoreState(shortState);
        if (typeof runFullAnalysis === 'function') runFullAnalysis();
        setTimeout(() => {
            console.log('Short beam results:', window.lastResults || 'no results');

            // --- Èï∑Ê¢Å„Ç±„Éº„Çπ: Èï∑„Åï 5 m, Âõ∫ÂÆö-„Éî„É≥, Á≠âÂàÜÂ∏ÉËç∑Èáç w=2 kN/m ---
            const longState = {
                nodes: [
                    { x: 0, y: 0, support: 'fixed', dx_forced: 0, dy_forced: 0, r_forced: 0 },
                    { x: 5, y: 0, support: 'pinned', dx_forced: 0, dy_forced: 0, r_forced: 0 }
                ],
                members: [
                    { i: 0, j: 1, E: '205000', I: 8.333e-6, A: 1e-3, Z: 1e-3, i_conn: 'rigid', j_conn: 'rigid' }
                ],
                nodeLoads: [],
                memberLoads: [ { member: 1, w: 2 } ]
            };

            console.log('runAutoTestCases: restoring long beam state and running analysis');
            if (typeof restoreState === 'function') restoreState(longState);
            if (typeof runFullAnalysis === 'function') runFullAnalysis();
            setTimeout(() => {
                console.log('Long beam results:', window.lastResults || 'no results');
                console.log('runAutoTestCases: finished');
            }, 1200);
        }, 1200);
    } catch (e) {
        console.error('runAutoTestCases error', e);
    }
};


// Âçò‰∏ÄÈÅ∏Êäû„Çí„ÇØ„É™„Ç¢„Åô„ÇãÈñ¢Êï∞
function clearSingleSelection() {
    console.log('Âçò‰∏ÄÈÅ∏Êäû„Çí„ÇØ„É™„Ç¢ - ‰ª•Ââç„ÅÆÁä∂ÊÖã:', {
        selectedNodeIndex,
        selectedMemberIndex
    });
    selectedNodeIndex = null;
    selectedMemberIndex = null;
    
    // windowÂ§âÊï∞„ÇÇÂêåÊúü
    window.selectedNodeIndex = null;
    window.selectedMemberIndex = null;
    
    if (typeof drawOnCanvas === 'function') {
        drawOnCanvas(); // „Éè„Ç§„É©„Ç§„ÉàË°®Á§∫„Çí„ÇØ„É™„Ç¢„Åô„Çã„Åü„ÇÅÂÜçÊèèÁîª
    }
    console.log('Âçò‰∏ÄÈÅ∏Êäû„ÇØ„É™„Ç¢ÂÆå‰∫Ü');
}

// ÈÅ∏Êäû„Åï„Çå„ÅüË¶ÅÁ¥†„ÇíË°®Á§∫„ÅßÂº∑Ë™ø„Åô„ÇãÈñ¢Êï∞
function highlightSelectedElements() {
    const canvas = document.getElementById("canvas") || document.getElementById("model-canvas");
    if (!canvas) {
        console.error('„Ç≠„É£„É≥„Éê„ÇπË¶ÅÁ¥†„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì');
        return;
    }
    
    const ctx = canvas.getContext("2d");
    if (!window.lastDrawingContext) {
        console.error('window.lastDrawingContext „ÅåÂà©Áî®„Åß„Åç„Åæ„Åõ„Çì');
        return;
    }
    
    try {
        const { nodes, members } = window.parseInputs();
        
        // Âçò‰∏ÄÈÅ∏ÊäûÂá¶ÁêÜÔºöÁØÄÁÇπ„ÅåÂÑ™ÂÖà„ÄÅÁØÄÁÇπ„Åå„Å™„ÅÑÂ†¥Âêà„ÅÆ„ÅøÈÉ®Êùê„ÇíË°®Á§∫
        const hasValidNode = window.selectedNodeIndex !== null && window.selectedNodeIndex >= 0;
        const hasValidMember = window.selectedMemberIndex !== null && window.selectedMemberIndex >= 0;
        
        if (hasValidNode) {
            // ÁØÄÁÇπ„ÅåÈÅ∏Êäû„Åï„Çå„Å¶„ÅÑ„ÇãÂ†¥Âêà„ÅØÁØÄÁÇπ„ÅÆ„Åø„ÇíÂº∑Ë™øÔºàÈùíËâ≤„ÅßÂº∑Ë™øÔºâ
            console.log('Âçò‰∏ÄÁØÄÁÇπÈÅ∏ÊäûÂá¶ÁêÜÈñãÂßã:', window.selectedNodeIndex);
            const nodeIndex = window.selectedNodeIndex; // 0„Éô„Éº„Çπ„ÅÆÈÖçÂàó„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ
            const node = nodes[nodeIndex];
            console.log('Âçò‰∏ÄÁØÄÁÇπÈÅ∏Êäû„ÉÅ„Çß„ÉÉ„ÇØ:', { selectedNodeIndex: window.selectedNodeIndex, nodeIndex, node, nodeExists: !!node });
            if (node) {
                const transformResult = window.lastDrawingContext.transform(node.x, node.y);
                console.log('Â§âÊèõÁµêÊûú:', { nodeCoords: {x: node.x, y: node.y}, transformResult });
                const drawX = transformResult.x;
                const drawY = transformResult.y;
                ctx.save();
                ctx.strokeStyle = '#0066ff';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.arc(drawX, drawY, 10, 0, 2 * Math.PI);
                ctx.stroke();
                ctx.restore();
                console.log('‚úÖ Âçò‰∏ÄÁØÄÁÇπÂº∑Ë™øË°®Á§∫ÂÆüË°å:', nodeIndex, { drawX, drawY });
            } else {
                console.log('‚ùå ÁØÄÁÇπ„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì:', nodeIndex);
            }
        } else if (hasValidMember) {
            // ÁØÄÁÇπ„ÅåÈÅ∏Êäû„Åï„Çå„Å¶„ÅÑ„Å™„ÅÑÂ†¥Âêà„ÅÆ„ÅøÈÉ®Êùê„ÇíÂº∑Ë™øÔºàÈùíËâ≤„ÅßÂº∑Ë™øÔºâ
            console.log('Âçò‰∏ÄÈÉ®ÊùêÈÅ∏ÊäûÂá¶ÁêÜÈñãÂßã:', window.selectedMemberIndex);
            const memberIndex = window.selectedMemberIndex; // 0„Éô„Éº„Çπ„ÅÆÈÖçÂàó„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ
            const member = members[memberIndex];
            console.log('Âçò‰∏ÄÈÉ®ÊùêÈÅ∏Êäû„ÉÅ„Çß„ÉÉ„ÇØ:', { selectedMemberIndex: window.selectedMemberIndex, memberIndex, member, memberExists: !!member });
            if (member) {
                const node1 = nodes[member.i];
                const node2 = nodes[member.j];
                if (node1 && node2) {
                    const pos1 = window.lastDrawingContext.transform(node1.x, node1.y);
                    const pos2 = window.lastDrawingContext.transform(node2.x, node2.y);
                    ctx.save();
                    ctx.strokeStyle = '#0066ff';
                    ctx.lineWidth = 5;
                    ctx.beginPath();
                    ctx.moveTo(pos1.x, pos1.y);
                    ctx.lineTo(pos2.x, pos2.y);
                    ctx.stroke();
                    ctx.restore();
                    console.log('‚úÖ Âçò‰∏ÄÈÉ®ÊùêÂº∑Ë™øË°®Á§∫ÂÆüË°å:', memberIndex, { pos1, pos2 });
                } else {
                    // ÈÅ∏Êäû„Åï„Çå„Åü„Éé„Éº„Éâ„ÅåË¶ã„Å§„Åã„Çâ„Å™„ÅÑÂ†¥Âêà„ÅØ„Çπ„Ç≠„ÉÉ„Éó
                }
            } else {
                // ÈÅ∏Êäû„Åï„Çå„ÅüÈÉ®Êùê„ÅåË¶ã„Å§„Åã„Çâ„Å™„ÅÑÂ†¥Âêà„ÅØ„Çπ„Ç≠„ÉÉ„Éó
            }
        } else {
            // Âçò‰∏ÄÈÅ∏Êäû„Åå„Å™„ÅÑÂ†¥Âêà
        }
        
        // Ë§áÊï∞ÈÅ∏Êäû„Åï„Çå„ÅüÁØÄÁÇπ„ÇíÂº∑Ë™øÔºàËµ§Ëâ≤„ÅßÂº∑Ë™øÔºâ
        if (window.selectedNodes && window.selectedNodes.size > 0) {
            for (const nodeId of window.selectedNodes) {
                const node = nodes[nodeId];
                if (node) {
                    const transformResult = window.lastDrawingContext.transform(node.x, node.y);
                    const drawX = transformResult.x;
                    const drawY = transformResult.y;
                    ctx.save();
                    ctx.strokeStyle = '#ff4444';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(drawX, drawY, 8, 0, 2 * Math.PI);
                    ctx.stroke();
                    ctx.restore();
                }
            }
        }
        
        // Ë§áÊï∞ÈÅ∏Êäû„Åï„Çå„ÅüÈÉ®Êùê„ÇíÂº∑Ë™øÔºàËµ§Ëâ≤„ÅßÂº∑Ë™øÔºâ
        if (window.selectedMembers && window.selectedMembers.size > 0) {
            for (const memberId of window.selectedMembers) {
                const member = members[memberId];
                if (member) {
                    const node1 = nodes[member.i];
                    const node2 = nodes[member.j];
                    if (node1 && node2) {
                        const pos1 = window.lastDrawingContext.transform(node1.x, node1.y);
                        const pos2 = window.lastDrawingContext.transform(node2.x, node2.y);
                        ctx.save();
                        ctx.strokeStyle = '#ff4444';
                        ctx.lineWidth = 4;
                        ctx.beginPath();
                        ctx.moveTo(pos1.x, pos1.y);
                        ctx.lineTo(pos2.x, pos2.y);
                        ctx.stroke();
                        ctx.restore();
                    }
                }
            }
        }
    } catch (e) {
        console.error('‚ùå Âº∑Ë™øË°®Á§∫„Ç®„É©„Éº:', e);
    }
}

// „Ç∞„É≠„Éº„Éê„É´„Å´Á¢∫ÂÆü„Å´ÁôªÈå≤
window.highlightSelectedElements = highlightSelectedElements;

// Ë§áÊï∞ÈÅ∏Êäû„Çí„ÇØ„É™„Ç¢„Åô„ÇãÈñ¢Êï∞
function clearMultiSelection() {
    console.log('Ë§áÊï∞ÈÅ∏Êäû„Çí„ÇØ„É™„Ç¢ - ‰ª•Ââç„ÅÆÁä∂ÊÖã:', {
        selectedNodes: Array.from(selectedNodes),
        selectedMembers: Array.from(selectedMembers)
    });
    selectedNodes.clear();
    selectedMembers.clear();
    isMultiSelecting = false;
    if (typeof drawOnCanvas === 'function') {
        drawOnCanvas();
    }
    console.log('Ë§áÊï∞ÈÅ∏Êäû„ÇØ„É™„Ç¢ÂÆå‰∫Ü');
}

function convertSectionProperties(props) {
    return {
        E: UNIT_CONVERSION.E_STEEL,  // N/mm¬≤
        G: UNIT_CONVERSION.G_STEEL,  // N/mm¬≤
        I: props.I * UNIT_CONVERSION.CM4_TO_MM4,  // cm‚Å¥ ‚Üí mm‚Å¥
        A: props.A * UNIT_CONVERSION.CM2_TO_MM2,  // cm¬≤ ‚Üí mm¬≤
        Z: props.Z * UNIT_CONVERSION.CM3_TO_MM3   // cm¬≥ ‚Üí mm¬≥
    };
}

function inverseTransform(mouseX, mouseY) {
    const drawingContext = window.lastDrawingContext;
    if (!drawingContext) {
        return null;
    }

    const { scale, offsetX, offsetY } = drawingContext;
    const modelX = (mouseX - offsetX) / scale;
    const modelY = (mouseY - offsetY) / -scale;

    return { x: modelX, y: modelY };
}

window.inverseTransform = inverseTransform;

window.normalizeAxisInfo = function normalizeAxisInfo(axisInfo) {
    if (!axisInfo || typeof axisInfo !== 'object') return null;

    const fallbackKeyFromMode = (mode) => {
        switch (mode) {
            case 'weak':
                return 'y';
            case 'both':
                return 'both';
            case 'strong':
                return 'x';
            default:
                return null;
        }
    };

    // --- „Ç®„ÇØ„Çª„É´Ë≤º„Çä‰ªò„ÅëÊ©üËÉΩ„ÅÆËøΩÂä† (Ê±éÁî®) ---
    /**
     * „ÉÜ„Éº„Éñ„É´„Å∏„ÅÆ„Ç®„ÇØ„Çª„É´Ë≤º„Çä‰ªò„Åë„ÇíÊúâÂäπÂåñ„Åô„ÇãÈñ¢Êï∞
     * @param {HTMLTableSectionElement} tableBody - ÂØæË±°„ÅÆtbodyË¶ÅÁ¥†
     * @param {HTMLElement} addBtn - Ë°åËøΩÂä†„Éú„Çø„É≥Ôºà„Éá„Éº„Çø„ÅåË°åÊï∞„ÇíË∂Ö„Åà„ÇãÂ†¥Âêà„Å´„ÇØ„É™„ÉÉ„ÇØ„Åô„ÇãÔºâ
     */
    const setupExcelPaste = (tableBody, addBtn) => {
        // Â¢ÉÁïåÊù°‰ª∂„ÅÆÊó•Êú¨Ë™û„Éû„ÉÉ„Éî„É≥„Ç∞
        const supportMap = {
            'Ëá™Áî±': 'free', 'free': 'free', 'f': 'free',
            '„Éî„É≥': 'pinned', 'pinned': 'pinned', 'pin': 'pinned', 'p': 'pinned',
            'Âõ∫ÂÆö': 'fixed', 'fixed': 'fixed', 'fix': 'fixed', 'x': 'fixed',
            '„É≠„Éº„É©„Éº': 'roller', 'roller': 'roller', 'r': 'roller',
            '„É≠„Éº„É©„Éº(X)': 'roller-x', 'roller-x': 'roller-x',
            '„É≠„Éº„É©„Éº(Y)': 'roller-y', 'roller-y': 'roller-y'
        };

        // ÈÉ®ÊùêÊé•ÂêàÊù°‰ª∂„ÅÆ„Éû„ÉÉ„Éî„É≥„Ç∞
        const connMap = {
            'Ââõ': 'rigid', 'rigid': 'rigid', 'ÂâõÊé•Âêà': 'rigid',
            '„Éî„É≥': 'pinned', 'pinned': 'pinned', '„Éî„É≥Êé•Âêà': 'pinned',
            '„Éê„Éç': 'spring', 'spring': 'spring', '„Éê„ÉçÊé•Âêà': 'spring'
        };

        tableBody.addEventListener('paste', (e) => {
            // ÂÖ•Âäõ„Éï„Ç£„Éº„É´„Éâ„Åæ„Åü„ÅØ„Çª„É¨„ÇØ„Éà„Éú„ÉÉ„ÇØ„Çπ„Å∏„ÅÆË≤º„Çä‰ªò„Åë„ÅÆ„ÅøÂØæË±°
            const target = e.target;
            if (!target || (!target.matches('input') && !target.matches('select'))) return;

            e.preventDefault();
            const clipboardData = (e.clipboardData || window.clipboardData).getData('text');
            if (!clipboardData) return;

            pushState(); // Â±•Ê≠¥„Å´‰øùÂ≠ò

            // Ë°å„Å®Âàó„Å´ÂàÜÂâ≤ (Excel„ÅØ„Çø„ÉñÂå∫Âàá„Çä)
            const rowsData = clipboardData.split(/\r\n|\n|\r/).filter(r => r.trim() !== '');
            
            // ÈñãÂßã‰ΩçÁΩÆ„ÅÆÁâπÂÆö
            const startCell = target.closest('td');
            const startRow = target.closest('tr');
            if (!startCell || !startRow) return;

            const startRowIndex = startRow.sectionRowIndex; // tbodyÂÜÖ„Åß„ÅÆ„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ
            const startColIndex = startCell.cellIndex;

            rowsData.forEach((rowData, rIdx) => {
                const cellsData = rowData.split('\t');
                const targetRowIndex = startRowIndex + rIdx;

                // Ë°å„ÅåË∂≥„Çä„Å™„ÅÑÂ†¥Âêà„ÅØËøΩÂä†„Éú„Çø„É≥„Çí„ÇØ„É™„ÉÉ„ÇØ„Åó„Å¶Êã°Âºµ
                if (targetRowIndex >= tableBody.rows.length) {
                    if (addBtn) {
                        addBtn.click();
                        // ËøΩÂä†Áõ¥Âæå„ÅÆË°å„ÅØÂ±•Ê≠¥‰øùÂ≠ò(pushState)„Çí„Çπ„Ç≠„ÉÉ„Éó„Åó„Åü„ÅÑ„Åå„ÄÅ
                        // „Éú„Çø„É≥„ÇØ„É™„ÉÉ„ÇØËá™‰Ωì„ÅåpushState„ÇíÂê´„ÇÄÂ†¥Âêà„Åå„ÅÇ„Çã„Åü„ÇÅ„ÄÅ„Åù„ÅÆ„Åæ„ÅæÁ∂öË°å
                    } else {
                        return; // ËøΩÂä†„Éú„Çø„É≥„Åå„Å™„ÅÑÂ†¥Âêà„ÅØÁÑ°Ë¶ñ
                    }
                }
                
                const targetRow = tableBody.rows[targetRowIndex];
                if (!targetRow) return;

                cellsData.forEach((cellValue, cIdx) => {
                    const targetColIndex = startColIndex + cIdx;
                    
                    // „Çª„É´„ÅåÂ≠òÂú®„Åô„Çã„ÅãÁ¢∫Ë™ç
                    if (targetColIndex >= targetRow.cells.length) return;
                    
                    const cell = targetRow.cells[targetColIndex];
                    
                    // „Çª„É´ÂÜÖ„ÅÆÂÖ•ÂäõË¶ÅÁ¥†„ÇíÊé¢„Åô
                    const input = cell.querySelector('input, select');
                    
                    // ÂâäÈô§„Éú„Çø„É≥„Å™„Å©„ÅÆ„Çª„É´„ÅØ„Çπ„Ç≠„ÉÉ„Éó
                    if (!input || input.type === 'button' || input.type === 'submit') return;

                    // ÂÄ§„ÅÆÈÅ©Áî®
                    const val = cellValue.trim();
                    
                    if (input.tagName === 'SELECT') {
                        // „Çª„É¨„ÇØ„Éà„Éú„ÉÉ„ÇØ„Çπ„ÅÆÂ†¥ÂêàÔºàÂ¢ÉÁïåÊù°‰ª∂„ÇÑÊé•ÂêàÊù°‰ª∂Ôºâ
                        // 1. „Éû„ÉÉ„Éî„É≥„Ç∞„ÇíË©¶Ë°å
                        let mappedVal = supportMap[val] || connMap[val];
                        
                        // 2. „Éû„ÉÉ„Éî„É≥„Ç∞„Åå„Å™„Åë„Çå„Å∞Áõ¥Êé•ÂÄ§„ÇíÊ§úÁ¥¢
                        if (!mappedVal) {
                            // „Ç™„Éó„Ç∑„Éß„É≥„ÅÆÂÄ§„Åæ„Åü„ÅØ„ÉÜ„Ç≠„Çπ„Éà„Å®‰∏ÄËá¥„Åô„Çã„ÅãÁ¢∫Ë™ç
                            for (let opt of input.options) {
                                if (opt.value === val || opt.textContent === val) {
                                    mappedVal = opt.value;
                                    break;
                                }
                            }
                        }

                        if (mappedVal) {
                            input.value = mappedVal;
                        }
                    } else {
                        // ÈÄöÂ∏∏„ÅÆÂÖ•Âäõ„Éï„Ç£„Éº„É´„Éâ
                        input.value = val;
                    }

                    // Â§âÊõ¥„Ç§„Éô„É≥„Éà„ÇíÁô∫ÁÅ´ÔºàÂÜçÊèèÁîª„Å™„Å©„Çí„Éà„É™„Ç¨„ÉºÔºâ
                    input.dispatchEvent(new Event('change', { bubbles: true }));
                    input.dispatchEvent(new Event('input', { bubbles: true }));
                });
            });
            
            drawOnCanvas();
            // Ëß£ÊûêÁµêÊûú„Å∏„ÅÆÂç≥ÊôÇÂèçÊò†„ÅåÂøÖË¶Å„Å™„Çâ‰ª•‰∏ã„ÇíÊúâÂäπÂåñ
            // runFullAnalysis();
        });
    };

    // ÁØÄÁÇπ„ÉÜ„Éº„Éñ„É´„Å´„Ç®„ÇØ„Çª„É´Ë≤º„Çä‰ªò„ÅëÊ©üËÉΩ„ÇíÈÅ©Áî®
    if (elements.nodesTable) {
        setupExcelPaste(elements.nodesTable, elements.addNodeBtn);
    }
    
    // ÈÉ®Êùê„ÉÜ„Éº„Éñ„É´„Å´„ÇÇÈÅ©Áî®Ôºà‰æøÂà©Ê©üËÉΩ„Å®„Åó„Å¶Ôºâ
    if (elements.membersTable) {
        setupExcelPaste(elements.membersTable, elements.addMemberBtn);
    }
    
    // Ëç∑Èáç„ÉÜ„Éº„Éñ„É´„Å´„ÇÇÈÅ©Áî®
    if (elements.nodeLoadsTable) {
        setupExcelPaste(elements.nodeLoadsTable, elements.addNodeLoadBtn);
    }
    if (elements.memberLoadsTable) {
        setupExcelPaste(elements.memberLoadsTable, elements.addMemberLoadBtn);
    }
    // --- „Ç®„ÇØ„Çª„É´Ë≤º„Çä‰ªò„ÅëÊ©üËÉΩ„ÅÆËøΩÂä† ÁµÇ‰∫Ü ---
    const fallbackModeFromKey = (key) => {
        switch (key) {
            case 'y':
                return 'weak';
            case 'both':
                return 'both';
            case 'x':
            default:
                return 'strong';
        }
    };

    const fallbackLabelFromKey = (key) => {
        switch (key) {
            case 'y':
                return 'Âº±Ëª∏ (YËª∏)';
            case 'both':
                return '‰∏°Ëª∏ (X=Y)';
            case 'x':
            default:
                return 'Âº∑Ëª∏ (XËª∏)';
        }
    };

    const candidateKey = typeof axisInfo.key === 'string' ? axisInfo.key.trim().toLowerCase() : '';
    const candidateMode = typeof axisInfo.mode === 'string' ? axisInfo.mode.trim().toLowerCase() : '';
    const candidateLabel = typeof axisInfo.label === 'string' ? axisInfo.label.trim() : '';

    const resolvedKey = ['x', 'y', 'both'].includes(candidateKey)
        ? candidateKey
        : (fallbackKeyFromMode(candidateMode) || 'x');
    const normalizedKey = ['x', 'y', 'both'].includes(resolvedKey) ? resolvedKey : 'x';

    const resolvedMode = ['strong', 'weak', 'both'].includes(candidateMode)
        ? (normalizedKey === 'both' ? 'both' : (candidateMode === 'both' ? fallbackModeFromKey(normalizedKey) : candidateMode))
        : fallbackModeFromKey(normalizedKey);

    const resolvedLabel = candidateLabel || fallbackLabelFromKey(normalizedKey);

    return { key: normalizedKey, mode: resolvedMode, label: resolvedLabel };
}

// ÈÉ®Êùê„ÉÑ„Éº„É´„ÉÅ„ÉÉ„ÉóÈñ¢Êï∞
function detectMemberAtPosition(clientX, clientY) {
    console.log('üîç detectMemberAtPositionÂëº„Å≥Âá∫„Åó - Â∫ßÊ®ô:', clientX, clientY);
    
    // DOMË¶ÅÁ¥†„Åã„ÇâÈÉ®Êùê„Éá„Éº„Çø„ÇíÂèñÂæó
    const membersTable = document.getElementById('members-table')?.getElementsByTagName('tbody')[0];
    if (!membersTable || membersTable.rows.length === 0) {
        console.log('‚ùå ÈÉ®Êùê„ÉÜ„Éº„Éñ„É´„ÅåË¶ã„Å§„Åã„Çâ„Å™„ÅÑ - Ë°åÊï∞:', membersTable?.rows?.length || 0);
        return null;
    }
    
    const nodesTable = document.getElementById('nodes-table')?.getElementsByTagName('tbody')[0];
    if (!nodesTable || nodesTable.rows.length === 0) {
        console.log('‚ùå ÁØÄÁÇπ„ÉÜ„Éº„Éñ„É´„ÅåË¶ã„Å§„Åã„Çâ„Å™„ÅÑ - Ë°åÊï∞:', nodesTable?.rows?.length || 0);
        return null;
    }
    
    console.log('üìä „ÉÜ„Éº„Éñ„É´Á¢∫Ë™ç - ÈÉ®Êùê:', membersTable.rows.length, 'Ë°å, ÁØÄÁÇπ:', nodesTable.rows.length, 'Ë°å');
    
    // „Ç≠„É£„É≥„Éê„ÇπË¶ÅÁ¥†„ÇíÂèñÂæó
    const canvas = document.getElementById("model-canvas");
    if (!canvas) {
        console.log('‚ùå „Ç≠„É£„É≥„Éê„ÇπË¶ÅÁ¥†„ÅåË¶ã„Å§„Åã„Çâ„Å™„ÅÑ');
        return null;
    }
    
    const getCellValue = (cell) => {
        if (!cell) return '';
        const input = cell.querySelector('input');
        if (input && typeof input.value === 'string') {
            const value = input.value.trim();
            if (value !== '') {
                return value;
            }
        }
        const select = cell.querySelector('select');
        if (select) {
            const selectedOption = select.options[select.selectedIndex];
            if (selectedOption) {
                const optionLabel = selectedOption.textContent?.trim();
                if (optionLabel) {
                    return optionLabel;
                }
            }
            const selectValue = select.value?.trim();
            if (selectValue) {
                return selectValue;
            }
        }
        return cell.textContent?.trim() || '';
    };
    const getCellNumber = (cell) => {
        const rawValue = getCellValue(cell);
        if (!rawValue) return NaN;
        const numericValue = parseFloat(rawValue.replace(/,/g, ''));
        return Number.isFinite(numericValue) ? numericValue : NaN;
    };
    const getCellInteger = (cell) => {
        const rawValue = getCellValue(cell);
        if (!rawValue) return NaN;
        const integerValue = parseInt(rawValue.replace(/,/g, ''), 10);
        return Number.isFinite(integerValue) ? integerValue : NaN;
    };

    const parseOptionalFloat = (value) => {
        if (value === undefined || value === null) return null;
        const numeric = Number.parseFloat(String(value).replace(/,/g, ''));
        return Number.isFinite(numeric) ? numeric : null;
    };

    const getSelectLabel = (select) => {
        if (!select) return '';
        const option = select.options?.[select.selectedIndex];
        if (option && typeof option.textContent === 'string') {
            const trimmed = option.textContent.trim();
            if (trimmed) return trimmed;
        }
        return select.value || '';
    };

    // ÁØÄÁÇπ„Éá„Éº„Çø„ÇíÂèñÂæóÔºà„Éò„ÉÉ„ÉÄ„ÉºË°å„Çí„Çπ„Ç≠„ÉÉ„ÉóÔºâ
    const nodesMap = {};
    const nodeRows = Array.from(nodesTable.rows);
    console.log('üìä ÁØÄÁÇπ„ÉÜ„Éº„Éñ„É´Ë°åÊï∞:', nodeRows.length);
    
    // ÊúÄÂàù„ÅÆË°å„Åå„Éò„ÉÉ„ÉÄ„Éº„ÅÆÂ†¥Âêà„ÅØ„Çπ„Ç≠„ÉÉ„Éó
    nodeRows.forEach((row, index) => {
        const firstCellText = getCellValue(row.cells[0]);
        
        // „Éò„ÉÉ„ÉÄ„ÉºË°å„ÅÆË≠òÂà•ÔºàÊï∞ÂÄ§‰ª•Â§ñ„Åæ„Åü„ÅØÁâπÂÆö„Ç≠„Éº„ÉØ„Éº„Éâ„ÇíÂê´„ÇÄÂ†¥Âêà„ÅØ„Éò„ÉÉ„ÉÄ„Éº„Å®„Åø„Å™„ÅôÔºâ
        const isHeader = isNaN(parseInt(firstCellText)) || 
                        firstCellText.includes('ÁØÄÁÇπ') || 
                        firstCellText.includes('Node') ||
                        firstCellText.includes('Áï™Âè∑');
        
        if (index === 0) {
            console.log('üìä ÁØÄÁÇπÊúÄÂàù„ÅÆË°å:', Array.from(row.cells).map(cell => cell.textContent?.trim()));
            console.log('üìä „Éò„ÉÉ„ÉÄ„ÉºÂà§ÂÆö:', isHeader, '(firstCell:', firstCellText, ')');
        }
        
        if (isHeader) {
            console.log(`üìä ÁØÄÁÇπË°å${index}„Çπ„Ç≠„ÉÉ„Éó („Éò„ÉÉ„ÉÄ„Éº):`, firstCellText);
            return;
        }
        
        const nodeNumber = getCellInteger(row.cells[0]);
        const x = getCellNumber(row.cells[1]);
        const y = getCellNumber(row.cells[2]);
        
        console.log(`üìä ÁØÄÁÇπË°å${index}: number=${nodeNumber}, x=${x}, y=${y}`);
        
        if (!isNaN(nodeNumber) && !isNaN(x) && !isNaN(y)) {
            nodesMap[nodeNumber] = { x, y };
            console.log(`‚úÖ ÁØÄÁÇπ${nodeNumber}ËøΩÂä†: (${x}, ${y})`);
        }
    });
    
    // ÈÉ®Êùê„Éá„Éº„Çø„ÇíÂèñÂæóÔºà„Éò„ÉÉ„ÉÄ„ÉºË°å„Çí„Çπ„Ç≠„ÉÉ„ÉóÔºâ
    const members = [];
    const memberRows = Array.from(membersTable.rows);
    console.log('üìä ÈÉ®Êùê„ÉÜ„Éº„Éñ„É´Ë°åÊï∞:', memberRows.length);
    
    const uniformLoadMap = new Map();
    const memberLoadsTable = document.getElementById('member-loads-table')?.getElementsByTagName('tbody')[0];
    if (memberLoadsTable && memberLoadsTable.rows) {
        Array.from(memberLoadsTable.rows).forEach((loadRow) => {
            const memberInput = loadRow.cells?.[0]?.querySelector('input');
            const loadInput = loadRow.cells?.[1]?.querySelector('input');
            const memberId = parseInt(memberInput?.value, 10);
            const loadValue = parseOptionalFloat(loadInput?.value);
            if (Number.isFinite(memberId)) {
                uniformLoadMap.set(memberId, loadValue);
            }
        });
    }

    memberRows.forEach((row, index) => {
        const firstCellText = getCellValue(row.cells[0]);
        
        // „Éò„ÉÉ„ÉÄ„ÉºË°å„ÅÆË≠òÂà•ÔºàÊï∞ÂÄ§‰ª•Â§ñ„Åæ„Åü„ÅØÁâπÂÆö„Ç≠„Éº„ÉØ„Éº„Éâ„ÇíÂê´„ÇÄÂ†¥Âêà„ÅØ„Éò„ÉÉ„ÉÄ„Éº„Å®„Åø„Å™„ÅôÔºâ
        const isHeader = isNaN(parseInt(firstCellText)) || 
                        firstCellText.includes('ÈÉ®Êùê') || 
                        firstCellText.includes('Member') ||
                        firstCellText.includes('Áï™Âè∑');
        
        if (index === 0) {
            console.log('üìä ÈÉ®ÊùêÊúÄÂàù„ÅÆË°å:', Array.from(row.cells).map(cell => cell.textContent?.trim()));
            console.log('üìä „Éò„ÉÉ„ÉÄ„ÉºÂà§ÂÆö:', isHeader, '(firstCell:', firstCellText, ')');
        }
        
        if (isHeader) {
            console.log(`üìä ÈÉ®ÊùêË°å${index}„Çπ„Ç≠„ÉÉ„Éó („Éò„ÉÉ„ÉÄ„Éº):`, firstCellText);
            return;
        }
        
        const memberNumber = getCellInteger(row.cells[0]);
        const nodeI = getCellInteger(row.cells[1]);
        const nodeJ = getCellInteger(row.cells[2]);

        const materialSelect = row.cells[3]?.querySelector('select');
        const materialSelectLabel = getSelectLabel(materialSelect);
        let material = '';
        if (materialSelectLabel) {
            material = materialSelectLabel;
        } else {
            material = getCellValue(row.cells[3]);
        }

        const strengthSelect = row.cells[4]?.querySelector('select');
        const strengthInput = row.cells[4]?.querySelector('input');
        let section = '';
        if (strengthSelect) {
            const selectedStrength = strengthSelect.options[strengthSelect.selectedIndex];
            const strengthLabel = selectedStrength?.textContent?.trim();
            if (strengthSelect.value === 'custom' && strengthInput && strengthInput.value.trim() !== '') {
                section = `‰ªªÊÑè (${strengthInput.value.trim()} N/mm¬≤)`;
            } else {
                section = strengthLabel || strengthSelect.value || '';
            }
        } else {
            section = getCellValue(row.cells[4]);
        }

        let sectionInfo = null;
        if (row.dataset.sectionInfo) {
            try {
                sectionInfo = JSON.parse(decodeURIComponent(row.dataset.sectionInfo));
                sectionInfo = ensureSectionSvgMarkup(sectionInfo);
            } catch (error) {
                console.warn('Failed to parse sectionInfo for row', index, error);
            }
        }
        const sectionLabel = row.dataset.sectionLabel || sectionInfo?.label;
        const sectionSummary = row.dataset.sectionSummary || sectionInfo?.dimensionSummary || '';
        if (sectionLabel) {
            section = sectionLabel;
        }

        const eInput = row.cells[3]?.querySelector('input[type="number"]');
        const elasticModulus = {
            value: eInput?.value?.trim() || '',
            numeric: parseOptionalFloat(eInput?.value),
            label: materialSelectLabel,
            optionValue: materialSelect?.value || ''
        };

        const strengthCell = row.cells[4];
        const strengthContainer = strengthCell?.querySelector('[data-strength-type]') || strengthCell?.firstElementChild || null;
        const strengthType = strengthContainer?.dataset?.strengthType || 'F-value';
        const strengthSelectEl = strengthContainer?.querySelector('select');
        const strengthInputs = strengthContainer ? Array.from(strengthContainer.querySelectorAll('input')) : [];
        let strengthValue = '';
        let strengthLabel = '';
        let strengthDetails = null;
        if (strengthType === 'wood-type') {
            strengthValue = strengthSelectEl?.value || '';
            strengthLabel = getSelectLabel(strengthSelectEl);
            strengthDetails = strengthInputs.reduce((acc, input) => {
                const key = input.id ? input.id.split('-').pop() : input.name || '';
                if (key) {
                    acc[key] = input.value;
                }
                return acc;
            }, {});
        } else {
            const strengthPrimaryInput = strengthInputs[0] || strengthInput;
            strengthValue = strengthPrimaryInput?.value || '';
            strengthLabel = getSelectLabel(strengthSelectEl) || strengthValue;
        }

        const inertiaInput = row.cells[5]?.querySelector('input[type="number"]');
        const areaInput = row.cells[6]?.querySelector('input[type="number"]');
        const modulusInput = row.cells[7]?.querySelector('input[type="number"]');

        const densityCell = row.querySelector('.density-cell');
        const densitySelect = densityCell?.querySelector('select');
        const densityInput = densityCell?.querySelector('input');
        const densityInfo = densityCell ? {
            value: densityInput?.value || '',
            numeric: parseOptionalFloat(densityInput?.value),
            label: getSelectLabel(densitySelect),
            optionValue: densitySelect?.value || ''
        } : null;

        let sectionAxis = null;
        if (row.dataset.sectionAxisKey || row.dataset.sectionAxisLabel || row.dataset.sectionAxisMode) {
            sectionAxis = normalizeAxisInfo({
                key: row.dataset.sectionAxisKey,
                mode: row.dataset.sectionAxisMode,
                label: row.dataset.sectionAxisLabel
            });
        } else if (sectionInfo && sectionInfo.axis) {
            sectionAxis = normalizeAxisInfo(sectionInfo.axis);
        }
        
        const hasDensityColumn = Boolean(densityCell);
        const startConnCell = hasDensityColumn ? row.cells[10] : row.cells[9];
        const endConnCell = hasDensityColumn ? row.cells[11] : row.cells[10];
        const startConnSelect = startConnCell?.querySelector('select');
        const endConnSelect = endConnCell?.querySelector('select');

        const areaNumeric = parseOptionalFloat(areaInput?.value);
        const densityNumeric = densityInfo?.numeric;
        const selfWeightPerLength = (densityNumeric !== null && areaNumeric !== null)
            ? (densityNumeric * (areaNumeric * 1e-4) * 9.80665 / 1000)
            : null;

        const uniformLoad = uniformLoadMap.get(memberNumber) ?? null;

        console.log(`üìä ÈÉ®ÊùêË°å${index}: member=${memberNumber}, nodeI=${nodeI}, nodeJ=${nodeJ}`);
        
        if (!isNaN(memberNumber) && !isNaN(nodeI) && !isNaN(nodeJ) && 
            nodesMap[nodeI] && nodesMap[nodeJ]) {
            members.push({
                number: memberNumber,
                nodeI,
                nodeJ,
                material,
                materialValue: materialSelect?.value || '',
                section,
                sectionLabel,
                sectionInfo,
                sectionSummary,
                sectionAxis,
                sectionSource: row.dataset.sectionSource || sectionInfo?.source || '',
                nodes: {
                    i: nodesMap[nodeI],
                    j: nodesMap[nodeJ]
                },
                properties: {
                    elasticModulus,
                    strength: {
                        type: strengthType,
                        value: strengthValue,
                        label: strengthLabel,
                        numeric: strengthType === 'wood-type' ? null : parseOptionalFloat(strengthValue),
                        details: strengthDetails
                    },
                    inertia: {
                        value: inertiaInput?.value || '',
                        numeric: parseOptionalFloat(inertiaInput?.value),
                        unit: 'cm‚Å¥'
                    },
                    area: {
                        value: areaInput?.value || '',
                        numeric: areaNumeric,
                        unit: 'cm¬≤'
                    },
                    sectionModulus: {
                        value: modulusInput?.value || '',
                        numeric: parseOptionalFloat(modulusInput?.value),
                        unit: 'cm¬≥',
                        zx: row.dataset.zx || '',
                        zy: row.dataset.zy || '',
                        zxNumeric: parseOptionalFloat(row.dataset.zx),
                        zyNumeric: parseOptionalFloat(row.dataset.zy)
                    },
                    radiusOfGyration: {
                        ix: row.dataset.ix || '',
                        iy: row.dataset.iy || '',
                        ixNumeric: parseOptionalFloat(row.dataset.ix),
                        iyNumeric: parseOptionalFloat(row.dataset.iy)
                    },
                    density: densityInfo,
                    selfWeightPerLength
                },
                connections: {
                    start: {
                        value: startConnSelect?.value || 'rigid',
                        label: getSelectLabel(startConnSelect) || 'Ââõ'
                    },
                    end: {
                        value: endConnSelect?.value || 'rigid',
                        label: getSelectLabel(endConnSelect) || 'Ââõ'
                    }
                },
                loads: {
                    uniform: uniformLoad
                }
            });
            console.log(`‚úÖ ÈÉ®Êùê${memberNumber}ËøΩÂä†: ${nodeI}-${nodeJ}`);
        }
    });
    
    if (members.length === 0 || Object.keys(nodesMap).length === 0) {
        console.log('‚ùå „Éá„Éº„Çø‰∏çË∂≥ - ÈÉ®Êùê:', members.length, 'ÂÄã, ÁØÄÁÇπ:', Object.keys(nodesMap).length, 'ÂÄã');
        return null;
    }
    
    console.log('üìè ÊúâÂäπ„Éá„Éº„Çø - ÈÉ®Êùê:', members.length, 'ÂÄã, ÁØÄÁÇπ:', Object.keys(nodesMap).length, 'ÂÄã');
    
    // „Ç≠„É£„É≥„Éê„ÇπÂ∫ßÊ®ô„Åã„Çâ„É¢„Éá„É´Â∫ßÊ®ô„Å∏„ÅÆÂ§âÊèõÔºàÊó¢Â≠ò„ÅÆinverseTransformÈñ¢Êï∞„Çí‰ΩøÁî®Ôºâ
    const rect = canvas.getBoundingClientRect();
    const mouseX = clientX - rect.left;
    const mouseY = clientY - rect.top;
    
    console.log('üñ±Ô∏è „Éû„Ç¶„Çπ‰ΩçÁΩÆ: „Ç≠„É£„É≥„Éê„ÇπÂÜÖ=', mouseX.toFixed(2), mouseY.toFixed(2));
    
    // Êó¢Â≠ò„ÅÆÂ∫ßÊ®ôÂ§âÊèõ„Ç∑„Çπ„ÉÜ„É†„Çí‰ΩøÁî®
    const worldCoords = inverseTransform(mouseX, mouseY);
    if (!worldCoords) {
        console.log('‚ùå Â∫ßÊ®ôÂ§âÊèõÂ§±Êïó - lastDrawingContext„ÅåÊú™ÂàùÊúüÂåñ');
        return null;
    }
    
    const { x: worldX, y: worldY } = worldCoords;
    console.log('üåç „ÉØ„Éº„É´„ÉâÂ∫ßÊ®ô:', worldX.toFixed(2), worldY.toFixed(2));
    
    // ÁèæÂú®„ÅÆÊèèÁîª„Ç≥„É≥„ÉÜ„Ç≠„Çπ„ÉàÊÉÖÂ†±„ÇíÂèñÂæó
    const currentDrawingContext = window.lastDrawingContext;
    const currentScale = currentDrawingContext?.scale || 1;
    const transformFn = currentDrawingContext?.transform;

    // ÁîªÈù¢‰∏ä„ÅÆËøëÊé•Âà§ÂÆö„ÅØ„Éî„ÇØ„Çª„É´Âçò‰Ωç„ÅßË°å„ÅÑ„ÄÅÈñæÂÄ§„Çí‰∏ÄÂÆö„Å´‰øù„Å§
    const tolerancePixels = 12;
    console.log('üìè ËøëÊé•Âà§ÂÆö„Åó„Åç„ÅÑÂÄ§:', `${tolerancePixels}px`, '(„Çπ„Ç±„Éº„É´:', currentScale.toFixed(2), ')');
    
    let closestMember = null;
    let closestDistancePixels = Infinity;
    let memberDistances = []; // „Éá„Éê„ÉÉ„Ç∞Áî®
    
    members.forEach((member) => {
        const node1 = member.nodes.i;
        const node2 = member.nodes.j;
        
        // „ÉØ„Éº„É´„ÉâÂ∫ßÊ®ô„Å®ÁîªÈù¢Â∫ßÊ®ô„ÅÆ‰∏°Êñπ„ÅßË∑ùÈõ¢„ÇíË®àÁÆó
        const worldDistance = distanceFromPointToLine(
            worldX, worldY,
            node1.x, node1.y,
            node2.x, node2.y
        );

        let screenDistance = Infinity;
        if (transformFn) {
            const screenNode1 = transformFn(node1.x, node1.y);
            const screenNode2 = transformFn(node2.x, node2.y);
            screenDistance = distanceFromPointToLine(
                mouseX, mouseY,
                screenNode1.x, screenNode1.y,
                screenNode2.x, screenNode2.y
            );
        }

        memberDistances.push({
            ÈÉ®Êùê: member.number,
            Ë∑ùÈõ¢_mm: worldDistance.toFixed(2),
            ÁîªÈù¢Ë∑ùÈõ¢_px: Number.isFinite(screenDistance) ? screenDistance.toFixed(2) : 'N/A',
            Â∫ßÊ®ô: `(${node1.x},${node1.y})-(${node2.x},${node2.y})`
        });
        
        if (Number.isFinite(screenDistance) && screenDistance <= tolerancePixels && screenDistance < closestDistancePixels) {
            closestDistancePixels = screenDistance;
            closestMember = {
                ...member,
                distance: worldDistance
            };
        }
    });
    
    // ÊúÄÂàù„ÅÆ5ÂÄã„ÅÆÈÉ®Êùê„ÅÆË∑ùÈõ¢„Çí„É≠„Ç∞Âá∫Âäõ
    console.log('üìä ÈÉ®ÊùêË∑ùÈõ¢ (ÊúÄÂàù„ÅÆ5ÂÄã):', memberDistances.slice(0, 5));
    console.log('üéØ Ê§úÂá∫ÁµêÊûú:', closestMember ? `ÈÉ®Êùê${closestMember.number} (ÁîªÈù¢Ë∑ùÈõ¢: ${closestDistancePixels.toFixed(2)}px, „ÉØ„Éº„É´„ÉâË∑ùÈõ¢: ${closestMember.distance.toFixed(2)})` : 'ÈÉ®Êùê„Å™„Åó');
    
    return closestMember;
}

function distanceFromPointToLine(px, py, x1, y1, x2, y2) {
    const dx = x2 - x1;
    const dy = y2 - y1;
    const length = Math.sqrt(dx * dx + dy * dy);
    
    if (length === 0) {
        return Math.sqrt((px - x1) * (px - x1) + (py - y1) * (py - y1));
    }
    
    // ÁÇπ„Åã„ÇâÁ∑öÂàÜ„Å∏„ÅÆÂ∞ÑÂΩ±„ÇíË®àÁÆó
    const t = Math.max(0, Math.min(1, ((px - x1) * dx + (py - y1) * dy) / (length * length)));
    const projX = x1 + t * dx;
    const projY = y1 + t * dy;
    
    return Math.sqrt((px - projX) * (px - projX) + (py - projY) * (py - projY));
}

function showMemberTooltip(memberData, mouseX, mouseY) {
    console.log('üîß „ÉÑ„Éº„É´„ÉÅ„ÉÉ„ÉóË°®Á§∫ÈñãÂßã - ÈÉ®Êùê:', memberData.number);
    
    const tooltip = document.querySelector('.member-tooltip');
    if (!tooltip || !memberData) {
        console.log('‚ùå „ÉÑ„Éº„É´„ÉÅ„ÉÉ„ÉóË°®Á§∫Â§±Êïó:', !tooltip ? 'DOMË¶ÅÁ¥†„Å™„Åó' : 'ÈÉ®Êùê„Éá„Éº„Çø„Å™„Åó');
        return;
    }
    
    console.log('‚úÖ „ÉÑ„Éº„É´„ÉÅ„ÉÉ„ÉóDOMË¶ÅÁ¥†Á¢∫Ë™çÂÆå‰∫Ü');
    
    const { number, nodeI, nodeJ, material, section, nodes, sectionInfo, sectionSummary, sectionAxis, properties = {}, connections = {}, loads = {} } = memberData;

    const length = Math.sqrt(Math.pow(nodes.j.x - nodes.i.x, 2) + Math.pow(nodes.j.y - nodes.i.y, 2));
    const axisLabel = sectionAxis?.label || sectionInfo?.axis?.label || '';

    const asNumeric = (value) => {
        if (value === undefined || value === null || value === '') return null;
        const numeric = Number.parseFloat(String(value).replace(/,/g, ''));
        return Number.isFinite(numeric) ? numeric : null;
    };

    const createChip = ({ label, numeric, raw, unit, digits, suffix, emphasis, wide, subValue }) => {
        let displayValue = null;
        if (numeric !== null && numeric !== undefined && Number.isFinite(numeric)) {
            const precision = digits !== undefined ? digits : (Math.abs(numeric) >= 1000 ? 0 : 2);
            displayValue = numeric.toLocaleString(undefined, {
                maximumFractionDigits: precision,
                minimumFractionDigits: 0
            });
        } else if (typeof raw === 'string' && raw.trim() !== '') {
            displayValue = raw.trim();
        }

        if (!displayValue) return '';

        const valueWithUnit = unit ? `${displayValue} ${unit}` : displayValue;
        const suffixText = suffix ? `<span class="chip-suffix">${suffix}</span>` : '';
        const subValueText = subValue ? `<span class="chip-subvalue">${subValue}</span>` : '';
        const modifiers = [wide ? ' tooltip-chip--wide' : '', emphasis ? ' tooltip-chip--emphasis' : ''].join('');

        return `<div class="tooltip-chip${modifiers}"><span class="chip-label">${label}</span><span class="chip-value">${valueWithUnit}</span>${suffixText}${subValueText}</div>`;
    };

    const generalInfoRows = [
        { label: 'IÂ∫ßÊ®ô', value: `(${nodes.i.x.toFixed(1)}, ${nodes.i.y.toFixed(1)})` },
        { label: 'JÂ∫ßÊ®ô', value: `(${nodes.j.x.toFixed(1)}, ${nodes.j.y.toFixed(1)})` }
    ];

    if (!sectionInfo && section) {
        generalInfoRows.push({ label: 'Êñ≠Èù¢', value: section });
    }

    const summaryChips = [
        { label: 'ÁØÄÁÇπ', value: `${nodeI} ‚Üí ${nodeJ}` },
        { label: 'Èï∑„Åï', value: `${length.toFixed(1)} mm` }
    ];

    if (axisLabel) {
        summaryChips.push({ label: 'Ëª∏', value: axisLabel });
    }

    if (material) {
        summaryChips.push({ label: 'ÊùêÊñô', value: material });
    }

    const summaryChipsHTML = summaryChips
        .map(chip => `<div class="tooltip-chip tooltip-chip--summary"><span class="chip-label">${chip.label}</span><span class="chip-value">${chip.value}</span></div>`)
        .join('');

    const generalInfoHTML = generalInfoRows
        .map(row => `<div class="tooltip-stat-item"><span class="stat-label">${row.label}</span><span class="stat-value">${row.value}</span></div>`)
        .join('');

    const generalInfoSectionHTML = generalInfoHTML
        ? `<div class="tooltip-subsection"><div class="tooltip-subtitle">Ê¶ÇË¶Å</div><div class="tooltip-stat-grid">${generalInfoHTML}</div></div>`
        : '';

    const {
        elasticModulus = {},
        strength = {},
        inertia = {},
        area: areaProp = {},
        sectionModulus = {},
        radiusOfGyration = {},
        density: densityPropRaw = null,
        selfWeightPerLength = null
    } = properties;

    const densityProp = (densityPropRaw && typeof densityPropRaw === 'object') ? densityPropRaw : {};

    const propertyChips = [];

    if (elasticModulus.value || Number.isFinite(elasticModulus.numeric)) {
        const suffix = elasticModulus.label && elasticModulus.label !== material ? elasticModulus.label : '';
        propertyChips.push(createChip({
            label: 'E',
            numeric: elasticModulus.numeric ?? asNumeric(elasticModulus.value),
            raw: elasticModulus.value,
            unit: 'N/mm¬≤',
            digits: 0,
            suffix
        }));
    }

    if (strength.type === 'wood-type') {
        const detailEntries = strength.details
            ? Object.entries(strength.details).map(([key, value]) => `${key.toUpperCase()}: ${value}`).join(' / ')
            : '';
        propertyChips.push(createChip({
            label: 'Êú®Êùê',
            raw: strength.label || '„Ç´„Çπ„Çø„É†',
            unit: '',
            wide: true,
            subValue: detailEntries ? `${detailEntries} N/mm¬≤` : ''
        }));
    } else if (strength.value || Number.isFinite(strength.numeric)) {
        const suffix = strength.label && strength.label !== strength.value ? strength.label : '';
        propertyChips.push(createChip({
            label: 'F',
            numeric: strength.numeric ?? asNumeric(strength.value),
            raw: strength.value,
            unit: 'N/mm¬≤',
            digits: 0,
            suffix
        }));
    }

    if (inertia.value || Number.isFinite(inertia.numeric)) {
        propertyChips.push(createChip({
            label: 'I',
            numeric: inertia.numeric ?? asNumeric(inertia.value),
            raw: inertia.value,
            unit: 'cm‚Å¥'
        }));
    }

    if (areaProp.value || Number.isFinite(areaProp.numeric)) {
        propertyChips.push(createChip({
            label: 'A',
            numeric: areaProp.numeric ?? asNumeric(areaProp.value),
            raw: areaProp.value,
            unit: 'cm¬≤'
        }));
    }

    const zxNumeric = sectionModulus.zxNumeric ?? asNumeric(sectionModulus.zx);
    const zyNumeric = sectionModulus.zyNumeric ?? asNumeric(sectionModulus.zy);
    const primaryZNumeric = sectionModulus.numeric ??
        (sectionAxis?.key === 'y' ? (zyNumeric ?? zxNumeric) : sectionAxis?.key === 'x' ? (zxNumeric ?? zyNumeric) : asNumeric(sectionModulus.value));
    const primaryZRaw = sectionModulus.value || (sectionAxis?.key === 'y' ? sectionModulus.zy : sectionModulus.zx);
    const zUnit = 'cm¬≥';

    const primaryZLabel = sectionAxis?.key === 'y' ? 'Zy' : sectionAxis?.key === 'x' ? 'Zx' : 'Z';
    if (primaryZRaw || Number.isFinite(primaryZNumeric)) {
        propertyChips.push(createChip({
            label: primaryZLabel,
            numeric: primaryZNumeric ?? asNumeric(primaryZRaw),
            raw: primaryZRaw,
            unit: zUnit
        }));
    }

    const zTolerance = 1e-6;
    if (sectionAxis?.key === 'x' && zyNumeric !== null && Math.abs((primaryZNumeric ?? zyNumeric) - zyNumeric) > zTolerance) {
        propertyChips.push(createChip({ label: 'Zy', numeric: zyNumeric, raw: sectionModulus.zy, unit: zUnit }));
    } else if (sectionAxis?.key === 'y' && zxNumeric !== null && Math.abs((primaryZNumeric ?? zxNumeric) - zxNumeric) > zTolerance) {
        propertyChips.push(createChip({ label: 'Zx', numeric: zxNumeric, raw: sectionModulus.zx, unit: zUnit }));
    } else if (!sectionAxis && zxNumeric !== null && zyNumeric !== null && Math.abs(zxNumeric - zyNumeric) > zTolerance) {
        propertyChips.push(createChip({ label: 'Zx', numeric: zxNumeric, raw: sectionModulus.zx, unit: zUnit }));
        propertyChips.push(createChip({ label: 'Zy', numeric: zyNumeric, raw: sectionModulus.zy, unit: zUnit }));
    }

    if (radiusOfGyration.ix || Number.isFinite(radiusOfGyration.ixNumeric)) {
        propertyChips.push(createChip({
            label: 'ix',
            numeric: radiusOfGyration.ixNumeric ?? asNumeric(radiusOfGyration.ix),
            raw: radiusOfGyration.ix,
            unit: 'cm'
        }));
    }

    if (radiusOfGyration.iy || Number.isFinite(radiusOfGyration.iyNumeric)) {
        propertyChips.push(createChip({
            label: 'iy',
            numeric: radiusOfGyration.iyNumeric ?? asNumeric(radiusOfGyration.iy),
            raw: radiusOfGyration.iy,
            unit: 'cm'
        }));
    }

    if (densityProp.value || Number.isFinite(densityProp.numeric)) {
        propertyChips.push(createChip({
            label: 'œÅ',
            numeric: densityProp.numeric ?? asNumeric(densityProp.value),
            raw: densityProp.value,
            unit: 'kg/m¬≥',
            suffix: densityProp.label && densityProp.label !== densityProp.value ? densityProp.label : ''
        }));
    }

    const propertySectionHTML = propertyChips.length
        ? `<div class="tooltip-subsection"><div class="tooltip-subtitle">Áâ©ÊÄßÂÄ§</div><div class="tooltip-chip-list">${propertyChips.join('')}</div></div>`
        : '';

    const connectionChips = [];
    if (connections.start?.label || connections.start?.value) {
        connectionChips.push(`<div class="tooltip-chip tooltip-chip--connection"><span class="chip-label">ÂßãÁ´Ø</span><span class="chip-value">${connections.start.label || connections.start.value}</span></div>`);
    }
    if (connections.end?.label || connections.end?.value) {
        connectionChips.push(`<div class="tooltip-chip tooltip-chip--connection"><span class="chip-label">ÁµÇÁ´Ø</span><span class="chip-value">${connections.end.label || connections.end.value}</span></div>`);
    }

    const connectionSectionHTML = connectionChips.length
        ? `<div class="tooltip-subsection"><div class="tooltip-subtitle">Êé•ÂêàÊù°‰ª∂</div><div class="tooltip-chip-list compact">${connectionChips.join('')}</div></div>`
        : '';

    const loadChips = [];
    const uniformLoadNumeric = asNumeric(loads.uniform);
    if (uniformLoadNumeric !== null) {
        loadChips.push(createChip({ label: 'w', numeric: uniformLoadNumeric, unit: 'kN/m', digits: 2 }));
    } else if (loads.uniform !== null && loads.uniform !== undefined && String(loads.uniform).trim() !== '') {
        loadChips.push(createChip({ label: 'w', raw: String(loads.uniform).trim(), unit: 'kN/m' }));
    }
    if (selfWeightPerLength !== null && selfWeightPerLength !== undefined) {
        loadChips.push(createChip({ label: 'Ëá™Èáç', numeric: selfWeightPerLength, unit: 'kN/m', digits: 3 }));
    }

    const loadSectionHTML = loadChips.length
        ? `<div class="tooltip-subsection"><div class="tooltip-subtitle">Ëç∑Èáç</div><div class="tooltip-chip-list compact">${loadChips.join('')}</div></div>`
        : '';

    // ==========================================================
    // Ëß£ÊûêÁµêÊûú„Çª„ÇØ„Ç∑„Éß„É≥
    // ==========================================================
    let analysisSectionHTML = '';

    // Ëß£ÊûêÁµêÊûú„Åå„Ç∞„É≠„Éº„Éê„É´Â§âÊï∞„Å´Â≠òÂú®„Åô„Çã„Åã„ÉÅ„Çß„ÉÉ„ÇØ
    if (window.lastResults && window.lastSectionCheckResults && window.lastBucklingResults) {
        const memberIndex = memberData.number - 1;

        const summaryChips = [];
        const statItems = [];

        // --- Êñ≠Èù¢ÁÆóÂÆöÁµêÊûú ---
        const checkResult = window.lastSectionCheckResults[memberIndex];
        if (checkResult && checkResult.maxRatio !== 'N/A') {
            const isNg = checkResult.status === 'NG';

            // ÊúÄÂ§ßÂêàÊàêÂøúÂäõÂ∫¶„ÇíË®àÁÆó
            let maxCombinedStress = null;
            const N = asNumeric(checkResult.N);
            const M = asNumeric(checkResult.M);
            const A_m2 = asNumeric(properties?.area?.numeric) * 1e-4; // cm2 -> m2
            const Z_m3 = asNumeric(properties?.sectionModulus?.numeric) * 1e-6; // cm3 -> m3

            if (N !== null && M !== null && A_m2 !== null && Z_m3 !== null && A_m2 > 0 && Z_m3 > 0) {
                const sigma_a = (Math.abs(N) * 1000) / (A_m2 * 1e6); // kN -> N, m2 -> mm2 => N/mm2
                const sigma_b = (Math.abs(M) * 1e6) / (Z_m3 * 1e9); // kNm -> Nmm, m3 -> mm3 => N/mm2
                maxCombinedStress = sigma_a + sigma_b;
                statItems.push(`<div class="tooltip-stat-item"><span class="stat-label">ÊúÄÂ§ßÂêàÊàêÂøúÂäõÂ∫¶</span><span class="stat-value">${maxCombinedStress.toFixed(1)} N/mm¬≤</span></div>`);
            }

            summaryChips.push(createChip({
                label: 'ÊúÄÂ§ßÊ§úÂÆöÊØî',
                numeric: checkResult.maxRatio,
                digits: 3,
                emphasis: isNg, // NG„ÅÆÂ†¥Âêà„ÅØÂº∑Ë™øË°®Á§∫
                wide: true,
                subValue: `Âà§ÂÆö: ${checkResult.status}`
            }));
        }

        // --- Â∫ßÂ±àËß£ÊûêÁµêÊûú ---
        const bucklingResult = window.lastBucklingResults[memberIndex];
        if (bucklingResult && typeof bucklingResult.safetyFactor === 'number' && isFinite(bucklingResult.safetyFactor)) {
            const isDangerous = bucklingResult.status === 'Â∫ßÂ±àÂç±Èô∫';
            const isWarning = bucklingResult.status === 'Ë¶ÅÊ≥®ÊÑè';
            summaryChips.push(createChip({
                label: 'Â∫ßÂ±àÂÆâÂÖ®Áéá',
                numeric: bucklingResult.safetyFactor,
                digits: 2,
                emphasis: isDangerous || isWarning, // Âç±Èô∫„ÉªË¶ÅÊ≥®ÊÑè„ÅÆÂ†¥Âêà„ÅØÂº∑Ë™øË°®Á§∫
                wide: true,
                subValue: `Âà§ÂÆö: ${bucklingResult.status}`
            }));
        }

        // --- ÊúÄÂ§ßÊñ≠Èù¢Âäõ ---
        const forceResult = window.lastResults.forces[memberIndex];
        if (forceResult) {
            const maxAxial = Math.max(Math.abs(forceResult.N_i), Math.abs(forceResult.N_j));
            const maxShear = Math.max(Math.abs(forceResult.Q_i), Math.abs(forceResult.Q_j));
            const maxMoment = Math.max(Math.abs(forceResult.M_i), Math.abs(forceResult.M_j));

            statItems.push(`<div class="tooltip-stat-item"><span class="stat-label">ÊúÄÂ§ßËª∏Âäõ</span><span class="stat-value">${maxAxial.toFixed(1)} kN</span></div>`);
            statItems.push(`<div class="tooltip-stat-item"><span class="stat-label">ÊúÄÂ§ß„Åõ„ÇìÊñ≠Âäõ</span><span class="stat-value">${maxShear.toFixed(1)} kN</span></div>`);
            statItems.push(`<div class="tooltip-stat-item"><span class="stat-label">ÊúÄÂ§ßÊõ≤„ÅíM</span><span class="stat-value">${maxMoment.toFixed(1)} kN¬∑m</span></div>`);
        }

        if (summaryChips.length > 0 || statItems.length > 0) {
            analysisSectionHTML = `
                <div class="tooltip-subsection">
                    <div class="tooltip-subtitle">üìà Ëß£ÊûêÁµêÊûú</div>
                    ${summaryChips.length > 0 ? `<div class="tooltip-chip-list">${summaryChips.join('')}</div>` : ''}
                    ${statItems.length > 0 ? `<div class="tooltip-stat-grid" style="margin-top: 8px;">${statItems.join('')}</div>` : ''}
                </div>`;
        }
    }
    // ==========================================================

    let sectionColumnHTML = '';
    const axisChip = axisLabel ? `<span class="section-axis-chip">${axisLabel}</span>` : '';
    const sectionSummaryText = sectionSummary || sectionInfo?.dimensionSummary;

    if (sectionInfo) {
        const dimensionItems = Array.isArray(sectionInfo.dimensions)
            ? sectionInfo.dimensions.filter(dim => dim && typeof dim.value === 'number' && isFinite(dim.value))
            : [];
        const limitedItems = dimensionItems.slice(0, 8);

        const dimensionsHTML = limitedItems.length > 0
            ? `<div class="section-dimension-grid">${limitedItems.map(dim => `<div class="section-dimension-item"><span class="dim-key">${dim.label || dim.key}</span><span class="dim-value">${dim.value} mm</span></div>`).join('')}</div>`
            : '';

        sectionColumnHTML = `
            <div class="section-preview-card">
                <div class="section-preview-header">
                    <span class="section-title">${sectionInfo.label || 'Êñ≠Èù¢ÊÉÖÂ†±'}</span>
                    ${axisChip}
                </div>
                ${sectionSummaryText ? `<div class="section-summary-text">${sectionSummaryText}</div>` : ''}
                ${sectionInfo.svgMarkup ? `<div class="tooltip-section-preview">${sectionInfo.svgMarkup}</div>` : ''}
                ${dimensionsHTML}
                ${sectionInfo.source ? `<div class="section-source">ÂèÇÁÖß: ${sectionInfo.source}</div>` : ''}
            </div>
        `.trim();
    } else {
        sectionColumnHTML = `
            <div class="section-preview-card">
                <div class="section-preview-header">
                    <span class="section-title">Êñ≠Èù¢ÊÉÖÂ†±</span>
                    ${axisChip}
                </div>
                <div class="section-placeholder">Êñ≠Èù¢ÊÉÖÂ†±„ÅåË®≠ÂÆö„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇ</div>
                ${sectionSummaryText ? `<div class="section-summary-text">${sectionSummaryText}</div>` : ''}
            </div>
        `.trim();
    }

    // 3Âàó„É¨„Ç§„Ç¢„Ç¶„ÉàÁî®„Å´ÊÉÖÂ†±„ÇíÂàÜÂâ≤
    const column1HTML = [
        summaryChipsHTML ? `<div class="tooltip-summary-chip-row">${summaryChipsHTML}</div>` : '',
        generalInfoSectionHTML,
        connectionSectionHTML
    ].filter(Boolean).join('');

    const column2HTML = [
        propertySectionHTML,
        loadSectionHTML,
        analysisSectionHTML
    ].filter(Boolean).join('');

    let content = `<div class="tooltip-header">ÈÉ®Êùê ${number}</div>`;
    content += `<div class="tooltip-body">`;
    content += `<div class="tooltip-info-pane">${column1HTML}</div>`;
    content += `<div class="tooltip-info-pane">${column2HTML}</div>`;
    content += `<div class="tooltip-figure-pane">${sectionColumnHTML}</div>`;
    content += `</div>`;
    
    tooltip.innerHTML = content;
    console.log('üìù „ÉÑ„Éº„É´„ÉÅ„ÉÉ„Éó„Ç≥„É≥„ÉÜ„É≥„ÉÑË®≠ÂÆöÂÆå‰∫Ü');
    
    // hidden„ÇØ„É©„Çπ„ÇíÂâäÈô§„Åó„Å¶„ÉÑ„Éº„É´„ÉÅ„ÉÉ„Éó„ÇíË°®Á§∫
    tooltip.classList.remove('hidden');
    tooltip.style.display = 'block';
    console.log('üëÅÔ∏è „ÉÑ„Éº„É´„ÉÅ„ÉÉ„ÉóË°®Á§∫Áä∂ÊÖãÂ§âÊõ¥ÂÆå‰∫Ü');
    
    // „ÉÑ„Éº„É´„ÉÅ„ÉÉ„Éó„ÅÆ‰ΩçÁΩÆ„ÇíË™øÊï¥
    const rect = tooltip.getBoundingClientRect();
    const offsetParent = tooltip.offsetParent;
    const padding = 10;
    let computedLeft;
    let computedTop;

    if (offsetParent) {
        const parentRect = offsetParent.getBoundingClientRect();
        const parentScrollLeft = offsetParent.scrollLeft || 0;
        const parentScrollTop = offsetParent.scrollTop || 0;
        const parentWidth = offsetParent.clientWidth || window.innerWidth;
        const parentHeight = offsetParent.clientHeight || window.innerHeight;

        const relativeX = mouseX - parentRect.left + parentScrollLeft;
        const relativeY = mouseY - parentRect.top + parentScrollTop;

        let left = relativeX + padding;
        let top = relativeY - padding;

        const maxLeft = parentScrollLeft + parentWidth - rect.width - padding;
        if (left > maxLeft) {
            left = Math.max(parentScrollLeft + padding, relativeX - rect.width - padding);
        }

        const maxTop = parentScrollTop + parentHeight - rect.height - padding;
        if (top > maxTop) {
            top = Math.max(parentScrollTop + padding, relativeY - rect.height - padding);
        }

        computedLeft = left;
        computedTop = top;
    } else {
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;

        let left = mouseX + padding;
        let top = mouseY - padding;

        if (left + rect.width > viewportWidth) {
            left = Math.max(padding, mouseX - rect.width - padding);
        }

        if (top + rect.height > viewportHeight) {
            top = Math.max(padding, mouseY - rect.height - padding);
        }

        computedLeft = left;
        computedTop = top;
    }

    tooltip.style.left = `${computedLeft}px`;
    tooltip.style.top = `${computedTop}px`;

    console.log('‚úÖ „ÉÑ„Éº„É´„ÉÅ„ÉÉ„ÉóË°®Á§∫ÂÆå‰∫Ü:', {
        ‰ΩçÁΩÆ: `${computedLeft}px, ${computedTop}px`,
        „Çµ„Ç§„Ç∫: `${rect.width}px √ó ${rect.height}px`,
        visible: tooltip.style.display,
        hiddenClass: tooltip.classList.contains('hidden')
    });
}

function hideMemberTooltip() {
    const tooltip = document.querySelector('.member-tooltip');
    if (tooltip) {
        tooltip.classList.add('hidden');
        tooltip.style.display = 'none';
        console.log('üîß „ÉÑ„Éº„É´„ÉÅ„ÉÉ„ÉóÈùûË°®Á§∫ÂÆå‰∫Ü');
    }
}

document.addEventListener('DOMContentLoaded', () => {
    console.log('üîç DOMContentLoaded„Ç§„Éô„É≥„Éà„ÅåÁô∫ÁÅ´„Åó„Åæ„Åó„Åü');
    
    // DOM Elements
    const elements = {
        nodesTable: document.getElementById('nodes-table').getElementsByTagName('tbody')[0],
        membersTable: document.getElementById('members-table').getElementsByTagName('tbody')[0],
        nodeLoadsTable: document.getElementById('node-loads-table').getElementsByTagName('tbody')[0],
        memberLoadsTable: document.getElementById('member-loads-table').getElementsByTagName('tbody')[0],
        addNodeBtn: document.getElementById('add-node-btn'),
        addMemberBtn: document.getElementById('add-member-btn'),
        addNodeLoadBtn: document.getElementById('add-node-load-btn'),
        addMemberLoadBtn: document.getElementById('add-member-load-btn'),
        calculateBtn: document.getElementById('calculate-btn'),
        calculateAndAnimateBtn: document.getElementById('calculate-and-animate-btn'),
        presetSelector: document.getElementById('preset-selector'),
        displacementResults: document.getElementById('displacement-results'),
        reactionResults: document.getElementById('reaction-results'),
        forceResults: document.getElementById('force-results'),
        errorMessage: document.getElementById('error-message'),
        modelCanvas: document.getElementById('model-canvas'),
        displacementCanvas: document.getElementById('displacement-canvas'),
        momentCanvas: document.getElementById('moment-canvas'),
        axialCanvas: document.getElementById('axial-canvas'),
        shearCanvas: document.getElementById('shear-canvas'),
        stressCanvas: document.getElementById('stress-canvas'),
        modeSelectBtn: document.getElementById('mode-select'),
        modeAddNodeBtn: document.getElementById('mode-add-node'),
        modeAddMemberBtn: document.getElementById('mode-add-member'),
        undoBtn: document.getElementById('undo-btn'),
        nodeContextMenu: document.getElementById('node-context-menu'),
        memberPropsPopup: document.getElementById('member-props-popup'),
        nodePropsPopup: document.getElementById('node-props-popup'),
        nodeLoadPopup: document.getElementById('node-load-popup'),
        nodeCoordsPopup: document.getElementById('node-coords-popup'),
        addMemberPopup: document.getElementById('add-member-popup'),
        gridToggle: document.getElementById('grid-toggle'),
        memberInfoToggle: document.getElementById('member-info-toggle'),
        gridSpacing: document.getElementById('grid-spacing'),
        animScaleInput: document.getElementById('anim-scale-input'),
        saveBtn: document.getElementById('save-btn'),
        loadBtn: document.getElementById('load-btn'),
        exportExcelBtn: document.getElementById('export-excel-btn'),
        reportBtn: document.getElementById('report-btn'),
        ratioCanvas: document.getElementById('ratio-canvas'),
        sectionCheckResults: document.getElementById('section-check-results'),
        deflectionCheckResults: document.getElementById('deflection-check-results'),
        ltbCheckResults: document.getElementById('ltb-check-results'),
        loadTermRadios: document.querySelectorAll('input[name="load-term"]'),
        resetModelBtn: document.getElementById('reset-model-btn'),
        autoScaleBtn: document.getElementById('auto-scale-btn'),
        zoomInBtn: document.getElementById('zoom-in-btn'),
        zoomOutBtn: document.getElementById('zoom-out-btn'),
        considerSelfWeightCheckbox: document.getElementById('consider-self-weight-checkbox'),
    };

    // Make elements object globally accessible
    window.elements = elements;

    // --- ËøΩÂä†: ÈÉ®ÊùêËøΩÂä†„Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó„ÅÆË°®Á§∫ÂàáÊõøÂà∂Âæ° ---
    const setupAddMemberPopupToggles = () => {
        const popup = document.getElementById('add-member-popup');
        if (!popup) return;

        const toggles = popup.querySelectorAll('.add-popup-toggle');
        
        const updateVisibility = () => {
            toggles.forEach(toggle => {
                const targetClass = toggle.getAttribute('data-target');
                const isChecked = toggle.checked;
                
                // „Éù„ÉÉ„Éó„Ç¢„ÉÉ„ÉóÂÜÖ„ÅÆÂØæË±°„ÇØ„É©„Çπ„ÇíÊåÅ„Å§Ë¶ÅÁ¥†„ÇíÂÖ®„Å¶ÂèñÂæó
                const targetElements = popup.querySelectorAll(`.${targetClass}`);
                targetElements.forEach(el => {
                    // props-gridÂÜÖ„ÅÆ„É¨„Ç§„Ç¢„Ç¶„Éà„ÇíÂ¥©„Åï„Å™„ÅÑ„Çà„ÅÜ„ÄÅdisplay„Éó„É≠„Éë„ÉÜ„Ç£„ÇíÈÅ©Âàá„Å´Âà∂Âæ°
                    if (el.tagName === 'LABEL' || el.tagName === 'INPUT' || el.tagName === 'SELECT' || el.tagName === 'DIV') {
                        // „Ç∞„É™„ÉÉ„Éâ„Ç¢„Ç§„ÉÜ„É†„Å®„Åó„Å¶„ÅÆË°®Á§∫Âà∂Âæ° (CSS„Å´Âßî„Å≠„Çã„Åãnone„Å´„Åô„Çã)
                        el.style.display = isChecked ? '' : 'none';
                    }
                });
            });
        };

        toggles.forEach(toggle => {
            toggle.addEventListener('change', updateVisibility);
        });

        // ÂàùÊúüÁä∂ÊÖã„ÅÆÈÅ©Áî®
        updateVisibility();
    };

    // ÂàùÊúüÂåñÊôÇ„Å´ÂÆüË°å
    try { setupAddMemberPopupToggles(); } catch (err) { console.warn('setupAddMemberPopupToggles failed', err); }

    // ‚ñº‚ñº‚ñº ‰øÆÊ≠£: Âõ≥Âà•„ÅÆÊñáÂ≠ó„Çµ„Ç§„Ç∫„Çπ„É©„Ç§„ÉÄ„ÉºÂàùÊúüÂåñ ‚ñº‚ñº‚ñº
    window.settings = window.settings || {};
    window.settings.fontScales = window.settings.fontScales || {
        model: 1.0,
        displacement: 1.0,
        moment: 1.0,
        axial: 1.0,
        shear: 1.0,
        stress: 1.0,
        ratio: 1.0
    };
    window.settings.deflectionCheck = window.settings.deflectionCheck || {
        amplificationFactor: 1.0,
        allowableDeflectionMm: 10,
        spanRatio: 300
    };

    window.settings.ltbCheck = window.settings.ltbCheck || {
        unbracedLengthFactor: 1.0,
        cb: 1.0,
        nu: 0.30
    };
    // ‰∫íÊèõÊÄß„ÅÆ„Åü„ÇÅ„ÄÅÂæìÊù•„ÅÆÂçò‰∏ÄË®≠ÂÆö„ÇÇ model „Çπ„Ç±„Éº„É´„ÅßÂàùÊúüÂåñ
    window.settings.fontScale = window.settings.fontScales.model;

    const setupFontSlider = (type, drawCallback) => {
        const slider = document.getElementById(`font-scale-${type}`);
        const label = document.getElementById(`font-scale-value-${type}`) || document.getElementById(`font-scale-value-${type}`);
        if (slider && label) {
            // ÂàùÊúüË°®Á§∫
            slider.value = window.settings.fontScales[type] || 1.0;
            label.textContent = (window.settings.fontScales[type] || 1.0).toFixed(1) + 'x';
            slider.addEventListener('input', (e) => {
                const scale = parseFloat(e.target.value) || 1.0;
                window.settings.fontScales[type] = scale;
                // ‰∫íÊèõÊÄß: model „Çπ„É©„Ç§„ÉÄ„Éº„ÅØÂæìÊù•„ÅÆ fontScale „ÇÇÊõ¥Êñ∞
                if (type === 'model') window.settings.fontScale = scale;
                label.textContent = scale.toFixed(1) + 'x';
                try { if (drawCallback) drawCallback(); } catch (err) { console.warn('font slider draw error', err); }
            });
        }
    };

    // ÂêÑ„Çπ„É©„Ç§„ÉÄ„Éº„ÇíË®≠ÂÆö
    setupFontSlider('model', () => { if (typeof drawOnCanvas === 'function') drawOnCanvas(); });

    setupFontSlider('displacement', () => {
        if (window.lastResults && typeof drawDisplacementDiagram === 'function') {
            const { D, nodes, members, memberLoads } = window.lastResults;
            drawDisplacementDiagram(nodes, members, D, memberLoads);
        }
    });

    setupFontSlider('moment', () => {
        if (window.lastResults && typeof drawMomentDiagram === 'function') {
            const { forces, nodes, members, memberLoads } = window.lastResults;
            drawMomentDiagram(nodes, members, forces, memberLoads);
        }
    });

    setupFontSlider('axial', () => {
        if (window.lastResults && typeof drawAxialForceDiagram === 'function') {
            const { forces, nodes, members } = window.lastResults;
            drawAxialForceDiagram(nodes, members, forces);
        }
    });

    setupFontSlider('shear', () => {
        if (window.lastResults && typeof drawShearForceDiagram === 'function') {
            const { forces, nodes, members, memberLoads } = window.lastResults;
            drawShearForceDiagram(nodes, members, forces, memberLoads);
        }
    });

    setupFontSlider('stress', () => {
        if (window.lastResults && typeof drawStressContour === 'function') {
            const { forces, nodes, members } = window.lastResults;
            const sections = members.map(m => m.sectionInfo?.rawDims || {});
            drawStressContour(nodes, members, forces, sections);
        }
    });

    setupFontSlider('ratio', () => { if (typeof drawRatioDiagram === 'function') drawRatioDiagram(); });
    // ‚ñ≤‚ñ≤‚ñ≤ Âõ≥Âà•ÊñáÂ≠ó„Çµ„Ç§„Ç∫ÂàùÊúüÂåñ ÁµÇ‰∫Ü ‚ñ≤‚ñ≤‚ñ≤

    // ÂêÑÂõ≥„ÅÆ„ÄåÂÖ®‰ΩìË°®Á§∫ / Fit„Äç„Éú„Çø„É≥Ë®≠ÂÆö
    const setupFitButton = (type, drawCallback) => {
        const btn = document.getElementById(`fit-view-${type}`);
        if (!btn) return;
        btn.addEventListener('click', () => {
            try {
                // „É™„Çª„ÉÉ„Éà: „Éë„É≥Ôºè„Ç∫„Éº„É†Áä∂ÊÖã
                if (type === 'model') {
                    panZoomState.isInitialized = false;
                    // „É™„Çª„ÉÉ„Éà„Åó„Åü„Çâ„É¢„Éá„É´Âõ≥„ÇíÂÜçÊèèÁîª
                    if (typeof drawOnCanvas === 'function') drawOnCanvas();
                    // „Éï„Ç©„É≥„Éà„Çπ„Ç±„Éº„É´„ÇÇÂàùÊúüÂåñ
                    window.settings.fontScales.model = 1.0;
                    const s = document.getElementById('font-scale-model');
                    const v = document.getElementById('font-scale-value-model');
                    if (s) s.value = '1.0';
                    if (v) v.textContent = '1.0x';
                } else {
                    if (resultPanZoomStates[type]) resultPanZoomStates[type].isInitialized = false;
                    window.settings.fontScales[type] = 1.0;
                    const s = document.getElementById(`font-scale-${type}`);
                    const v = document.getElementById(`font-scale-value-${type}`);
                    if (s) s.value = '1.0';
                    if (v) v.textContent = '1.0x';
                    // ÁµêÊûúÂõ≥„ÇíÂÜçÊèèÁîª
                    if (drawCallback) {
                        drawCallback();
                    } else {
                        if (type === 'displacement' && typeof drawDisplacementDiagram === 'function' && window.lastResults) {
                            const { D, nodes, members, memberLoads } = window.lastResults;
                            drawDisplacementDiagram(nodes, members, D, memberLoads);
                        } else if (type === 'moment' && typeof drawMomentDiagram === 'function' && window.lastResults) {
                            const { forces, nodes, members, memberLoads } = window.lastResults;
                            drawMomentDiagram(nodes, members, forces, memberLoads);
                        } else if (type === 'axial' && typeof drawAxialForceDiagram === 'function' && window.lastResults) {
                            const { forces, nodes, members } = window.lastResults;
                            drawAxialForceDiagram(nodes, members, forces);
                        } else if (type === 'shear' && typeof drawShearForceDiagram === 'function' && window.lastResults) {
                            const { forces, nodes, members, memberLoads } = window.lastResults;
                            drawShearForceDiagram(nodes, members, forces, memberLoads);
                        } else if (type === 'ratio' && typeof drawRatioDiagram === 'function') {
                            drawRatioDiagram();
                        }
                    }
                }
            } catch (err) {
                console.warn('Fit button handler error', err);
            }
        });
    };

    // ÂêÑÂõ≥„ÅÆ Fit „Éú„Çø„É≥„ÇíÁôªÈå≤
    setupFitButton('model', () => { if (typeof drawOnCanvas === 'function') drawOnCanvas(); });
    setupFitButton('displacement', () => {
        if (window.lastResults && typeof drawDisplacementDiagram === 'function') {
            const { D, nodes, members, memberLoads } = window.lastResults;
            drawDisplacementDiagram(nodes, members, D, memberLoads);
        }
    });
    setupFitButton('moment', () => {
        if (window.lastResults && typeof drawMomentDiagram === 'function') {
            const { forces, nodes, members, memberLoads } = window.lastResults;
            drawMomentDiagram(nodes, members, forces, memberLoads);
        }
    });
    setupFitButton('axial', () => {
        if (window.lastResults && typeof drawAxialForceDiagram === 'function') {
            const { forces, nodes, members } = window.lastResults;
            drawAxialForceDiagram(nodes, members, forces);
        }
    });
    setupFitButton('shear', () => {
        if (window.lastResults && typeof drawShearForceDiagram === 'function') {
            const { forces, nodes, members, memberLoads } = window.lastResults;
            drawShearForceDiagram(nodes, members, forces, memberLoads);
        }
    });
    setupFitButton('ratio', () => { if (typeof drawRatioDiagram === 'function') drawRatioDiagram(); });

    // „Éù„ÉÉ„Éó„Ç¢„ÉÉ„ÉóÂÜÖ„ÅÆ„Éê„ÉçÂÖ•ÂäõË°®Á§∫ÂàáÊõø„ÅÆÂàùÊúüË®≠ÂÆö
    try {
        const popupIConn = document.getElementById('popup-i-conn');
        const popupJConn = document.getElementById('popup-j-conn');
        const popupISpringBox = document.getElementById('popup-i-spring-box');
        const popupJSpringBox = document.getElementById('popup-j-spring-box');
        const toggleBox = (selectEl, boxEl) => {
            if (!selectEl || !boxEl) return;
            boxEl.style.display = (selectEl.value === 'spring') ? '' : 'none';
        };
        if (popupIConn && popupISpringBox) {
            popupIConn.addEventListener('change', () => toggleBox(popupIConn, popupISpringBox));
            toggleBox(popupIConn, popupISpringBox);
        }
        if (popupJConn && popupJSpringBox) {
            popupJConn.addEventListener('change', () => toggleBox(popupJConn, popupJSpringBox));
            toggleBox(popupJConn, popupJSpringBox);
        }
    } catch (e) {
        console.warn('popup spring init error', e);
    }

    // AIÊ©üËÉΩ„ÅÆË°®Á§∫Âàá„ÇäÊõø„ÅàË®≠ÂÆö
    setupAIFeaturesToggle();
    
    // AI„É¢„Éá„É´ÁîüÊàê„ÅÆ„Ç§„Éô„É≥„Éà„É™„Çπ„Éä„ÉºË®≠ÂÆö
    setupAIModelGenerationListeners();
    
    // Èü≥Â£∞ÂÖ•ÂäõÊ©üËÉΩ„ÅÆ„Ç§„Éô„É≥„Éà„É™„Çπ„Éä„ÉºË®≠ÂÆö
    setupVoiceInputListeners();

    // „Éá„Éê„ÉÉ„Ç∞: „Ç®„ÇØ„Çª„É´Âá∫Âäõ„Éú„Çø„É≥„ÅÆÂ≠òÂú®Á¢∫Ë™ç
    console.log('„Ç®„ÇØ„Çª„É´Âá∫Âäõ„Éú„Çø„É≥„ÅÆË¶ÅÁ¥†:', elements.exportExcelBtn);
    console.log('„Éú„Çø„É≥„ÅåÂ≠òÂú®„Åô„Çã„Åã:', !!elements.exportExcelBtn);
    
    // „Éá„Éê„ÉÉ„Ç∞: ÈáçË¶Å„Å™„Éù„ÉÉ„Éó„Ç¢„ÉÉ„ÉóË¶ÅÁ¥†„ÅÆÂ≠òÂú®Á¢∫Ë™ç
    console.log('üîç „Éù„ÉÉ„Éó„Ç¢„ÉÉ„ÉóË¶ÅÁ¥†„ÉÅ„Çß„ÉÉ„ÇØ:', {
        memberPropsPopup: !!elements.memberPropsPopup,
        nodePropsPopup: !!elements.nodePropsPopup,
        addMemberPopup: !!elements.addMemberPopup
    });
    
    // „Éá„Éê„ÉÉ„Ç∞: ÈÉ®ÊùêËøΩÂä†„Éú„Çø„É≥„ÅÆÂ≠òÂú®Á¢∫Ë™ç
    console.log('üîç ÈÉ®ÊùêËøΩÂä†„Éú„Çø„É≥„ÉÅ„Çß„ÉÉ„ÇØ:', {
        modeAddMemberBtn: !!elements.modeAddMemberBtn,
        buttonElement: elements.modeAddMemberBtn
    });

    let panZoomState = { scale: 1, offsetX: 0, offsetY: 0, isInitialized: false };
    
    // Make panZoomState globally accessible
    window.panZoomState = panZoomState;
    
    let lastResults = null;
    let lastAnalysisResult = null;
    let lastSectionCheckResults = null;
    let lastDeflectionCheckResults = null;
    let lastLtbCheckResults = null;
    let lastDisplacementScale = 0;
    
    // „Éû„Ç¶„Çπ‰ΩçÁΩÆ„ÇíËøΩË∑°ÔºàË¶ñË¶öÁöÑ„Éï„Ç£„Éº„Éâ„Éê„ÉÉ„ÇØÁî®Ôºâ
    let currentMouseX = 0;
    let currentMouseY = 0;
    
    // ÁµêÊûúÂõ≥„ÅÆ„Éë„É≥„Éª„Ç∫„Éº„É†Áä∂ÊÖã„ÇíÁÆ°ÁêÜ
    let resultPanZoomStates = {
        displacement: { scale: 1, offsetX: 0, offsetY: 0, isInitialized: false },
        moment: { scale: 1, offsetX: 0, offsetY: 0, isInitialized: false },
        axial: { scale: 1, offsetX: 0, offsetY: 0, isInitialized: false },
        shear: { scale: 1, offsetX: 0, offsetY: 0, isInitialized: false },
        ratio: { scale: 1, offsetX: 0, offsetY: 0, isInitialized: false }
    };

    const dispScaleInput = document.getElementById('disp-scale-input');
    dispScaleInput.addEventListener('change', (e) => {
        if(lastResults) {
            const newScale = parseFloat(e.target.value);
            if(!isNaN(newScale)) {
                drawDisplacementDiagram(lastResults.nodes, lastResults.members, lastResults.D, lastResults.memberLoads, newScale);
            }
        }
    });

    // Global State
    let canvasMode = 'select';
    let firstMemberNode = null;
    let selectedNodeIndex = null;
    let selectedMemberIndex = null;
    let isDragging = false;
    let isDraggingCanvas = false;
    
    // „ÉÑ„Éº„É´„ÉÅ„ÉÉ„ÉóË¶ÅÁ¥†„ÅÆÂ≠òÂú®Á¢∫Ë™çÔºà„Éá„Éê„ÉÉ„Ç∞Áî®Ôºâ
    const tooltipElement = document.querySelector('.member-tooltip');
    console.log('üîç ÂàùÊúüÂåñÊôÇ„ÉÑ„Éº„É´„ÉÅ„ÉÉ„ÉóË¶ÅÁ¥†„ÉÅ„Çß„ÉÉ„ÇØ:', {
        Â≠òÂú®: !!tooltipElement,
        id: tooltipElement?.id,
        „ÇØ„É©„Çπ: tooltipElement?.className,
        Ë°®Á§∫Áä∂ÊÖã: tooltipElement?.style.display,
        hidden„ÇØ„É©„Çπ: tooltipElement?.classList.contains('hidden')
    });
    
    if (!tooltipElement) {
        console.warn('‚ö†Ô∏è „ÉÑ„Éº„É´„ÉÅ„ÉÉ„ÉóË¶ÅÁ¥†„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„ÇìÔºÅHTML„ÇíÁ¢∫Ë™ç„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ');
    }
    let lastMouseX = 0;
    let lastMouseY = 0;
    // let historyStack = []; // HistoryManager„Å´ÁßªË°å
    const resolutionScale = 2.0;
    let newMemberDefaults = { E: '205000', F: '235', I: '18400', A: '2340', Z: '1230', i_conn: 'rigid', j_conn: 'rigid' };
    
    // „Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó„ÅÆÂàùÊúüÂåñÔºàÁ¢∫ÂÆü„Å´ÈùûË°®Á§∫„Å´„Åô„ÇãÔºâ
    if (elements.memberPropsPopup) {
        elements.memberPropsPopup.style.display = 'none';
        elements.memberPropsPopup.style.visibility = 'hidden';
        console.log('‚úÖ memberPropsPopupÂàùÊúüÂåñÂÆå‰∫Ü (ÈùûË°®Á§∫Ë®≠ÂÆö)');
    }
    if (elements.nodePropsPopup) {
        elements.nodePropsPopup.style.display = 'none';
        elements.nodePropsPopup.style.visibility = 'hidden';
        console.log('‚úÖ nodePropsPopupÂàùÊúüÂåñÂÆå‰∫Ü (ÈùûË°®Á§∫Ë®≠ÂÆö)');
    }
    if (elements.nodeLoadPopup) {
        elements.nodeLoadPopup.style.display = 'none';
        elements.nodeLoadPopup.style.visibility = 'hidden';
    }
    if (elements.nodeCoordsPopup) {
        elements.nodeCoordsPopup.style.display = 'none';
        elements.nodeCoordsPopup.style.visibility = 'hidden';
    }
    if (elements.addMemberPopup) {
        elements.addMemberPopup.style.display = 'none';
        elements.addMemberPopup.style.visibility = 'hidden';
    }
    
    // „ÉÑ„Éº„É´„ÉÅ„ÉÉ„ÉóË°®Á§∫„ÅÆÁä∂ÊÖãÁÆ°ÁêÜ
    let hoveredMember = null;
    let tooltipTimeout = null;
    
    // „Ç∞„É≠„Éº„Éê„É´Â§âÊï∞„Çíwindow„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„Å´ÁôªÈå≤Ôºà„Éè„Ç§„É©„Ç§„ÉàÈñ¢Êï∞„Åã„Çâ„Ç¢„ÇØ„Çª„Çπ„Åß„Åç„Çã„Çà„ÅÜ„Å´Ôºâ
    window.selectedNodeIndex = null;
    window.selectedMemberIndex = null;
    
    // Ë§áÊï∞ÈÅ∏ÊäûÊ©üËÉΩ„ÅÆÁä∂ÊÖã
    let isMultiSelecting = false;
    let multiSelectStart = { x: 0, y: 0 };
    let multiSelectEnd = { x: 0, y: 0 };
    let selectedNodes = new Set();
    let selectedMembers = new Set();
    let isShiftPressed = false;
    let isRangeSelecting = false;
    let rangeSelectionAdditive = false;
    let selectionChoiceMenu = null;
    
    // windowÂ§âÊï∞„Å®„Åó„Å¶ÁôªÈå≤Ôºà„ÇØ„É≠„Çπ„Çπ„Ç≥„Éº„Éó„Ç¢„ÇØ„Çª„ÇπÁî®Ôºâ
    window.selectedNodes = selectedNodes;
    window.selectedMembers = selectedMembers;
    
    // Ë§áÊï∞ÈÅ∏ÊäûÁî®„ÅÆÈñ¢Êï∞
    const clearMultiSelection = () => {
        console.log('Ë§áÊï∞ÈÅ∏Êäû„Çí„ÇØ„É™„Ç¢ - ‰ª•Ââç„ÅÆÁä∂ÊÖã:', {
            selectedNodes: Array.from(selectedNodes),
            selectedMembers: Array.from(selectedMembers),
            windowSelectedNodes: Array.from(window.selectedNodes || []),
            windowSelectedMembers: Array.from(window.selectedMembers || [])
        });
        selectedNodes.clear();
        selectedMembers.clear();
        console.log('Ë§áÊï∞ÈÅ∏Êäû„ÇØ„É™„Ç¢Âæå - windowÂêåÊúüÁ¢∫Ë™ç:', {
            windowSelectedNodesSize: window.selectedNodes ? window.selectedNodes.size : 'undefined',
            windowSelectedMembersSize: window.selectedMembers ? window.selectedMembers.size : 'undefined'
        });
        isMultiSelecting = false;
        isRangeSelecting = false;
        rangeSelectionAdditive = false;
        multiSelectStart = { x: 0, y: 0 };
        multiSelectEnd = { x: 0, y: 0 };
        hideSelectionChoiceMenu();
        if (typeof drawOnCanvas === 'function') {
            drawOnCanvas();
        }
        console.log('Ë§áÊï∞ÈÅ∏Êäû„ÇØ„É™„Ç¢ÂÆå‰∫Ü');
    };

    const hideSelectionChoiceMenu = () => {
        if (selectionChoiceMenu) {
            selectionChoiceMenu.remove();
            selectionChoiceMenu = null;
        }
    };

    // ‰∏çÂÆâÂÆöÊßãÈÄ†„ÅÆÂàÜÊûêÊ©üËÉΩ
    let unstableNodes = new Set();
    let unstableMembers = new Set();
    let instabilityMessage = '';

    const analyzeInstability = (K_global, reduced_indices, nodes, members) => {
        const analysis = {
            message: '',
            unstableNodes: new Set(),
            unstableMembers: new Set()
        };

        try {
            // 1. ÊãòÊùü‰∏çË∂≥„ÅÆÁØÄÁÇπ„ÇíÊ§úÂá∫
            const constraintAnalysis = analyzeConstraints(nodes);
            if (constraintAnalysis.unconstrainedNodes.length > 0) {
                analysis.unstableNodes = new Set(constraintAnalysis.unconstrainedNodes);
                analysis.message += `ÊãòÊùü„Åå‰∏çË∂≥„Åó„Å¶„ÅÑ„ÇãÁØÄÁÇπ: ${constraintAnalysis.unconstrainedNodes.map(i => i+1).join(', ')}`;
            }

            // 2. Ê©üÊßãÔºà„É°„Ç´„Éã„Ç∫„É†Ôºâ„ÇíÊ§úÂá∫
            const mechanismAnalysis = analyzeMechanisms(nodes, members);
            if (mechanismAnalysis.problematicMembers.length > 0) {
                mechanismAnalysis.problematicMembers.forEach(idx => analysis.unstableMembers.add(idx));
                if (analysis.message) analysis.message += '\n';
                analysis.message += `‰∏çÂÆâÂÆö„Å™ÈÉ®ÊùêÊßãÊàê: ${mechanismAnalysis.problematicMembers.map(i => i+1).join(', ')}`;
            }

            // 3. ÂâõÊÄß„Éû„Éà„É™„ÉÉ„ÇØ„Çπ„ÅÆÁâπÁï∞ÊÄß„ÇíÂàÜÊûê
            const matrixAnalysis = analyzeStiffnessMatrix(K_global, reduced_indices);
            if (matrixAnalysis.zeroEnergyModes.length > 0) {
                if (analysis.message) analysis.message += '\n';
                analysis.message += `ÁâπÁï∞„É¢„Éº„ÉâÔºàÈõ∂„Ç®„Éç„É´„ÇÆ„Éº„É¢„Éº„ÉâÔºâ„ÅåÊ§úÂá∫„Åï„Çå„Åæ„Åó„Åü`;
            }

            // „Ç∞„É≠„Éº„Éê„É´Â§âÊï∞„Å´Ë®≠ÂÆöÔºàÊèèÁîªÁî®Ôºâ
            unstableNodes = analysis.unstableNodes;
            unstableMembers = analysis.unstableMembers;
            instabilityMessage = analysis.message;

            return analysis;
        } catch (error) {
            console.error('‰∏çÂÆâÂÆöÊÄßËß£Êûê‰∏≠„Å´„Ç®„É©„Éº:', error);
            return {
                message: '‰∏çÂÆâÂÆöÊÄß„ÅÆË©≥Á¥∞ÂàÜÊûê‰∏≠„Å´„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü',
                unstableNodes: new Set(),
                unstableMembers: new Set()
            };
        }
    };

    const analyzeConstraints = (nodes) => {
        const unconstrainedNodes = [];
        
        nodes.forEach((node, index) => {
            let constraintCount = 0;
            if (node.restraint_x) constraintCount++;
            if (node.restraint_y) constraintCount++;
            if (node.restraint_r) constraintCount++;
            
            // ÂÖ®„ÅèÊãòÊùü„Åï„Çå„Å¶„ÅÑ„Å™„ÅÑÁØÄÁÇπ„ÄÅ„Åæ„Åü„ÅØ‰∏çÂçÅÂàÜ„Å™ÊãòÊùü„ÅÆÁØÄÁÇπ„ÇíÊ§úÂá∫
            if (constraintCount === 0) {
                unconstrainedNodes.push(index);
            }
        });

        return { unconstrainedNodes };
    };

    const analyzeMechanisms = (nodes, members) => {
        const problematicMembers = [];
        
        // Âü∫Êú¨ÁöÑ„Å™„É°„Ç´„Éã„Ç∫„É†Ê§úÂá∫
        // 1. Â≠§Á´ã„Åó„ÅüÈÉ®ÊùêÔºà„Å©„Å°„Çâ„Åã„ÅÆÁ´Ø„ÅåÊãòÊùü„Åï„Çå„Å¶„ÅÑ„Å™„ÅÑÔºâ
        members.forEach((member, index) => {
            const startNode = nodes[member.start];
            const endNode = nodes[member.end];
            
            const startConstraints = (startNode.restraint_x ? 1 : 0) + 
                                   (startNode.restraint_y ? 1 : 0) + 
                                   (startNode.restraint_r ? 1 : 0);
            const endConstraints = (endNode.restraint_x ? 1 : 0) + 
                                 (endNode.restraint_y ? 1 : 0) + 
                                 (endNode.restraint_r ? 1 : 0);
            
            // ‰∏°Á´Ø„Å®„ÇÇÂçÅÂàÜ„Å™ÊãòÊùü„Åå„Å™„ÅÑÂ†¥Âêà
            if (startConstraints < 2 && endConstraints < 2) {
                problematicMembers.push(index);
            }
        });

        return { problematicMembers };
    };

    const analyzeStiffnessMatrix = (K_global, reduced_indices) => {
        const zeroEnergyModes = [];
        
        try {
            // Á∞°ÊòìÁöÑ„Å™ÁâπÁï∞ÊÄßÊ§úÂá∫
            // ÂØæËßíË¶ÅÁ¥†„Åå„Çº„É≠„Åæ„Åü„ÅØÊ•µÂ∞è„ÅÆË¶ÅÁ¥†„ÇíÊ§úÂá∫
            reduced_indices.forEach((idx, i) => {
                if (Math.abs(K_global[idx][idx]) < 1e-10) {
                    zeroEnergyModes.push(idx);
                }
            });
        } catch (error) {
            console.error('ÂâõÊÄß„Éû„Éà„É™„ÉÉ„ÇØ„ÇπËß£Êûê„Ç®„É©„Éº:', error);
        }

        return { zeroEnergyModes };
    };

    // ‰∏çÂÆâÂÆöË¶ÅÁ¥†„Çí„Éè„Ç§„É©„Ç§„ÉàË°®Á§∫„Åô„ÇãÈñ¢Êï∞
    const highlightInstabilityElements = (ctx, transform) => {
        if (!ctx || !transform) return;
        
        const { nodes, members } = parseInputs();
        if (!nodes.length) return;

        // ‰∏çÂÆâÂÆö„Å™ÁØÄÁÇπ„Çí„Éè„Ç§„É©„Ç§„Éà
        if (unstableNodes.size > 0) {
            ctx.save();
            ctx.strokeStyle = '#FF6B35'; // „Ç™„É¨„É≥„Ç∏Ëâ≤
            ctx.fillStyle = 'rgba(255, 107, 53, 0.3)';
            ctx.lineWidth = 4;

            unstableNodes.forEach(nodeIndex => {
                if (nodeIndex < nodes.length) {
                    const node = nodes[nodeIndex];
                    const x = node.x * transform.scale + transform.offsetX;
                    const y = node.y * transform.scale + transform.offsetY;
                    
                    // ÁÇπÊªÖÂäπÊûú„ÅÆ„Åü„ÇÅ„ÅÆÂ§ß„Åç„ÇÅ„ÅÆÂÜÜ
                    ctx.beginPath();
                    ctx.arc(x, y, 12, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.stroke();
                    
                    // Ë≠¶Âëä„Éû„Éº„ÇØ
                    ctx.fillStyle = '#FF6B35';
                    const fontScale = window.settings?.fontScale || 1.0;
                    ctx.font = `bold ${16 * fontScale}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.fillText('‚ö†', x, y + 5);
                }
            });
            ctx.restore();
        }

        // ‰∏çÂÆâÂÆö„Å™ÈÉ®Êùê„Çí„Éè„Ç§„É©„Ç§„Éà
        if (unstableMembers.size > 0) {
            ctx.save();
            ctx.strokeStyle = '#FF6B35'; // „Ç™„É¨„É≥„Ç∏Ëâ≤
            ctx.lineWidth = 6;
            ctx.setLineDash([10, 5]); // Á†¥Á∑ö

            unstableMembers.forEach(memberIndex => {
                if (memberIndex < members.length) {
                    const member = members[memberIndex];
                    const startNode = nodes[member.start];
                    const endNode = nodes[member.end];
                    
                    if (startNode && endNode) {
                        const x1 = startNode.x * transform.scale + transform.offsetX;
                        const y1 = startNode.y * transform.scale + transform.offsetY;
                        const x2 = endNode.x * transform.scale + transform.offsetX;
                        const y2 = endNode.y * transform.scale + transform.offsetY;
                        
                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(x2, y2);
                        ctx.stroke();
                    }
                }
            });
            ctx.restore();
        }

        // ‰∏çÂÆâÂÆöÊÄß„É°„ÉÉ„Çª„Éº„Ç∏„Åå„ÅÇ„ÇãÂ†¥Âêà„ÅØÁîªÈù¢‰∏äÈÉ®„Å´Ë°®Á§∫
        if (instabilityMessage) {
            ctx.save();
            ctx.fillStyle = 'rgba(255, 107, 53, 0.9)';
            ctx.strokeStyle = '#FF6B35';
            ctx.lineWidth = 2;
            
            // „É°„ÉÉ„Çª„Éº„Ç∏„Éú„ÉÉ„ÇØ„Çπ
            const boxWidth = Math.min(800, ctx.canvas.width - 40);
            const boxHeight = 60 + (instabilityMessage.split('\n').length - 1) * 20;
            const boxX = (ctx.canvas.width - boxWidth) / 2;
            const boxY = 20;
            
            ctx.fillRect(boxX, boxY, boxWidth, boxHeight);
            ctx.strokeRect(boxX, boxY, boxWidth, boxHeight);
            
            // „ÉÜ„Ç≠„Çπ„Éà
            ctx.fillStyle = '#FFFFFF';
            const fontScale = window.settings?.fontScale || 1.0;
            ctx.font = `bold ${16 * fontScale}px Arial`;
            ctx.textAlign = 'center';
            
            const lines = instabilityMessage.split('\n');
            lines.forEach((line, index) => {
                ctx.fillText(line, ctx.canvas.width / 2, boxY + 25 + index * 20);
            });
            
            ctx.restore();
        }
    };

    // ‰∏çÂÆâÂÆöÊÄßÂàÜÊûêÁµêÊûú„Çí„ÇØ„É™„Ç¢„Åô„ÇãÈñ¢Êï∞
    const clearInstabilityHighlight = () => {
        unstableNodes.clear();
        unstableMembers.clear();
        instabilityMessage = '';
    };

    // ÂÖ•ÂäõÂÄ§„ÅÆ„É™„Ç¢„É´„Çø„Ç§„É†Ê§úË®ºÊ©üËÉΩ
    const validateInputValue = (input, validationType) => {
        const value = input.value.trim();
        let isValid = true;
        let errorMessage = '';

        try {
            const { nodes, members } = parseInputs();
            
            switch (validationType) {
                case 'node-reference':
                    // ÁØÄÁÇπÁï™Âè∑„ÅÆÂèÇÁÖß„ÉÅ„Çß„ÉÉ„ÇØ
                    if (value && !isNaN(value)) {
                        const nodeIndex = parseInt(value) - 1;
                        if (nodeIndex < 0 || nodeIndex >= nodes.length) {
                            isValid = false;
                            errorMessage = `ÁØÄÁÇπ ${value} „ÅØÂ≠òÂú®„Åó„Åæ„Åõ„Çì`;
                        }
                    }
                    break;
                
                case 'member-reference':
                    // ÈÉ®ÊùêÁï™Âè∑„ÅÆÂèÇÁÖß„ÉÅ„Çß„ÉÉ„ÇØ
                    if (value && !isNaN(value)) {
                        const memberIndex = parseInt(value) - 1;
                        if (memberIndex < 0 || memberIndex >= members.length) {
                            isValid = false;
                            errorMessage = `ÈÉ®Êùê ${value} „ÅØÂ≠òÂú®„Åó„Åæ„Åõ„Çì`;
                        }
                    }
                    break;
                
                case 'member-nodes':
                    // ÈÉ®ÊùêË°®„ÅÆÁØÄÁÇπÁï™Âè∑„ÉÅ„Çß„ÉÉ„ÇØ
                    if (value && !isNaN(value)) {
                        const nodeIndex = parseInt(value) - 1;
                        if (nodeIndex < 0 || nodeIndex >= nodes.length) {
                            isValid = false;
                            errorMessage = `ÁØÄÁÇπ ${value} „ÅØÂ≠òÂú®„Åó„Åæ„Åõ„Çì`;
                        }
                    }
                    break;
                
                case 'positive-number':
                    // Ê≠£„ÅÆÊï∞ÂÄ§„ÉÅ„Çß„ÉÉ„ÇØ
                    if (value && !isNaN(value)) {
                        if (parseFloat(value) <= 0) {
                            isValid = false;
                            errorMessage = 'Ê≠£„ÅÆÂÄ§„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ';
                        }
                    }
                    break;
                
                case 'non-negative-number':
                    // ÈùûË≤†Êï∞ÂÄ§„ÉÅ„Çß„ÉÉ„ÇØ
                    if (value && !isNaN(value)) {
                        if (parseFloat(value) < 0) {
                            isValid = false;
                            errorMessage = '0‰ª•‰∏ä„ÅÆÂÄ§„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ';
                        }
                    }
                    break;
            }
        } catch (error) {
            // parseInputs „ÅåÂ§±Êïó„Åó„ÅüÂ†¥Âêà„ÅØÊ§úË®º„Çí„Çπ„Ç≠„ÉÉ„Éó
            console.debug('ÂÖ•ÂäõÊ§úË®º‰∏≠„Å´parseInputs„Ç®„É©„Éº:', error);
        }

        // „Çπ„Çø„Ç§„É´„ÅÆÈÅ©Áî®
        if (isValid) {
            input.style.backgroundColor = '';
            input.style.borderColor = '';
            input.removeAttribute('title');
        } else {
            input.style.backgroundColor = '#ffebee';
            input.style.borderColor = '#f44336';
            input.setAttribute('title', errorMessage);
        }

        return isValid;
    };

    // ÂÖ•Âäõ„Éï„Ç£„Éº„É´„Éâ„Å´Ê§úË®ºÊ©üËÉΩ„ÇíË®≠ÂÆö
    const setupInputValidation = (input, validationType) => {
        input.addEventListener('input', () => {
            validateInputValue(input, validationType);
        });
        input.addEventListener('blur', () => {
            validateInputValue(input, validationType);
        });
        
        // ÂàùÊúüÊ§úË®º
        setTimeout(() => validateInputValue(input, validationType), 100);
    };

    // „ÉÜ„Éº„Éñ„É´„ÅÆË°å„Å´Âøú„Åò„ÅüÂÖ•ÂäõÊ§úË®º„ÇíË®≠ÂÆö
    const setupTableInputValidation = (row, tableBody) => {
        if (tableBody === elements.membersTable) {
            // ÈÉ®ÊùêË°®ÔºöÂßãÁÇπ„ÉªÁµÇÁÇπ„ÅÆÁØÄÁÇπÁï™Âè∑Ê§úË®º
            const startNodeInput = row.cells[1]?.querySelector('input');
            const endNodeInput = row.cells[2]?.querySelector('input');
            if (startNodeInput) setupInputValidation(startNodeInput, 'member-nodes');
            if (endNodeInput) setupInputValidation(endNodeInput, 'member-nodes');
            
            // Êñ≠Èù¢ÊÄßËÉΩ„ÅØÊ≠£„ÅÆÂÄ§
            const iInput = row.cells[5]?.querySelector('input');
            const aInput = row.cells[6]?.querySelector('input');
            if (iInput) setupInputValidation(iInput, 'positive-number');
            if (aInput) setupInputValidation(aInput, 'positive-number');
            
        } else if (tableBody === elements.nodeLoadsTable) {
            // ÁØÄÁÇπËç∑ÈáçË°®ÔºöÁØÄÁÇπÁï™Âè∑Ê§úË®º
            const nodeInput = row.cells[0]?.querySelector('input');
            if (nodeInput) setupInputValidation(nodeInput, 'node-reference');
            
        } else if (tableBody === elements.memberLoadsTable) {
            // ÈÉ®ÊùêËç∑ÈáçË°®ÔºöÈÉ®ÊùêÁï™Âè∑Ê§úË®º
            const memberInput = row.cells[0]?.querySelector('input');
            if (memberInput) setupInputValidation(memberInput, 'member-reference');
        }
    };

    // Êó¢Â≠ò„ÅÆ„ÉÜ„Éº„Éñ„É´Ë°å„Å´ÂÖ•ÂäõÊ§úË®º„ÇíÈÅ©Áî®
    const initializeExistingInputValidation = () => {
        // ÈÉ®ÊùêË°®„ÅÆÊ§úË®º
        Array.from(elements.membersTable.rows).forEach(row => {
            setupTableInputValidation(row, elements.membersTable);
        });
        
        // ÁØÄÁÇπËç∑ÈáçË°®„ÅÆÊ§úË®º
        Array.from(elements.nodeLoadsTable.rows).forEach(row => {
            setupTableInputValidation(row, elements.nodeLoadsTable);
        });
        
        // ÈÉ®ÊùêËç∑ÈáçË°®„ÅÆÊ§úË®º
        Array.from(elements.memberLoadsTable.rows).forEach(row => {
            setupTableInputValidation(row, elements.memberLoadsTable);
        });
    };

    const showSelectionChoiceMenu = (pageX, pageY, onSelectNodes, onSelectMembers) => {
        console.log('showSelectionChoiceMenu „ÅåÂëº„Å≥Âá∫„Åï„Çå„Åæ„Åó„Åü:', { pageX, pageY });
        hideSelectionChoiceMenu();

        // Ë°®Á§∫‰ΩçÁΩÆ„ÇíË™øÊï¥„Åó„Å¶ÁîªÈù¢ÂÜÖ„Å´Âèé„Åæ„Çã„Çà„ÅÜ„Å´„Åô„ÇãÔºà„Éû„Ç¶„Çπ‰ΩçÁΩÆ„ÅÆËøë„Åè„Å´Ë°®Á§∫Ôºâ
        const maxX = window.innerWidth - 280; // „É°„Éã„É•„Éº„ÅÆÂπÖ„ÇíËÄÉÊÖÆ
        const maxY = window.innerHeight - 150; // „É°„Éã„É•„Éº„ÅÆÈ´ò„Åï„ÇíËÄÉÊÖÆ
        const adjustedX = Math.min(Math.max(50, pageX), maxX);
        const adjustedY = Math.min(Math.max(50, pageY + 20), maxY); // „Éû„Ç¶„Çπ‰ΩçÁΩÆ„Åã„ÇâÂ∞ë„Åó‰∏ã„Å´Ë°®Á§∫
        
        console.log('„É°„Éã„É•„Éº‰ΩçÁΩÆË™øÊï¥:', { 
            original: { pageX, pageY }, 
            adjusted: { adjustedX, adjustedY },
            windowSize: { width: window.innerWidth, height: window.innerHeight }
        });

        const menu = document.createElement('div');
        menu.style.cssText = `
            position: fixed;
            top: ${adjustedY}px;
            left: ${adjustedX}px;
            transform: translate(-50%, 0px);
            background: #ffffff;
            border: 3px solid #007bff;
            border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            padding: 16px 20px;
            z-index: 9999999;
            font-family: Arial, sans-serif;
            max-width: 260px;
            color: #333;
            min-width: 200px;
        `;

        const message = document.createElement('div');
        message.textContent = 'ÁØÄÁÇπ„Å®ÈÉ®Êùê„Åå‰∏°ÊñπÂê´„Åæ„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ„Å©„Å°„Çâ„ÇíÈÅ∏ÊäûÁä∂ÊÖã„Å´„Åó„Åæ„Åô„ÅãÔºü';
        message.style.cssText = `
            margin-bottom: 10px;
            font-size: 14px;
            line-height: 1.4;
        `;
        menu.appendChild(message);

        const buttonContainer = document.createElement('div');
        buttonContainer.style.cssText = `
            display: grid;
            grid-template-columns: repeat(2, minmax(0, 1fr));
            gap: 8px;
        `;

        const createButton = (label, color, handler) => {
            const button = document.createElement('button');
            button.textContent = label;
            button.style.cssText = `
                padding: 8px 10px;
                border-radius: 4px;
                border: none;
                cursor: pointer;
                font-size: 13px;
                transition: background 0.2s ease;
                color: #ffffff;
                background-color: ${color};
            `;
            button.addEventListener('click', (event) => {
                event.stopPropagation();
                hideSelectionChoiceMenu();
                handler();
            });
            button.addEventListener('mouseenter', () => {
                button.style.filter = 'brightness(1.1)';
            });
            button.addEventListener('mouseleave', () => {
                button.style.filter = 'none';
            });
            return button;
        };

        buttonContainer.appendChild(createButton('ÁØÄÁÇπ„ÅÆ„Åø', '#007bff', onSelectNodes));
        buttonContainer.appendChild(createButton('ÈÉ®Êùê„ÅÆ„Åø', '#28a745', onSelectMembers));

        menu.appendChild(buttonContainer);

        menu.addEventListener('click', (event) => event.stopPropagation());

        selectionChoiceMenu = menu;
        document.body.appendChild(menu);
        console.log('ÈÅ∏Êäû„É°„Éã„É•„Éº„ÇíDOM„Å´ËøΩÂä†„Åó„Åæ„Åó„Åü:', menu);

        setTimeout(() => {
            const outsideHandler = () => hideSelectionChoiceMenu();
            document.addEventListener('click', outsideHandler, { once: true });
        }, 0);
    };

    const getSelectionRectangle = () => {
        const left = Math.min(multiSelectStart.x, multiSelectEnd.x);
        const right = Math.max(multiSelectStart.x, multiSelectEnd.x);
        const top = Math.min(multiSelectStart.y, multiSelectEnd.y);
        const bottom = Math.max(multiSelectStart.y, multiSelectEnd.y);
        return {
            left,
            right,
            top,
            bottom,
            width: Math.abs(right - left),
            height: Math.abs(bottom - top)
        };
    };

    const isPointInsideRect = (point, rect) => (
        point.x >= rect.left && point.x <= rect.right &&
        point.y >= rect.top && point.y <= rect.bottom
    );

    const segmentsIntersect = (p1, p2, q1, q2) => {
        const EPS = 1e-6;
        const orientation = (a, b, c) => {
            const val = (b.y - a.y) * (c.x - b.x) - (b.x - a.x) * (c.y - b.y);
            if (Math.abs(val) < EPS) return 0;
            return val > 0 ? 1 : 2;
        };
        const onSegment = (a, b, c) => (
            Math.min(a.x, c.x) - EPS <= b.x && b.x <= Math.max(a.x, c.x) + EPS &&
            Math.min(a.y, c.y) - EPS <= b.y && b.y <= Math.max(a.y, c.y) + EPS
        );

        const o1 = orientation(p1, p2, q1);
        const o2 = orientation(p1, p2, q2);
        const o3 = orientation(q1, q2, p1);
        const o4 = orientation(q1, q2, p2);

        if (o1 !== o2 && o3 !== o4) return true;
        if (o1 === 0 && onSegment(p1, q1, p2)) return true;
        if (o2 === 0 && onSegment(p1, q2, p2)) return true;
        if (o3 === 0 && onSegment(q1, p1, q2)) return true;
        if (o4 === 0 && onSegment(q1, p2, q2)) return true;
        return false;
    };

    const segmentIntersectsRect = (p1, p2, rect) => {
        const { left, right, top, bottom } = rect;
        if (Math.max(p1.x, p2.x) < left || Math.min(p1.x, p2.x) > right ||
            Math.max(p1.y, p2.y) < top || Math.min(p1.y, p2.y) > bottom) {
            return false;
        }
        if (isPointInsideRect(p1, rect) || isPointInsideRect(p2, rect)) {
            return true;
        }
        const rectPoints = [
            { x: left, y: top },
            { x: right, y: top },
            { x: right, y: bottom },
            { x: left, y: bottom }
        ];
        for (let i = 0; i < 4; i++) {
            const q1 = rectPoints[i];
            const q2 = rectPoints[(i + 1) % 4];
            if (segmentsIntersect(p1, p2, q1, q2)) {
                return true;
            }
        }
        return false;
    };

    const drawSelectionRectangle = (ctx) => {
        if (!isRangeSelecting || !isMultiSelecting) return;
        const rect = getSelectionRectangle();
        if (rect.width < 2 && rect.height < 2) return;
        ctx.save();
        ctx.strokeStyle = 'rgba(0, 123, 255, 0.9)';
        ctx.fillStyle = 'rgba(0, 123, 255, 0.15)';
        ctx.lineWidth = 1.5;
        ctx.setLineDash([6, 4]);
        ctx.strokeRect(rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top);
        ctx.setLineDash([]);
        ctx.fillRect(rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top);
        ctx.restore();
    };

    const finalizeRangeSelection = (event = null) => {
        console.log('finalizeRangeSelectionÈñãÂßã');
        if (!lastDrawingContext) {
            console.log('lastDrawingContext „Åå null „ÅÆ„Åü„ÇÅÁµÇ‰∫Ü');
            return;
        }
        const rect = getSelectionRectangle();
        console.log('ÈÅ∏ÊäûÁØÑÂõ≤:', rect);
        if (rect.width < 3 && rect.height < 3) {
            console.log('ÈÅ∏ÊäûÁØÑÂõ≤„ÅåÂ∞è„Åï„Åô„Åé„Çã„Åü„ÇÅÁµÇ‰∫Ü');
            return;
        }

        try {
            const { nodes, members } = parseInputs();
            console.log('parseInputsÊàêÂäü - nodes:', nodes.length, 'members:', members.length);
            const nodesInRect = [];
            nodes.forEach((node, idx) => {
                const pos = lastDrawingContext.transform(node.x, node.y);
                if (isPointInsideRect(pos, rect)) {
                    nodesInRect.push(idx);
                    console.log('ÁØÑÂõ≤ÂÜÖ„ÅÆÁØÄÁÇπ:', idx, 'pos:', pos);
                }
            });

            const membersInRect = [];
            members.forEach((member, idx) => {
                const start = lastDrawingContext.transform(nodes[member.i].x, nodes[member.i].y);
                const end = lastDrawingContext.transform(nodes[member.j].x, nodes[member.j].y);
                if (segmentIntersectsRect(start, end, rect)) {
                    membersInRect.push(idx);
                    console.log('ÁØÑÂõ≤ÂÜÖ„ÅÆÈÉ®Êùê:', idx, 'start:', start, 'end:', end);
                }
            });
            
            console.log('Ê§úÂá∫ÁµêÊûú - nodesInRect:', nodesInRect.length, 'membersInRect:', membersInRect.length);

            const additiveMode = rangeSelectionAdditive;
            const applySelection = (target) => {
                console.log('applySelection called with target:', target, 'additiveMode:', additiveMode);
                console.log('nodesInRect:', nodesInRect, 'membersInRect:', membersInRect);
                if (target === 'nodes') {
                    if (selectedMembers.size > 0) {
                        selectedMembers.clear();
                    }
                    if (!additiveMode) {
                        selectedNodes.clear();
                    }
                    nodesInRect.forEach(idx => {
                        if (additiveMode && selectedNodes.has(idx)) {
                            selectedNodes.delete(idx);
                        } else {
                            selectedNodes.add(idx);
                        }
                    });
                    console.log('nodes selected:', Array.from(selectedNodes));
                } else if (target === 'members') {
                    if (selectedNodes.size > 0) {
                        selectedNodes.clear();
                    }
                    if (!additiveMode) {
                        selectedMembers.clear();
                    }
                    membersInRect.forEach(idx => {
                        if (additiveMode && selectedMembers.has(idx)) {
                            selectedMembers.delete(idx);
                        } else {
                            selectedMembers.add(idx);
                        }
                    });
                    console.log('members selected:', Array.from(selectedMembers));
                }
                if (typeof drawOnCanvas === 'function') {
                    drawOnCanvas();
                }
            };

            if (!nodesInRect.length && !membersInRect.length) {
                console.log('ÁØÑÂõ≤ÂÜÖ„Å´Ë¶ÅÁ¥†„ÅåË¶ã„Å§„Åã„Çâ„Å™„Åã„Å£„Åü„Åü„ÇÅÁµÇ‰∫Ü');
                return;
            }

            console.log('ÈÅ∏ÊäûÂá¶ÁêÜ„ÇíÈñãÂßã - nodesInRect:', nodesInRect, 'membersInRect:', membersInRect);
            console.log('ÁèæÂú®„ÅÆÈÅ∏ÊäûÁä∂ÊÖã - selectedNodes.size:', selectedNodes.size, 'selectedMembers.size:', selectedMembers.size);

            if (nodesInRect.length && membersInRect.length) {
                console.log('ÁØÄÁÇπ„Å®ÈÉ®Êùê„ÅÆ‰∏°Êñπ„ÅåÊ§úÂá∫„Åï„Çå„Åæ„Åó„Åü');
                // Êó¢Â≠ò„ÅÆÈÅ∏ÊäûÁä∂ÊÖã„Å´Âøú„Åò„Å¶ÂÑ™ÂÖàÁöÑ„Å´ÈÅ∏Êäû„Åô„Çã„Çø„Ç§„Éó„ÇíÊ±∫ÂÆö
                if (selectedNodes.size > 0 && selectedMembers.size === 0) {
                    console.log('Êó¢Â≠ò„ÅÆÁØÄÁÇπÈÅ∏Êäû„Åå„ÅÇ„Çã„Åü„ÇÅÁØÄÁÇπ„ÇíÈÅ∏Êäû');
                    applySelection('nodes');
                } else if (selectedMembers.size > 0 && selectedNodes.size === 0) {
                    console.log('Êó¢Â≠ò„ÅÆÈÉ®ÊùêÈÅ∏Êäû„Åå„ÅÇ„Çã„Åü„ÇÅÈÉ®Êùê„ÇíÈÅ∏Êäû');
                    applySelection('members');
                } else {
                    // ÁØÄÁÇπ„Å®ÈÉ®Êùê„ÅÆ‰∏°Êñπ„ÅåÂê´„Åæ„Çå„ÇãÂ†¥Âêà„ÅØÂ∏∏„Å´ÈÅ∏Êäû„É°„Éã„É•„Éº„ÇíË°®Á§∫
                    console.log('ÁØÄÁÇπ„Å®ÈÉ®Êùê„ÅÆ‰∏°Êñπ„ÅåÂê´„Åæ„Çå„Çã„Åü„ÇÅÈÅ∏Êäû„É°„Éã„É•„Éº„ÇíË°®Á§∫');
                    // „Éû„Ç¶„Çπ„ÅÆÁèæÂú®‰ΩçÁΩÆ„ÇíÂèñÂæóÔºà„Éû„Ç¶„Çπ„Ç¢„ÉÉ„ÉóÊôÇ„ÅÆ‰ΩçÁΩÆÔºâ
                    const pageX = event ? event.clientX : window.innerWidth / 2;
                    const pageY = event ? event.clientY : window.innerHeight / 2;
                    console.log('„É°„Éã„É•„ÉºË°®Á§∫‰ΩçÁΩÆ:', { pageX, pageY, eventType: event?.type });
                    showSelectionChoiceMenu(pageX, pageY, () => applySelection('nodes'), () => applySelection('members'));
                }
            } else if (nodesInRect.length) {
                applySelection('nodes');
            } else {
                applySelection('members');
            }
        } catch (error) {
            console.error('ÁØÑÂõ≤ÈÅ∏Êäû„ÅÆÂá¶ÁêÜ‰∏≠„Å´„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü:', error);
        }
    };

    // ‰∏ÄÊã¨Á∑®ÈõÜ„É°„Éã„É•„Éº„ÇíË°®Á§∫„Åô„ÇãÈñ¢Êï∞
    const showBulkEditMenu = (pageX, pageY) => {
        console.log('showBulkEditMenu Èñ¢Êï∞„ÅåÂëº„Å≥Âá∫„Åï„Çå„Åæ„Åó„Åü', { pageX, pageY, selectedMembers: Array.from(selectedMembers) });
        
        // Êó¢Â≠ò„ÅÆ„Åô„Åπ„Å¶„ÅÆ„É°„Éã„É•„Éº„Å®„Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó„ÇíÁ¢∫ÂÆü„Å´Èö†„Åô
        const existingMenu = document.getElementById('bulk-edit-menu');
        if (existingMenu) {
            console.log('Êó¢Â≠ò„ÅÆ„É°„Éã„É•„Éº„ÇíÂâäÈô§');
            existingMenu.remove();
        }
        
        // ‰ªñ„ÅÆ„Ç≥„É≥„ÉÜ„Ç≠„Çπ„Éà„É°„Éã„É•„Éº„Å®„Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó„ÇÇÈö†„Åô
        if (elements.nodeContextMenu) elements.nodeContextMenu.style.display = 'none';
        if (elements.memberPropsPopup) elements.memberPropsPopup.style.display = 'none';
        if (elements.nodeLoadPopup) elements.nodeLoadPopup.style.display = 'none';
        if (elements.nodeCoordsPopup) elements.nodeCoordsPopup.style.display = 'none';
        
        // „Éö„Éº„Ç∏‰∏ä„ÅÆ„Åô„Åπ„Å¶„ÅÆ„Ç≥„É≥„ÉÜ„Ç≠„Çπ„Éà„É°„Éã„É•„Éº„ÇíÈö†„Åô
        document.querySelectorAll('.context-menu').forEach(menu => {
            if (menu.id !== 'bulk-edit-menu') {
                menu.style.display = 'none';
            }
        });
        
        // ‰∏ÄÊã¨Á∑®ÈõÜ„É°„Éã„É•„Éº„Çí‰ΩúÊàê
        const menu = document.createElement('div');
        menu.id = 'bulk-edit-menu';
        // CSS„ÇØ„É©„Çπ„Çí‰Ωø„Çè„Åö„Å´„Åô„Åπ„Å¶„Ç§„É≥„É©„Ç§„É≥„Çπ„Çø„Ç§„É´„ÅßË®≠ÂÆö
        menu.style.cssText = `
            position: fixed !important;
            background-color: white !important;
            border: 2px solid #007bff !important;
            border-radius: 4px !important;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3) !important;
            padding: 8px 0px !important;
            min-width: 200px !important;
            z-index: 999999 !important;
            font-size: 14px !important;
            font-family: Arial, sans-serif !important;
            display: block !important;
            visibility: visible !important;
            pointer-events: auto !important;
            opacity: 1 !important;
            transform: scale(1) !important;
            transition: none !important;
        `;
        
        console.log('„É°„Éã„É•„ÉºË¶ÅÁ¥†„Çí‰ΩúÊàê:', menu);
        
        const menuItem = document.createElement('div');
        menuItem.textContent = `ÈÅ∏Êäû„Åó„Åü${selectedMembers.size}„Å§„ÅÆÈÉ®Êùê„Çí‰∏ÄÊã¨Á∑®ÈõÜ...`;
        // CSS„ÇØ„É©„Çπ„Çí‰Ωø„Çè„Åö„Å´„Åô„Åπ„Å¶„Ç§„É≥„É©„Ç§„É≥„Çπ„Çø„Ç§„É´„ÅßË®≠ÂÆö
        menuItem.style.cssText = `
            padding: 10px 20px !important;
            cursor: pointer !important;
            font-size: 16px !important;
            font-weight: bold !important;
            color: #007bff !important;
            border-bottom: 1px solid #eee !important;
            transition: background-color 0.2s !important;
            display: block !important;
            width: 100% !important;
            box-sizing: border-box !important;
        `;
        
        console.log('„É°„Éã„É•„Éº„Ç¢„Ç§„ÉÜ„É†„Çí‰ΩúÊàê:', menuItem);
        
        menuItem.addEventListener('click', () => {
            console.log('„É°„Éã„É•„Éº„Ç¢„Ç§„ÉÜ„É†„Åå„ÇØ„É™„ÉÉ„ÇØ„Åï„Çå„Åæ„Åó„Åü');
            menu.remove();
            showBulkEditDialog();
        });
        
        menuItem.addEventListener('mouseover', () => {
            menuItem.style.backgroundColor = '#f0f0f0';
        });
        
        menuItem.addEventListener('mouseout', () => {
            menuItem.style.backgroundColor = 'white';
        });
        
        menu.appendChild(menuItem);
        
        // Á¢∫ÂÆü„Å´body„ÅÆÊúÄÂæå„Å´ËøΩÂä†
        console.log('bodyË¶ÅÁ¥†:', document.body);
        console.log('bodyË¶ÅÁ¥†„ÅÆÂ≠êË¶ÅÁ¥†Êï∞ÔºàËøΩÂä†ÂâçÔºâ:', document.body.children.length);
        document.body.appendChild(menu);
        console.log('bodyË¶ÅÁ¥†„ÅÆÂ≠êË¶ÅÁ¥†Êï∞ÔºàËøΩÂä†ÂæåÔºâ:', document.body.children.length);
        console.log('ËøΩÂä†„Åï„Çå„Åü„É°„Éã„É•„ÉºË¶ÅÁ¥†:', document.getElementById('bulk-edit-menu'));
        
        // „É°„Éã„É•„Éº„ÅÆ„Çµ„Ç§„Ç∫„ÇíÂèñÂæó„Åó„Å¶„Åã„Çâ‰ΩçÁΩÆ„ÇíË™øÊï¥
        const menuRect = menu.getBoundingClientRect();
        const windowWidth = window.innerWidth;
        const windowHeight = window.innerHeight;
        
        // „Éû„Ç¶„Çπ‰ΩçÁΩÆ„Çí„ÇØ„É©„Ç§„Ç¢„É≥„ÉàÂ∫ßÊ®ô„Å´Â§âÊèõ
        let menuLeft = pageX - window.scrollX;
        let menuTop = pageY - window.scrollY;
        
        // ÁîªÈù¢„Åã„Çâ„ÅØ„ÅøÂá∫„Åï„Å™„ÅÑ„Çà„ÅÜ„Å´Ë™øÊï¥
        if (menuLeft + menuRect.width > windowWidth) {
            menuLeft = windowWidth - menuRect.width - 10;
        }
        if (menuTop + menuRect.height > windowHeight) {
            menuTop = windowHeight - menuRect.height - 10;
        }
        if (menuLeft < 0) menuLeft = 10;
        if (menuTop < 0) menuTop = 10;
        
        menu.style.left = `${menuLeft}px`;
        menu.style.top = `${menuTop}px`;
        
        // „Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥ÂäπÊûú„ÇíÁÑ°ÂäπÂåñÔºà„Éá„Éê„ÉÉ„Ç∞„ÅÆ„Åü„ÇÅÔºâ
        /*
        menu.style.opacity = '0';
        menu.style.transform = 'scale(0.8)';
        menu.style.transition = 'all 0.2s ease-out';
        
        // „Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥„ÇíÈñãÂßã
        setTimeout(() => {
            menu.style.opacity = '1';
            menu.style.transform = 'scale(1)';
        }, 10);
        */
        
        console.log('„É°„Éã„É•„Éº„ÇíDOM„Å´ËøΩÂä†„Åó„Åæ„Åó„Åü„ÄÇË™øÊï¥Âæå„ÅÆ‰ΩçÁΩÆ:', { 
            left: menu.style.left, 
            top: menu.style.top,
            originalPageX: pageX,
            originalPageY: pageY,
            windowSize: { width: windowWidth, height: windowHeight },
            menuSize: { width: menuRect.width, height: menuRect.height }
        });
        
        // „É°„Éã„É•„ÉºÂ§ñ„ÇØ„É™„ÉÉ„ÇØ„ÅßÈñâ„Åò„Çã
        const closeMenu = (e) => {
            if (!menu.contains(e.target)) {
                menu.remove();
                document.removeEventListener('click', closeMenu);
            }
        };
        setTimeout(() => document.addEventListener('click', closeMenu), 10);
    };

    // ‰∏ÄÊã¨Á∑®ÈõÜ„ÉÄ„Ç§„Ç¢„É≠„Ç∞„ÇíË°®Á§∫„Åô„ÇãÈñ¢Êï∞
    const showBulkEditDialog = () => {
        console.log('‰∏ÄÊã¨Á∑®ÈõÜ„ÉÄ„Ç§„Ç¢„É≠„Ç∞„ÇíË°®Á§∫:', Array.from(selectedMembers));
        
        // Êó¢Â≠ò„ÅÆ„ÉÄ„Ç§„Ç¢„É≠„Ç∞„Åå„ÅÇ„Çå„Å∞ÂâäÈô§
        const existingDialog = document.getElementById('bulk-edit-dialog');
        if (existingDialog) {
            existingDialog.remove();
        }

        // „Éê„ÉçÂÖ•ÂäõÁîüÊàêÁî®„Éò„É´„Éë„ÉºÔºà„ÉÄ„Ç§„Ç¢„É≠„Ç∞ÂÜÖÁî®Ôºâ
        const createBulkSpringInputs = (prefix) => `
            <div id="${prefix}-spring-box" style="display:none; margin-top:6px; padding:8px; background:#f8f9fa; border:1px solid #ddd; border-radius:4px;">
                <div style="display:grid; grid-template-columns: 1fr 1fr 1fr; gap:8px; font-size:12px;">
                    <div>
                        <label style="display:block; margin-bottom:2px;">Kx (kN/mm)</label>
                        <div style="display:flex; align-items:center;">
                            <input type="number" id="${prefix}-kx" step="0.01" min="0" style="width:60px;">
                            <label style="margin-left:4px; margin-bottom:0;"><input type="checkbox" id="${prefix}-rigid-kx">Ââõ</label>
                        </div>
                    </div>
                    <div>
                        <label style="display:block; margin-bottom:2px;">Ky (kN/mm)</label>
                        <div style="display:flex; align-items:center;">
                            <input type="number" id="${prefix}-ky" step="0.01" min="0" style="width:60px;">
                            <label style="margin-left:4px; margin-bottom:0;"><input type="checkbox" id="${prefix}-rigid-ky">Ââõ</label>
                        </div>
                    </div>
                    <div>
                        <label style="display:block; margin-bottom:2px;">Kr (kN¬∑mm/rad)</label>
                        <div style="display:flex; align-items:center;">
                            <input type="number" id="${prefix}-kr" step="0.01" min="0" style="width:60px;">
                            <label style="margin-left:4px; margin-bottom:0;"><input type="checkbox" id="${prefix}-rigid-kr">Ââõ</label>
                        </div>
                    </div>
                </div>
            </div>
        `;
        
        // „ÉÄ„Ç§„Ç¢„É≠„Ç∞„Çí‰ΩúÊàê
        const dialog = document.createElement('div');
        dialog.id = 'bulk-edit-dialog';
        dialog.style.cssText = `
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background-color: white; border: 2px solid #007bff; border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3); padding: 20px;
            min-width: 500px; max-width: 90vw; max-height: 90vh; overflow-y: auto; z-index: 3000;
            font-family: Arial, sans-serif;
        `;
        
        dialog.innerHTML = `
            <h3 style="margin-top:0; border-bottom:1px solid #eee; padding-bottom:10px;">ÈÉ®Êùê‰∏ÄÊã¨Á∑®ÈõÜ (${selectedMembers.size}„Å§„ÅÆÈÉ®Êùê)</h3>
            
            <div style="display:grid; grid-template-columns: 1fr 1fr; gap:20px;">
                <div>
                    <h4 style="font-size:14px; color:#0056b3; margin:10px 0;">ÊùêÊñôÊÉÖÂ†±</h4>
                    <div style="margin-bottom: 10px;">
                        <label style="display:flex; align-items:center;"><input type="checkbox" id="bulk-edit-e"> ÂºæÊÄß‰øÇÊï∞ E (N/mm¬≤)</label>
                        <div id="bulk-e-container" style="margin-left: 20px; display: none;"></div>
                    </div>
                    <div style="margin-bottom: 10px;">
                        <label style="display:flex; align-items:center;"><input type="checkbox" id="bulk-edit-f"> Âü∫Ê∫ñÂº∑Â∫¶ F (N/mm¬≤)</label>
                        <div id="bulk-f-container" style="margin-left: 20px; display: none;"></div>
                    </div>
                    <div style="margin-bottom: 10px;">
                        <label style="display:flex; align-items:center;"><input type="checkbox" id="bulk-edit-density"> ÂØÜÂ∫¶ œÅ (kg/m¬≥)</label>
                        <div id="bulk-density-container" style="margin-left: 20px; display: none;"></div>
                    </div>

                    <h4 style="font-size:14px; color:#0056b3; margin:15px 0 10px;">Ëç∑Èáç</h4>
                    <div style="margin-bottom: 10px;">
                        <label style="display:flex; align-items:center;"><input type="checkbox" id="bulk-edit-load"> Á≠âÂàÜÂ∏ÉËç∑Èáç w (kN/m)</label>
                        <div id="bulk-load-container" style="margin-left: 20px; display: none;">
                            <input type="number" id="bulk-load-w" step="0.01" placeholder="kN/m" style="width: 100%;">
                        </div>
                    </div>
                </div>

                <div>
                    <h4 style="font-size:14px; color:#0056b3; margin:10px 0;">Êñ≠Èù¢ÊÉÖÂ†±</h4>
                    <div style="margin-bottom: 10px;">
                        <label style="display:flex; align-items:center;"><input type="checkbox" id="bulk-edit-section-vals"> Êñ≠Èù¢ÊÄßËÉΩ (I, A, Z)</label>
                        <div id="bulk-section-vals-container" style="margin-left: 20px; display: none; display:grid; gap:5px;">
                            <div style="display:flex; align-items:center; justify-content:space-between;"><span>I:</span><input type="number" id="bulk-i" step="0.01" style="width:80px;"></div>
                            <div style="display:flex; align-items:center; justify-content:space-between;"><span>A:</span><input type="number" id="bulk-a" step="0.01" style="width:80px;"></div>
                            <div style="display:flex; align-items:center; justify-content:space-between;"><span>Z:</span><input type="number" id="bulk-z" step="0.01" style="width:80px;"></div>
                        </div>
                    </div>
                    <div style="margin-bottom: 10px;">
                        <label style="display:flex; align-items:center;"><input type="checkbox" id="bulk-edit-section"> Êñ≠Èù¢ÈÅ∏Êäû„ÉÑ„Éº„É´</label>
                        <div id="bulk-section-container" style="margin-left: 20px; display: none;">
                            <button id="bulk-section-btn" style="padding: 5px 10px; background: #28a745; color: white; border: none; border-radius: 3px; cursor: pointer; width:100%;">Êñ≠Èù¢ÈÅ∏Êäû...</button>
                            <div id="bulk-section-info" style="margin-top: 5px; font-size: 12px; color: #666;"></div>
                        </div>
                    </div>

                    <h4 style="font-size:14px; color:#0056b3; margin:15px 0 10px;">Â∫ßÂ±àÈñ¢ÈÄ£</h4>
                    <div style="margin-bottom: 10px;">
                        <label style="display:flex; align-items:center;"><input type="checkbox" id="bulk-edit-radius-i"> Êñ≠Èù¢2Ê¨°ÂçäÂæÑ i (cm)</label>
                        <input type="number" id="bulk-radius-i" step="0.01" style="margin-left: 20px; display: none; width: 80px;">
                    </div>
                    <div style="margin-bottom: 10px;">
                        <label style="display:flex; align-items:center;"><input type="checkbox" id="bulk-edit-buckling-k"> Â∫ßÂ±à‰øÇÊï∞ K</label>
                        <input type="number" id="bulk-buckling-k" step="0.1" placeholder="Ëá™Âãï" style="margin-left: 20px; display: none; width: 80px;">
                    </div>
                </div>
            </div>

            <h4 style="font-size:14px; color:#0056b3; margin:15px 0 10px;">Êé•ÂêàÊù°‰ª∂</h4>
            <div style="display:grid; grid-template-columns: 1fr 1fr; gap:20px;">
                <div>
                    <label style="display:flex; align-items:center;"><input type="checkbox" id="bulk-edit-i-conn"> ÂßãÁ´ØÊé•Âêà</label>
                    <div id="bulk-i-conn-container" style="margin-left: 20px; display: none;">
                        <select id="bulk-i-conn" style="width:100%;">
                            <option value="rigid">ÂâõÊé•Âêà</option>
                            <option value="pinned">„Éî„É≥Êé•Âêà</option>
                            <option value="spring">„Éê„ÉçÊé•Âêà</option>
                        </select>
                        ${createBulkSpringInputs('bulk-i')}
                    </div>
                </div>
                <div>
                    <label style="display:flex; align-items:center;"><input type="checkbox" id="bulk-edit-j-conn"> ÁµÇÁ´ØÊé•Âêà</label>
                    <div id="bulk-j-conn-container" style="margin-left: 20px; display: none;">
                        <select id="bulk-j-conn" style="width:100%;">
                            <option value="rigid">ÂâõÊé•Âêà</option>
                            <option value="pinned">„Éî„É≥Êé•Âêà</option>
                            <option value="spring">„Éê„ÉçÊé•Âêà</option>
                        </select>
                        ${createBulkSpringInputs('bulk-j')}
                    </div>
                </div>
            </div>

            <div style="margin-top: 20px; text-align: center; border-top: 1px solid #eee; padding-top: 15px;">
                <button id="bulk-apply-btn" style="margin-right: 10px; padding: 10px 30px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight:bold;">ÈÅ©Áî®</button>
                <button id="bulk-cancel-btn" style="padding: 10px 20px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer;">„Ç≠„É£„É≥„Çª„É´</button>
            </div>
        `;
        
        document.body.appendChild(dialog);
        
        // ÂêÑÁ®ÆÂÖ•ÂäõUI„ÅÆÁîüÊàê„Éò„É´„Éë„Éº
        const setupInputContainer = (checkboxId, containerId, generator) => {
            const checkbox = document.getElementById(checkboxId);
            const container = document.getElementById(containerId);
            if (checkbox && container) {
                checkbox.addEventListener('change', () => {
                    container.style.display = checkbox.checked ? (checkboxId.includes('section-vals') ? 'grid' : 'block') : 'none';
                    if (checkbox.checked && generator && container.innerHTML === '') {
                        // HTMLÁîüÊàê„ÅåÂøÖË¶Å„Å™Â†¥Âêà
                        container.innerHTML = generator();
                    }
                });
            }
        };

        // E, F, Density„ÅÆÂãïÁöÑÁîüÊàê
        setupInputContainer('bulk-edit-e', 'bulk-e-container', () => createEInputHTML('bulk-e', '205000'));
        // F„ÅØE„Å´‰æùÂ≠ò„Åô„Çã„Åü„ÇÅ„ÄÅE„ÅÆÁîüÊàêÂæå„Å´„Ç§„Éô„É≥„ÉàË®≠ÂÆö„ÅåÂøÖË¶Å„Å†„Åå„ÄÅÁ∞°ÊòìÁöÑ„Å´ÂàùÊúüÂÄ§„ÅßÁîüÊàê
        setupInputContainer('bulk-edit-f', 'bulk-f-container', () => {
             const wrapper = document.createElement('div');
             wrapper.appendChild(createStrengthInputHTML('steel', 'bulk-f'));
             return wrapper.innerHTML;
        });
        setupInputContainer('bulk-edit-density', 'bulk-density-container', () => createDensityInputHTML('bulk-density', 7850));

        // ÂçòÁ¥î„Å™Ë°®Á§∫ÂàáÊõø„ÅÆ„Çª„ÉÉ„Éà„Ç¢„ÉÉ„Éó
        ['bulk-edit-load', 'bulk-edit-section', 'bulk-edit-radius-i', 'bulk-edit-buckling-k', 
         'bulk-edit-i-conn', 'bulk-edit-j-conn', 'bulk-edit-section-vals'].forEach(id => {
            const cb = document.getElementById(id);
            if (!cb) return;
            // ÂØæÂøú„Åô„Çã„Ç≥„É≥„ÉÜ„Éä„Åæ„Åü„ÅØInput„ÅÆID„ÇíÊé®Ê∏¨
            let targetId = id.replace('bulk-edit-', 'bulk-');
            if (id === 'bulk-edit-load') targetId = 'bulk-load-container';
            if (id === 'bulk-edit-section') targetId = 'bulk-section-container';
            if (id === 'bulk-edit-i-conn') targetId = 'bulk-i-conn-container';
            if (id === 'bulk-edit-j-conn') targetId = 'bulk-j-conn-container';
            if (id === 'bulk-edit-section-vals') targetId = 'bulk-section-vals-container';
            
            const target = document.getElementById(targetId);
            if (target) {
                cb.addEventListener('change', () => {
                    target.style.display = cb.checked ? (id === 'bulk-edit-section-vals' ? 'grid' : 'block') : 'none';
                    if (id === 'bulk-edit-section-vals' && cb.checked) target.style.display = 'grid';
                });
            }
        });

        // Êé•ÂêàÊù°‰ª∂„ÅÆ„Éê„ÉçË°®Á§∫ÂàáÊõø
        const setupConnSpringToggle = (connId, boxId) => {
            const select = document.getElementById(connId);
            const box = document.getElementById(boxId);
            if (select && box) {
                select.addEventListener('change', () => {
                    box.style.display = select.value === 'spring' ? 'block' : 'none';
                });
            }
        };
        setupConnSpringToggle('bulk-i-conn', 'bulk-i-spring-box');
        setupConnSpringToggle('bulk-j-conn', 'bulk-j-spring-box');

        // Ââõ„ÉÅ„Çß„ÉÉ„ÇØ„Éú„ÉÉ„ÇØ„Çπ„ÅÆÂà∂Âæ° (input„ÅÆdisableÂàá„ÇäÊõø„Åà)
        const setupRigidCheck = (prefix) => {
            ['kx', 'ky', 'kr'].forEach(k => {
                const cb = document.getElementById(`${prefix}-rigid-${k}`);
                const inp = document.getElementById(`${prefix}-${k}`);
                if (cb && inp) {
                    cb.addEventListener('change', () => {
                        inp.disabled = cb.checked;
                    });
                }
            });
        };
        setupRigidCheck('bulk-i');
        setupRigidCheck('bulk-j');
        
        // Êñ≠Èù¢ÈÅ∏Êäû„ÉÑ„Éº„É´ÈÄ£Êê∫
        const sectionBtn = document.getElementById('bulk-section-btn');
        if (sectionBtn) {
            sectionBtn.addEventListener('click', () => {
                const url = `steel_selector.html?targetMember=bulk&bulk=true`;
                window.open(url, 'BulkSteelSelector', 'width=1200,height=800,scrollbars=yes,resizable=yes');
                
                // window.bulkSectionProperties „ÅØ communication.js Á≠â„ÅßÂèó„ÅëÂèñ„ÇãÊÉ≥ÂÆö
                // „Åì„Åì„Åß„ÅØÂÆöÊúü„ÉÅ„Çß„ÉÉ„ÇØ„ÅßÂèçÊò†
                const checkInterval = setInterval(() => {
                     const storedData = localStorage.getItem('steelSelectionForFrameAnalyzer');
                     if (storedData) {
                         try {
                             const data = JSON.parse(storedData);
                             if (data.targetMemberIndex === 'bulk' && data.properties) {
                                 window.bulkSectionProperties = data.properties;
                                 const infoElement = document.getElementById('bulk-section-info');
                                 if (infoElement) {
                                     infoElement.textContent = `ÈÅ∏ÊäûÊ∏à„Åø: ${data.properties.sectionName || '-'} (I=${data.properties.I}, A=${data.properties.A})`;
                                     infoElement.style.color = '#28a745';
                                 }
                                 localStorage.removeItem('steelSelectionForFrameAnalyzer');
                                 clearInterval(checkInterval);
                             }
                         } catch(e) {}
                     }
                }, 500);
            });
        }
        
        // ÈÅ©Áî®„Éª„Ç≠„É£„É≥„Çª„É´„Éú„Çø„É≥
        document.getElementById('bulk-apply-btn').addEventListener('click', () => {
            applyBulkEdit();
            dialog.remove();
        });
        document.getElementById('bulk-cancel-btn').addEventListener('click', () => {
            dialog.remove();
        });
    };

    // ‰∏ÄÊã¨Á∑®ÈõÜ„ÇíÈÅ©Áî®„Åô„ÇãÈñ¢Êï∞
    const applyBulkEdit = () => {
        console.log('‰∏ÄÊã¨Á∑®ÈõÜ„ÇíÈÅ©Áî®ÈñãÂßã');
        
        const updates = {};
        
        // „ÉÅ„Çß„ÉÉ„ÇØ„Åï„Çå„ÅüÈ†ÖÁõÆ„ÇíÂèéÈõÜ
        if (document.getElementById('bulk-edit-e').checked) {
            const eSelect = document.getElementById('bulk-e-select');
            const eInput = document.getElementById('bulk-e-input');
            updates.E = (eSelect && eSelect.value !== 'custom') ? eSelect.value : (eInput ? eInput.value : null);
        }
        
        if (document.getElementById('bulk-edit-f').checked) {
            const container = document.getElementById('bulk-f-container');
            if (container) {
                const fSelect = container.querySelector('select');
                const fInput = container.querySelector('input');
                updates.F = (fSelect && fSelect.value !== 'custom') ? fSelect.value : (fInput ? fInput.value : null);
            }
        }

        if (document.getElementById('bulk-edit-density').checked) {
            const dSelect = document.getElementById('bulk-density-select');
            const dInput = document.getElementById('bulk-density-input');
            updates.Density = (dSelect && dSelect.value !== 'custom') ? dSelect.value : (dInput ? dInput.value : null);
        }

        if (document.getElementById('bulk-edit-section-vals').checked) {
            updates.I = document.getElementById('bulk-i').value;
            updates.A = document.getElementById('bulk-a').value;
            updates.Z = document.getElementById('bulk-z').value;
        }

        if (document.getElementById('bulk-edit-radius-i').checked) {
            updates.radius_i = document.getElementById('bulk-radius-i').value;
        }

        if (document.getElementById('bulk-edit-buckling-k').checked) {
            updates.buckling_k = document.getElementById('bulk-buckling-k').value;
        }
        
        // Êé•ÂêàÊù°‰ª∂„ÅÆÂèñÂæóÈñ¢Êï∞
        const getConnUpdate = (prefix) => {
            const select = document.getElementById(`${prefix}-conn`);
            const val = select.value;
            const update = { type: val };
            if (val === 'spring') {
                update.Kx = document.getElementById(`${prefix}-kx`).value;
                update.Ky = document.getElementById(`${prefix}-ky`).value;
                update.Kr = document.getElementById(`${prefix}-kr`).value;
                update.rigidKx = document.getElementById(`${prefix}-rigid-kx`).checked;
                update.rigidKy = document.getElementById(`${prefix}-rigid-ky`).checked;
                update.rigidKr = document.getElementById(`${prefix}-rigid-kr`).checked;
            }
            return update;
        };

        if (document.getElementById('bulk-edit-i-conn').checked) {
            updates.i_conn = getConnUpdate('bulk-i');
        }
        
        if (document.getElementById('bulk-edit-j-conn').checked) {
            updates.j_conn = getConnUpdate('bulk-j');
        }
        
        // Êñ≠Èù¢ÈÅ∏Êäû„Å´„Çà„ÇãÊñ≠Èù¢ÊÄßËÉΩ„ÅÆ‰∏ÄÊã¨Êõ¥Êñ∞
        if (document.getElementById('bulk-edit-section').checked && window.bulkSectionProperties) {
            updates.sectionProperties = window.bulkSectionProperties;
        }
        
        // Á≠âÂàÜÂ∏ÉËç∑Èáç
        if (document.getElementById('bulk-edit-load').checked) {
            updates.memberLoad = {
                w: parseFloat(document.getElementById('bulk-load-w').value || 0)
            };
        }
        
        console.log('‰∏ÄÊã¨Á∑®ÈõÜÂÜÖÂÆπ:', updates);
        
        // ÈÅ∏Êäû„Åï„Çå„ÅüÈÉ®Êùê„Å´Â§âÊõ¥„ÇíÈÅ©Áî®
        pushState(); // Â§âÊõ¥Ââç„ÅÆÁä∂ÊÖã„Çí‰øùÂ≠ò
        
        for (const memberIndex of selectedMembers) {
            const row = elements.membersTable.rows[memberIndex];
            if (!row) continue;
            
            // EÂÄ§„ÅÆÊõ¥Êñ∞
            if (updates.E) {
                const eSelect = row.cells[3].querySelector('select');
                const eInput = row.cells[3].querySelector('input[type="number"]');
                if (eSelect && eInput) {
                    const hasOption = Array.from(eSelect.options).some(opt => opt.value === updates.E);
                    eSelect.value = hasOption ? updates.E : 'custom';
                    eInput.value = updates.E;
                    eInput.readOnly = (eSelect.value !== 'custom');
                    eSelect.dispatchEvent(new Event('change'));
                }
            }

            // FÂÄ§„ÅÆÊõ¥Êñ∞
            if (updates.F) {
                const strengthContainer = row.cells[4].firstElementChild;
                if (strengthContainer) {
                    const fSelect = strengthContainer.querySelector('select');
                    const fInput = strengthContainer.querySelector('input');
                    if (fSelect && fInput) {
                         if (fInput) {
                             fInput.value = updates.F;
                             if (fSelect) fSelect.value = 'custom';
                         } else if (fSelect) {
                             fSelect.value = updates.F;
                         }
                    }
                }
            }
            
            // ÂØÜÂ∫¶„ÅÆÊõ¥Êñ∞
            if (updates.Density) {
                const densityCell = row.querySelector('.density-cell');
                if (densityCell) {
                    const dSelect = densityCell.querySelector('select');
                    const dInput = densityCell.querySelector('input');
                    if (dSelect && dInput) {
                         const hasOption = Array.from(dSelect.options).some(opt => opt.value === updates.Density);
                         dSelect.value = hasOption ? updates.Density : 'custom';
                         dInput.value = updates.Density;
                         dInput.readOnly = (dSelect.value !== 'custom');
                    }
                }
            }

            // Êñ≠Èù¢ÊÄßËÉΩ (I, A, Z)
            if (updates.I) row.cells[5].querySelector('.section-I-input').value = updates.I;
            if (updates.A) row.cells[6].querySelector('.section-A-input').value = updates.A;
            if (updates.Z) row.cells[7].querySelector('.section-Z-input').value = updates.Z;
            if (typeof window.updateReductionDisplays === 'function') {
                window.updateReductionDisplays(row);
            }

            // Êñ≠Èù¢2Ê¨°ÂçäÂæÑ i
            if (updates.radius_i !== undefined) {
                const iInput = row.querySelector('.radius-i-input');
                if (iInput) iInput.value = updates.radius_i;
                if (updates.radius_i) {
                    row.dataset.ix = updates.radius_i;
                    row.dataset.iy = updates.radius_i;
                } else {
                    delete row.dataset.ix;
                    delete row.dataset.iy;
                }
            }

            // Â∫ßÂ±à‰øÇÊï∞ K
            if (updates.buckling_k !== undefined) {
                const kInput = row.querySelector('.buckling-k-input');
                if (kInput) kInput.value = updates.buckling_k;
                if (updates.buckling_k) row.dataset.bucklingK = updates.buckling_k;
                else delete row.dataset.bucklingK;
            }
            
            // Êñ≠Èù¢ÈÅ∏Êäû„ÉÑ„Éº„É´„Åã„Çâ„ÅÆÂèçÊò†
            if (updates.sectionProperties) {
                const sp = updates.sectionProperties;
                if (sp.I) row.cells[5].querySelector('.section-I-input').value = sp.I;
                if (sp.A) row.cells[6].querySelector('.section-A-input').value = sp.A;
                if (sp.Z) row.cells[7].querySelector('.section-Z-input').value = sp.Z;
                if (typeof window.updateReductionDisplays === 'function') {
                    window.updateReductionDisplays(row);
                }
                
                if (sp.Zx) row.dataset.zx = sp.Zx;
                if (sp.Zy) row.dataset.zy = sp.Zy;
                if (sp.ix) row.dataset.ix = sp.ix;
                if (sp.iy) row.dataset.iy = sp.iy;
                
                const iInput = row.querySelector('.radius-i-input');
                if (iInput && (sp.ix || sp.iy)) {
                    const v = Math.min(parseFloat(sp.ix)||9999, parseFloat(sp.iy)||9999);
                    if (v < 9999) iInput.value = v.toFixed(2);
                }

                if (sp.sectionInfo) {
                    if (typeof window.setRowSectionInfo === 'function') {
                        window.setRowSectionInfo(row, sp.sectionInfo);
                    }
                }
                if (sp.sectionAxis || sp.sectionAxisLabel) {
                     const axisInfo = sp.sectionAxis || { label: sp.sectionAxisLabel };
                     if (typeof window.applySectionAxisDataset === 'function') {
                         window.applySectionAxisDataset(row, axisInfo);
                     }
                }
            }
            
            // Êé•ÂêàÊù°‰ª∂„ÅÆÊõ¥Êñ∞ helper
            const updateConn = (connSelect, updateData) => {
                if (!connSelect || !updateData) return;
                connSelect.value = updateData.type;
                connSelect.dispatchEvent(new Event('change'));

                if (updateData.type === 'spring') {
                    const cell = connSelect.closest('.conn-cell');
                    const springBox = cell ? cell.querySelector('.spring-inputs') : null;
                    if (springBox) {
                        const setVal = (cls, val) => { const el = springBox.querySelector(cls); if(el) el.value = val; };
                        const setChk = (cls, chk) => { 
                            const el = springBox.querySelector(cls); 
                            if(el) { 
                                el.checked = chk; 
                                el.dispatchEvent(new Event('change'));
                            } 
                        };
                        
                        setVal('.spring-kx', updateData.Kx);
                        setVal('.spring-ky', updateData.Ky);
                        setVal('.spring-kr', updateData.Kr);
                        setChk('.spring-rigid-kx', updateData.rigidKx);
                        setChk('.spring-rigid-ky', updateData.rigidKy);
                        setChk('.spring-rigid-kr', updateData.rigidKr);
                    }
                }
            };

            const connSelectsRow = Array.from(row.querySelectorAll('.conn-select'));
            if (updates.i_conn) updateConn(connSelectsRow[0], updates.i_conn);
            if (updates.j_conn) updateConn(connSelectsRow[1], updates.j_conn);
            
            // Á≠âÂàÜÂ∏ÉËç∑Èáç
            if (updates.memberLoad) {
                const existingLoadRow = Array.from(elements.memberLoadsTable.rows).find(loadRow => {
                    const memberInput = loadRow.cells[0].querySelector('input');
                    return parseInt(memberInput.value) - 1 === memberIndex;
                });
                
                if (existingLoadRow) {
                    existingLoadRow.cells[1].querySelector('input').value = updates.memberLoad.w;
                } else if (updates.memberLoad.w !== 0) {
                    const newLoadRow = elements.memberLoadsTable.insertRow();
                    newLoadRow.innerHTML = `
                        <td><input type="number" value="${memberIndex + 1}" min="1"></td>
                        <td><input type="number" value="${updates.memberLoad.w}" step="0.01"></td>
                        <td><button class="delete-row-btn">√ó</button></td>
                    `;
                    const deleteBtn = newLoadRow.querySelector('.delete-row-btn');
                    deleteBtn.onclick = () => { pushState(); newLoadRow.remove(); drawOnCanvas(); };
                    newLoadRow.querySelectorAll('input').forEach(input => {
                        input.addEventListener('change', () => drawOnCanvas());
                    });
                }
            }
        }
        
        if (typeof drawOnCanvas === 'function') {
            drawOnCanvas();
        }
        
        const message = document.createElement('div');
        message.style.cssText = 'position:fixed; top:20px; right:20px; background:#28a745; color:white; padding:10px 15px; border-radius:4px; z-index:4000;';
        message.textContent = `${selectedMembers.size}„Å§„ÅÆÈÉ®Êùê„Çí‰∏ÄÊã¨Á∑®ÈõÜ„Åó„Åæ„Åó„Åü`;
        document.body.appendChild(message);
        setTimeout(() => message.remove(), 3000);
    };

    // ÁØÄÁÇπ‰∏ÄÊã¨Á∑®ÈõÜ„É°„Éã„É•„ÉºË°®Á§∫Èñ¢Êï∞
    const showBulkNodeEditMenu = (pageX, pageY) => {
        // Êó¢Â≠ò„ÅÆ„Åô„Åπ„Å¶„ÅÆ„É°„Éã„É•„Éº„Å®„Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó„ÇíÁ¢∫ÂÆü„Å´Èö†„Åô
        const existingMenu = document.getElementById('bulk-node-edit-menu');
        if (existingMenu) {
            existingMenu.remove();
        }
        
        // ‰ªñ„ÅÆ„Ç≥„É≥„ÉÜ„Ç≠„Çπ„Éà„É°„Éã„É•„Éº„Å®„Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó„ÇÇÈö†„Åô
        if (elements.nodeContextMenu) elements.nodeContextMenu.style.display = 'none';
        if (elements.memberPropsPopup) elements.memberPropsPopup.style.display = 'none';
        if (elements.nodeLoadPopup) elements.nodeLoadPopup.style.display = 'none';
        if (elements.nodeCoordsPopup) elements.nodeCoordsPopup.style.display = 'none';
        
        // ÁØÄÁÇπ‰∏ÄÊã¨Á∑®ÈõÜ„É°„Éã„É•„Éº„Çí‰ΩúÊàê
        const menu = document.createElement('div');
        menu.id = 'bulk-node-edit-menu';
        menu.style.cssText = `
            position: fixed !important;
            background-color: white !important;
            border: 1px solid #ccc !important;
            border-radius: 6px !important;
            box-shadow: 0 4px 20px rgba(0,0,0,0.2) !important;
            padding: 4px 0px !important;
            z-index: 9999999 !important;
            min-width: 180px !important;
            font-family: Arial, sans-serif !important;
            font-size: 14px !important;
            display: block !important;
            visibility: visible !important;
            opacity: 1 !important;
        `;
        
        const menuItem = document.createElement('div');
        menuItem.style.cssText = `
            padding: 10px 16px;
            cursor: pointer;
            background-color: white !important;
            color: #333 !important;
            font-size: 14px !important;
        `;
        menuItem.textContent = 'ÈÅ∏Êäû„Åó„ÅüÁØÄÁÇπ„Çí‰∏ÄÊã¨Á∑®ÈõÜ';
        
        menuItem.addEventListener('mouseover', () => {
            menuItem.style.backgroundColor = '#f0f8ff';
        });
        
        menuItem.addEventListener('mouseout', () => {
            menuItem.style.backgroundColor = 'white';
        });
        
        menuItem.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            
            // „É°„Éã„É•„Éº„ÇíÂâäÈô§
            if (document.getElementById('bulk-node-edit-menu')) {
                document.getElementById('bulk-node-edit-menu').remove();
            }
            
            // „ÉÄ„Ç§„Ç¢„É≠„Ç∞„ÇíË°®Á§∫
            window.showBulkNodeEditDialog();
        });
        menu.appendChild(menuItem);
        document.body.appendChild(menu);
        
        // „É°„Éã„É•„Éº„ÅÆ„Çµ„Ç§„Ç∫„ÇíÂèñÂæó„Åó„Å¶„Åã„Çâ‰ΩçÁΩÆ„ÇíË™øÊï¥ÔºàÈÉ®Êùê‰∏ÄÊã¨Á∑®ÈõÜ„Å®Âêå„ÅòÊñπÂºèÔºâ
        const menuRect = menu.getBoundingClientRect();
        const windowWidth = window.innerWidth;
        const windowHeight = window.innerHeight;
        
        // „Éû„Ç¶„Çπ‰ΩçÁΩÆ„Çí„ÇØ„É©„Ç§„Ç¢„É≥„ÉàÂ∫ßÊ®ô„Å´Â§âÊèõ
        let menuLeft = pageX - window.scrollX;
        let menuTop = pageY - window.scrollY;
        
        // ÁîªÈù¢„Åã„Çâ„ÅØ„ÅøÂá∫„Åï„Å™„ÅÑ„Çà„ÅÜ„Å´Ë™øÊï¥
        if (menuLeft + menuRect.width > windowWidth) {
            menuLeft = windowWidth - menuRect.width - 10;
        }
        if (menuTop + menuRect.height > windowHeight) {
            menuTop = windowHeight - menuRect.height - 10;
        }
        if (menuLeft < 0) menuLeft = 10;
        if (menuTop < 0) menuTop = 10;
        
        menu.style.left = `${menuLeft}px`;
        menu.style.top = `${menuTop}px`;
        
        console.log('„É°„Éã„É•„Éº‰ΩçÁΩÆË®≠ÂÆö:', {
            mouse: { x: pageX, y: pageY },
            client: { x: pageX - window.scrollX, y: pageY - window.scrollY },
            menuRect: { width: menuRect.width, height: menuRect.height },
            final: { x: menuLeft, y: menuTop }
        });
        
        // „É°„Éã„É•„ÉºÂ§ñ„ÇØ„É™„ÉÉ„ÇØ„ÅßÈñâ„Åò„Çã
        const closeMenu = (event) => {
            if (!menu.contains(event.target)) {
                if (document.body.contains(menu)) {
                    document.body.removeChild(menu);
                }
                document.removeEventListener('click', closeMenu);
            }
        };
        setTimeout(() => document.addEventListener('click', closeMenu), 200);
    };

    // ÁØÄÁÇπ‰∏ÄÊã¨Á∑®ÈõÜ„ÉÄ„Ç§„Ç¢„É≠„Ç∞Ë°®Á§∫Èñ¢Êï∞
    const showBulkNodeEditDialog = () => {
        // Êó¢Â≠ò„ÅÆ„ÉÄ„Ç§„Ç¢„É≠„Ç∞„Åå„ÅÇ„Çå„Å∞ÂâäÈô§
        const existingDialog = document.getElementById('bulk-node-edit-dialog');
        if (existingDialog) {
            existingDialog.remove();
        }
        
        const dialog = document.createElement('div');
        dialog.id = 'bulk-node-edit-dialog';
        dialog.style.cssText = `
            position: fixed;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            background: white;
            border: 2px solid #333;
            border-radius: 8px;
            padding: 20px;
            z-index: 10001;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            min-width: 400px;
            max-height: 80vh;
            overflow-y: auto;
            font-family: Arial, sans-serif;
        `;
        
        dialog.innerHTML = `
            <h3>ÁØÄÁÇπ‰∏ÄÊã¨Á∑®ÈõÜ (${selectedNodes.size}ÂÄã„ÅÆÁØÄÁÇπ)</h3>
            
            <div style="margin-bottom: 15px;">
                <label><input type="checkbox" id="bulk-edit-coords"> Â∫ßÊ®ô</label>
                <div id="bulk-coords-container" style="margin-left: 20px; display: none;">
                    <div style="display: flex; gap: 10px; align-items: center; margin-bottom: 5px;">
                        <label style="min-width: 50px;">XÂ∫ßÊ®ô:</label>
                        <select id="bulk-coord-x-mode" style="width: 80px;">
                            <option value="set">Ë®≠ÂÆö</option>
                            <option value="add">Âä†ÁÆó</option>
                        </select>
                        <input type="number" id="bulk-coord-x" step="0.01" placeholder="m" style="width: 100px;">
                        <span style="font-size: 12px;">m</span>
                    </div>
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <label style="min-width: 50px;">YÂ∫ßÊ®ô:</label>
                        <select id="bulk-coord-y-mode" style="width: 80px;">
                            <option value="set">Ë®≠ÂÆö</option>
                            <option value="add">Âä†ÁÆó</option>
                        </select>
                        <input type="number" id="bulk-coord-y" step="0.01" placeholder="m" style="width: 100px;">
                        <span style="font-size: 12px;">m</span>
                    </div>
                </div>
            </div>
            
            <div style="margin-bottom: 15px;">
                <label><input type="checkbox" id="bulk-edit-support"> Â¢ÉÁïåÊù°‰ª∂</label>
                <div id="bulk-support-container" style="margin-left: 20px; display: none;">
                    <select id="bulk-support-type" style="width: 150px;">
                        <option value="free">Ëá™Áî±</option>
                        <option value="pinned">„Éî„É≥</option>
                        <option value="fixed">Âõ∫ÂÆö</option>
                        <option value="roller_x_fixed">„É≠„Éº„É©„Éº(ÂûÇÁõ¥Ëá™Áî±)</option>
                        <option value="roller_y_fixed">„É≠„Éº„É©„Éº(Ê∞¥Âπ≥Ëá™Áî±)</option>
                    </select>
                </div>
            </div>
            
            <div class="dialog-buttons" style="margin-top: 20px; text-align: right;">
                <button onclick="window.applyBulkNodeEdit()" style="background: #28a745; color: white; border: none; padding: 8px 16px; border-radius: 4px; margin-right: 10px; cursor: pointer;">ÈÅ©Áî®</button>
                <button onclick="document.body.removeChild(document.getElementById('bulk-node-edit-dialog'))" style="background: #6c757d; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer;">„Ç≠„É£„É≥„Çª„É´</button>
            </div>
        `;
        
        document.body.appendChild(dialog);
        console.log('ÁØÄÁÇπ‰∏ÄÊã¨Á∑®ÈõÜ„ÉÄ„Ç§„Ç¢„É≠„Ç∞„Åå‰ΩúÊàê„Åï„Çå„Åæ„Åó„Åü');
        
        // „ÉÅ„Çß„ÉÉ„ÇØ„Éú„ÉÉ„ÇØ„Çπ„ÅÆ„Ç§„Éô„É≥„Éà„É™„Çπ„Éä„Éº„ÇíËøΩÂä†
        document.getElementById('bulk-edit-coords').addEventListener('change', function() {
            document.getElementById('bulk-coords-container').style.display = this.checked ? 'block' : 'none';
        });
        
        document.getElementById('bulk-edit-support').addEventListener('change', function() {
            document.getElementById('bulk-support-container').style.display = this.checked ? 'block' : 'none';
        });
    };

    // „Ç¶„Ç£„É≥„Éâ„Ç¶„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„Å´Èñ¢Êï∞„Çí„Ç¢„Çø„ÉÉ„ÉÅ
    window.showBulkNodeEditDialog = showBulkNodeEditDialog;

    // ÁØÄÁÇπ‰∏ÄÊã¨Á∑®ÈõÜÈÅ©Áî®Èñ¢Êï∞
    const applyBulkNodeEdit = () => {
        const updates = {};
        
        // Â∫ßÊ®ô„ÅÆÂá¶ÁêÜ
        if (document.getElementById('bulk-edit-coords').checked) {
            const xMode = document.getElementById('bulk-coord-x-mode').value;
            const yMode = document.getElementById('bulk-coord-y-mode').value;
            const x = document.getElementById('bulk-coord-x').value;
            const y = document.getElementById('bulk-coord-y').value;
            
            if (x) {
                updates.coordX = { mode: xMode, value: parseFloat(x) };
            }
            if (y) {
                updates.coordY = { mode: yMode, value: parseFloat(y) };
            }
        }
        
        // Â¢ÉÁïåÊù°‰ª∂„ÅÆÂá¶ÁêÜ
        if (document.getElementById('bulk-edit-support').checked) {
            updates.support = document.getElementById('bulk-support-type').value;
        }
        
        console.log('ÁØÄÁÇπ‰∏ÄÊã¨Á∑®ÈõÜÂÜÖÂÆπ:', updates);
        
        // ÈÅ∏Êäû„Åï„Çå„ÅüÁØÄÁÇπ„Å´Â§âÊõ¥„ÇíÈÅ©Áî®
        pushState(); // Â§âÊõ¥Ââç„ÅÆÁä∂ÊÖã„Çí‰øùÂ≠ò
        
        const editedCount = selectedNodes.size;
        for (const nodeIndex of selectedNodes) {
            const row = elements.nodesTable.rows[nodeIndex];
            if (!row) continue;
            // Â∫ßÊ®ô„ÅÆÊõ¥Êñ∞
            if (updates.coordX) {
                const currentX = parseFloat(row.cells[1].querySelector('input').value);
                const newX = updates.coordX.mode === 'set' ? 
                    updates.coordX.value : 
                    currentX + updates.coordX.value;
                row.cells[1].querySelector('input').value = newX.toFixed(2);
            }
            if (updates.coordY) {
                const currentY = parseFloat(row.cells[2].querySelector('input').value);
                const newY = updates.coordY.mode === 'set' ? 
                    updates.coordY.value : 
                    currentY + updates.coordY.value;
                row.cells[2].querySelector('input').value = newY.toFixed(2);
            }
            // Â¢ÉÁïåÊù°‰ª∂„ÅÆÊõ¥Êñ∞
            if (updates.support) {
                row.cells[3].querySelector('select').value = updates.support;
            }
        }
        if (typeof drawOnCanvas === 'function') {
            drawOnCanvas();
        }
        document.body.removeChild(document.getElementById('bulk-node-edit-dialog'));
        clearMultiSelection(); // Á∑®ÈõÜÂæå„Å´ÈÅ∏Êäû„Çí„ÇØ„É™„Ç¢
        // ÊàêÂäü„É°„ÉÉ„Çª„Éº„Ç∏„ÇíË°®Á§∫
        const message = document.createElement('div');
        message.style.position = 'fixed';
        message.style.top = '20px';
        message.style.right = '20px';
        message.style.background = '#28a745';
        message.style.color = 'white';
        message.style.padding = '10px 15px';
        message.style.borderRadius = '4px';
        message.style.zIndex = '4000';
        message.textContent = `${editedCount}„Å§„ÅÆÁØÄÁÇπ„Çí‰∏ÄÊã¨Á∑®ÈõÜ„Åó„Åæ„Åó„Åü`;
        document.body.appendChild(message);
        setTimeout(() => message.remove(), 3000);
    };

    // „Ç¶„Ç£„É≥„Éâ„Ç¶„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„Å´Èñ¢Êï∞„Çí„Ç¢„Çø„ÉÉ„ÉÅ
    window.applyBulkNodeEdit = applyBulkNodeEdit;
    
    // --- Matrix Math Library ---
    const mat = {
        create: (rows, cols, value = 0) => Array(rows).fill().map(() => Array(cols).fill(value)),
        
        multiply: (A, B) => {
            // undefined„ÉÅ„Çß„ÉÉ„ÇØ„ÇíËøΩÂä†
            if (!A || !B || !A.length || !B[0] || !B[0].length) {
                console.error('Matrix multiply: Invalid matrices', { A, B });
                return null;
            }
            const C = mat.create(A.length, B[0].length);
            for (let i = 0; i < A.length; i++) {
                for (let j = 0; j < B[0].length; j++) {
                    for (let k = 0; k < A[0].length; k++) {
                        C[i][j] += A[i][k] * B[k][j];
                    }
                }
            }
            return C;
        },
        
        transpose: (A) => {
            if (!A || !A[0]) return null;
            return A[0].map((_, colIndex) => A.map(row => row[colIndex]));
        },
        
        add: (A, B) => {
            if (!A || !B || A.length !== B.length) return null;
            return A.map((row, i) => row.map((val, j) => val + B[i][j]));
        },
        
        subtract: (A, B) => {
            if (!A || !B || A.length !== B.length) return null;
            return A.map((row, i) => row.map((val, j) => val - B[i][j]));
        },
        
        solve: (A, b) => {
            if (!A || !b || !A.length) return null;
            const n = A.length;
            // Ë°åÂàó„Å®Âè≥Ëæ∫„ÇíÁµêÂêà„Åó„ÅüÊã°ÂºµË°åÂàó„Çí‰Ωú„ÇãÔºàÈùûÁ†¥Â£äÔºâ
            const M = A.map((row, i) => [...row, b[i][0]]);
            const EPSILON = 1e-10;

            for (let i = 0; i < n; i++) {
                // „Éî„Éú„ÉÉ„ÉàÈÅ∏ÊäûÔºàÁµ∂ÂØæÂÄ§„ÅåÊúÄÂ§ß„ÅÆË°å„ÇíÈÅ∏„Å∂Ôºâ
                let maxRow = i;
                for (let k = i + 1; k < n; k++) {
                    if (Math.abs(M[k][i]) > Math.abs(M[maxRow][i])) maxRow = k;
                }

                // ÁâπÁï∞Ë°åÂàó„ÅÆÂà§ÂÆö
                if (Math.abs(M[maxRow][i]) < EPSILON) {
                    console.error(`Matrix is singular or nearly singular at pivot ${i}`);
                    return null;
                }

                // Ë°å„ÅÆÂÖ•„ÇåÊõø„Åà
                [M[i], M[maxRow]] = [M[maxRow], M[i]];

                // ÂâçÈÄ≤Ê∂àÂéª
                for (let k = i + 1; k < n; k++) {
                    const factor = M[k][i] / M[i][i];
                    for (let j = i; j <= n; j++) {
                        M[k][j] -= factor * M[i][j];
                    }
                }
            }

            // ÂæåÈÄÄ‰ª£ÂÖ•
            const x = mat.create(n, 1);
            for (let i = n - 1; i >= 0; i--) {
                let sum = 0;
                for (let j = i + 1; j < n; j++) sum += M[i][j] * x[j][0];
                x[i][0] = (M[i][n] - sum) / M[i][i];
            }
            return x;
        }
    };
    
    // --- Utility: debounce & State and History Management ---

    // debounce helper (ÂÖ•Âäõ„Ç§„Éô„É≥„Éà„ÅÆÂ§öÁô∫„ÇíÊäëÂà∂)
    function debounce(func, wait) {
        let timeout = null;
        return function(...args) {
            const ctx = this;
            clearTimeout(timeout);
            timeout = setTimeout(() => func.apply(ctx, args), wait);
        };
    }

    // debounced pushState to reduce frequent history entries during typing
    const debouncedPushState = debounce(() => {
        try { HistoryManager.push(getCurrentState()); } catch (e) { console.error('debouncedPushState error', e); }
    }, 500);

    // [Êñ∞Ë¶è] Êñ≠Èù¢„Éë„É©„É°„Éº„ÇøÊâãÂãïÂ§âÊõ¥Áõ£Ë¶ñ
    const setupSectionPropertyWatchers = (row) => {
        try {
            const Iinput = row.cells[5]?.querySelector('input');
            const Ainput = row.cells[6]?.querySelector('input');
            const Zinput = row.cells[7]?.querySelector('input');
            [Iinput, Ainput, Zinput].forEach(inp => {
                if (!inp) return;
                inp.addEventListener('change', () => {
                    // „É¶„Éº„Ç∂„ÉºË¶ÅÊúõ: „É©„Éô„É´Ë°®Á§∫„Å∏„ÅÆ„Äå(ÊâãÂãïÂ§âÊõ¥)„ÄçËøΩË®ò„ÇíÂªÉÊ≠¢„Åó„Åæ„Åó„Åü„ÄÇ
                    // „Åü„Å†„ÅóÊñ≠Èù¢ÊÉÖÂ†±„ÅØÊâãÂãïÂ§âÊõ¥„Å´„Çà„ÇäÂè§„Åè„Å™„ÇãÂèØËÉΩÊÄß„Åå„ÅÇ„Çã„Åü„ÇÅ dataset „ÅØ„ÇØ„É™„Ç¢„Åó„Åæ„Åô„ÄÇ
                    const axisCell = row.querySelector('.section-axis-cell');
                    if (axisCell) axisCell.textContent = '-';
                    delete row.dataset.sectionInfo;
                });
            });
        } catch (e) {
            console.warn('setupSectionPropertyWatchers error', e);
        }
    };

    // --- State and History Management ---
    const getCurrentState = () => {
        const state = { nodes: [], members: [], nodeLoads: [], memberLoads: [] };
        Array.from(elements.nodesTable.rows).forEach(row => {
            state.nodes.push({
                x: row.cells[1].querySelector('input').value,
                y: row.cells[2].querySelector('input').value,
                support: row.cells[3].querySelector('select').value,
                dx_forced: row.cells[4]?.querySelector('input')?.value || 0,
                dy_forced: row.cells[5]?.querySelector('input')?.value || 0,
                r_forced: row.cells[6]?.querySelector('input')?.value || 0
            });
        });
        Array.from(elements.membersTable.rows).forEach(row => {
            const e_select = row.cells[3].querySelector('select');
            const e_input = row.cells[3].querySelector('input[type="number"]');
            const strengthInputContainer = row.cells[4].firstElementChild;
            const strengthType = strengthInputContainer.dataset.strengthType;
            let strengthValue;
            if (strengthType === 'F-value' || strengthType === 'Fc' || strengthType === 'F-stainless' || strengthType === 'F-aluminum') {
                strengthValue = strengthInputContainer.querySelector('input').value;
            } else if (strengthType === 'wood-type') {
                strengthValue = strengthInputContainer.querySelector('select').value;
            }

            state.members.push({
                i: row.cells[1].querySelector('input').value,
                j: row.cells[2].querySelector('input').value,
                E: e_select.value === 'custom' ? e_input.value : e_select.value,
                strengthType: strengthType,
                strengthValue: strengthValue,
                I: row.cells[5].querySelector('.section-I-input')?.value,
                I_factor: row.cells[5].querySelector('.section-I-factor')?.value || '1.0',
                A: row.cells[6].querySelector('.section-A-input')?.value,
                A_factor: row.cells[6].querySelector('.section-A-factor')?.value || '1.0',
                Z: row.cells[7].querySelector('.section-Z-input')?.value,
                Z_factor: row.cells[7].querySelector('.section-Z-factor')?.value || '1.0',
                i_radius: row.querySelector('.radius-i-input')?.value || '',
                i_factor: row.querySelector('.section-i-factor')?.value || '1.0',
                bucklingK: (row.querySelector('.buckling-k-input') ? row.querySelector('.buckling-k-input').value : ''),
            });
            
            // Êé•ÂêàÊù°‰ª∂„ÅÆÂèñÂæó - ÂãïÁöÑ„Å´selectË¶ÅÁ¥†„ÇíÊ§úÁ¥¢
            const cellCount = row.cells.length;
            const lastCellIndex = cellCount - 1; // ÂâäÈô§„Éú„Çø„É≥
            
            let iConnIndex = -1, jConnIndex = -1;
            let selectCount = 0;
            for (let i = lastCellIndex - 1; i >= 0; i--) {
                const cell = row.cells[i];
                if (cell && cell.querySelector('select')) {
                    selectCount++;
                    if (selectCount === 1) {
                        jConnIndex = i; // ÊúÄÂàù„Å´Ë¶ã„Å§„Åã„Å£„Åüselect„ÅØÁµÇÁ´ØÊé•Á∂ö
                    } else if (selectCount === 2) {
                        iConnIndex = i; // 2Áï™ÁõÆ„Å´Ë¶ã„Å§„Åã„Å£„Åüselect„ÅØÂßãÁ´ØÊé•Á∂ö
                        break;
                    }
                }
            }
            
            // Êé•ÂêàÊù°‰ª∂„ÇíËøΩÂä†ÔºàÂÆâÂÖ®„Å™ÂèñÂæóÔºâ
            const currentMember = state.members[state.members.length - 1];
            const iConnSelect = iConnIndex >= 0 ? row.cells[iConnIndex]?.querySelector('select') : null;
            const jConnSelect = jConnIndex >= 0 ? row.cells[jConnIndex]?.querySelector('select') : null;
            currentMember.i_conn = iConnSelect?.value || 'rigid';
            currentMember.j_conn = jConnSelect?.value || 'rigid';
            currentMember.Zx = row.dataset.zx;
            currentMember.Zy = row.dataset.zy;
            currentMember.ix = row.dataset.ix;
            currentMember.iy = row.dataset.iy;

            // ÂêÑË°å„ÅÆ„Éê„ÉçÂâõÊÄß„ÇíÂèñÂæóÔºàË©≤ÂΩì„Çª„É´ÂÜÖ„ÅÆ .spring-inputs „ÇíÊé¢„ÅôÔºâ
            // UIÂÖ•ÂäõÂçò‰Ωç„ÇíÂÜÖÈÉ®Âçò‰Ωç„Å∏Â§âÊèõ„Åô„Çã
            // UI: Kx,Ky -> kN/mm  , Kr -> kN¬∑mm/rad
            // ÂÜÖÈÉ®Ë®àÁÆó: Kx,Ky -> kN/m   (1 kN/mm = 1000 kN/m)
            //            Kr -> kN¬∑m/rad (1 kN¬∑mm = 0.001 kN¬∑m)
            const convertSpringFromUI = (Kx_ui, Ky_ui, Kr_ui) => ({ Kx: Kx_ui * 1000, Ky: Ky_ui * 1000, Kr: Kr_ui * 1e-3 });

            const readSpringFromCell = (cell) => {
                if (!cell) return null;
                const container = cell.querySelector('.spring-inputs');
                if (!container) return null;
                const kxEl = container.querySelector('.spring-kx');
                const kyEl = container.querySelector('.spring-ky');
                const krEl = container.querySelector('.spring-kr');
                const rigidKxEl = container.querySelector('.spring-rigid-kx');
                const rigidKyEl = container.querySelector('.spring-rigid-ky');
                const rigidKrEl = container.querySelector('.spring-rigid-kr');
                const parse = (el) => {
                    if (!el) return 0;
                    const v = parseFloat(el.value);
                    return Number.isFinite(v) ? v : 0;
                };
                const Kx_raw = parse(kxEl);
                const Ky_raw = parse(kyEl);
                const Kr_raw = parse(krEl); // UIÂÖ•ÂäõÂÄ§ (kN¬∑mm/rad)
                const { Kx, Ky, Kr } = convertSpringFromUI(Kx_raw, Ky_raw, Kr_raw);
                const isRigidKx = rigidKxEl ? rigidKxEl.checked : false;
                const isRigidKy = rigidKyEl ? rigidKyEl.checked : false;
                const isRigidKr = rigidKrEl ? rigidKrEl.checked : false;
                const EPS_LOCAL = (typeof EPS_SPRING !== 'undefined') ? EPS_SPRING : 1e-6;
                if (!isRigidKx && !isRigidKy && (Kx === 0 || Kx === null) && (Ky === 0 || Ky === null)) {
                    return { Kx: EPS_LOCAL, Ky: EPS_LOCAL, Kr: Kr || 0, rigidKx: isRigidKx, rigidKy: isRigidKy, rigidKr: isRigidKr };
                }
                return { Kx: Kx || 0, Ky: Ky || 0, Kr: Kr || 0, rigidKx: isRigidKx, rigidKy: isRigidKy, rigidKr: isRigidKr };
            };

            // ÂßãÁ´Ø„Éê„Éç
            try {
                if (currentMember.i_conn === 'spring') {
                    const iCell = iConnIndex >= 0 ? row.cells[iConnIndex] : null;
                    const s = readSpringFromCell(iCell);
                    if (s) {
                        currentMember.spring_i = s;
                    } else {
                        // „Ç∞„É≠„Éº„Éê„É´ÂÖ•Âäõ„ÇíÂªÉÊ≠¢„Åó„Åü„Åü„ÇÅ„ÄÅÊú™ÊåáÂÆö„ÅØ„Çº„É≠ÂâõÊÄß„Å®„Åô„Çã
                        currentMember.spring_i = { Kx: 0, Ky: 0, Kr: 0 };
                    }
                }
            } catch (e) {
                console.warn('ÂßãÁ´Ø„Éê„ÉçË™≠„ÅøÂèñ„Çä„Ç®„É©„Éº', e);
            }

            // ÁµÇÁ´Ø„Éê„Éç
            try {
                if (currentMember.j_conn === 'spring') {
                    const jCell = jConnIndex >= 0 ? row.cells[jConnIndex] : null;
                    const s2 = readSpringFromCell(jCell);
                    if (s2) {
                        currentMember.spring_j = s2;
                    } else {
                        currentMember.spring_j = { Kx: 0, Ky: 0, Kr: 0 };
                    }
                }
            } catch (e) {
                console.warn('ÁµÇÁ´Ø„Éê„ÉçË™≠„ÅøÂèñ„Çä„Ç®„É©„Éº', e);
            }

            // Êñ≠Èù¢ÊÉÖÂ†±„Å®Ëª∏Ë®≠ÂÆö„Çí‰øùÂ≠ò
            const sectionInfoEncoded = row.dataset.sectionInfo;
            let sectionInfo = null;
            if (sectionInfoEncoded) {
                try {
                    sectionInfo = JSON.parse(decodeURIComponent(sectionInfoEncoded));
                } catch (error) {
                    console.warn('Failed to parse sectionInfo from dataset:', error);
                }
            }

            const resolveAxisInfo = () => {
                const datasetAxis = normalizeAxisInfo({
                    key: row.dataset.sectionAxisKey,
                    mode: row.dataset.sectionAxisMode,
                    label: row.dataset.sectionAxisLabel
                });

                if (datasetAxis) {
                    return datasetAxis;
                }

                if (sectionInfo && sectionInfo.axis) {
                    return normalizeAxisInfo(sectionInfo.axis);
                }

                return null;
            };

            const sectionAxis = resolveAxisInfo();

            currentMember.sectionInfo = sectionInfo || null;
            currentMember.sectionInfoEncoded = sectionInfoEncoded || '';
            currentMember.sectionLabel = row.dataset.sectionLabel || sectionInfo?.label || '';
            currentMember.sectionSummary = row.dataset.sectionSummary || sectionInfo?.dimensionSummary || '';
            currentMember.sectionSource = row.dataset.sectionSource || sectionInfo?.source || '';
            currentMember.sectionAxis = sectionAxis;
            currentMember.sectionAxisKey = sectionAxis?.key || '';
            currentMember.sectionAxisMode = sectionAxis?.mode || '';
            currentMember.sectionAxisLabel = sectionAxis?.label || '';
        });
        Array.from(elements.nodeLoadsTable.rows).forEach(row => {
            state.nodeLoads.push({ node: row.cells[0].querySelector('input').value, px: row.cells[1].querySelector('input').value, py: row.cells[2].querySelector('input').value, mz: row.cells[3].querySelector('input').value });
        });
        Array.from(elements.memberLoadsTable.rows).forEach(row => {
            state.memberLoads.push({ member: row.cells[0].querySelector('input').value, w: row.cells[1].querySelector('input').value });
        });
        return state;
    };

    // Â±•Ê≠¥ÁÆ°ÁêÜ„Éû„Éç„Éº„Ç∏„É£„Éº (ÂúßÁ∏Æ„Å®ÈáçË§áÊéíÈô§„Å´„Çà„Çã„Éë„Éï„Ç©„Éº„Éû„É≥„ÇπÊîπÂñÑÁâà)
    const HistoryManager = {
        stack: [],
        maxSize: 50, // Â±•Ê≠¥„ÅÆÊúÄÂ§ß‰øùÊåÅÊï∞

        push: function(state) {
            if (!state) return;
            
            try {
                // „Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÇíJSONÊñáÂ≠óÂàóÂåñ
                const jsonString = JSON.stringify(state);
                
                // Áõ¥Ââç„ÅÆÁä∂ÊÖã„Å®ÊØîËºÉ„Åó„Å¶Â§âÊõ¥„Åå„Å™„Åë„Çå„Å∞‰øùÂ≠ò„Åó„Å™„ÅÑ
                if (this.stack.length > 0) {
                    const lastItem = this.stack[this.stack.length - 1];
                    let lastJsonString;
                    
                    if (lastItem.compressed && typeof pako !== 'undefined') {
                        lastJsonString = pako.inflate(lastItem.data, { to: 'string' });
                    } else {
                        lastJsonString = lastItem.data;
                    }
                    
                    if (lastJsonString === jsonString) {
                        // Áä∂ÊÖã„Å´Â§âÊõ¥„Åå„Å™„ÅÑ„Åü„ÇÅ‰øùÂ≠ò„Åó„Å™„ÅÑ
                        return;
                    }
                }

                // pako„ÅåÂà©Áî®ÂèØËÉΩ„Å™„ÇâÂúßÁ∏Æ„Åó„Å¶‰øùÂ≠ò„ÄÅ„Å™„Åë„Çå„Å∞ÊñáÂ≠óÂàó„ÅÆ„Åæ„Åæ‰øùÂ≠ò
                if (typeof pako !== 'undefined') {
                    const compressed = pako.deflate(jsonString);
                    this.stack.push({ compressed: true, data: compressed });
                } else {
                    this.stack.push({ compressed: false, data: jsonString });
                }

                // „Çµ„Ç§„Ç∫Âà∂Èôê„ÇíË∂Ö„Åà„Åü„ÇâÂè§„ÅÑÂ±•Ê≠¥„ÇíÂâäÈô§
                if (this.stack.length > this.maxSize) {
                    this.stack.shift();
                }
                
                this.updateUI();
            } catch (e) {
                console.error('Â±•Ê≠¥‰øùÂ≠ò„Ç®„É©„Éº:', e);
            }
        },

        pop: function() {
            if (this.stack.length === 0) return null;

            try {
                const item = this.stack.pop();
                let jsonString;
                
                if (item.compressed && typeof pako !== 'undefined') {
                    jsonString = pako.inflate(item.data, { to: 'string' });
                } else {
                    jsonString = item.data;
                }
                
                this.updateUI();
                return JSON.parse(jsonString);
            } catch (e) {
                console.error('Â±•Ê≠¥Âæ©ÂÖÉ„Ç®„É©„Éº:', e);
                return null;
            }
        },

        clear: function() {
            this.stack = [];
            this.updateUI();
        },

        updateUI: function() {
            const undoBtn = document.getElementById('undo-btn');
            if (undoBtn) {
                const hasHistory = this.stack.length > 0;
                undoBtn.disabled = !hasHistory;
                undoBtn.style.opacity = hasHistory ? '1' : '0.5';
                undoBtn.title = hasHistory ? "ÂÖÉ„Å´Êàª„Åô („Ç∑„Éß„Éº„Éà„Ç´„ÉÉ„Éà: Ctrl+Z)" : "ÂÖÉ„Å´Êàª„ÅôÂ±•Ê≠¥„Åå„ÅÇ„Çä„Åæ„Åõ„Çì";
            }
        }
    };

    const pushState = () => { HistoryManager.push(getCurrentState()); };

    const restoreState = (state) => {
        console.log('üîç restoreStateÂëº„Å≥Âá∫„ÅóÊôÇÂàª:', new Date().toISOString());
        console.log('üîç restoreStateÂëº„Å≥Âá∫„Åó„Éë„É©„É°„Éº„Çø:', { state });
        
        // Èñ¢Êï∞ÈñãÂßãÊôÇ„ÅÆÊñ≠Èù¢ÊÉÖÂ†±Áä∂ÊÖã„ÇíË®òÈå≤
        const membersTable = document.getElementById('members-table');
        if (membersTable) {
            const rows = membersTable.querySelectorAll('tbody tr');
            console.log('üîç restoreStateÈñãÂßãÊôÇ„ÅÆÊñ≠Èù¢ÊÉÖÂ†±Áä∂ÊÖã:');
            rows.forEach((row, index) => {
                const sectionInfo = row.dataset.sectionInfo;
                const sectionNameCell = row.querySelector('.section-name-cell');
                const sectionAxisCell = row.querySelector('.section-axis-cell');
                console.log(`üîç ÈÉ®Êùê${index + 1}: dataset.sectionInfo=${!!sectionInfo}, Èï∑„Åï=${sectionInfo ? sectionInfo.length : 0}, Êñ≠Èù¢ÂêçÁß∞="${sectionNameCell ? sectionNameCell.textContent : 'N/A'}", Ëª∏ÊñπÂêë="${sectionAxisCell ? sectionAxisCell.textContent : 'N/A'}"`);
            });
        }
        
        if (!state) return;
        
        const safeDecode = (value) => {
            if (typeof value !== 'string' || value.length === 0) return value || '';
            try {
                return decodeURIComponent(value);
            } catch (error) {
                return value;
            }
        };

        const parseSectionInfo = (member) => {
            if (!member) return null;
            if (member.sectionInfo && typeof member.sectionInfo === 'object' && !Array.isArray(member.sectionInfo)) {
                return ensureSectionSvgMarkup(cloneDeep(member.sectionInfo));
            }

            let encoded = '';
            if (typeof member.sectionInfo === 'string' && member.sectionInfo.trim()) {
                encoded = member.sectionInfo.trim();
            } else if (typeof member.sectionInfoEncoded === 'string' && member.sectionInfoEncoded.trim()) {
                encoded = member.sectionInfoEncoded.trim();
            }

            if (!encoded) return null;

            const decoded = safeDecode(encoded);
            try {
                const parsed = JSON.parse(decoded);
                return parsed && typeof parsed === 'object' ? ensureSectionSvgMarkup(parsed) : null;
            } catch (error) {
                console.warn('Failed to parse sectionInfo during restoreState:', error, member);
                return null;
            }
        };
        const toNumberOrDefault = (value, defaultValue = 0) => {
            const num = typeof value === 'number' ? value : parseFloat(value);
            return Number.isFinite(num) ? num : defaultValue;
        };

        try {
            // Êó¢Â≠ò„ÅÆÊñ≠Èù¢ÊÉÖÂ†±„Çí„Éê„ÉÉ„ÇØ„Ç¢„ÉÉ„ÉóÔºà„ÉÜ„Éº„Éñ„É´„ÇØ„É™„Ç¢ÂâçÔºâ
            const existingSectionInfo = [];
            const membersTable = document.getElementById('members-table');
            if (membersTable) {
                const rows = membersTable.querySelectorAll('tbody tr');
                rows.forEach((row, index) => {
                    const sectionInfo = row.dataset.sectionInfo;
                    const sectionNameCell = row.querySelector('.section-name-cell');
                    const sectionAxisCell = row.querySelector('.section-axis-cell');
                    
                    let parsedSectionInfo = null;
                    if (sectionInfo) {
                        try {
                            const decoded = decodeURIComponent(sectionInfo);
                            parsedSectionInfo = JSON.parse(decoded);
                        } catch (error) {
                            console.warn(`restoreState: ÈÉ®Êùê${index + 1}„ÅÆÊñ≠Èù¢ÊÉÖÂ†±„ÅÆ„Éë„Éº„Çπ„Å´Â§±Êïó:`, error);
                        }
                    }
                    
                    existingSectionInfo[index] = {
                        sectionName: sectionNameCell ? sectionNameCell.textContent : '',
                        sectionAxis: sectionAxisCell ? sectionAxisCell.textContent : '',
                        sectionInfo: parsedSectionInfo,
                        sectionInfoEncoded: row.dataset.sectionInfoEncoded || '',
                        sectionLabel: row.dataset.sectionLabel || '',
                        sectionSummary: row.dataset.sectionSummary || '',
                        sectionSource: row.dataset.sectionSource || '',
                        sectionAxisKey: row.dataset.sectionAxisKey || '',
                        sectionAxisMode: row.dataset.sectionAxisMode || '',
                        sectionAxisLabel: row.dataset.sectionAxisLabel || ''
                    };
                });
            }
            
            console.log('üîç restoreState: Êó¢Â≠ò„ÅÆÊñ≠Èù¢ÊÉÖÂ†±„Çí„Éê„ÉÉ„ÇØ„Ç¢„ÉÉ„Éó:', existingSectionInfo);
            
            elements.nodesTable.innerHTML = '';
            elements.membersTable.innerHTML = '';
            elements.nodeLoadsTable.innerHTML = '';
            elements.memberLoadsTable.innerHTML = '';
            
            console.log('üîç restoreState: „ÉÜ„Éº„Éñ„É´„ÇØ„É™„Ç¢ÂÆå‰∫Ü');
            
            // ÁØÄÁÇπÂæ©ÂÖÉ
            state.nodes.forEach((n, index) => {
                // ÁØÄÁÇπ„Éá„Éº„Çø„ÅÆ„É≠„Ç∞Âá∫Âäõ
                console.log(`üîç Âæ©ÂÖÉ‰∏≠„ÅÆÁØÄÁÇπ ${index + 1}:`, {
                    x: n.x,
                    y: n.y,
                    support: n.support,
                    dx_forced: n.dx_forced,
                    dy_forced: n.dy_forced,
                    r_forced: n.r_forced
                });
                
                // Â¢ÉÁïåÊù°‰ª∂„ÅÆË©≥Á¥∞„ÉÅ„Çß„ÉÉ„ÇØ
                console.log(`üîç ÁØÄÁÇπ ${index + 1} Â¢ÉÁïåÊù°‰ª∂Ë©≥Á¥∞„ÉÅ„Çß„ÉÉ„ÇØ:`, {
                    support: n.support,
                    supportStringified: JSON.stringify(n.support),
                    type: typeof n.support,
                    length: n.support ? n.support.length : 'undefined',
                    isFree: n.support === 'free',
                    isPinned: n.support === 'pinned', 
                    isFixed: n.support === 'fixed',
                    isRoller: n.support === 'roller'
                });
                // Â¢ÉÁïåÊù°‰ª∂„ÅÆ„Éá„Éï„Ç©„É´„ÉàÂÄ§„ÇíË®≠ÂÆö
                const support = n.support || 'free';
                console.log(`üîç ÁØÄÁÇπ ${index + 1} Â¢ÉÁïåÊù°‰ª∂ÂÄ§: "${support}"`);
                
                // selectË¶ÅÁ¥†„ÅÆHTML„Çí„É≠„Ç∞Âá∫Âäõ
                // roller‰∫íÊèõÊÄßÂØæÂøú: Âè§„ÅÑ 'roller' „ÅØ 'roller_y_fixed' (Ê∞¥Âπ≥Ëá™Áî±) „Å®„Åó„Å¶Êâ±„ÅÜ
                const supportVal = (support === 'roller') ? 'roller_y_fixed' : support;
                const selectHTML = `<select>
                    <option value="free"${supportVal==='free'?' selected':''}>Ëá™Áî±</option>
                    <option value="pinned"${supportVal==='pinned'?' selected':''}>„Éî„É≥</option>
                    <option value="fixed"${supportVal==='fixed'?' selected':''}>Âõ∫ÂÆö</option>
                    <option value="roller_x_fixed"${supportVal==='roller_x_fixed'?' selected':''}>„É≠„Éº„É©„Éº(ÂûÇÁõ¥Ëá™Áî±)</option>
                    <option value="roller_y_fixed"${supportVal==='roller_y_fixed'?' selected':''}>„É≠„Éº„É©„Éº(Ê∞¥Âπ≥Ëá™Áî±)</option>
                </select>`;
                console.log(`üîç ÁØÄÁÇπ ${index + 1} „ÅÆselectË¶ÅÁ¥†HTML:`, selectHTML);
                
                addRow(elements.nodesTable, [
                    `#`, 
                    `<input type="number" value="${n.x}">`, 
                    `<input type="number" value="${n.y}">`, 
                    selectHTML, 
                    `<input type="number" value="${n.dx_forced || 0}" step="0.1">`, 
                    `<input type="number" value="${n.dy_forced || 0}" step="0.1">`, 
                    `<input type="number" value="${n.r_forced || 0}" step="0.001">`
                ], false);
                
                // ‰ΩúÊàê„Åï„Çå„ÅüselectË¶ÅÁ¥†„ÅÆÂÆüÈöõ„ÅÆÂÄ§„ÇíÁ¢∫Ë™ç
                const lastRow = elements.nodesTable.rows[elements.nodesTable.rows.length - 1];
                if (lastRow && lastRow.cells[3]) {
                    const selectElement = lastRow.cells[3].querySelector('select');
                    if (selectElement) {
                        console.log(`üîç ÁØÄÁÇπ ${index + 1} „ÅÆÂÆüÈöõ„ÅÆselectÂÄ§:`, selectElement.value);
                    }
                }
            });
            
            // ÈÉ®ÊùêÂæ©ÂÖÉ
            state.members.forEach((m, index) => {
                // „Éá„Éê„ÉÉ„Ç∞„É≠„Ç∞„ÅØÊú¨Áï™Áí∞Â¢É„Åß„ÅØÂâäÈô§
                // console.log(`üîç Âæ©ÂÖÉ‰∏≠„ÅÆÈÉ®Êùê ${index + 1}:`, { i: m.i, j: m.j, E: m.E, I: m.I, A: m.A, Z: m.Z });
                
                try {
                    // ÂÆâÂÖ®„Å™Êï∞ÂÄ§Â§âÊèõÈñ¢Êï∞
                    const safeParseFloat = (value, defaultValue) => {
                        if (value === undefined || value === null || value === '') {
                            return defaultValue;
                        }
                        const parsed = parseFloat(value);
                        return isNaN(parsed) ? defaultValue : parsed;
                    };
                    
                    const I_m4 = safeParseFloat(m.I, 1.84e-5) * 1e-8;
                    const A_m2 = safeParseFloat(m.A, 2.34e-3) * 1e-4;
                    const Z_m3 = safeParseFloat(m.Z, 1.23e-3) * 1e-6;
                    
                    // console.log(`üîç ÈÉ®Êùê ${index + 1} Â§âÊèõÂæå„ÅÆÂÄ§:`, { I_m4, A_m2, Z_m3 });
                    
                    // memberRowHTML „ÅÆÊàª„ÇäÂÄ§„ÇíÂÆâÂÖ®„Å´ÂèñÂæó
                    const E_value = m.E || '205000';
                    const i_conn = m.i_conn || 'rigid';
                    const j_conn = m.j_conn || 'rigid';
                    const sectionName = m.sectionName || '';
                    const sectionAxis = m.sectionAxis || '';
                    
                    // ÁØÄÁÇπÁï™Âè∑„ÅÆÂÆâÂÖ®„Å™ÂèñÂæó
                    const i = m.i || m.startNode || 0;
                    const j = m.j || m.endNode || 1;
                    
                    // console.log(`üîç ÈÉ®Êùê ${index + 1} memberRowHTMLÂºïÊï∞:`, { i, j, E: E_value, I: I_m4, A: A_m2, Z: Z_m3 });
                    
                    const memberHTML = memberRowHTML(i, j, E_value, "235", I_m4, A_m2, Z_m3, '', i_conn, j_conn, sectionName, sectionAxis, (m.bucklingK !== undefined ? m.bucklingK : ''));
                    if (!memberHTML || !Array.isArray(memberHTML)) {
                        console.warn('memberRowHTML returned invalid data:', memberHTML);
                        return;
                    }
                    
                    const newRow = addRow(elements.membersTable, [`#`, ...memberHTML], false);

                    // ‰ΩéÊ∏õ‰øÇÊï∞„ÉªÊñ≠Èù¢2Ê¨°ÂçäÂæÑ„ÅÆÂæ©ÂÖÉÔºà‰∫íÊèõÊÄß„ÅÆ„Åü„ÇÅ„ÄÅÁÑ°„ÅÑÂ†¥Âêà„ÅØ„Éá„Éï„Ç©„É´„Éà1.0/Á©∫Ê¨ÑÔºâ
                    if (newRow) {
                        const setVal = (selector, value, fallback) => {
                            const el = newRow.querySelector(selector);
                            if (!el) return;
                            if (value === undefined || value === null || value === '') {
                                if (fallback !== undefined) el.value = fallback;
                                return;
                            }
                            el.value = value;
                        };

                        setVal('.section-I-factor', m.I_factor, '1.0');
                        setVal('.section-A-factor', m.A_factor, '1.0');
                        setVal('.section-Z-factor', m.Z_factor, '1.0');
                        setVal('.section-i-factor', m.i_factor, '1.0');
                        // i(Êñ≠Èù¢2Ê¨°ÂçäÂæÑ)„ÅØÊó¢Â≠ò„ÅÆi_rad„Å´Âä†„Åà„Å¶„ÄÅ‰øùÂ≠òÂÄ§„Åå„ÅÇ„Çå„Å∞ÂÑ™ÂÖà
                        setVal('.radius-i-input', m.i_radius, '');
                        if (typeof window.updateReductionDisplays === 'function') {
                            window.updateReductionDisplays(newRow);
                        }
                    }
                    
                    if (newRow && newRow.cells && newRow.cells.length > 4) {
                        // ÂºæÊÄß‰øÇÊï∞„ÅÆÂæ©ÂÖÉ
                        const eContainer = newRow.cells[2] ? newRow.cells[2].querySelector('div') : null;
                        if (eContainer) {
                            const eSelect = eContainer.querySelector('select');
                            const eInput = eContainer.querySelector('input');
                            if (eSelect && eInput) {
                                // EÂÄ§„ÇíÈÅ©Âàá„Å´Ë®≠ÂÆö
                                const eValue = E_value;
                                const materials = { "205000": "„Çπ„ÉÅ„Éº„É´", "193000": "„Çπ„ÉÜ„É≥„É¨„Çπ", "70000": "„Ç¢„É´„Éü„Éã„Ç¶„É†", "8000": "Êú®Êùê" };
                                const e_val_str = parseFloat(eValue).toString();
                                const isPresetMaterial = materials.hasOwnProperty(e_val_str);
                                
                                if (isPresetMaterial) {
                                    eSelect.value = e_val_str;
                                    eInput.value = e_val_str;
                                    eInput.readOnly = true;
                                } else {
                                    eSelect.value = 'custom';
                                    eInput.value = eValue;
                                    eInput.readOnly = false;
                                }
                                eSelect.dispatchEvent(new Event('change')); // Trigger update
                            }
                        }
                        
                        // Èôç‰ºèÂº∑Â∫¶„ÅÆÂæ©ÂÖÉ
                        const strengthCell = newRow.cells[4];
                        if (strengthCell) {
                            const strengthInputContainer = strengthCell.firstElementChild;
                            if (strengthInputContainer) {
                                if (m.strengthType === 'F-value' || m.strengthType === 'Fc' || m.strengthType === 'F-stainless' || m.strengthType === 'F-aluminum') {
                                    const strengthInput = strengthInputContainer.querySelector('input');
                                    if (strengthInput) strengthInput.value = m.strengthValue;
                                    const strengthSelect = strengthInputContainer.querySelector('select');
                                    if (strengthSelect) strengthSelect.value = 'custom';
                                } else if (m.strengthType === 'wood-type') {
                                    const strengthSelect = strengthInputContainer.querySelector('select');
                                    if (strengthSelect) strengthSelect.value = m.strengthValue;
                                }
                            }
                        }

                        // „Åù„ÅÆ‰ªñ„ÅÆ„Éá„Éº„ÇøÂæ©ÂÖÉ
                        if(m.Zx) newRow.dataset.zx = m.Zx;
                        if(m.Zy) newRow.dataset.zy = m.Zy;
                        if(m.ix) newRow.dataset.ix = m.ix;
                        if(m.iy) newRow.dataset.iy = m.iy;
                        
                        // Êñ≠Èù¢ÊÉÖÂ†±„ÅÆdatasetÂ±ûÊÄß„ÇíË®≠ÂÆöÔºàÊó¢Â≠ò„ÅÆÊñ≠Èù¢ÊÉÖÂ†±„ÇíÂÑ™ÂÖàÔºâ
                        let sectionInfoToApply = m.sectionInfo;
                        
                        // Êó¢Â≠ò„ÅÆÊñ≠Èù¢ÊÉÖÂ†±„Åå„ÅÇ„ÇãÂ†¥Âêà„ÅØ„Åù„Çå„Çí‰ΩøÁî®
                        if (existingSectionInfo[index] && existingSectionInfo[index].sectionInfo) {
                            sectionInfoToApply = existingSectionInfo[index].sectionInfo;
                            console.log(`üîß restoreState: ÈÉ®Êùê${index + 1}„ÅÆÊó¢Â≠òÊñ≠Èù¢ÊÉÖÂ†±„Çí‰ΩøÁî®:`, sectionInfoToApply);
                        } else if (m.sectionInfo) {
                            console.log(`üîß restoreState: ÈÉ®Êùê${index + 1}„ÅÆÊñ∞„Åó„ÅÑÊñ≠Èù¢ÊÉÖÂ†±„Çí‰ΩøÁî®:`, m.sectionInfo);
                        } else {
                            // AIÁîüÊàêÈÉ®Êùê„Å™„Å©„ÄÅÊñ≠Èù¢ÊÉÖÂ†±„Åå„Å™„ÅÑÂ†¥Âêà„ÅØ„Éá„Éï„Ç©„É´„ÉàÊñ≠Èù¢ÊÉÖÂ†±„Çí‰ΩúÊàê
                            const I_m4 = parseFloat(m.I) || 0;
                            const A_m2 = parseFloat(m.A) || 0;
                            sectionInfoToApply = {
                                typeKey: 'estimated',
                                label: 'Êé®ÂÆöÊñ≠Èù¢ÔºàÂÜÜÂΩ¢Ôºâ',
                                rawDims: {
                                    D: Math.sqrt(A_m2 * 1e4 / Math.PI) * 2 * 10, // A„Åã„ÇâÁõ¥ÂæÑ„ÇíË®àÁÆóÔºàmmÔºâ
                                    D_scaled: Math.sqrt(A_m2 * 1e4 / Math.PI) * 2 * 10
                                },
                                dimensions: [
                                    { name: 'D', value: Math.sqrt(A_m2 * 1e4 / Math.PI) * 2 * 10, unit: 'mm' }
                                ],
                                dimensionSummary: `D=${(Math.sqrt(A_m2 * 1e4 / Math.PI) * 2 * 10).toFixed(1)}mm`
                            };
                            console.log(`üîß restoreState: ÈÉ®Êùê${index + 1}„Å´„Éá„Éï„Ç©„É´„ÉàÊñ≠Èù¢ÊÉÖÂ†±„ÇíË®≠ÂÆö:`, sectionInfoToApply);
                        }
                        
                        if (sectionInfoToApply && typeof window.setRowSectionInfo === 'function') {
                            console.log(`üîß restoreState: ÈÉ®Êùê${index + 1}„ÅÆÊñ≠Èù¢ÊÉÖÂ†±„ÇísetRowSectionInfo„ÅßË®≠ÂÆö:`, sectionInfoToApply);
                            window.setRowSectionInfo(newRow, sectionInfoToApply);
                        } else if (sectionInfoToApply) {
                            // „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ: Áõ¥Êé•Ë®≠ÂÆö
                            console.log(`üîß restoreState: ÈÉ®Êùê${index + 1}„ÅÆÊñ≠Èù¢ÊÉÖÂ†±„ÇíÁõ¥Êé•Ë®≠ÂÆöÔºà„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÔºâ:`, sectionInfoToApply);
                            newRow.dataset.sectionInfo = JSON.stringify(sectionInfoToApply);
                        }
                        // „Åù„ÅÆ‰ªñ„ÅÆdatasetÂ±ûÊÄß„ÅØsetRowSectionInfo„ÅßÂá¶ÁêÜ„Åï„Çå„Çã„Åü„ÇÅ„ÄÅÂÄãÂà•Ë®≠ÂÆö„ÅØ‰∏çË¶Å

                        // ---- ÈÉ®Êùê„ÅÆ„Éê„ÉçÊÉÖÂ†±„Åå‰øùÂ≠ò„Åï„Çå„Å¶„ÅÑ„ÇãÂ†¥Âêà„ÅØ„ÉÜ„Éº„Éñ„É´Ë°å„ÅÆË°®Á§∫„ÇíÂæ©ÂÖÉ ----
                        try {
                            // conn-select Ë¶ÅÁ¥†„ÅØ memberRowHTML „Åß2„Å§‰Ωú„Çâ„Çå„ÇãÔºàÂßãÁ´Ø, ÁµÇÁ´ØÔºâ
                            const connSelects = newRow.querySelectorAll('select.conn-select');
                            const showSpringBoxFor = (selectEl) => {
                                const box = selectEl.closest('.conn-cell')?.querySelector('.spring-inputs');
                                if (box) box.style.display = (selectEl.value === 'spring') ? '' : 'none';
                            };

                            if (connSelects && connSelects.length >= 2) {
                                const iSel = connSelects[0];
                                const jSel = connSelects[1];
                                if (m.i_conn) iSel.value = m.i_conn;
                                if (m.j_conn) jSel.value = m.j_conn;
                                // Ë°®Á§∫ÂàáÊõø
                                try { showSpringBoxFor(iSel); } catch(e){}
                                try { showSpringBoxFor(jSel); } catch(e){}

                                // „Éê„ÉçÂÄ§„ÅÆÂæ©ÂÖÉÔºàUIÂçò‰Ωç„Åß‰øùÂ≠ò„Åï„Çå„Å¶„ÅÑ„ÇãÊÉ≥ÂÆöÔºâ
                                if (m.spring_i && iSel.value === 'spring') {
                                    const iBox = iSel.closest('.conn-cell')?.querySelector('.spring-inputs');
                                    if (iBox) {
                                        const kx = iBox.querySelector('.spring-kx');
                                        const ky = iBox.querySelector('.spring-ky');
                                        const kr = iBox.querySelector('.spring-kr');
                                        if (kx && m.spring_i.Kx !== undefined) kx.value = Number(m.spring_i.Kx);
                                        if (ky && m.spring_i.Ky !== undefined) ky.value = Number(m.spring_i.Ky);
                                        if (kr && m.spring_i.Kr !== undefined) kr.value = Number(m.spring_i.Kr);
                                    }
                                }
                                if (m.spring_j && jSel.value === 'spring') {
                                    const jBox = jSel.closest('.conn-cell')?.querySelector('.spring-inputs');
                                    if (jBox) {
                                        const kx = jBox.querySelector('.spring-kx');
                                        const ky = jBox.querySelector('.spring-ky');
                                        const kr = jBox.querySelector('.spring-kr');
                                        if (kx && m.spring_j.Kx !== undefined) kx.value = Number(m.spring_j.Kx);
                                        if (ky && m.spring_j.Ky !== undefined) ky.value = Number(m.spring_j.Ky);
                                        if (kr && m.spring_j.Kr !== undefined) kr.value = Number(m.spring_j.Kr);
                                    }
                                }
                            }
                        } catch (e) {
                            console.warn('restoreState: „Éê„ÉçË°®Á§∫Âæ©ÂÖÉ‰∏≠„Å´„Ç®„É©„Éº', e);
                        }

                        // Êó¢Â≠ò„ÅÆÊñ≠Èù¢ÊÉÖÂ†±„Åå„Å™„ÅÑÂ†¥Âêà„ÅÆ„Åø„ÄÅÊñ∞„Åó„ÅÑÊñ≠Èù¢ÊÉÖÂ†±„ÇíËß£Êûê„Åó„Å¶ÈÅ©Áî®
                        if (!existingSectionInfo[index] || !existingSectionInfo[index].sectionInfo) {
                            let parsedSectionInfo = parseSectionInfo(m);
                            const decodedLabel = safeDecode(m.sectionLabel || '');
                            const decodedSummary = safeDecode(m.sectionSummary || '');
                            const decodedSource = safeDecode(m.sectionSource || '');

                            if (!parsedSectionInfo && (decodedLabel || decodedSummary || decodedSource)) {
                                parsedSectionInfo = {};
                                if (decodedLabel) parsedSectionInfo.label = decodedLabel;
                                if (decodedSummary) parsedSectionInfo.dimensionSummary = decodedSummary;
                                if (decodedSource) parsedSectionInfo.source = decodedSource;
                            }

                            const axisInfo = buildAxisInfo(m, parsedSectionInfo);
                            if (axisInfo) {
                                if (!parsedSectionInfo) parsedSectionInfo = {};
                                parsedSectionInfo.axis = { ...axisInfo };
                            }

                            if (parsedSectionInfo) {
                                if (typeof window.setRowSectionInfo === 'function') {
                                    window.setRowSectionInfo(newRow, parsedSectionInfo);
                                } else {
                                    console.warn('setRowSectionInfoÈñ¢Êï∞„ÅåÂÆöÁæ©„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇÊñ≠Èù¢ÊÉÖÂ†±Âæ©ÂÖÉ„Çí„Çπ„Ç≠„ÉÉ„Éó„Åó„Åæ„Åô„ÄÇ');
                                }
                            } else if (axisInfo) {
                                if (typeof window.applySectionAxisDataset === 'function') {
                                    window.applySectionAxisDataset(newRow, axisInfo);
                                } else {
                                    console.warn('applySectionAxisDatasetÈñ¢Êï∞„ÅåÂÆöÁæ©„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇËª∏ÊÉÖÂ†±Âæ©ÂÖÉ„Çí„Çπ„Ç≠„ÉÉ„Éó„Åó„Åæ„Åô„ÄÇ');
                                }
                            } else {
                                // Âøµ„ÅÆ„Åü„ÇÅÊó¢Â≠ò„ÅÆ„Éá„Éº„Çø„Çª„ÉÉ„Éà„Çí„ÇØ„É™„Ç¢
                                if (typeof window.applySectionAxisDataset === 'function') {
                                    window.applySectionAxisDataset(newRow, null);
                                }
                            }
                        }
                    }
                } catch (memberError) {
                    console.error('Error restoring member:', memberError, m);
                }
            });
            
            // ÁØÄÁÇπËç∑ÈáçÂæ©ÂÖÉ
            console.log('üîç restoreState: ÁØÄÁÇπËç∑ÈáçÂæ©ÂÖÉÈñãÂßã, Ëç∑ÈáçÊï∞:', state.nodeLoads.length);
            console.log('üîç restoreState: ÁØÄÁÇπËç∑Èáç„Éá„Éº„ÇøË©≥Á¥∞:', state.nodeLoads);
            state.nodeLoads.forEach((l, index) => {
                console.log(`üîç restoreState: ÁØÄÁÇπËç∑Èáç ${index + 1} Âæ©ÂÖÉ:`, l);
                addRow(elements.nodeLoadsTable, [`<input type="number" value="${l.node}">`, `<input type="number" value="${l.px}">`, `<input type="number" value="${l.py}">`, `<input type="number" value="${l.mz}">`], false);
            });
            
            // ÈÉ®ÊùêËç∑ÈáçÂæ©ÂÖÉ
            console.log('üîç restoreState: ÈÉ®ÊùêËç∑ÈáçÂæ©ÂÖÉÈñãÂßã, Ëç∑ÈáçÊï∞:', state.memberLoads.length);
            state.memberLoads.forEach((l, index) => {
                console.log(`üîç restoreState: ÈÉ®ÊùêËç∑Èáç ${index + 1} Âæ©ÂÖÉ:`, l);
                addRow(elements.memberLoadsTable, [`<input type="number" value="${l.member}">`, `<input type="number" value="${l.w}">`], false);
            });
            
            renumberTables();
            
            // Âæ©ÂÖÉÂÆå‰∫ÜÂæå„ÅÆÊñ≠Èù¢ÊÉÖÂ†±Áä∂ÊÖã„ÇíË®òÈå≤
            console.log('üîç restoreStateÂÆå‰∫ÜÂæå„ÅÆÊñ≠Èù¢ÊÉÖÂ†±Áä∂ÊÖã:');
            const finalMembersTable = document.getElementById('members-table');
            if (finalMembersTable) {
                const finalRows = finalMembersTable.querySelectorAll('tbody tr');
                finalRows.forEach((row, index) => {
                    const sectionInfo = row.dataset.sectionInfo;
                    const sectionNameCell = row.querySelector('.section-name-cell');
                    const sectionAxisCell = row.querySelector('.section-axis-cell');
                    console.log(`üîç ÈÉ®Êùê${index + 1}: dataset.sectionInfo=${!!sectionInfo}, Èï∑„Åï=${sectionInfo ? sectionInfo.length : 0}, Êñ≠Èù¢ÂêçÁß∞="${sectionNameCell ? sectionNameCell.textContent : 'N/A'}", Ëª∏ÊñπÂêë="${sectionAxisCell ? sectionAxisCell.textContent : 'N/A'}"`);
                });
            }
            
            // ÈÉ®Êùê„ÉÜ„Éº„Éñ„É´„ÅÆÊñ≠Èù¢ÊÉÖÂ†±Ë°®Á§∫„ÇíÊõ¥Êñ∞
            setTimeout(() => {
                console.log('üîß restoreState: ÈÉ®Êùê„ÉÜ„Éº„Éñ„É´„ÅÆÊñ≠Èù¢ÊÉÖÂ†±Ë°®Á§∫„ÇíÊõ¥Êñ∞‰∏≠...');
                const memberRows = elements.membersTable.querySelectorAll('tbody tr');
                memberRows.forEach((row, memberIndex) => {
                    const memberData = state.members[memberIndex];
                    if (memberData && memberData.sectionName) {
                        // Êñ≠Èù¢ÂêçÁß∞„Çª„É´„ÅÆÊõ¥Êñ∞
                        const sectionNameCell = row.querySelector('.section-name-cell');
                        if (sectionNameCell) {
                            sectionNameCell.textContent = memberData.sectionName;
                        }
                        
                        // Ëª∏ÊÉÖÂ†±„Çª„É´„ÅÆÊõ¥Êñ∞
                        const sectionAxisCell = row.querySelector('.section-axis-cell');
                        if (sectionAxisCell && memberData.sectionAxis) {
                            sectionAxisCell.textContent = memberData.sectionAxis;
                        }
                        
                        // datasetÂ±ûÊÄß„ÅÆË®≠ÂÆöÔºàsetRowSectionInfoÈñ¢Êï∞„Çí‰ΩøÁî®Ôºâ
                        if (memberData.sectionInfo && typeof window.setRowSectionInfo === 'function') {
                            console.log(`üîß restoreState: ÈÉ®Êùê${memberIndex}„ÅÆÊñ≠Èù¢ÊÉÖÂ†±„ÇísetRowSectionInfo„ÅßË®≠ÂÆö:`, memberData.sectionInfo);
                            window.setRowSectionInfo(row, memberData.sectionInfo);
                        } else if (memberData.sectionInfo) {
                            // „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ: Áõ¥Êé•Ë®≠ÂÆö
                            console.log(`üîß restoreState: ÈÉ®Êùê${memberIndex}„ÅÆÊñ≠Èù¢ÊÉÖÂ†±„ÇíÁõ¥Êé•Ë®≠ÂÆöÔºà„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÔºâ:`, memberData.sectionInfo);
                            row.dataset.sectionInfo = JSON.stringify(memberData.sectionInfo);
                        }
                        // „Åù„ÅÆ‰ªñ„ÅÆdatasetÂ±ûÊÄß„ÅØsetRowSectionInfo„ÅßÂá¶ÁêÜ„Åï„Çå„Çã„Åü„ÇÅ„ÄÅÂÄãÂà•Ë®≠ÂÆö„ÅØ‰∏çË¶Å
                        
                        console.log(`üîß ÈÉ®Êùê${memberIndex + 1}„ÅÆÊñ≠Èù¢ÊÉÖÂ†±„ÇíÊõ¥Êñ∞: ${memberData.sectionName}`);
                    }
                });
                
                // 3D„Éì„É•„Éº„Ç¢„ÅåÈñã„ÅÑ„Å¶„ÅÑ„ÇãÂ†¥Âêà„ÅØÊõ¥Êñ∞„ÇíÈÄÅ‰ø°
                if (viewerWindow && !viewerWindow.closed) {
                    console.log('üîß restoreState: 3D„Éì„É•„Éº„Ç¢„Å´Êñ≠Èù¢ÊÉÖÂ†±Êõ¥Êñ∞„ÇíÈÄÅ‰ø°‰∏≠...');
                    sendModelToViewer();
                }
            }, 100);
            
            if (typeof drawOnCanvas === 'function') {
                drawOnCanvas();
            }
        } catch (error) {
            console.error('Error in restoreState:', error);
            alert('ÂÖÉ„Å´Êàª„ÅôÂá¶ÁêÜ‰∏≠„Å´„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü„ÄÇ„Ç≥„É≥„ÇΩ„Éº„É´„ÅßË©≥Á¥∞„ÇíÁ¢∫Ë™ç„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ');
        }
    };
    
    elements.undoBtn.onclick = () => { 
        const lastState = HistoryManager.pop(); 
        if (lastState) { 
            restoreState(lastState); 
        } 
    };
    
    // Make state management functions globally accessible
    window.pushState = pushState;
    window.restoreState = restoreState;
    window.getCurrentState = getCurrentState;
    
    /**
     * „ÉÜ„Éº„Éñ„É´Ë°å„ÅÆÂü∫Êú¨ÊßãÈÄ†„Çí‰ΩúÊàê
     * @param {HTMLTableSectionElement} tableBody - ÂØæË±°„ÅÆ„ÉÜ„Éº„Éñ„É´„Éú„Éá„Ç£
     * @param {Array} cells - „Çª„É´„ÅÆÂÜÖÂÆπÈÖçÂàó
     * @returns {HTMLTableRowElement} ‰ΩúÊàê„Åï„Çå„ÅüË°åË¶ÅÁ¥†
     */
    const createTableRow = (tableBody, cells) => {
        const newRow = tableBody.insertRow();
        cells.forEach(cellContent => { 
            const cell = newRow.insertCell(); 
            if (typeof cellContent === 'string') {
                cell.innerHTML = cellContent;
            } else if (cellContent instanceof Node) {
                cell.appendChild(cellContent);
            } else {
                cell.innerHTML = String(cellContent);
            }
        });
        
        // ÂâäÈô§„Éú„Çø„É≥„Çª„É´„ÇíËøΩÂä†
        const deleteCell = newRow.insertCell();
        deleteCell.innerHTML = '<button class="delete-row-btn">√ó</button>';
        
        return newRow;
    };

    /**
     * ÈÉ®Êùê„ÉÜ„Éº„Éñ„É´Áî®„ÅÆÁâπÂà•„Å™Ë®≠ÂÆö„ÇíÈÅ©Áî®ÔºàÂ†ÖÁâ¢ÁâàÔºâ
     * @param {HTMLTableRowElement} row - Ë®≠ÂÆöÂØæË±°„ÅÆË°å
     */
    const setupMemberRowSpecialFeatures = (row) => {
        // 1. Êñ≠Èù¢ÁÆóÂÆöÈñ¢ÈÄ£„ÅÆ„ÇØ„É©„Çπ„ÇíËøΩÂä†
        if (row.cells[4]) row.cells[4].classList.add('section-check-item');
        if (row.cells[7]) row.cells[7].classList.add('section-check-item');

        // 2. Êñ≠Èù¢ÈÅ∏Êäû„Éú„Çø„É≥„ÅÆÊåøÂÖ•
        let firstConnIndex = -1;
        for(let i = 0; i < row.cells.length; i++) {
            try {
                if(row.cells[i].querySelector && (row.cells[i].querySelector('.conn-cell') || row.cells[i].querySelector('.conn-select'))) {
                    firstConnIndex = i;
                    break;
                }
            } catch(e) {}
        }

        let insertIndex = firstConnIndex !== -1 ? firstConnIndex : (row.cells.length > 0 ? row.cells.length - 1 : 0);
        
        // Êó¢„Å´„Éú„Çø„É≥„Åå„ÅÇ„ÇãÂ†¥Âêà„ÅØÊåøÂÖ•„Åó„Å™„ÅÑ
        if (!row.querySelector('.select-props-btn')) {
            const selectCell = row.insertCell(insertIndex);
            selectCell.innerHTML = `<button class="select-props-btn" title="ÈãºÊùê„Éá„Éº„Çø„ÉÑ„Éº„É´„ÇíÈñã„Åè">ÈÅ∏Êäû</button>`;
        }

        // 3. ÂÖ®„Çª„É´„ÅÆ„ÇØ„É©„Çπ‰ªò‰∏é („Ç≥„É≥„ÉÜ„É≥„ÉÑ„Éô„Éº„ÇπÂà§ÂÆö)
        for (let i = 0; i < row.cells.length; i++) {
            const cell = row.cells[i];
            if(!cell) continue;

            // ÂâäÈô§„Éú„Çø„É≥„ÅåÂê´„Åæ„Çå„Çã„Çª„É´„ÅØ„Çπ„Ç≠„ÉÉ„Éó
            if (cell.querySelector('.delete-row-btn')) continue;

            // „ÇØ„É©„Çπ„Çí‰∏ÄÊó¶„É™„Çª„ÉÉ„Éà
            cell.classList.remove('col-material', 'col-section', 'col-buckling', 'col-conn', 'density-column');

            // --- „Ç≥„É≥„ÉÜ„É≥„ÉÑ„Éô„Éº„Çπ„Åß„ÅÆÂà§ÂÆö (ÂÑ™ÂÖà) ---
            try {
                // ÂØÜÂ∫¶ (Density)
                if (cell.classList.contains('density-cell') || cell.querySelector('input[title*="ÂØÜÂ∫¶"]')) {
                    cell.classList.add('col-material', 'density-column');
                    continue; 
                }

                // Â∫ßÂ±à‰øÇÊï∞ K
                if (cell.querySelector('.buckling-k-input')) {
                    cell.classList.add('col-buckling');
                    continue;
                }

                // Êñ≠Èù¢2Ê¨°ÂçäÂæÑ i („Åì„Åì„ÅåÈáçË¶ÅÔºö‰ª•Ââç„ÅÆ„Ç≥„Éº„Éâ„ÅßÊºè„Çå„Å¶„ÅÑ„ÅüÂèØËÉΩÊÄß„ÅÇ„Çä)
                if (cell.querySelector('.radius-i-input')) {
                    cell.classList.add('col-buckling');
                    continue;
                }

                // Êñ≠Èù¢ÈÅ∏Êäû„Éú„Çø„É≥
                if (cell.querySelector('.select-props-btn')) {
                    cell.classList.add('col-section');
                    continue;
                }

                // Êñ≠Èù¢ÂêçÁß∞ / Ëª∏ÊñπÂêë
                if (cell.querySelector('.section-name-cell') || cell.querySelector('.section-axis-cell')) {
                    cell.classList.add('col-section');
                    continue;
                }

                // Êé•ÂêàÊù°‰ª∂
                if (cell.querySelector('.conn-cell') || cell.querySelector('.conn-select')) {
                    cell.classList.add('col-conn');
                    continue;
                }
                
                // --- Âõ∫ÂÆö‰ΩçÁΩÆ„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ ---
                // E, F
                if (i === 3 || i === 4) {
                    cell.classList.add('col-material');
                    continue;
                }
                // I, A, Z
                if (i === 5 || i === 6 || i === 7) {
                    cell.classList.add('col-section');
                    continue;
                }

            } catch (e) {
                console.warn('Cell class assignment error', e);
            }
        }
    };

    /**
     * ÊùêÊñô„Çø„Ç§„ÉóÂ§âÊõ¥ÊôÇ„ÅÆÂº∑Â∫¶ÂÖ•ÂäõUI„ÇíË®≠ÂÆö
     * @param {HTMLTableRowElement} row - ÂØæË±°„ÅÆË°å
     */
    const setupMaterialTypeHandling = (row) => {
        const eSelect = row.cells[3].querySelector('select');
        const strengthCell = row.cells[4];
        
        const handleMaterialChange = () => {
            if (!eSelect || !eSelect.options || eSelect.selectedIndex < 0) {
                console.warn('ÈÉ®Êùê„ÅÆÊùêÊñôÈÅ∏ÊäûË¶ÅÁ¥†„ÅåÁÑ°Âäπ„Åß„Åô');
                return;
            }
            
            const selectedOption = eSelect.options[eSelect.selectedIndex];
            if (!selectedOption) {
                console.warn('ÈÉ®Êùê„ÅÆÊùêÊñôÈÅ∏Êäû„Ç™„Éó„Ç∑„Éß„É≥„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì');
                return;
            }
            
            let materialType = 'steel';
            const optionText = selectedOption.textContent || '';
            
            if (optionText.includes('Êú®Êùê')) materialType = 'wood';
            else if (optionText.includes('„Ç≥„É≥„ÇØ„É™„Éº„Éà')) materialType = 'concrete';
            else if (optionText.includes('„Çπ„ÉÜ„É≥„É¨„Çπ')) materialType = 'stainless';
            else if (optionText.includes('„Ç¢„É´„Éü„Éã„Ç¶„É†')) materialType = 'aluminum';
            
            // Êó¢Â≠ò„ÅÆÂÄ§„Çí‰øùÊåÅ„Åô„Çã„Åü„ÇÅ„ÅÆÂá¶ÁêÜ
            let currentValue = undefined;
            let forceCustom = false;
            
            const typeMap = {
                'steel': 'F-value',
                'wood': 'wood-type',
                'stainless': 'F-stainless',
                'aluminum': 'F-aluminum'
            };
            const expectedType = typeMap[materialType];
            const existingDiv = strengthCell.firstElementChild;
            
            // Êó¢Â≠ò„ÅÆË¶ÅÁ¥†„ÅåÂêå„ÅòÊùêÊñô„Çø„Ç§„Éó„Å™„ÇâÂÄ§„ÇíÂºï„ÅçÁ∂ô„Åê
            if (existingDiv && existingDiv.dataset.strengthType === expectedType) {
                const existingSelect = existingDiv.querySelector('select');
                
                if (materialType === 'wood') {
                     if (existingSelect) {
                         if (existingSelect.value === 'custom') {
                             const inputs = existingDiv.querySelectorAll('input');
                             if (inputs.length >= 4) {
                                 currentValue = {
                                     baseStrengths: {
                                         ft: parseFloat(inputs[0].value),
                                         fc: parseFloat(inputs[1].value),
                                         fb: parseFloat(inputs[2].value),
                                         fs: parseFloat(inputs[3].value)
                                     }
                                 };
                             }
                         } else {
                             currentValue = existingSelect.value;
                         }
                     }
                } else {
                    // Steel, Stainless, Aluminum
                    const existingInput = existingDiv.querySelector('input');
                    if (existingInput) currentValue = existingInput.value;
                    if (existingSelect && existingSelect.value === 'custom') forceCustom = true;
                }
            }

            strengthCell.innerHTML = '';
            strengthCell.appendChild(createStrengthInputHTML(materialType, `member-strength-${row.rowIndex}`, currentValue, forceCustom));
            
            // Ëá™ÈáçËÄÉÊÖÆ„Åå„Ç™„É≥„ÅÆÂ†¥Âêà„ÄÅÂØÜÂ∫¶„ÇÇÊõ¥Êñ∞
            if (elements.considerSelfWeightCheckbox && elements.considerSelfWeightCheckbox.checked) {
                const densityCell = row.querySelector('.density-cell');
                if (densityCell) {
                    const eInput = row.cells[3].querySelector('input[type="number"]');
                    const eValue = eSelect.value === 'custom' ? eInput.value : eSelect.value;
                    const newDensity = MATERIAL_DENSITY_DATA[eValue] || MATERIAL_DENSITY_DATA['custom'];
                    
                    // ÂØÜÂ∫¶„Çª„É´„ÅÆHTML„ÇíÊõ¥Êñ∞
                    densityCell.innerHTML = createDensityInputHTML(`member-density-${row.rowIndex}`, newDensity);
                }
            }
            
            // Êú®ÊùêÈÅ∏ÊäûÊôÇ„ÅÆÂºæÊÄß‰øÇÊï∞ÈÄ£ÂãïÂá¶ÁêÜ
            if (materialType === 'wood') {
                setTimeout(() => setupWoodElasticModulusSync(row, strengthCell), 100);
            }
        };
        
        eSelect.addEventListener('change', handleMaterialChange);
        
        // ÂàùÊúüÂåñÂá¶ÁêÜ
        try {
            handleMaterialChange();
        } catch (error) {
            console.warn('ÊùêÊñô„Çø„Ç§„ÉóÂàùÊúüÂåñÂ§±Êïó:', error);
        }
    };

    /**
     * Êú®ÊùêÈÅ∏ÊäûÊôÇ„ÅÆÂºæÊÄß‰øÇÊï∞Ëá™ÂãïÊõ¥Êñ∞„ÇíË®≠ÂÆö
     * @param {HTMLTableRowElement} row - ÂØæË±°„ÅÆË°å
     * @param {HTMLTableCellElement} strengthCell - Âº∑Â∫¶ÂÖ•Âäõ„Çª„É´
     */
    const setupWoodElasticModulusSync = (row, strengthCell) => {
        const strengthSelect = strengthCell.querySelector('select');
        const eInput = row.cells[3].querySelector('input');
        
        if (!strengthSelect || !eInput) return;
        
        const woodElasticModuli = {
            'Akamatsu_Group': 8000, 'Kuromatsu_Group': 8000, 'Beimatsu_Group': 8000,
            'Karamatsu_Group': 9000, 'Hiba_Group': 9000, 'Hinoki_Group': 9000, 'Beihi_Group': 9000,
            'Tuga_Group': 8000, 'Beituga_Group': 8000,
            'Momi_Group': 7000, 'Ezomatsu_Group': 7000, 'Todomatsu_Group': 7000, 'Benimatsu_Group': 7000,
            'Sugi_Group': 7000, 'Beisugi_Group': 7000, 'Spruce_Group': 7000,
            'Kashi_Group': 10000,
            'Kuri_Group': 8000, 'Nara_Group': 8000, 'Buna_Group': 8000, 'Keyaki_Group': 8000
        };
        
        const updateElasticModulus = () => {
            const woodType = strengthSelect.value;
            if (woodElasticModuli[woodType]) {
                eInput.value = woodElasticModuli[woodType];
            }
        };
        
        strengthSelect.addEventListener('change', updateElasticModulus);
        updateElasticModulus(); // ÂàùÊúüÂÄ§Ë®≠ÂÆö
    };

    /**
     * Ë°åÂâäÈô§„Éú„Çø„É≥„ÅÆ„Ç§„Éô„É≥„Éà„É™„Çπ„Éä„Éº„ÇíË®≠ÂÆö
     * @param {HTMLTableRowElement} row - ÂØæË±°„ÅÆË°å
     * @param {HTMLTableSectionElement} tableBody - ÊâÄÂ±û„Åô„Çã„ÉÜ„Éº„Éñ„É´„Éú„Éá„Ç£
     */
    const setupRowDeleteHandler = (row, tableBody) => {
        const deleteBtn = row.querySelector('.delete-row-btn');
        
        if (tableBody === elements.membersTable) {
            deleteBtn.onclick = () => handleMemberRowDeletion(row);
        } else if (tableBody === elements.nodesTable) {
            deleteBtn.onclick = () => handleNodeRowDeletion(row);
        } else {
            deleteBtn.onclick = () => handleGenericRowDeletion(row);
        }
    };

    /**
     * ÈÉ®ÊùêË°åÂâäÈô§„ÅÆÂá¶ÁêÜ
     * @param {HTMLTableRowElement} row - ÂâäÈô§ÂØæË±°„ÅÆË°å
     */
    const handleMemberRowDeletion = (row) => {
        pushState();
        const deletedMemberNumber = row.rowIndex;
        
        // Èñ¢ÈÄ£„Åô„ÇãÈÉ®ÊùêËç∑Èáç„ÇíÂâäÈô§
        const loadsToDelete = Array.from(elements.memberLoadsTable.rows)
            .filter(r => parseInt(r.cells[0].querySelector('input').value) - 1 === deletedMemberNumber);
        loadsToDelete.forEach(r => r.remove());
        
        // ÂæåÁ∂ö„ÅÆÈÉ®ÊùêËç∑Èáç„ÅÆÁï™Âè∑„ÇíË™øÊï¥
        Array.from(elements.memberLoadsTable.rows).forEach(r => {
            const input = r.cells[0].querySelector('input');
            const current = parseInt(input.value);
            if (current - 1 > deletedMemberNumber) {
                input.value = current - 1;
            }
        });
        
        row.remove();
        renumberTables();
        if (typeof drawOnCanvas === 'function') {
            drawOnCanvas();
        }
    };

    /**
     * ÁØÄÁÇπË°åÂâäÈô§„ÅÆÂá¶ÁêÜ
     * @param {HTMLTableRowElement} row - ÂâäÈô§ÂØæË±°„ÅÆË°å
     */
    const handleNodeRowDeletion = (row) => {
        pushState();
        const deletedNodeIndex = row.rowIndex - 1;
        const deletedNodeNumber = deletedNodeIndex + 1;
        
        const membersToDelete = [];
        const membersToUpdate = [];
        
        // Èñ¢ÈÄ£„Åô„ÇãÈÉ®Êùê„ÅÆÂá¶ÁêÜ
        Array.from(elements.membersTable.rows).forEach(r => {
            const i = r.cells[1].querySelector('input');
            const j = r.cells[2].querySelector('input');
            const c_i = parseInt(i.value);
            const c_j = parseInt(j.value);
            
            if (c_i === deletedNodeNumber || c_j === deletedNodeNumber) {
                membersToDelete.push(r);
            } else {
                if (c_i > deletedNodeNumber) {
                    membersToUpdate.push({ input: i, newValue: c_i - 1 });
                }
                if (c_j > deletedNodeNumber) {
                    membersToUpdate.push({ input: j, newValue: c_j - 1 });
                }
            }
        });
        
        // Èñ¢ÈÄ£„Åô„ÇãÁØÄÁÇπËç∑Èáç„ÅÆÂá¶ÁêÜ
        const nodeLoadsToDelete = [];
        const nodeLoadsToUpdate = [];
        
        Array.from(elements.nodeLoadsTable.rows).forEach(r => {
            const n = r.cells[0].querySelector('input');
            const current = parseInt(n.value);
            
            if (current === deletedNodeNumber) {
                nodeLoadsToDelete.push(r);
            } else if (current > deletedNodeNumber) {
                nodeLoadsToUpdate.push({ input: n, newValue: current - 1 });
            }
        });
        
        // Èñ¢ÈÄ£„Åô„ÇãÈÉ®ÊùêËç∑Èáç„ÅÆÂá¶ÁêÜ
        const memberLoadsToDelete = [];
        const memberLoadsToUpdate = [];
        
        // ÂâäÈô§„Åï„Çå„ÇãÈÉ®Êùê„ÅÆÁï™Âè∑„ÇíÂèñÂæó
        const deletedMemberNumbers = membersToDelete.map(r => {
            const memberIndex = Array.from(elements.membersTable.rows).indexOf(r);
            return memberIndex + 1; // 1„Éô„Éº„Çπ„ÅÆÁï™Âè∑
        });
        
        Array.from(elements.memberLoadsTable.rows).forEach(r => {
            const m = r.cells[0].querySelector('input');
            const current = parseInt(m.value);
            
            if (deletedMemberNumbers.includes(current)) {
                memberLoadsToDelete.push(r);
            } else {
                // ÂâäÈô§„Åï„Çå„ÇãÈÉ®Êùê„Çà„ÇäÂæå„ÅÆÁï™Âè∑„ÇíÊõ¥Êñ∞
                const adjustment = deletedMemberNumbers.filter(num => num < current).length;
                if (adjustment > 0) {
                    memberLoadsToUpdate.push({ input: m, newValue: current - adjustment });
                }
            }
        });
        
        // ÂâäÈô§„Å®Êõ¥Êñ∞„ÇíÂÆüË°å
        membersToDelete.forEach(r => r.remove());
        nodeLoadsToDelete.forEach(r => r.remove());
        memberLoadsToDelete.forEach(r => r.remove());
        membersToUpdate.forEach(item => item.input.value = item.newValue);
        nodeLoadsToUpdate.forEach(item => item.input.value = item.newValue);
        memberLoadsToUpdate.forEach(item => item.input.value = item.newValue);
        
        row.remove();
        renumberTables();
        if (typeof drawOnCanvas === 'function') {
            drawOnCanvas();
        }
    };

    /**
     * ‰∏ÄËà¨ÁöÑ„Å™Ë°åÂâäÈô§„ÅÆÂá¶ÁêÜ
     * @param {HTMLTableRowElement} row - ÂâäÈô§ÂØæË±°„ÅÆË°å
     */
    const handleGenericRowDeletion = (row) => {
        pushState();
        row.remove();
        renumberTables();
        if (typeof drawOnCanvas === 'function') {
            drawOnCanvas();
        }
    };

    /**
     * Ë°å„ÅÆÂÖ•Âäõ„Éï„Ç£„Éº„É´„Éâ„Å´„Ç§„Éô„É≥„Éà„É™„Çπ„Éä„Éº„ÇíË®≠ÂÆö
     * @param {HTMLTableRowElement} row - ÂØæË±°„ÅÆË°å
     * @param {HTMLTableSectionElement} tableBody - ÊâÄÂ±û„Åô„Çã„ÉÜ„Éº„Éñ„É´„Éú„Éá„Ç£
     */
    const setupRowInputListeners = (row, tableBody) => {
        row.querySelectorAll('input, select').forEach(element => {
            // Ë®≠ÂÆöÁ∑®ÈõÜÈñãÂßãÊôÇ„Å´Áä∂ÊÖã„Çí‰øùÂ≠ò
            element.addEventListener('focus', pushState);
            // ÂÖ•Âäõ‰∏≠„ÅØ„Éá„Éê„Ç¶„É≥„Çπ„Åó„Å¶Â±•Ê≠¥„ÇíËøΩÂä†
            element.addEventListener('input', () => { if (typeof debouncedPushState === 'function') debouncedPushState(); });
            // ÂÄ§Á¢∫ÂÆöÊôÇ„ÅØÂç≥ÊôÇ‰øùÂ≠ò & ÊèèÁîªÊõ¥Êñ∞
            element.addEventListener('change', () => {
                pushState();
                if (typeof drawOnCanvas === 'function') drawOnCanvas();
            });
        });
        
        // ÂÖ•ÂäõÊ§úË®º„ÅÆË®≠ÂÆö
        setupTableInputValidation(row, tableBody);
    };

    // ‚ñº‚ñº‚ñº ËøΩÂä†„Éª‰øÆÊ≠£: ÈÉ®Êùê„ÉÜ„Éº„Éñ„É´„ÅÆÂàóË°®Á§∫„ÇíÊõ¥Êñ∞„ÉªÂêåÊúü„Åô„ÇãÈñ¢Êï∞ ‚ñº‚ñº‚ñº
    const updateMemberTableVisibility = () => {
        const table = document.getElementById('members-table');
        if (!table) return;

        // 1. Ë°®Á§∫Âà∂Âæ°„Éà„Ç∞„É´„ÅÆÁä∂ÊÖã„ÇíÂèñÂæó
        const toggles = document.querySelectorAll('.column-toggles .col-toggle');
        const visibilityState = {};
        toggles.forEach(toggle => {
            const target = toggle.getAttribute('data-target');
            if (target) visibilityState[target] = toggle.checked;
        });

        // 2. Ëá™ÈáçËÄÉÊÖÆ„ÉÅ„Çß„ÉÉ„ÇØ„Éú„ÉÉ„ÇØ„Çπ„ÅÆÁä∂ÊÖã„ÇíÂèñÂæó
        const isDensityEnabled = document.getElementById('consider-self-weight-checkbox')?.checked;

        // Ë¶ÅÁ¥†„ÇíË°®Á§∫„Åô„Åπ„Åç„ÅãÂà§ÂÆö„Åô„ÇãÈñ¢Êï∞
        const shouldShow = (element) => {
            // ÂØÜÂ∫¶ÂàóÔºàdensity-columnÔºâ„ÅÆÁâπ‰æãÂà∂Âæ°
            // Ëá™ÈáçËÄÉÊÖÆ„ÅåOFF„Å™„Çâ„ÄÅ‰ªñ„ÅÆÊù°‰ª∂„Å´Èñ¢„Çè„Çâ„ÅöÈùûË°®Á§∫
            if (element.classList.contains('density-column') && !isDensityEnabled) {
                return false;
            }

            // „ÇØ„É©„Çπ„Å´Âü∫„Å•„ÅèË°®Á§∫Âà∂Âæ°Ôºà„Éà„Ç∞„É´Ôºâ
            // Ë¶ÅÁ¥†„ÅåÁâπÂÆö„ÅÆ„ÇØ„É©„ÇπÔºàcol-material„Å™„Å©Ôºâ„ÇíÊåÅ„Å£„Å¶„ÅÑ„Å¶„ÄÅ„Åù„ÅÆ„Éà„Ç∞„É´„ÅåOFF„Å™„ÇâÈùûË°®Á§∫
            for (const [cls, isVisible] of Object.entries(visibilityState)) {
                if (element.classList.contains(cls) && !isVisible) {
                    return false; 
                }
            }

            return true; // Èö†„ÅôÁêÜÁî±„Åå„Å™„Åë„Çå„Å∞Ë°®Á§∫
        };

        // „Éò„ÉÉ„ÉÄ„Éº„ÅÆË°®Á§∫ÂàáÊõø
        const headers = table.querySelectorAll('thead th');
        headers.forEach(th => {
            th.style.display = shouldShow(th) ? '' : 'none';
        });

        // „Éú„Éá„Ç£„ÅÆ„Çª„É´„ÅÆË°®Á§∫ÂàáÊõø
        const rows = table.querySelectorAll('tbody tr');
        rows.forEach(row => {
            Array.from(row.cells).forEach(cell => {
                cell.style.display = shouldShow(cell) ? '' : 'none';
            });
        });
    };
    // ‚ñ≤‚ñ≤‚ñ≤ ËøΩÂä†ÁµÇ‰∫Ü ‚ñ≤‚ñ≤‚ñ≤

    // Minimal utils shim: provides executeWithErrorHandling and showMessage used by the app.
    // This restores runtime behavior when the original utils module is missing.
    const utils = window.utils || (window.utils = {
        executeWithErrorHandling: (fn, meta = {}, userMessage = 'Âá¶ÁêÜ‰∏≠„Å´„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü') => {
            try {
                return fn();
            } catch (err) {
                console.error('utils.executeWithErrorHandling caught error', { meta, err });
                try { utils.showMessage(`${userMessage}${err && err.message ? ': ' + err.message : ''}`, 'error', 4000); } catch (e) { console.error('utils.showMessage failed', e); }
                return null;
            }
        },
        showMessage: (text, type = 'info', timeout = 3000) => {
            try {
                let toast = document.getElementById('fa-toast-message');
                if (!toast) {
                    toast = document.createElement('div');
                    toast.id = 'fa-toast-message';
                    toast.style.position = 'fixed';
                    toast.style.right = '20px';
                    toast.style.top = '20px';
                    toast.style.zIndex = 100000;
                    toast.style.padding = '10px 14px';
                    toast.style.borderRadius = '6px';
                    toast.style.color = '#fff';
                    toast.style.fontFamily = 'sans-serif';
                    toast.style.boxShadow = '0 6px 18px rgba(0,0,0,0.25)';
                    document.body.appendChild(toast);
                }
                toast.textContent = text;
                toast.style.background = (type === 'error') ? '#d32f2f' : (type === 'warning' ? '#ff9800' : '#333');
                toast.style.display = 'block';
                clearTimeout(toast._timer);
                toast._timer = setTimeout(() => { try { toast.style.display = 'none'; } catch (e) {} }, timeout);
            } catch (e) {
                console.warn('utils.showMessage error', e);
            }
        }
    });

    const addRow = (tableBody, cells, saveHistory = true) => {
        return utils.executeWithErrorHandling(() => {
            if (saveHistory) pushState();
            
            const newRow = createTableRow(tableBody, cells);
            
            // „ÉÜ„Éº„Éñ„É´Âõ∫Êúâ„ÅÆË®≠ÂÆö
            if (tableBody === elements.membersTable) {
                setupMemberRowSpecialFeatures(newRow);
                setupMaterialTypeHandling(newRow);
                // Êñ≠Èù¢ÊâãÂãïÂ§âÊõ¥Áõ£Ë¶ñ„ÇíËøΩÂä†
                if (typeof setupSectionPropertyWatchers === 'function') setupSectionPropertyWatchers(newRow);
            }
            
            // „Ç§„Éô„É≥„Éà„É™„Çπ„Éä„Éº„ÅÆË®≠ÂÆö
            setupRowDeleteHandler(newRow, tableBody);
            setupRowInputListeners(newRow, tableBody);
            
            // ‚ñº‚ñº‚ñº ËøΩÂä†: Ë°åËøΩÂä†Áõ¥Âæå„Å´Ë°®Á§∫Áä∂ÊÖã„ÇíÂêåÊúü„Åï„Åõ„Çã ‚ñº‚ñº‚ñº
            if (tableBody === elements.membersTable) {
                try { updateMemberTableVisibility(); } catch (e) { console.warn('updateMemberTableVisibility failed', e); }
            }
            // ‚ñ≤‚ñ≤‚ñ≤ ËøΩÂä†ÁµÇ‰∫Ü ‚ñ≤‚ñ≤‚ñ≤

            if (saveHistory) {
                renumberTables();
                // „Éó„É™„Çª„ÉÉ„ÉàË™≠„ÅøËæº„Åø‰∏≠„ÅØÊèèÁîª„Çí„Çπ„Ç≠„ÉÉ„Éó
                if (typeof drawOnCanvas === 'function' && !window.isLoadingPreset) {
                    drawOnCanvas();
                }
            }
            
            return newRow;
        }, { tableType: tableBody.id, cellCount: cells.length }, '„ÉÜ„Éº„Éñ„É´Ë°å„ÅÆËøΩÂä†„Å´Â§±Êïó„Åó„Åæ„Åó„Åü');
    };

    const renumberTables = () => {
        elements.nodesTable.querySelectorAll('tr').forEach((row, i) => row.cells[0].textContent = i + 1);
        elements.membersTable.querySelectorAll('tr').forEach((row, i) => row.cells[0].textContent = i + 1);
    };
    window.addRow = addRow;
    window.renumberTables = renumberTables;
    
    const calculate = () => {
        try {
            elements.errorMessage.style.display = 'none';
            clearResults(); 
            const { nodes, members, nodeLoads, memberLoads, memberSelfWeights, nodeSelfWeights } = parseInputs();
            
            // Ëß£ÊûêÁî®„Å´Ëá™Èáç„ÅÆÁ≠âÂàÜÂ∏ÉËç∑Èáç„ÇíÈÉ®ÊùêËç∑Èáç„Å´ÂêàÊàê
            const combinedMemberLoads = [...memberLoads];
            if (memberSelfWeights && memberSelfWeights.length > 0) {
                memberSelfWeights.forEach(selfWeightLoad => {
                    if (selfWeightLoad.loadType === 'distributed') {
                        // Ê∞¥Âπ≥ÈÉ®Êùê„ÅÆËá™Èáç„ÇíÁ≠âÂàÜÂ∏ÉËç∑Èáç„Å®„Åó„Å¶ËøΩÂä†
                        const distributedLoad = {
                            memberIndex: selfWeightLoad.memberIndex,
                            w: selfWeightLoad.w // Êó¢„Å´ÈÅ©Âàá„Å™Á¨¶Âè∑ÔºàË≤†„ÅÆÂÄ§Ôºâ„ÅåË®≠ÂÆöÊ∏à„Åø
                        };
                        combinedMemberLoads.push(distributedLoad);
                        
                        // „Éá„Éê„ÉÉ„Ç∞„É≠„Ç∞ÔºàÊúÄÂàù„ÅÆ1Âõû„ÅÆ„ÅøÔºâ
                        if (!window.distributedLoadLogCount) window.distributedLoadLogCount = 0;
                        if (window.distributedLoadLogCount === 0) {
                            console.log(`Á≠âÂàÜÂ∏ÉËç∑ÈáçËøΩÂä†: ÈÉ®Êùê${selfWeightLoad.memberIndex + 1}, w=${distributedLoad.w.toFixed(4)}kN/m`);
                            window.distributedLoadLogCount = 1;
                        }
                    } else if (selfWeightLoad.loadType === 'mixed' && selfWeightLoad.w !== 0) {
                        // Êñú„ÇÅÈÉ®Êùê„ÅÆÂûÇÁõ¥ÊàêÂàÜ„ÇíÁ≠âÂàÜÂ∏ÉËç∑Èáç„Å®„Åó„Å¶ËøΩÂä†
                        const distributedLoad = {
                            memberIndex: selfWeightLoad.memberIndex,
                            w: selfWeightLoad.w // Êó¢„Å´ÈÅ©Âàá„Å™Á¨¶Âè∑ÔºàË≤†„ÅÆÂÄ§Ôºâ„ÅåË®≠ÂÆöÊ∏à„Åø
                        };
                        combinedMemberLoads.push(distributedLoad);
                        
                        // „Éá„Éê„ÉÉ„Ç∞„É≠„Ç∞
                        if (!window.distributedLoadLogCount) window.distributedLoadLogCount = 0;
                        if (window.distributedLoadLogCount < 3) {
                            console.log(`Ê∑∑ÂêàËç∑Èáç(ÂûÇÁõ¥ÊàêÂàÜ)ËøΩÂä†: ÈÉ®Êùê${selfWeightLoad.memberIndex + 1}, w=${distributedLoad.w.toFixed(4)}kN/m`);
                            window.distributedLoadLogCount++;
                        }
                    }
                });
            }
            
            // ÊßãÈÄ†Ëß£Êûê„Åß‰ΩøÁî®„Åï„Çå„ÇãÊúÄÁµÇÁöÑ„Å™ÈÉ®ÊùêËç∑Èáç„Çí„É≠„Ç∞Âá∫Âäõ
            if (!window.finalMemberLoadsLogCount) window.finalMemberLoadsLogCount = 0;
            if (window.finalMemberLoadsLogCount === 0) {
                console.log('=== ÊßãÈÄ†Ëß£Êûê„Åß‰ΩøÁî®„Åï„Çå„ÇãÈÉ®ÊùêËç∑Èáç ===');
                combinedMemberLoads.forEach((load, idx) => {
                    console.log(`ÈÉ®Êùê${load.memberIndex + 1}: w=${load.w.toFixed(4)}kN/m`);
                });
                console.log('================================');
                window.finalMemberLoadsLogCount = 1;
            }
            
            // Ëß£ÊûêÁî®„Å´Ëá™ÈáçËç∑Èáç„ÇíÁØÄÁÇπËç∑Èáç„Å´ÂêàÊàê
            const combinedNodeLoads = [...nodeLoads];
            if (nodeSelfWeights && nodeSelfWeights.length > 0) {
                nodeSelfWeights.forEach(selfWeightLoad => {
                    const existingLoad = combinedNodeLoads.find(load => load.nodeIndex === selfWeightLoad.nodeIndex);
                    if (existingLoad) {
                        // Êó¢Â≠òËç∑Èáç„Å´Ëá™Èáç„ÇíÂä†ÁÆó
                        existingLoad.px += selfWeightLoad.px;
                        existingLoad.py += selfWeightLoad.py;
                        existingLoad.mz += selfWeightLoad.mz;
                    } else {
                        // Êñ∞„Åó„ÅÑÁØÄÁÇπËç∑Èáç„Å®„Åó„Å¶ËøΩÂä†
                        combinedNodeLoads.push({
                            nodeIndex: selfWeightLoad.nodeIndex,
                            px: selfWeightLoad.px,
                            py: selfWeightLoad.py,
                            mz: selfWeightLoad.mz
                        });
                    }
                });
            }
            const dof = nodes.length * 3;
            let K_global = mat.create(dof, dof);
            let F_global = mat.create(dof, 1);
            const fixedEndForces = {};
            
            // Âêå‰∏ÄÈÉ®Êùê„ÅÆËç∑Èáç„ÇíÂêàË®à„Åó„Å¶ÈáçË§á„ÇíÈò≤„Åê
            const memberLoadMap = new Map();
            combinedMemberLoads.forEach(load => {
                const memberIndex = load.memberIndex;
                if (memberLoadMap.has(memberIndex)) {
                    // Êó¢Â≠òËç∑Èáç„Å´Âä†ÁÆó
                    memberLoadMap.get(memberIndex).w += load.w;
                } else {
                    // Êñ∞Ë¶èËøΩÂä†
                    memberLoadMap.set(memberIndex, { memberIndex, w: load.w });
                }
            });
            
            // „Éá„Éê„ÉÉ„Ç∞„É≠„Ç∞ÔºöÂêàË®à„Åï„Çå„ÅüËç∑Èáç„ÇíÁ¢∫Ë™ç
            if (!window.mergedLoadLogCount) window.mergedLoadLogCount = 0;
            if (window.mergedLoadLogCount === 0) {
                console.log('=== ÂêàË®à„Åï„Çå„ÅüÈÉ®ÊùêËç∑Èáç ===');
                memberLoadMap.forEach((load, memberIndex) => {
                    console.log(`ÈÉ®Êùê${memberIndex + 1}: w=${load.w.toFixed(4)}kN/m`);
                });
                console.log('========================');
                window.mergedLoadLogCount = 1;
            }
            
            // ÂêàË®à„Åï„Çå„ÅüËç∑Èáç„ÅßÂõ∫ÂÆöÁ´ØÂäõ„ÇíË®àÁÆó
            memberLoadMap.forEach(load => {
                const member = members[load.memberIndex];
                const L = member.length, w = load.w;
                let fel;
                const EI = member.E * member.I;

                if (!w || w === 0) {
                    fel = [0,0,0,0,0,0];
                } else {
                    // compute j-end displacement for fixed-fixed particular solution
                    // „Åõ„ÇìÊñ≠Â§âÂΩ¢„Éë„É©„É°„Éº„Çø„ÅÆË®àÁÆó (parseInputs„Å®ÂêåÊßò)
                    const nu = 0.3;
                    const G = member.E / (2 * (1 + nu));
                    const kappa = 1.5;
                    const As = member.A / kappa;
                    // Á≠âÂàÜÂ∏ÉËç∑Èáç„Å´„Çà„ÇãÁâáÊåÅ„Å°Ê¢ÅÂÖàÁ´Ø„ÅÆ„Åõ„ÇìÊñ≠„Åü„Çè„Åø: (w * L^2) / (2 * G * As)
                    const v_shear_load = (G > 0 && As > 0) ? ((w * L * L) / (2 * G * As)) : 0;

                    // Êõ≤„ÅíÂ§âÂΩ¢„Å´„Åõ„ÇìÊñ≠Â§âÂΩ¢„ÇíÂä†ÁÆó
                    const v_load = -(w * Math.pow(L, 4)) / (8 * EI) - v_shear_load;
                    const theta_load = -(w * Math.pow(L, 3)) / (6 * EI);
                    const D_load = [0, v_load, theta_load];

                    // K_jj is lower-right 3x3 of member.k_local
                    const K_jj = [
                        [member.k_local[3][3], member.k_local[3][4], member.k_local[3][5]],
                        [member.k_local[4][3], member.k_local[4][4], member.k_local[4][5]],
                        [member.k_local[5][3], member.k_local[5][4], member.k_local[5][5]]
                    ];

                    // P_j_fix = -K_jj * D_load
                    const P_j_fix = [0,0,0];
                    for (let r=0; r<3; r++) {
                        for (let c=0; c<3; c++) {
                            P_j_fix[r] -= (K_jj[r][c] || 0) * (D_load[c] || 0);
                        }
                    }

                    const N_j = P_j_fix[0];
                    const Q_j = P_j_fix[1];
                    const M_j = P_j_fix[2];

                    const N_i = -N_j;
                    const Q_i = (w * L) - Q_j;
                    const M_i = -M_j - Q_j * L - (w * L * L) / 2;

                    // Now prepare alternative correction approach based on simple-beam particular
                    const theta_i_free = -(w * Math.pow(L, 3)) / (24 * EI);
                    const theta_j_free =  (w * Math.pow(L, 3)) / (24 * EI);
                    const D_simple = [0,0,theta_i_free,0,0,theta_j_free];

                    const F_correction = [0,0,0,0,0,0];
                    for (let r=0; r<6; r++){
                        for (let c=0; c<6; c++){
                            F_correction[r] -= (member.k_local[r][c] || 0) * (D_simple[c] || 0);
                        }
                    }

                    const Q_simple = (w * L) / 2;

                    fel = [
                        F_correction[0],
                        Q_simple + F_correction[1],
                        F_correction[2],
                        F_correction[3],
                        Q_simple + F_correction[4],
                        F_correction[5]
                    ];
                }
                const T_t = mat.transpose(member.T), feg = mat.multiply(T_t, fel.map(v => [v])), i = member.i, j = member.j;
                F_global[i*3][0] -= feg[0][0]; F_global[i*3+1][0] -= feg[1][0]; F_global[i*3+2][0] -= feg[2][0];
                F_global[j*3][0] -= feg[3][0]; F_global[j*3+1][0] -= feg[4][0]; F_global[j*3+2][0] -= feg[5][0];
                fixedEndForces[load.memberIndex] = fel; // ÈÉ®Êùê„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ„ÅßÊ≠£„Åó„Åè‰øùÂ≠ò
            });
            combinedNodeLoads.forEach(load => { const i = load.nodeIndex * 3; F_global[i][0] += load.px; F_global[i+1][0] += load.py; F_global[i+2][0] += load.mz; });
            members.forEach((member) => {
                const {k_local, T, i, j} = member;
                const T_t = mat.transpose(T);
                if (!T_t) {
                    console.error('Matrix transpose failed for member:', member);
                    return;
                }
                const k_global_member = mat.multiply(mat.multiply(T_t, k_local), T);
                if (!k_global_member) {
                    console.error('Matrix multiply failed for member:', member);
                    return;
                }
                const indices = [i*3, i*3+1, i*3+2, j*3, j*3+1, j*3+2];
                for (let row = 0; row < 6; row++) for (let col = 0; col < 6; col++) K_global[indices[row]][indices[col]] += k_global_member[row][col];
            });

            // ÂêÑÈÉ®ÊùêÁ´Ø„ÅÆ„Éê„ÉçÂâõÊÄß„ÅØ parseInputs ÂÅ¥„Åß k_local „Å´ÁµÑ„ÅøËæº„Åæ„Çå„Å¶„ÅÑ„Çã„Åü„ÇÅ„ÄÅ
            // „Åì„Åì„Åß„ÅØ K_global „Å´Áõ¥Êé•Âä†ÁÆó„Åô„ÇãÂá¶ÁêÜ„ÅØË°å„ÅÑ„Åæ„Åõ„Çì„ÄÇ
            // ==========================================================
            // Âº∑Âà∂Â§â‰Ωç„ÇíËÄÉÊÖÆ„Åó„ÅüËß£Êûê„É≠„Ç∏„ÉÉ„ÇØÔºàËá™Áî±ÁØÄÁÇπ„ÇÇÂØæÂøúÔºâ
            // ==========================================================

            // 1. Áâ©ÁêÜÁöÑ„Å™ÊîØÁÇπ„Å´„Çà„ÇãÊãòÊùüËá™Áî±Â∫¶„ÇíÂÆöÁæ©
            const support_constraints = new Set();
            nodes.forEach((node, i) => {
                if (node.support === 'fixed' || node.support === 'fixed-x' || node.support === 'fixed-top') {
                    support_constraints.add(i * 3);
                    support_constraints.add(i * 3 + 1);
                    support_constraints.add(i * 3 + 2);
                } else if (node.support === 'pinned') {
                    support_constraints.add(i * 3);
                    support_constraints.add(i * 3 + 1);
                } else if (node.support === 'roller' || node.support === 'roller_y_fixed') {
                    // Ê∞¥Âπ≥Ëá™Áî± (XËá™Áî±, YÂõ∫ÂÆö)
                    support_constraints.add(i * 3 + 1);
                } else if (node.support === 'roller_x_fixed') {
                    // ÂûÇÁõ¥Ëá™Áî± (XÂõ∫ÂÆö, YËá™Áî±)
                    support_constraints.add(i * 3);
                }
            });

            // 2. Âº∑Âà∂Â§â‰Ωç„Åå‰∏é„Åà„Çâ„Çå„ÅüËá™Áî±Â∫¶„ÇíÁâπÂÆö„Åó„ÄÅÊó¢Áü•Â§â‰Ωç„Éô„ÇØ„Éà„É´D_s„Çí‰ΩúÊàê
            const D_s = mat.create(dof, 1);
            const forced_disp_constraints = new Set();
            nodes.forEach((node, i) => {
                if (Math.abs(node.dx_forced) > 1e-9) {
                    D_s[i * 3][0] = node.dx_forced;
                    forced_disp_constraints.add(i * 3);
                }
                if (Math.abs(node.dy_forced) > 1e-9) {
                    D_s[i * 3 + 1][0] = node.dy_forced;
                    forced_disp_constraints.add(i * 3 + 1);
                }
                if (Math.abs(node.r_forced) > 1e-9) {
                    D_s[i * 3 + 2][0] = node.r_forced;
                    forced_disp_constraints.add(i * 3 + 2);
                }
            });

            // 3. Áâ©ÁêÜÊîØÁÇπ„Å®Âº∑Âà∂Â§â‰Ωç„ÇíÂêàÁÆó„Åó„ÄÅÊúÄÁµÇÁöÑ„Å™„ÄåÊãòÊùüËá™Áî±Â∫¶„Äç„Å®„ÄåËá™Áî±Â∫¶„Äç„ÇíÊ±∫ÂÆö
            const constrained_indices_set = new Set([...support_constraints, ...forced_disp_constraints]);
            const constrained_indices = Array.from(constrained_indices_set).sort((a, b) => a - b);
            const free_indices = [...Array(dof).keys()].filter(i => !constrained_indices_set.has(i));

            if (free_indices.length === 0) { // ÂÆåÂÖ®ÊãòÊùü„É¢„Éá„É´„ÅÆÂ†¥Âêà
                const D_global = D_s;
                const K_D = mat.multiply(K_global, D_global);
                if (!K_D) {
                    console.error('Matrix multiply failed: K_global * D_global');
                    return;
                }
                const R = mat.subtract(K_D, F_global);
                const memberForces = members.map((member, idx) => {
                    const { T, k_local, i, j } = member;
                    const d_global_member = [ ...D_global.slice(i * 3, i * 3 + 3), ...D_global.slice(j * 3, j * 3 + 3) ];
                    const d_local = mat.multiply(T, d_global_member);
                    if (!d_local) {
                        console.error('Matrix multiply failed: T * d_global_member for member', idx);
                        return { N_i: 0, Q_i: 0, M_i: 0, N_j: 0, Q_j: 0, M_j: 0 };
                    }
                    let f_local = mat.multiply(k_local, d_local);
                    if (!f_local) {
                        console.error('Matrix multiply failed: k_local * d_local for member', idx);
                        return { N_i: 0, Q_i: 0, M_i: 0, N_j: 0, Q_j: 0, M_j: 0 };
                    }
                    if(fixedEndForces[idx]) { const fel_mat = fixedEndForces[idx].map(v=>[v]); f_local = mat.add(f_local, fel_mat); }
                    return { N_i: f_local[0][0], Q_i: f_local[1][0], M_i: f_local[2][0], N_j: f_local[3][0], Q_j: f_local[4][0], M_j: f_local[5][0] };
                });
                displayResults(D_global, R, memberForces, nodes, members, nodeLoads, memberLoads);
                return;
            }

            // 3. Ë°åÂàó„ÇíÂàÜÂâ≤ (K_ff, K_fs, K_sf, K_ss)
            const K_ff = free_indices.map(r => free_indices.map(c => K_global[r][c]));
            const K_fs = free_indices.map(r => constrained_indices.map(c => K_global[r][c]));
            const K_sf = constrained_indices.map(r => free_indices.map(c => K_global[r][c]));
            const K_ss = constrained_indices.map(r => constrained_indices.map(c => K_global[r][c]));

            // 4. „Éô„ÇØ„Éà„É´„ÇíÂàÜÂâ≤
            const F_f = free_indices.map(idx => [F_global[idx][0]]);
            const F_s = constrained_indices.map(idx => [F_global[idx][0]]);
            const D_s_constrained = constrained_indices.map(idx => [D_s[idx][0]]);

            // 5. Âº∑Âà∂Â§â‰Ωç„Å´„Çà„ÇãÁ≠â‰æ°ÁØÄÁÇπÂäõ„ÇíË®àÁÆó„Åó„ÄÅËç∑Èáç„Éô„ÇØ„Éà„É´„Çí‰øÆÊ≠£
            // F_modified = F_f - K_fs * D_s_constrained
            const Kfs_Ds = mat.multiply(K_fs, D_s_constrained);
            const F_modified = mat.subtract(F_f, Kfs_Ds);

            // 6. Êú™Áü•Â§â‰Ωç D_f „ÇíËß£„Åè
            const D_f = mat.solve(K_ff, F_modified);
            if (!D_f) {
                const instabilityAnalysis = analyzeInstability(K_global, free_indices, nodes, members);
                throw new Error(`Ëß£„ÇíÊ±Ç„ÇÅ„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åõ„Çì„Åß„Åó„Åü„ÄÇÊßãÈÄ†„Åå‰∏çÂÆâÂÆö„Åß„ÅÇ„Çã„Åã„ÄÅÊãòÊùü„Åå‰∏çÈÅ©Âàá„Åß„ÅÇ„ÇãÂèØËÉΩÊÄß„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ\n${instabilityAnalysis.message}`);
            }

            // 7. ÂÖ®‰ΩìÂ§â‰Ωç„Éô„ÇØ„Éà„É´ D_global „ÇíÁµÑ„ÅøÁ´ã„Å¶„Çã
            const D_global = mat.create(dof, 1);
            free_indices.forEach((val, i) => { D_global[val][0] = D_f[i][0]; });
            constrained_indices.forEach((val, i) => { D_global[val][0] = D_s_constrained[i][0]; });

            // 8. ÂèçÂäõ R „ÇíË®àÁÆó
            // R = K_sf * D_f + K_ss * D_s_constrained - F_s
            const Ksf_Df = mat.multiply(K_sf, D_f);
            const Kss_Ds = mat.multiply(K_ss, D_s_constrained);
            let R_constrained = mat.add(Ksf_Df, Kss_Ds);
            R_constrained = mat.subtract(R_constrained, F_s);

            const R = mat.create(dof, 1);
            constrained_indices.forEach((val, i) => { R[val][0] = R_constrained[i][0]; });

            // ==========================================================
            const memberForces = members.map((member, idx) => {
                const { T, k_local, i, j } = member;
                const d_global_member = [ ...D_global.slice(i * 3, i * 3 + 3), ...D_global.slice(j * 3, j * 3 + 3) ];
                const d_local = mat.multiply(T, d_global_member);
                let f_local = mat.multiply(k_local, d_local);
                if(fixedEndForces[idx]) { const fel_mat = fixedEndForces[idx].map(v=>[v]); f_local = mat.add(f_local, fel_mat); }
                return { N_i: f_local[0][0], Q_i: f_local[1][0], M_i: f_local[2][0], N_j: f_local[3][0], Q_j: f_local[4][0], M_j: f_local[5][0] };
            });
            
            // Ë®àÁÆóÊàêÂäüÊôÇ„ÅØ‰∏çÂÆâÂÆöÊÄß„Éè„Ç§„É©„Ç§„Éà„Çí„ÇØ„É™„Ç¢
            clearInstabilityHighlight();
            
            // Ëß£ÊûêÁµêÊûú„Çí„Ç∞„É≠„Éº„Éê„É´„Å´‰øùÂ≠òÔºàÂøúÂäõÂ∫¶„Ç≥„É≥„Çø„ÉºÂõ≥Áî®Ôºâ
            window.lastAnalysisResults = {
                displacements: D_global,
                reactions: R,
                forces: memberForces,
                nodes: nodes,
                members: members
            };
            
            // ÂêàË®à„Åï„Çå„ÅüÈÉ®ÊùêËç∑Èáç„ÇíÈÖçÂàó„Å´Â§âÊèõ
            const finalMemberLoads = Array.from(memberLoadMap.values());
            
            displayResults(D_global, R, memberForces, nodes, members, combinedNodeLoads, finalMemberLoads);
        } catch (error) {
            elements.errorMessage.textContent = `„Ç®„É©„Éº: ${error.message}`;
            elements.errorMessage.style.display = 'block';
            console.error(error);
            
            // ‰∏çÂÆâÂÆöË¶ÅÁ¥†„Çí„Éè„Ç§„É©„Ç§„ÉàË°®Á§∫
            if (typeof drawOnCanvas === 'function') {
                drawOnCanvas();
            }
        }
    };
    
    const parseInputs = () => {
        console.log('üîç parseInputs called - ÁèæÂú®„ÅÆÈÉ®Êùê„ÉÜ„Éº„Éñ„É´„ÅÆÁä∂ÊÖã„ÇíÁ¢∫Ë™ç');
        
        // „Éó„É™„Çª„ÉÉ„ÉàË™≠„ÅøËæº„Åø‰∏≠„ÅØÁ∞°ÊòìÁöÑ„Å™„ÉÄ„Éü„Éº„Éá„Éº„Çø„ÇíËøî„Åó„Å¶„Ç®„É©„Éº„ÇíÂõûÈÅø
        if (window.isLoadingPreset) {
            console.log('üîç parseInputs: „Éó„É™„Çª„ÉÉ„ÉàË™≠„ÅøËæº„Åø‰∏≠„ÅÆ„Åü„ÇÅ„ÉÄ„Éü„Éº„Éá„Éº„Çø„ÇíËøî„Åó„Åæ„Åô');
            return {
                nodes: [],
                members: [],
                nodeLoads: [],
                memberLoads: [],
                memberSelfWeights: [],
                nodeSelfWeights: []
            };
        }
        
        // „Ç®„É©„Éº„É≠„Ç∞„Çí„É™„Çª„ÉÉ„ÉàÔºàÊñ∞„Åó„ÅÑËß£Êûê„Çµ„Ç§„ÇØ„É´„ÅÆÈñãÂßãÊôÇÔºâ
        if (window.resetErrorLogs) {
            window.memberErrorLogged = {};
            window.cellCountErrorLogged = {};
            window.cellMissingErrorLogged = {};
            window.selfWeightLogCount = 0;
            window.resetErrorLogs = false;
        }
        
        const nodes = Array.from(elements.nodesTable.rows).map((row, i) => {
            // ÂÆâÂÖ®„Å™ÂÄ§ÂèñÂæó
            const xInput = row.cells[1]?.querySelector('input');
            const yInput = row.cells[2]?.querySelector('input');
            const supportSelect = row.cells[3]?.querySelector('select');

            if (!xInput || !yInput || !supportSelect) {
                throw new Error(`ÁØÄÁÇπ ${i + 1}: ÂÖ•Âäõ„Éï„Ç£„Éº„É´„Éâ„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì`);
            }

            // Âº∑Âà∂Â§â‰Ωç„ÅÆË™≠„ÅøÂèñ„Çä„ÇíËøΩÂä†
            const dx_forced_mm = parseFloat(row.cells[4]?.querySelector('input')?.value) || 0;
            const dy_forced_mm = parseFloat(row.cells[5]?.querySelector('input')?.value) || 0;
            const r_forced_rad = parseFloat(row.cells[6]?.querySelector('input')?.value) || 0;

            return {
                id: i + 1,
                x: parseFloat(xInput.value),
                y: parseFloat(yInput.value),
                support: supportSelect.value,
                // Âº∑Âà∂Â§â‰Ωç„ÇíÂü∫Êú¨Âçò‰Ωç(m, rad)„ÅßÊ†ºÁ¥ç
                dx_forced: dx_forced_mm / 1000,
                dy_forced: dy_forced_mm / 1000,
                r_forced: r_forced_rad
            };
        });
        const members = Array.from(elements.membersTable.rows).map((row, index) => {
            // ÂÆâÂÖ®„Å™ÁØÄÁÇπÁï™Âè∑ÂèñÂæó
            const iNodeInput = row.cells[1]?.querySelector('input');
            const jNodeInput = row.cells[2]?.querySelector('input');
            
            if (!iNodeInput || !jNodeInput) {
                throw new Error(`ÈÉ®Êùê ${index + 1}: ÁØÄÁÇπÁï™Âè∑„ÅÆÂÖ•Âäõ„Éï„Ç£„Éº„É´„Éâ„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì`);
            }
            
            const i = parseInt(iNodeInput.value) - 1;
            const j = parseInt(jNodeInput.value) - 1;
            
            // ÂºæÊÄß‰øÇÊï∞„ÅÆÂèñÂæó„ÇÇÂÆâÂÖ®„Å´
            const e_select = row.cells[3]?.querySelector('select');
            const e_input = row.cells[3]?.querySelector('input[type="number"]');
            
            if (!e_select) {
                throw new Error(`ÈÉ®Êùê ${index + 1}: ÂºæÊÄß‰øÇÊï∞„ÅÆÈÅ∏Êäû„Éï„Ç£„Éº„É´„Éâ„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì`);
            }
            
            let E = (e_select.value === 'custom' ? parseFloat(e_input?.value || 0) : parseFloat(e_select.value)) * 1000;
            
            // ÂºæÊÄß‰øÇÊï∞ÈÅ∏ÊäûÊ¨Ñ„Åã„ÇâÊùêÊñôÂêç„ÇíÁõ¥Êé•ÂèñÂæó
            const getMaterialNameFromSelect = (selectElement) => {
                if (!selectElement || !selectElement.options || selectElement.selectedIndex < 0) {
                    console.warn('ÈÉ®Êùê„ÅÆÊùêÊñôÈÅ∏ÊäûË¶ÅÁ¥†„ÅåÁÑ°Âäπ„Åß„Åô');
                    return '‰∏çÊòé„Å™ÊùêÊñô';
                }
                
                const selectedOption = selectElement.options[selectElement.selectedIndex];
                if (!selectedOption) {
                    console.warn('ÈÉ®Êùê„ÅÆÊùêÊñôÈÅ∏Êäû„Ç™„Éó„Ç∑„Éß„É≥„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì');
                    return '‰∏çÊòé„Å™ÊùêÊñô';
                }
                
                if (selectedOption.value === 'custom') {
                    const eValue = parseFloat(e_input?.value || 0);
                    return `‰ªªÊÑèÊùêÊñô(E=${(eValue/1000).toLocaleString()}GPa)`;
                }
                return selectedOption.textContent || '‰∏çÊòé„Å™ÊùêÊñô'; // "„Çπ„ÉÅ„Éº„É´", "„Çπ„ÉÜ„É≥„É¨„Çπ", "„Ç¢„É´„Éü„Éã„Ç¶„É†", "Êú®Êùê" „Å™„Å©
            };
            const material = getMaterialNameFromSelect(e_select);
            
            const strengthInputContainer = row.cells[4].firstElementChild;
            if (!strengthInputContainer) {
                console.warn(`Ë°å ${index} „ÅÆÂº∑Â∫¶ÂÖ•Âäõ„Ç≥„É≥„ÉÜ„Éä„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì`);
                const fallbackAInput = row.cells[6]?.querySelector('.section-A-input');
                const fallbackAFactorInput = row.cells[6]?.querySelector('.section-A-factor');
                const v = parseFloat(fallbackAInput?.value);
                const f = parseFloat(fallbackAFactorInput?.value);
                const factor = Number.isFinite(f) ? f : 1.0;
                const A_reduced_cm2 = (Number.isFinite(v) ? v : 0) * factor;
                return { i, j, E, A: A_reduced_cm2, material, strengthProps: { type: 'unknown' } };
            }
            const strengthType = strengthInputContainer.dataset.strengthType;
            let strengthProps = { type: strengthType };

            if (strengthType === 'wood-type') {
                    const presetSelect = strengthInputContainer.querySelector('select');
                    if (presetSelect) {
                        strengthProps.preset = presetSelect.value;
                        if (presetSelect.value === 'custom') {
                            // ‰ªªÊÑèÂÖ•Âäõ„ÅÆÂ†¥Âêà„ÄÅÂü∫Ê∫ñÂº∑Â∫¶„Å®„Åó„Å¶ÂÄ§„ÇíË™≠„ÅøÂèñ„Çã
                            const ftInput = strengthInputContainer.querySelector('input[id*="-ft"]');
                            const fcInput = strengthInputContainer.querySelector('input[id*="-fc"]');
                            const fbInput = strengthInputContainer.querySelector('input[id*="-fb"]');
                            const fsInput = strengthInputContainer.querySelector('input[id*="-fs"]');
                            
                            if (ftInput && fcInput && fbInput && fsInput) {
                                strengthProps.baseStrengths = {
                                    ft: parseFloat(ftInput.value),
                                    fc: parseFloat(fcInput.value),
                                    fb: parseFloat(fbInput.value),
                                    fs: parseFloat(fsInput.value)
                                };
                            }
                        }
                    }
                }
            else { // Steel, Stainless, Aluminum
                const strengthInput = strengthInputContainer.querySelector('input');
                if (strengthInput) {
                    strengthProps.value = parseFloat(strengthInput.value);
                }
            }

            // ÂÆâÂÖ®„Å™ÂÄ§ÂèñÂæóÔºàÊñ≠Èù¢Ë´∏ÈáèÔºâ
            const iMomentInput = row.cells[5]?.querySelector('.section-I-input');
            const iMomentFactorInput = row.cells[5]?.querySelector('.section-I-factor');
            const aAreaInput = row.cells[6]?.querySelector('.section-A-input');
            const aAreaFactorInput = row.cells[6]?.querySelector('.section-A-factor');
            const zSectionInput = row.cells[7]?.querySelector('.section-Z-input');
            const zSectionFactorInput = row.cells[7]?.querySelector('.section-Z-factor');
            
            if (!iMomentInput || !aAreaInput || !zSectionInput) {
                throw new Error(`ÈÉ®Êùê ${index + 1}: Êñ≠Èù¢Ë´∏Èáè„ÅÆÂÖ•Âäõ„Éï„Ç£„Éº„É´„Éâ„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì`);
            }
            
            const safeFactor = (el) => {
                const v = parseFloat(el?.value);
                return Number.isFinite(v) ? v : 1.0;
            };

            const I = (parseFloat(iMomentInput.value) * safeFactor(iMomentFactorInput)) * 1e-8;
            const A = (parseFloat(aAreaInput.value) * safeFactor(aAreaFactorInput)) * 1e-4;
            const Z = (parseFloat(zSectionInput.value) * safeFactor(zSectionFactorInput)) * 1e-6;

            // Â∫ßÂ±à‰øÇÊï∞ K „ÅÆÂèñÂæóÔºà„ÇØ„É©„Çπ„Çª„É¨„ÇØ„Çø„Çí‰Ωø„Å£„Å¶ÂÆâÂÖ®„Å´ÂèñÂæóÔºâ
            let bucklingK = null;
            try {
                const kEl = row.querySelector('.buckling-k-input');
                if (kEl && kEl.value !== '') {
                    const parsedK = parseFloat(kEl.value);
                    if (!isNaN(parsedK)) bucklingK = parsedK;
                }
            } catch (e) {
                console.warn('Â∫ßÂ±à‰øÇÊï∞ K „ÅÆÂèñÂæó„Ç®„É©„Éº:', e);
                bucklingK = null;
            }
            
            // ÂØÜÂ∫¶Âàó„ÅåÂ≠òÂú®„Åô„Çã„Åã„Å©„ÅÜ„Åã„Åß„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ„ÇíË™øÊï¥Ôºà„Çà„ÇäÂÆâÂÖ®„Å™ÊñπÊ≥ïÔºâ
            const cellCount = row.cells.length;
            let hasDensityColumn = false;
            
            // „Çª„É´Êï∞„ÅßÂà§ÂÆöÔºàÂØÜÂ∫¶Âàó„Åå„ÅÇ„ÇãÂ†¥Âêà„ÅØ13Âàó„ÄÅ„Å™„ÅÑÂ†¥Âêà„ÅØ12ÂàóÔºâ
            if (cellCount >= 13) {
                hasDensityColumn = true;
            } else if (cellCount >= 12) {
                hasDensityColumn = false;
            } else {
                if (!window.cellCountErrorLogged || !window.cellCountErrorLogged[index]) {
                    if (!window.cellCountErrorLogged) window.cellCountErrorLogged = {};
                    window.cellCountErrorLogged[index] = true;
                    console.warn(`ÈÉ®Êùê ${index + 1}: „Çª„É´Êï∞„Åå‰∏çË∂≥„Åó„Å¶„ÅÑ„Åæ„Åô (${cellCount})`);
                }
                // „Éá„Éï„Ç©„É´„Éà„ÅßÂØÜÂ∫¶Âàó„Å™„Åó„Å®‰ªÆÂÆö
                hasDensityColumn = false;
            }
            
            // ÂÆüÈöõ„ÅÆ„Çª„É´ÊßãÈÄ†„ÇíÂãïÁöÑ„Å´Ëß£Êûê„Åó„Å¶selectË¶ÅÁ¥†„ÇíÊé¢„Åô
            let iConnIndex = -1, jConnIndex = -1;
            
            // Âæå„Çç„Åã„Çâ2Áï™ÁõÆ„Å®3Áï™ÁõÆ„ÅÆ„Çª„É´„Çí„ÉÅ„Çß„ÉÉ„ÇØÔºàÂâäÈô§„Éú„Çø„É≥„ÇíÈô§„ÅèÔºâ
            // ÈÄöÂ∏∏„ÅÆÊßãÈÄ†: [..., ÂßãÁ´Øselect, ÁµÇÁ´Øselect, ÂâäÈô§„Éú„Çø„É≥] „Åæ„Åü„ÅØ [..., ÂßãÁ´Øselect, ÁµÇÁ´Øselect, Êñ≠Èù¢ÈÅ∏Êäû„Éú„Çø„É≥, ÂâäÈô§„Éú„Çø„É≥]
            const lastCellIndex = cellCount - 1; // ÂâäÈô§„Éú„Çø„É≥
            
            // ÊúÄÂæå„Åã„ÇâÈÄÜÈ†Ü„Å´selectË¶ÅÁ¥†„ÇíÊé¢„Åô
            let selectCount = 0;
            for (let i = lastCellIndex - 1; i >= 0; i--) {
                const cell = row.cells[i];
                if (cell && cell.querySelector('select')) {
                    selectCount++;
                    if (selectCount === 1) {
                        jConnIndex = i; // ÊúÄÂàù„Å´Ë¶ã„Å§„Åã„Å£„Åüselect„ÅØÁµÇÁ´ØÊé•Á∂ö
                    } else if (selectCount === 2) {
                        iConnIndex = i; // 2Áï™ÁõÆ„Å´Ë¶ã„Å§„Åã„Å£„Åüselect„ÅØÂßãÁ´ØÊé•Á∂ö
                        break;
                    }
                }
            }
            
            // selectË¶ÅÁ¥†„ÅåË¶ã„Å§„Åã„Çâ„Å™„ÅÑÂ†¥Âêà„ÅÆÂá¶ÁêÜ
            if (iConnIndex === -1 || jConnIndex === -1) {
                if (!window.cellMissingErrorLogged || !window.cellMissingErrorLogged[index]) {
                    if (!window.cellMissingErrorLogged) window.cellMissingErrorLogged = {};
                    window.cellMissingErrorLogged[index] = true;
                    console.warn(`ÈÉ®Êùê ${index + 1}: Êé•Á∂öÊù°‰ª∂„ÅÆselectË¶ÅÁ¥†„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì (cellCount: ${cellCount}, found selects: ${selectCount})`);
                }
                // „Éá„Éï„Ç©„É´„ÉàÂÄ§„ÇíË®≠ÂÆö„Åó„Å¶„Ç®„É©„Éº„ÇíÂõûÈÅø
                return {
                    i: parseInt(row.cells[1].querySelector('input').value) - 1,
                    j: parseInt(row.cells[2].querySelector('input').value) - 1,
                    E: parseFloat(eInput.value),
                    strengthProps: { Fy: parseFloat(fInput.value) },
                    I: I,
                    A: A,
                    Z: Z,
                    Zx: 0,
                    Zy: 0,
                    ix: Math.sqrt(I / A),
                    iy: Math.sqrt(I / A),
                    length: 0,
                    c: 1,
                    s: 0,
                    T: [[1,0,0,0,0,0],[0,1,0,0,0,0],[0,0,1,0,0,0],[0,0,0,1,0,0],[0,0,0,0,1,0],[0,0,0,0,0,1]],
                    i_conn: 'rigid',
                    j_conn: 'rigid',
                    k_local: [[1,0,0,0,0,0],[0,1,0,0,0,0],[0,0,1,0,0,0],[0,0,0,1,0,0],[0,0,0,0,1,0],[0,0,0,0,0,1]],
                    material: 'steel'
                };
            }
            
            // ÂÆâÂÖ®„Å™ÂÄ§ÂèñÂæóÔºànull„ÉÅ„Çß„ÉÉ„ÇØ‰ªò„ÅçÔºâ
            const iConnSelect = iConnIndex >= 0 ? row.cells[iConnIndex]?.querySelector('select') : null;
            const jConnSelect = jConnIndex >= 0 ? row.cells[jConnIndex]?.querySelector('select') : null;
            
            let i_conn, j_conn;
            if (!iConnSelect || !jConnSelect) {
                // „Ç®„É©„ÉºÁä∂Ê≥Å„ÅÆË©≥Á¥∞„É≠„Ç∞„Çí‰∏ÄÂ∫¶„Å†„ÅëÂá∫ÂäõÔºà„Éá„Éê„ÉÉ„Ç∞„ÅÆ„Åü„ÇÅ‰∏ÄÊôÇÁöÑ„Å´Âà∂ÈôêËß£Èô§Ôºâ
                if (!window.memberErrorLogged || !window.memberErrorLogged[index] || window.memberErrorLogged[index] < 2) {
                    if (!window.memberErrorLogged) window.memberErrorLogged = {};
                    window.memberErrorLogged[index] = (window.memberErrorLogged[index] || 0) + 1;
                    console.warn(`ÈÉ®Êùê ${index + 1}: Êé•Á∂öÊù°‰ª∂„ÅÆselectË¶ÅÁ¥†„Å´„Ç¢„ÇØ„Çª„Çπ„Åß„Åç„Åæ„Åõ„Çì`, {
                        cellCount: cellCount,
                        hasDensityColumn: hasDensityColumn,
                        iConnIndex: iConnIndex,
                        jConnIndex: jConnIndex,
                        hasIConnCell: iConnIndex >= 0 ? !!row.cells[iConnIndex] : false,
                        hasJConnCell: jConnIndex >= 0 ? !!row.cells[jConnIndex] : false,
                        hasIConnSelect: !!iConnSelect,
                        hasJConnSelect: !!jConnSelect,
                        selectCount: selectCount,
                        cellsWithSelects: Array.from(row.cells).map((cell, i) => ({
                            index: i,
                            hasSelect: !!cell.querySelector('select'),
                            innerHTML: cell.innerHTML.substring(0, 50) + '...'
                        })).filter(c => c.hasSelect)
                    });
                }
                // „Éá„Éï„Ç©„É´„ÉàÂÄ§„ÇíË®≠ÂÆö
                i_conn = iConnSelect?.value || 'rigid';
                j_conn = jConnSelect?.value || 'rigid';
            } else {
                i_conn = iConnSelect.value;
                j_conn = jConnSelect.value;
            }
            const Zx = parseFloat(row.dataset.zx) * 1e-6, Zy = parseFloat(row.dataset.zy) * 1e-6;

            // Ê®™Â∫ßÂ±àÁ≠â„Å´‰Ωø„ÅÜÊñ≠Èù¢ÁâπÊÄßÔºàÈãºÊùêDBÁî±Êù•ÊÉ≥ÂÆöÔºâ
            // dataset „ÅØÂü∫Êú¨ÁöÑ„Å´„ÄåcmÁ≥ª„Äç(Ix/Iy/J: cm^4, Iw: cm^6) „Çí‰øùÊåÅ„Åô„ÇãÂâçÊèê
            const Ix_m4 = (row.dataset.ixMom !== undefined && row.dataset.ixMom !== '') ? (parseFloat(row.dataset.ixMom) * 1e-8) : undefined; // m^4
            const Iy_m4 = (row.dataset.iyMom !== undefined && row.dataset.iyMom !== '') ? (parseFloat(row.dataset.iyMom) * 1e-8) : undefined; // m^4

            let J_m4 = undefined;
            let Iw_m6 = undefined;
            try {
                const jInput = row.querySelector('.section-J-input');
                const iwInput = row.querySelector('.section-Iw-input');
                if (jInput && String(jInput.value).trim() !== '') {
                    const v = parseFloat(jInput.value);
                    if (Number.isFinite(v)) {
                        J_m4 = v * 1e-8; // cm^4 -> m^4
                        row.dataset.j = jInput.value;
                    }
                }
                if (iwInput && String(iwInput.value).trim() !== '') {
                    const v = parseFloat(iwInput.value);
                    if (Number.isFinite(v)) {
                        Iw_m6 = v * 1e-12; // cm^6 -> m^6
                        row.dataset.iw = iwInput.value;
                    }
                }
            } catch (e) { /* ignore */ }

            if (J_m4 === undefined) {
                J_m4 = (row.dataset.j !== undefined && row.dataset.j !== '') ? (parseFloat(row.dataset.j) * 1e-8) : undefined; // m^4
            }
            if (Iw_m6 === undefined) {
                Iw_m6 = (row.dataset.iw !== undefined && row.dataset.iw !== '') ? (parseFloat(row.dataset.iw) * 1e-12) : undefined; // m^6
            }
            // Êñ≠Èù¢2Ê¨°ÂçäÂæÑ i „ÅÆÂèñ„ÇäÊâ±„ÅÑ: UI „ÅÆ .radius-i-input „ÇíÂÑ™ÂÖà„Åó„ÄÅ„Å™„Åë„Çå„Å∞ dataset „ÅÆ ix/iy„ÄÅ
            // „Åù„Çå„Åß„ÇÇ„Å™„Åë„Çå„Å∞ I/A „Åã„ÇâÊé®ÂÆö„Åô„Çã„ÄÇÂÜÖÈÉ®„Åß„ÅØ ix/iy „ÅØ cm Âçò‰Ωç„Åß‰∏ÄÊôÇ‰øùÊåÅ„Åó„ÄÅÂæå„Åß m „Å´Â§âÊèõ„Åô„Çã„ÄÇ
            let ix = parseFloat(row.dataset.ix); // cmÂçò‰Ωç
            let iy = parseFloat(row.dataset.iy); // cmÂçò‰Ωç
            let i_radius = null; // m Âçò‰Ωç

            // ÂÑ™ÂÖà: Á∑®ÈõÜÂèØËÉΩ„Å™ÂÖ•ÂäõÊ¨Ñ„Åã„ÇâÂèñÂæóÔºàcm -> m „Å´Â§âÊèõÔºâ
            try {
                const iRadInput = row.querySelector('.radius-i-input');
                const iRadFactorInput = row.querySelector('.section-i-factor');
                if (iRadInput && iRadInput.value !== '') {
                    const parsed = parseFloat(iRadInput.value);
                    const fRaw = parseFloat(iRadFactorInput?.value);
                    const factor = Number.isFinite(fRaw) ? fRaw : 1.0;
                    if (!isNaN(parsed)) {
                        const reducedCm = parsed * factor;
                        i_radius = reducedCm * 1e-2; // cm -> m
                        ix = reducedCm; // cm
                        iy = reducedCm; // cm
                    }
                }
            } catch (e) { /* ignore */ }

            // Ê¨°„Å´ dataset „ÅÆ ix/iy „ÇíÂèÇÁÖßÔºàcmÔºâ
            if (i_radius === null) {
                if (isNaN(ix) && !isNaN(parseFloat(row.dataset.ix))) ix = parseFloat(row.dataset.ix);
                if (isNaN(iy) && !isNaN(parseFloat(row.dataset.iy))) iy = parseFloat(row.dataset.iy);
                if (isNaN(ix) && isNaN(iy)) {
                    // Êé®ÂÆö: sqrt(I/A) „Çí m Âçò‰Ωç„ÅßÁÆóÂá∫„Åó cm „Å´Â§âÊèõ
                    if (A > 0) {
                        const est_cm = Math.sqrt(I / A) * 100;
                        ix = est_cm;
                        iy = est_cm;
                        i_radius = est_cm * 1e-2;
                    } else {
                        ix = 0; iy = 0; i_radius = 0;
                    }
                } else {
                    if (isNaN(ix)) ix = iy;
                    if (isNaN(iy)) iy = ix;
                    // i_radius „ÅØÂ∞è„Åï„ÅÑÊñπ„ÇíÊé°Áî®
                    i_radius = Math.min(ix, iy) * 1e-2;
                }
            }

            // cm -> m „Å´Â§âÊèõ„Åó„Å¶Ê†ºÁ¥çÔºàÊó¢Â≠ò„Ç≥„Éº„Éâ„Å®„ÅÆ‰∫íÊèõÊÄß„ÅÆ„Åü„ÇÅÔºâ
            ix = Number(ix) * 1e-2;
            iy = Number(iy) * 1e-2;
            if (isNaN(E) || isNaN(I) || isNaN(A) || isNaN(Z)) throw new Error(`ÈÉ®Êùê ${index + 1} „ÅÆÁâ©ÊÄßÂÄ§„ÅåÁÑ°Âäπ„Åß„Åô„ÄÇ`);
            if (i < 0 || j < 0 || i >= nodes.length || j >= nodes.length) throw new Error(`ÈÉ®Êùê ${index + 1} „ÅÆÁØÄÁÇπÁï™Âè∑„Åå‰∏çÊ≠£„Åß„Åô„ÄÇ`);
            const ni = nodes[i], nj = nodes[j];
            if (!ni || !nj) throw new Error(`ÈÉ®Êùê ${index + 1} „ÅÆÁØÄÁÇπ„Éá„Éº„Çø„ÅåÁÑ°Âäπ„Åß„Åô (i=${i}, j=${j})„ÄÇ`);
            const dx = nj.x - ni.x, dy = nj.y - ni.y, L = Math.sqrt(dx**2 + dy**2);
            if(L === 0) {
                console.warn(`‚ö†Ô∏è ÈÉ®Êùê ${index+1} „ÅÆÈï∑„Åï„Åå0„Åß„Åô„ÄÇ„Åì„ÅÆÈÉ®Êùê„Çí„Çπ„Ç≠„ÉÉ„Éó„Åó„Åæ„Åô„ÄÇ`);
                console.warn(`  ÂßãÁÇπÁØÄÁÇπ${i+1}: (${ni.x}, ${ni.y}), ÁµÇÁÇπÁØÄÁÇπ${j+1}: (${nj.x}, ${nj.y})`);
                return null; // „Åì„ÅÆÈÉ®Êùê„Çí„Çπ„Ç≠„ÉÉ„Éó
            }

            // --- „Éê„ÉçÂâõÊÄß„ÅÆË™≠„ÅøÂèñ„Çä ---
            // UIÂçò‰Ωç -> ÂÜÖÈÉ®Âçò‰Ωç„Å∏„ÅÆÂ§âÊèõ„ÇíË°å„ÅÜÔºàUI: kN/mm, kN¬∑mm/rad -> ÂÜÖÈÉ®: kN/m, kN¬∑m/radÔºâ
            const EPS_SPRING = 1e-9; // ÂÜÖÈÉ®Âçò‰Ωç(kN/m)„Åß„ÅÆÊúÄÂ∞èÂÄ§ÔºàÂæìÊù•„Çà„ÇäÂ∞è„Åï„ÇÅÔºâ
            const readSpringFromCell = (cell) => {
                if (!cell) return null;
                const container = cell.querySelector('.spring-inputs');
                if (!container) return null;
                const kxEl = container.querySelector('.spring-kx');
                const kyEl = container.querySelector('.spring-ky');
                const krEl = container.querySelector('.spring-kr');
                const rigidKxEl = container.querySelector('.spring-rigid-kx');
                const rigidKyEl = container.querySelector('.spring-rigid-ky');
                const rigidKrEl = container.querySelector('.spring-rigid-kr');
                const parse = (el) => {
                    if (!el) return 0;
                    const v = parseFloat(el.value);
                    return Number.isFinite(v) ? v : 0;
                };
                const Kx_ui = parse(kxEl); // kN/mm
                const Ky_ui = parse(kyEl); // kN/mm
                const Kr_ui = parse(krEl); // kN¬∑mm/rad
                // Âçò‰ΩçÂ§âÊèõ: UI -> ÂÜÖÈÉ®
                const Kx = Kx_ui * 1000; // kN/mm -> kN/m
                const Ky = Ky_ui * 1000; // kN/mm -> kN/m
                const Kr = Kr_ui * 1e-3;  // kN¬∑mm -> kN¬∑m
                const isRigidKx = rigidKxEl ? rigidKxEl.checked : false;
                const isRigidKy = rigidKyEl ? rigidKyEl.checked : false;
                const isRigidKr = rigidKrEl ? rigidKrEl.checked : false;
                // Ê∞¥Âπ≥„ÉªÂûÇÁõ¥„Å®„ÇÇ„Å´0„ÅÆÂ†¥Âêà„ÅØÊúÄÂ∞èEPS„ÇíÂÖ•„Çå„Å¶Ëß£Êûê„ÇíÂÆâÂÆöÂåñ„Åï„Åõ„ÇãÔºà„Åü„Å†„ÅóÂâõÊåáÂÆö„ÅØÂÑ™ÂÖàÔºâ
                if (!isRigidKx && !isRigidKy && (Kx === 0 || Kx === null) && (Ky === 0 || Ky === null)) {
                    return { Kx: EPS_SPRING, Ky: EPS_SPRING, Kr: Kr || 0, rigidKx: isRigidKx, rigidKy: isRigidKy, rigidKr: isRigidKr };
                }
                return { Kx: Kx || 0, Ky: Ky || 0, Kr: Kr || 0, rigidKx: isRigidKx, rigidKy: isRigidKy, rigidKr: isRigidKr };
            };

            let spring_i = null;
            let spring_j = null;
            try {
                if (i_conn === 'spring') {
                    const iCell = iConnIndex >= 0 ? row.cells[iConnIndex] : null;
                    spring_i = readSpringFromCell(iCell) || { Kx: 0, Ky: 0, Kr: 0 };
                }
            } catch (e) {
                console.warn('ÂßãÁ´Ø„Éê„ÉçË™≠„ÅøÂèñ„Çä„Ç®„É©„Éº(parseInputs)', e);
                spring_i = { Kx: 0, Ky: 0, Kr: 0 };
            }
            try {
                if (j_conn === 'spring') {
                    const jCell = jConnIndex >= 0 ? row.cells[jConnIndex] : null;
                    spring_j = readSpringFromCell(jCell) || { Kx: 0, Ky: 0, Kr: 0 };
                }
            } catch (e) {
                console.warn('ÁµÇÁ´Ø„Éê„ÉçË™≠„ÅøÂèñ„Çä„Ç®„É©„Éº(parseInputs)', e);
                spring_j = { Kx: 0, Ky: 0, Kr: 0 };
            }
            
            const c = dx/L, s = dy/L, T = [ [c,s,0,0,0,0], [-s,c,0,0,0,0], [0,0,1,0,0,0], [0,0,0,c,s,0], [0,0,0,-s,c,0], [0,0,0,0,0,1] ];
            
            // --- „ÉÜ„Ç£„É¢„Ç∑„Çß„É≥„Ç≥Ê¢ÅÁêÜË´ñ„ÅÆ„Åü„ÇÅ„ÅÆ„Åõ„ÇìÊñ≠Â§âÂΩ¢„Éë„É©„É°„Éº„Çø ---
            // „Éù„Ç¢„ÇΩ„É≥ÊØî nu = 0.3 (ÈãºÊùê„ÅÆÊ®ôÊ∫ñÂÄ§) „Å®‰ªÆÂÆö
            const nu = 0.3;
            // „Åõ„ÇìÊñ≠ÂºæÊÄß‰øÇÊï∞ G = E / (2 * (1 + nu))
            const G = E / (2 * (1 + nu));
            // „Åõ„ÇìÊñ≠ÊúâÂäπÊñ≠Èù¢Á©ç As„ÄÇÂΩ¢Áä∂‰øÇÊï∞ kappa = 1.5 (Áü©ÂΩ¢1.2„ÄúHÂΩ¢Á≠â„ÅÆÂπ≥ÂùáÁöÑÊ¶ÇÁÆóÂÄ§) „Å®‰ªÆÂÆö
            const kappa = 1.5;
            const As = A / kappa;
            // „Åõ„ÇìÊñ≠ÊüîËªüÂ∫¶ (Èï∑„Åï / GAs)
            const shear_flex = (G > 0 && As > 0) ? (L / (G * As)) : 0;

            // Axial stiffness with series springs (member and end springs)
            // axialFlexibility = L/(E*A) + 1/Kx_i + 1/Kx_j  (if springs provided)
            let axialFlexibility = L / (E * A);
            if (i_conn === 'spring') {
                const Kxi = spring_i && Number(spring_i.Kx) > 0 ? Number(spring_i.Kx) : 0;
                if (Kxi > 0) axialFlexibility += 1 / Kxi;
                else axialFlexibility = Infinity; // zero or missing spring -> open in series
            }
            if (j_conn === 'spring') {
                const Kxj = spring_j && Number(spring_j.Kx) > 0 ? Number(spring_j.Kx) : 0;
                if (Kxj > 0) axialFlexibility += 1 / Kxj;
                else axialFlexibility = Infinity;
            }
            const EAL = (axialFlexibility === Infinity) ? 0 : (1 / axialFlexibility);
            const EIL = E * I / L, EIL2 = E * I / L**2, EIL3 = E * I / L**3;

            // --- General calculation of k_local for any end condition ---
            // Replace older semi-rigid approximations with a general flexibility-based element
            // that assembles beam flexibility and end-spring flexibility, then inverts to get stiffness.
            let k_local;

            // Helper: invert 3x3
            const invert3x3 = (m) => {
                const det = m[0][0] * (m[1][1] * m[2][2] - m[1][2] * m[2][1]) -
                            m[0][1] * (m[1][0] * m[2][2] - m[1][2] * m[2][0]) +
                            m[0][2] * (m[1][0] * m[2][1] - m[1][1] * m[2][0]);
                // „Åó„Åç„ÅÑÂÄ§„Çí„Çà„ÇäÂ∞è„Åï„Åè„Åó„Å¶È´òÂâõÊÄßÈÉ®Êùê„Åß„ÅÆË™§Âà§ÂÆö„ÇíÈò≤Ê≠¢
                if (Math.abs(det) < 1e-30) return null;
                const invDet = 1 / det;
                return [
                    [(m[1][1] * m[2][2] - m[1][2] * m[2][1]) * invDet, (m[0][2] * m[2][1] - m[0][1] * m[2][2]) * invDet, (m[0][1] * m[1][2] - m[0][2] * m[1][1]) * invDet],
                    [(m[1][2] * m[2][0] - m[1][0] * m[2][2]) * invDet, (m[0][0] * m[2][2] - m[0][2] * m[2][0]) * invDet, (m[0][2] * m[1][0] - m[0][0] * m[1][2]) * invDet],
                    [(m[1][0] * m[2][1] - m[1][1] * m[2][0]) * invDet, (m[0][1] * m[2][0] - m[0][0] * m[2][1]) * invDet, (m[0][0] * m[1][1] - m[0][1] * m[1][0]) * invDet]
                ];
            };

            const getFlexibility = (connType, springData) => {
                // [axial, shear, rotation]
                if (connType === 'rigid') return [0, 0, 0];
                if (connType === 'pinned') return [0, 0, 1e9];
                if (connType === 'spring' && springData) {
                    // Respect explicit 'rigid' checkboxes: if rigid flag is true, flexibility = 0
                    let fx = 1e9;
                    if (springData.rigidKx) fx = 0;
                    else if (springData.Kx && springData.Kx > 1e-12) fx = 1 / springData.Kx;

                    let fy = 1e9;
                    if (springData.rigidKy) fy = 0;
                    else if (springData.Ky && springData.Ky > 1e-12) fy = 1 / springData.Ky;

                    let fr = 1e9;
                    if (springData.rigidKr) fr = 0;
                    else if (springData.Kr && springData.Kr > 1e-12) fr = 1 / springData.Kr;

                    return [fx, fy, fr];
                }
                return [0,0,0];
            };

            // Beam flexibility for j-end quantities (N, Q, M) when j is fixed and i is free
            const L2 = L * L, L3 = L2 * L;
            const EI_beam = E * I, EA = E * A;
            // f_beam[1][1] („Åü„Çè„ÅøÈ†Ö) „Å´„Åõ„ÇìÊñ≠Â§âÂΩ¢È†Ö shear_flex „ÇíÂä†ÁÆó
            const f_beam = [
                [L / EA, 0, 0],
                [0, L3 / (3 * EI_beam) + shear_flex, L2 / (2 * EI_beam)],
                [0, L2 / (2 * EI_beam), L / EI_beam]
            ];

            const f_spring_i = getFlexibility(i_conn, spring_i);
            const f_spring_j = getFlexibility(j_conn, spring_j);

            const B = [
                [-1, 0, 0],
                [0, -1, 0],
                [0, -L, -1]
            ];

            const f_total = [[0,0,0],[0,0,0],[0,0,0]];
            for (let r = 0; r < 3; r++) {
                for (let c = 0; c < 3; c++) {
                    let val = f_beam[r][c] || 0;
                    if (r === c) val += (f_spring_j[r] || 0);
                    for (let k = 0; k < 3; k++) {
                        val += (B[k][r] || 0) * (f_spring_i[k] || 0) * (B[k][c] || 0);
                    }
                    f_total[r][c] = val;
                }
            }

            const K_jj = invert3x3(f_total);
            if (!K_jj) {
                k_local = mat.create(6,6,0);
            } else {
                const K_ij = mat.create(3,3);
                for (let r=0; r<3; r++) {
                    for (let c=0; c<3; c++) {
                        let sum = 0;
                        for (let k=0; k<3; k++) sum += B[r][k] * K_jj[k][c];
                        K_ij[r][c] = sum;
                    }
                }
                const K_ji = mat.transpose(K_ij);
                const K_ii = mat.create(3,3);
                for (let r=0; r<3; r++) {
                    for (let c=0; c<3; c++) {
                        let sum = 0;
                        for (let k=0; k<3; k++) sum += B[r][k] * K_ji[k][c];
                        K_ii[r][c] = sum;
                    }
                }

                k_local = [
                    [K_ii[0][0], K_ii[0][1], K_ii[0][2], K_ij[0][0], K_ij[0][1], K_ij[0][2]],
                    [K_ii[1][0], K_ii[1][1], K_ii[1][2], K_ij[1][0], K_ij[1][1], K_ij[1][2]],
                    [K_ii[2][0], K_ii[2][1], K_ii[2][2], K_ij[2][0], K_ij[2][1], K_ij[2][2]],
                    [K_ji[0][0], K_ji[0][1], K_ji[0][2], K_jj[0][0], K_jj[0][1], K_jj[0][2]],
                    [K_ji[1][0], K_ji[1][1], K_ji[1][2], K_jj[1][0], K_jj[1][1], K_jj[1][2]],
                    [K_ji[2][0], K_ji[2][1], K_ji[2][2], K_jj[2][0], K_jj[2][1], K_jj[2][2]]
                ];
            }

            // --- ÈÉ®ÊùêÁ´Ø„ÅÆ‰∏¶ÈÄ≤„Éê„Éç„ÅØÊó¢„Å´ k_local „ÅÆËª∏ÊñπÂêëÂâõÊÄß(EAL)„ÅÆÁõ¥ÂàóÂêàÊàê„Å®„Åó„Å¶ÁµÑ„ÅøËæº„Åæ„Çå„Å¶„ÅÑ„Çã ---
            // Ê≥®ÊÑè: „Åì„Åì„Åß„ÅØËª∏ÊñπÂêë(Kx)„ÅÆ„Åø„ÇíË¶ÅÁ¥†ÂÜÖ„ÅßÁõ¥ÂàóÂêàÊàê„Å®„Åó„Å¶Êâ±„ÅÑ„ÄÅÂõûËª¢„Éê„Éç(Kr)„ÅØ Ri/Rj „Å´ÂèçÊò†„Åó„Å¶„ÅÑ„Çã„ÄÇ
            // Ê®™ÊñπÂêë(Ky)„ÅÆË©≥Á¥∞„Å™Ë¶ÅÁ¥†ÂÜÖ‰∏¶Âàó/Áõ¥ÂàóÊâ±„ÅÑ„ÅØÊú™ÂÆüË£ÖÔºàÂøÖË¶Å„Å™„ÇâÂæå„ÅßÊã°ÂºµÔºâ„ÄÇ

            // Êñ≠Èù¢ÊÉÖÂ†±„ÇíÂèñÂæóÔºà3D„Éì„É•„Éº„Ç¢Áî®Ôºâ
            let sectionInfo = null;
            let sectionAxis = null;
            if (row.dataset.sectionInfo) {
                try {
                    // encode„Åï„Çå„Å¶„ÅÑ„ÇãÂ†¥Âêà„Å®„Åï„Çå„Å¶„ÅÑ„Å™„ÅÑÂ†¥Âêà„ÅÆ‰∏°Êñπ„Å´ÂØæÂøú
                    const sectionInfoStr = row.dataset.sectionInfo;
                    if (sectionInfoStr.startsWith('%7B') || sectionInfoStr.startsWith('%')) {
                        // URL„Ç®„É≥„Ç≥„Éº„Éâ„Åï„Çå„Å¶„ÅÑ„ÇãÂ†¥Âêà
                        sectionInfo = JSON.parse(decodeURIComponent(sectionInfoStr));
                    } else {
                        // „Ç®„É≥„Ç≥„Éº„Éâ„Åï„Çå„Å¶„ÅÑ„Å™„ÅÑÂ†¥Âêà
                        sectionInfo = JSON.parse(sectionInfoStr);
                    }
                    console.log(`üîç ÈÉ®Êùê${index + 1}„ÅÆÊñ≠Èù¢ÊÉÖÂ†±„ÇíÂèñÂæó:`, sectionInfo);
                } catch (error) {
                    console.warn(`ÈÉ®Êùê ${index + 1}: Êñ≠Èù¢ÊÉÖÂ†±„ÅÆ„Éë„Éº„Çπ„Å´Â§±Êïó`, error);
                }
            } else {
                console.log(`‚ö†Ô∏è ÈÉ®Êùê${index + 1}: sectionInfo„ÅåÂ≠òÂú®„Åó„Åæ„Åõ„Çì`);
            }

            // Ëª∏ÊÉÖÂ†±„ÇíÂèñÂæóÔºà3„Å§„ÅÆÂÄãÂà•Â±ûÊÄß„Åã„ÇâÊßãÁØâÔºâ
            if (row.dataset.sectionAxisKey || row.dataset.sectionAxisMode || row.dataset.sectionAxisLabel) {
                sectionAxis = {
                    key: row.dataset.sectionAxisKey,
                    mode: row.dataset.sectionAxisMode,
                    label: row.dataset.sectionAxisLabel
                };
                console.log(`üîç ÈÉ®Êùê${index + 1}„ÅÆËª∏ÊÉÖÂ†±„ÇíÂèñÂæó:`, sectionAxis);
            }

            return { i,j,E,strengthProps,I,A,Z,Zx,Zy,ix,iy,length:L,c,s,T,i_conn,j_conn,k_local,material,sectionInfo,sectionAxis, spring_i, spring_j, bucklingK, Ix: Ix_m4, Iy: Iy_m4, J: J_m4, Iw: Iw_m6 };
        }).filter(member => member !== null); // Èï∑„Åï0„ÅÆÈÉ®Êùê(null)„ÇíÈô§Â§ñ

        // „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ: sectionInfo „ÅåÊ¨†ËêΩ„Åó„Å¶„ÅÑ„ÇãË°å„Å´ÂØæ„Åó„Å¶ÊúÄÂ∞èÈôê„ÅÆ sectionInfo „ÇíËá™ÂãïÁîüÊàê„Åó„Å¶Ë®≠ÂÆö„Åô„Çã
        try {
            Array.from(elements.membersTable.rows).forEach((row, rIdx) => {
                try {
                    if (!row.dataset || !row.dataset.sectionInfo) {
                        const nameCellText = row.querySelector('.section-name-cell')?.textContent?.trim() || '';
                        const axisFromDataset = (row.dataset && (row.dataset.sectionAxisKey || row.dataset.sectionAxisMode || row.dataset.sectionAxisLabel)) ? {
                            key: row.dataset.sectionAxisKey || 'x',
                            mode: row.dataset.sectionAxisMode || 'strong',
                            label: row.dataset.sectionAxisLabel || 'Âº∑Ëª∏ (XËª∏)'
                        } : null;

                        const zx = row.dataset?.zx || row.cells[7]?.querySelector('input')?.value || '';
                        const a = row.cells[6]?.querySelector('input')?.value || '';

                        const fallbackInfo = {
                            typeKey: 'unknown',
                            label: nameCellText || `Ëá™ÂãïË£úÂÆå: unknown`,
                            axis: axisFromDataset || { key: 'x', mode: 'strong', label: 'Âº∑Ëª∏ (XËª∏)' },
                            dimensions: [],
                            dimensionSummary: `Zx:${zx} A:${a}`,
                            source: 'fallback'
                        };

                        if (typeof window.setRowSectionInfo === 'function') {
                            window.setRowSectionInfo(row, fallbackInfo);
                        } else {
                            try { row.dataset.sectionInfo = encodeURIComponent(JSON.stringify(fallbackInfo)); }
                            catch (err) { row.dataset.sectionInfo = JSON.stringify(fallbackInfo); }
                        }
                        console.log(`üîß „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØË®≠ÂÆö: Ë°å${rIdx + 1} „Å´ sectionInfo „ÇíË®≠ÂÆö„Åó„Åæ„Åó„Åü`, fallbackInfo);
                    }
                } catch (innerErr) {
                    console.warn('„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÁîüÊàê‰∏≠„Å´Ë°åÂçò‰Ωç„Åß„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü:', innerErr);
                }
            });
        } catch (err) {
            console.warn('„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÔºösectionInfo Ëá™ÂãïË®≠ÂÆö„Åß„Ç®„É©„ÉºÁô∫Áîü', err);
        }

        console.log(`üìä ÈÉ®ÊùêÂá¶ÁêÜÁµêÊûú: ÂÖ®${elements.membersTable.rows.length}Ë°å‰∏≠„ÄÅÊúâÂäπ„Å™ÈÉ®Êùê${members.length}ÂÄã`);
        
        const nodeLoads = Array.from(elements.nodeLoadsTable.rows).map((r, i) => { 
            const n = parseInt(r.cells[0].querySelector('input').value) - 1; 
            if (n < 0 || n >= nodes.length) {
                console.warn(`ÁØÄÁÇπËç∑Èáç ${i+1} „ÅÆÁØÄÁÇπÁï™Âè∑„Åå‰∏çÊ≠£„Åß„Åô (ÁØÄÁÇπÁï™Âè∑: ${n + 1}, ÊúÄÂ§ßÁØÄÁÇπÊï∞: ${nodes.length})„ÄÇ„Åì„ÅÆËç∑Èáç„ÅØ„Çπ„Ç≠„ÉÉ„Éó„Åï„Çå„Åæ„Åô„ÄÇ`);
                return null; // ÁÑ°Âäπ„Å™Ëç∑Èáç„ÅØ null „ÇíËøî„Åô
            }
            const px = parseFloat(r.cells[1].querySelector('input').value) || 0;
            const py = parseFloat(r.cells[2].querySelector('input').value) || 0;
            const mz = parseFloat(r.cells[3].querySelector('input').value) || 0;
            console.log(`üîç parseInputs: ÁØÄÁÇπËç∑Èáç ${i+1} Ë™≠„ÅøÂèñ„Çä: ÁØÄÁÇπ${n+1}, px=${px}, py=${py}, mz=${mz}`);
            return { nodeIndex:n, px:px, py:py, mz:mz }; 
        }).filter(load => load !== null); // null „ÅÆËç∑Èáç„ÇíÈô§Â§ñ
        const memberLoads = Array.from(elements.memberLoadsTable.rows).map((r, i) => { 
            const m = parseInt(r.cells[0].querySelector('input').value) - 1; 
            if (m < 0 || m >= members.length) {
                console.warn(`ÈÉ®ÊùêËç∑Èáç ${i+1} „ÅÆÈÉ®ÊùêÁï™Âè∑„Åå‰∏çÊ≠£„Åß„Åô (ÈÉ®ÊùêÁï™Âè∑: ${m + 1}, ÊúÄÂ§ßÈÉ®ÊùêÊï∞: ${members.length})„ÄÇ„Åì„ÅÆËç∑Èáç„ÅØ„Çπ„Ç≠„ÉÉ„Éó„Åï„Çå„Åæ„Åô„ÄÇ`);
                return null; // ÁÑ°Âäπ„Å™Ëç∑Èáç„ÅØ null „ÇíËøî„Åô
            }
            return { memberIndex:m, w:parseFloat(r.cells[1].querySelector('input').value)||0 }; 
        }).filter(load => load !== null); // null „ÅÆËç∑Èáç„ÇíÈô§Â§ñ
        
        // Ëá™ÈáçËç∑Èáç„ÇíËøΩÂä†
        const considerSelfWeightCheckbox = document.getElementById('consider-self-weight-checkbox');
        const membersTableBody = document.getElementById('members-table').getElementsByTagName('tbody')[0];
        const { memberSelfWeights, nodeSelfWeights } = calculateSelfWeight.calculateAllSelfWeights(
            nodes, 
            members, 
            considerSelfWeightCheckbox, 
            membersTableBody
        );
        
        if (memberSelfWeights.length > 0) {
            // Ëá™ÈáçËç∑Èáç„É≠„Ç∞„ÅÆÈ†ªÂ∫¶Âà∂Èôê
            if (!window.selfWeightLogCount) window.selfWeightLogCount = 0;
            if (window.selfWeightLogCount < 3) {
                console.log('Ëá™ÈáçËç∑Èáç„ÇíËøΩÂä†:', memberSelfWeights);
                window.selfWeightLogCount++;
            }
        }
        
        return { nodes, members, nodeLoads, memberLoads, memberSelfWeights, nodeSelfWeights };
    };
    
    // windowÂ§âÊï∞„Å®„Åó„Å¶ÁôªÈå≤Ôºà„ÇØ„É≠„Çπ„Çπ„Ç≥„Éº„Éó„Ç¢„ÇØ„Çª„ÇπÁî®Ôºâ
    window.parseInputs = parseInputs;
    
    const clearResults = () => {
        const canvases = [elements.displacementCanvas, elements.momentCanvas, elements.axialCanvas, elements.shearCanvas, elements.ratioCanvas];
        canvases.forEach(c => { if (c) { const ctx = c.getContext('2d'); ctx.clearRect(0, 0, c.width, c.height); } });
        const tables = [elements.displacementResults, elements.reactionResults, elements.forceResults, elements.sectionCheckResults, elements.deflectionCheckResults, elements.ltbCheckResults];
        tables.forEach(t => { if(t) t.innerHTML = ''; });
        lastResults = null;
        lastAnalysisResult = null;
        lastSectionCheckResults = null;
        lastDeflectionCheckResults = null;
        lastLtbCheckResults = null;
        window.lastResults = null; // „Ç∞„É≠„Éº„Éê„É´Â§âÊï∞„ÇÇ„ÇØ„É™„Ç¢
        window.lastSectionCheckResults = null;
        window.lastDeflectionCheckResults = null;
        window.lastLtbCheckResults = null;
        window.lastBucklingResults = null;
    };
    
    const displayResults = (D, R, forces, nodes, members, nodeLoads, memberLoads) => {
        lastResults = { D, R, forces, nodes, members, nodeLoads, memberLoads };
        window.lastResults = lastResults; // „Ç∞„É≠„Éº„Éê„É´„Å´‰øùÂ≠ò

        // „Ç®„ÇØ„Çª„É´Âá∫ÂäõÁî®„ÅÆËß£ÊûêÁµêÊûú„Çí‰øùÂ≠ò
        lastAnalysisResult = {
            displacements: D ? Array.from({length: D.length / 3}, (_, i) => ({
                x: D[i*3][0],
                y: D[i*3+1][0],
                rotation: D[i*3+2][0]
            })) : [],
            forces: forces ? forces.map(f => ({
                i: { N: -f.N_i, Q: f.Q_i, M: f.M_i },
                j: { N: f.N_j, Q: -f.Q_j, M: f.M_j }
            })) : [],
            reactions: R ? Array.from({length: R.length / 3}, (_, i) => ({
                x: -R[i*3][0] || 0,
                y: -R[i*3+1][0] || 0,
                mz: -R[i*3+2][0] || 0
            })) : [],
            nodes: nodes || [],
            members: members || [],
            sectionCheckResults: null,  // Âæå„ÅßÊñ≠Èù¢Ê§úÂÆöÂÆüË°åÊôÇ„Å´Ë®≠ÂÆö„Åï„Çå„Çã
            deflectionCheckResults: null,
            deflectionCheckSettings: null
        };

        // ÊßãÈÄ†Ëß£ÊûêÂÆå‰∫ÜÂæå„Å´Ëá™Âãï„ÅßÂ∫ßÂ±àËß£Êûê„ÇíÂÆüË°å
        if (forces && forces.length > 0) {
            try {
                lastBucklingResults = calculateBucklingAnalysis();
                window.lastBucklingResults = lastBucklingResults; // „Ç∞„É≠„Éº„Éê„É´„Å´‰øùÂ≠ò
                // Â∫ßÂ±àËß£ÊûêÁµêÊûú„ÇÇËá™Âãï„ÅßË°®Á§∫
                displayBucklingResults();
            } catch (error) {
                console.warn('Â∫ßÂ±àËß£Êûê‰∏≠„Å´„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü„Åå„ÄÅÂá¶ÁêÜ„ÇíÁ∂öË°å„Åó„Åæ„Åô:', error);
            }
        }
        
        elements.errorMessage.style.display = 'none';
        let dispHTML = `<thead><tr><th>ÁØÄÁÇπ #</th><th>Â§â‰Ωç Œ¥x (mm)</th><th>Â§â‰Ωç Œ¥y (mm)</th><th>ÂõûËª¢Ëßí Œ∏z (rad)</th></tr></thead><tbody>`; for (let i = 0; i < D.length / 3; i++) { dispHTML += `<tr><td>${i+1}</td><td>${(D[i*3][0]*1000).toFixed(2)}</td><td>${(D[i*3+1][0]*1000).toFixed(2)}</td><td>${D[i*3+2][0].toFixed(2)}</td></tr>`; } elements.displacementResults.innerHTML = dispHTML + '</tbody>';
        let reactHTML = `<thead><tr><th>ÁØÄÁÇπ #</th><th>ÂèçÂäõ Rx (kN)</th><th>ÂèçÂäõ Ry (kN)</th><th>ÂèçÂäõ Mz (kN„Éªm)</th></tr></thead><tbody>`; nodes.forEach((n, i) => { if (n.support !== 'free') { const rx = -R[i*3][0]||0, ry = -R[i*3+1][0]||0, mz = -R[i*3+2][0]||0; reactHTML += `<tr><td>${i+1}</td><td>${rx.toFixed(2)}</td><td>${ry.toFixed(2)}</td><td>${mz.toFixed(2)}</td></tr>`; } }); elements.reactionResults.innerHTML = reactHTML + '</tbody>';
        let forceHTML = `<thead><tr><th>ÈÉ®Êùê #</th><th>ÂßãÁ´Ø #i</th><th>ÁµÇÁ´Ø #j</th><th>Ëª∏Âäõ N (kN)</th><th>„Åõ„ÇìÊñ≠Âäõ Q (kN)</th><th>Êõ≤„ÅíM (kN„Éªm)</th></tr></thead><tbody>`; forces.forEach((f, i) => { const ni = members[i].i+1, nj = members[i].j+1; forceHTML += `<tr><td rowspan="2">${i+1}</td><td>${ni} (iÁ´Ø)</td><td>-</td><td>${(-f.N_i).toFixed(2)}</td><td>${f.Q_i.toFixed(2)}</td><td>${f.M_i.toFixed(2)}</td></tr><tr><td>-</td><td>${nj} (jÁ´Ø)</td><td>${f.N_j.toFixed(2)}</td><td>${(-f.Q_j).toFixed(2)}</td><td>${f.M_j.toFixed(2)}</td></tr>`; }); elements.forceResults.innerHTML = forceHTML + '</tbody>';
        drawDisplacementDiagram(nodes, members, D, memberLoads);
        drawMomentDiagram(nodes, members, forces, memberLoads);
        drawAxialForceDiagram(nodes, members, forces);
        drawShearForceDiagram(nodes, members, forces, memberLoads);
    };

// --- Canvas Drawing ---
    let lastDrawingContext = null;
    
    // ÈáçË§áÂà§ÂÆöÁî®„ÅÆ„Éò„É´„Éë„ÉºÈñ¢Êï∞
    function boxesOverlap(box1, box2) {
        return !(box1.x + box1.width < box2.x || 
                box2.x + box2.width < box1.x || 
                box1.y + box1.height < box2.y || 
                box2.y + box2.height < box1.y);
    }
    
    // ÈáçË§áÈù¢Á©çË®àÁÆóÁî®„ÅÆ„Éò„É´„Éë„ÉºÈñ¢Êï∞
    function calculateOverlapArea(box1, box2) {
        const overlapX = Math.max(0, Math.min(box1.x + box1.width, box2.x + box2.width) - Math.max(box1.x, box2.x));
        const overlapY = Math.max(0, Math.min(box1.y + box1.height, box2.y + box2.height) - Math.max(box1.y, box2.y));
        return overlapX * overlapY;
    }
    
    // ÈÉ®ÊùêÁï™Âè∑„ÅÆÈáçË§áÂõûÈÅø‰ΩçÁΩÆË®àÁÆóÔºàÈÉ®Êùê‰∏ä„Å´Âà∂ÈôêÔºâ
    function calculateMemberLabelPositions(members, nodes, transform, ctx) {
        const memberLabelPositions = [];
        
        members.forEach((m, memberIndex) => {
            const start = transform(nodes[m.i].x, nodes[m.i].y);
            const end = transform(nodes[m.j].x, nodes[m.j].y);
            
            const fontScale = window.settings?.fontScale || 1.0;
            ctx.font = `${10 * fontScale}px Arial`;
            const memberText = (memberIndex + 1).toString();
            const textMetrics = ctx.measureText(memberText);
            const textWidth = textMetrics.width;
            const textHeight = 10;
            const padding = 2;
            const boxWidth = textWidth + padding * 2;
            const boxHeight = textHeight + padding * 2;
            
            // ÈÉ®Êùê‰∏ä„ÅÆÂÄôË£ú‰ΩçÁΩÆ„ÇíÁîüÊàêÔºàÈÉ®ÊùêÁ∑ö‰∏ä„ÅÆË§áÊï∞ÁÇπÔºâ
            const candidates = [];
            const numCandidates = 7; // ÂÄôË£úÊï∞„ÇíÂ¢ó„ÇÑ„Åó„Å¶ÈÅ∏ÊäûËÇ¢„ÇíË±äÂØå„Å´„Åô„Çã
            
            for (let i = 0; i < numCandidates; i++) {
                const t = i / (numCandidates - 1); // 0„Åã„Çâ1„ÅÆÈñì„ÅßÂàÜÂâ≤
                const x = start.x + (end.x - start.x) * t;
                const y = start.y + (end.y - start.y) * t;
                
                candidates.push({ x, y, t });
            }
            
            // ÊúÄÈÅ©„Å™‰ΩçÁΩÆ„ÇíÈÅ∏ÊäûÔºà‰ªñ„ÅÆ„É©„Éô„É´„Å®ÈáçË§á„Åó„Å™„ÅÑÈÉ®Êùê‰∏ä„ÅÆÁÇπÔºâ
            let bestPosition = candidates[Math.floor(numCandidates / 2)]; // „Éá„Éï„Ç©„É´„Éà„ÅØ‰∏≠ÁÇπ
            let minOverlap = Infinity;
            
            for (const candidate of candidates) {
                const candidateBox = {
                    x: candidate.x - boxWidth / 2,
                    y: candidate.y - boxHeight / 2,
                    width: boxWidth,
                    height: boxHeight
                };
                
                let overlapCount = 0;
                let totalOverlapArea = 0;
                
                // Êó¢Â≠ò„ÅÆ„É©„Éô„É´‰ΩçÁΩÆ„Å®„ÅÆÈáçË§á„ÉÅ„Çß„ÉÉ„ÇØ
                for (const existing of memberLabelPositions) {
                    if (boxesOverlap(candidateBox, existing)) {
                        overlapCount++;
                        totalOverlapArea += calculateOverlapArea(candidateBox, existing);
                    }
                }
                
                // ÈáçË§áÂ∫¶„ÅÆË®àÁÆó + ‰∏≠ÂøÉ„Å´Ëøë„ÅÑ„Åª„Å©Â•Ω„Åæ„Åó„ÅÑÔºà‰∏≠ÂøÉ„Åã„Çâ„ÅÆË∑ùÈõ¢„Å´„Çà„Çã„Éö„Éä„É´„ÉÜ„Ç£Ôºâ
                const centerBias = Math.abs(candidate.t - 0.5) * 100; // ‰∏≠ÂøÉ„Åã„ÇâÈõ¢„Çå„Çã„Åª„Å©„Éö„Éä„É´„ÉÜ„Ç£
                const overlapScore = overlapCount * 1000 + totalOverlapArea + centerBias;
                
                if (overlapScore < minOverlap) {
                    minOverlap = overlapScore;
                    bestPosition = candidate;
                }
            }
            
            // ÈÅ∏Êäû„Åï„Çå„Åü‰ΩçÁΩÆ„Çí„É©„Éô„É´‰ΩçÁΩÆ„É™„Çπ„Éà„Å´ËøΩÂä†
            memberLabelPositions.push({
                x: bestPosition.x - boxWidth / 2,
                y: bestPosition.y - boxHeight / 2,
                width: boxWidth,
                height: boxHeight,
                memberIndex: memberIndex,
                textX: bestPosition.x,
                textY: bestPosition.y,
                t: bestPosition.t // ÈÉ®Êùê‰∏ä„ÅÆ‰ΩçÁΩÆ„Éë„É©„É°„Éº„Çø
            });
        });
        
        return memberLabelPositions;
    }
    
    // windowÂ§âÊï∞„Å®„Åó„Å¶ÁôªÈå≤Ôºà„ÇØ„É≠„Çπ„Çπ„Ç≥„Éº„Éó„Ç¢„ÇØ„Çª„ÇπÁî®Ôºâ
    window.lastDrawingContext = null;
    const getDrawingContext = (canvas) => {
        let nodes;
        try { nodes = parseInputs().nodes; } catch (e) { nodes = []; }
        if (!canvas) return null;
        
        const isModelCanvas = canvas.id === 'model-canvas';
        const isResultCanvas = ['displacement-canvas', 'moment-canvas', 'axial-canvas', 'shear-canvas', 'ratio-canvas'].includes(canvas.id);
        
        const minX = nodes.length > 0 ? Math.min(...nodes.map(n => n.x)) : 0;
        const maxX = nodes.length > 0 ? Math.max(...nodes.map(n => n.x)) : 0;
        const minY = nodes.length > 0 ? Math.min(...nodes.map(n => n.y)) : 0;
        const maxY = nodes.length > 0 ? Math.max(...nodes.map(n => n.y)) : 0;
        const modelWidth = maxX - minX;
        const modelHeight = maxY - minY;
        
        const padding = 70;
        const isRatioCanvas = canvas.id === 'ratio-canvas';
        const minHeight = isRatioCanvas ? 350 : 250;
        const maxHeight = isRatioCanvas ? 1200 : 800;
        
        // „Ç≠„É£„É≥„Éê„Çπ„ÅÆÈ´ò„Åï„ÇíÂÖà„Å´Ê±∫ÂÆö„Åô„Çã
        let requiredHeight;
        if (nodes.length === 0) {
            requiredHeight = isRatioCanvas ? 500 : 400;
        } else if (modelWidth === 0 && modelHeight === 0) {
            requiredHeight = isRatioCanvas ? 500 : 400;
        } else {
            // „Åæ„Åö‰ªÆ„ÅÆ„Ç≥„É≥„ÉÜ„Éä„Çµ„Ç§„Ç∫„Åß„Çπ„Ç±„Éº„É´„ÇíË®àÁÆó
            const containerRect = canvas.parentElement.getBoundingClientRect();
            const tempScaleX = (containerRect.width - 2 * padding) / (modelWidth || 1);
            const tempScaleY = (containerRect.height - 2 * padding) / (modelHeight || 1);
            const tempScale = Math.min(tempScaleX, tempScaleY) * 0.9;
            requiredHeight = modelHeight * tempScale + 2 * padding;
            requiredHeight = Math.max(minHeight, Math.min(maxHeight, requiredHeight));
        }

        canvas.style.height = `${requiredHeight}px`;
        
        // „Ç≠„É£„É≥„Éê„Çπ„ÅÆÈ´ò„Åï„ÇíÂ§âÊõ¥„Åó„ÅüÂæå„Å´„ÄÅÊñ∞„Åó„ÅÑ„Çµ„Ç§„Ç∫„ÇíÂèñÂæó„Åó„Å¶„Çπ„Ç±„Éº„É´„ÇíÂÜçË®àÁÆó
        const rect = canvas.getBoundingClientRect();
        const containerRect = canvas.parentElement.getBoundingClientRect();
        
        let scale, offsetX, offsetY;
        
        if (nodes.length === 0) {
            scale = 50; // An arbitrary scale for an empty grid
            offsetX = padding;
            offsetY = rect.height - padding;
        } else if (modelWidth === 0 && modelHeight === 0) {
            // Single node or all nodes at the same location. Center the view on the first node.
            scale = 50; // Default zoom level
            const nodeX = nodes[0].x;
            const nodeY = nodes[0].y;
            offsetX = (rect.width / 2) - (nodeX * scale);
            offsetY = (rect.height / 2) + (nodeY * scale);
        } else {
            // Êñ∞„Åó„ÅÑ„Çµ„Ç§„Ç∫„Åß„Çπ„Ç±„Éº„É´„ÇíÊ≠£Á¢∫„Å´Ë®àÁÆó
            const scaleX = (rect.width - 2 * padding) / (modelWidth || 1);
            const scaleY = (rect.height - 2 * padding) / (modelHeight || 1);
            scale = Math.min(scaleX, scaleY) * 0.9;
            
            // „É™„Çµ„Ç§„Ç∫ÊôÇ„ÅØÂ∏∏„Å´Ëá™Âãï„Çπ„Ç±„Éº„É™„É≥„Ç∞„ÇíÂÆüË°åÔºàpanZoomState.isInitialized = false„ÅÆÂ†¥ÂêàÔºâ
            if (isModelCanvas && panZoomState.isInitialized) {
                // „É¢„Éá„É´Âõ≥„ÅåÂàùÊúüÂåñÊ∏à„Åø„ÅÆÂ†¥Âêà„ÄÅÊó¢Â≠ò„ÅÆ„Éë„É≥„Éª„Ç∫„Éº„É†ÊÉÖÂ†±„Çí‰ΩøÁî®
                ({ scale, offsetX, offsetY } = panZoomState);
            } else if (isResultCanvas) {
                // ÁµêÊûúÂõ≥„ÅÆÂ†¥Âêà„ÄÅÂØæÂøú„Åô„Çã„Éë„É≥„Éª„Ç∫„Éº„É†Áä∂ÊÖã„ÇíÂèñÂæó
                const resultState = resultPanZoomStates[canvas.id.replace('-canvas', '')];
                if (resultState.isInitialized) {
                    // ÁµêÊûúÂõ≥„ÅåÂàùÊúüÂåñÊ∏à„Åø„ÅÆÂ†¥Âêà„ÄÅÊó¢Â≠ò„ÅÆ„Éë„É≥„Éª„Ç∫„Éº„É†ÊÉÖÂ†±„Çí‰ΩøÁî®
                    ({ scale, offsetX, offsetY } = resultState);
            } else {
                    // ÁµêÊûúÂõ≥„ÅÆÂàùÂõûÊèèÁîªÊôÇ„ÅØ„ÄÅÂ∏∏„Å´‰∏≠Â§Æ„Å´ÈÖçÁΩÆ
                    offsetX = padding + (rect.width - 2 * padding - modelWidth * scale) / 2 - minX * scale;
                    offsetY = padding + (rect.height - 2 * padding - modelHeight * scale) / 2 + maxY * scale;
                    
                    // ÁµêÊûúÂõ≥„ÅÆÁä∂ÊÖã„Çí‰øùÂ≠ò
                    Object.assign(resultState, { scale, offsetX, offsetY, isInitialized: true });
                }
            } else {
                // „É¢„Éá„É´Âõ≥„ÅÆÂàùÂõûÊèèÁîªÊôÇ/„É™„Çµ„Ç§„Ç∫ÊôÇ„ÅØ„ÄÅÂ∏∏„Å´‰∏≠Â§Æ„Å´ÈÖçÁΩÆ
                offsetX = padding + (rect.width - 2 * padding - modelWidth * scale) / 2 - minX * scale;
                offsetY = padding + (rect.height - 2 * padding - modelHeight * scale) / 2 + maxY * scale;

                if (isModelCanvas) {
                    // „É¢„Éá„É´Âõ≥„ÅÆÁä∂ÊÖã„Çí‰øùÂ≠ò
                    panZoomState = { scale, offsetX, offsetY, isInitialized: true };
                }
            }
        }

        const dpr = window.devicePixelRatio || 1;
        canvas.width = rect.width * dpr * resolutionScale;
        canvas.height = rect.height * dpr * resolutionScale;

        const ctx = canvas.getContext('2d');
        ctx.scale(dpr * resolutionScale, dpr * resolutionScale);
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        const fontScale = window.settings?.fontScale || 1.0;
        ctx.font = `${12 * fontScale}px Arial`;
        
        const transform = (x, y) => ({ x: x * scale + offsetX, y: -y * scale + offsetY });
        
        return { ctx, transform, scale, offsetX, offsetY };
    };
    // Â∫ßÊ®ôËª∏„ÇíÊèèÁîª„Åô„ÇãÈñ¢Êï∞
    const drawCoordinateAxes = (ctx, transform, scale, offsetX, offsetY, canvasWidth, canvasHeight) => {
        // ÂÆüÈöõ„ÅÆ„Ç≠„É£„É≥„Éê„Çπ„ÅÆÊèèÁîªÈ†òÂüü„ÅÆ„Çµ„Ç§„Ç∫„Çí‰ΩøÁî®
        const rect = ctx.canvas.getBoundingClientRect();
        const actualWidth = rect.width;
        const actualHeight = rect.height;
        
        // Â∫ßÊ®ôËª∏„ÅÆÁØÑÂõ≤„ÇíË®àÁÆó
        const leftX = (-offsetX) / scale; // Â∑¶Á´Ø„ÅÆXÂ∫ßÊ®ô
        const rightX = (actualWidth - offsetX) / scale; // Âè≥Á´Ø„ÅÆXÂ∫ßÊ®ô
        const topY = (offsetY) / scale; // ‰∏äÁ´Ø„ÅÆYÂ∫ßÊ®ôÔºàYËª∏„ÅØÂèçËª¢„Åó„Å¶„ÅÑ„ÇãÔºâ
        const bottomY = (offsetY - actualHeight) / scale; // ‰∏ãÁ´Ø„ÅÆYÂ∫ßÊ®ô
        
        // „Ç∞„É™„ÉÉ„ÉâÈñìÈöî„ÇíÂèñÂæó
        const gridSpacing = parseFloat(elements.gridSpacing.value);
        if (isNaN(gridSpacing) || gridSpacing <= 0) return;
        
        // „Ç∞„É™„ÉÉ„ÉâË®≠ÂÆöÂÄ§„ÅÆÂ∞èÊï∞ÁÇπ‰ª•‰∏ãÊ°ÅÊï∞„ÇíÂèñÂæó
        const gridSpacingStr = elements.gridSpacing.value.toString();
        const decimalPlaces = gridSpacingStr.includes('.') ? 
            gridSpacingStr.split('.')[1].length : 0;
        
        // ÈÅ©Âàá„Å™ÁõÆÁõõÈñìÈöî„ÇíË®àÁÆóÔºà„Ç∞„É™„ÉÉ„ÉâÈñìÈöî„ÅÆÂÄçÊï∞Ôºâ
        const xRange = rightX - leftX;
        const yRange = topY - bottomY;
        const getTickInterval = (range, baseSpacing) => {
            const desiredTicks = 10; // 10ÂÄãÁ®ãÂ∫¶„ÅÆÁõÆÁõõ„Çä„ÅåÁõÆÂÆâ
            const rawInterval = range / desiredTicks;
            const multiplier = Math.ceil(rawInterval / baseSpacing);
            return Math.max(1, multiplier) * baseSpacing;
        };
        
        const xTickInterval = getTickInterval(xRange, gridSpacing);
        const yTickInterval = getTickInterval(yRange, gridSpacing);
        
        ctx.save();
        ctx.strokeStyle = '#999';
        ctx.fillStyle = '#666';
        const fontScale = window.settings?.fontScale || 1.0;
        ctx.font = `${10 * fontScale}px Arial`;
        ctx.lineWidth = 1;
        
        // XËª∏„ÅÆÁõÆÁõõ„ÇäÔºà‰∏ãÁ´ØÔºâ
        const xStart = Math.floor(leftX / xTickInterval) * xTickInterval;
        const xEnd = Math.ceil(rightX / xTickInterval) * xTickInterval;
        
        for (let x = xStart; x <= xEnd; x += xTickInterval) {
            const screenPos = transform(x, bottomY);
            if (screenPos.x >= 0 && screenPos.x <= actualWidth) {
                // ÁõÆÁõõ„ÇäÁ∑öÔºàÁü≠„ÅÑÁ∏¶Á∑öÔºâ
                ctx.beginPath();
                ctx.moveTo(screenPos.x, actualHeight - 15);
                ctx.lineTo(screenPos.x, actualHeight - 5);
                ctx.stroke();
                
                // Êï∞ÂÄ§Ë°®Á§∫Ôºà„Ç∞„É™„ÉÉ„ÉâË®≠ÂÆöÂÄ§„Å®Âêå„ÅòÂ∞èÊï∞ÁÇπ‰ª•‰∏ãÊ°ÅÊï∞Ôºâ
                ctx.textAlign = 'center';
                ctx.fillText(x.toFixed(decimalPlaces), screenPos.x, actualHeight - 18);
            }
        }
        
        // YËª∏„ÅÆÁõÆÁõõ„ÇäÔºàÂ∑¶Á´ØÔºâ
        const yStart = Math.floor(bottomY / yTickInterval) * yTickInterval;
        const yEnd = Math.ceil(topY / yTickInterval) * yTickInterval;
        
        for (let y = yStart; y <= yEnd; y += yTickInterval) {
            const screenPos = transform(leftX, y);
            if (screenPos.y >= 0 && screenPos.y <= actualHeight) {
                // ÁõÆÁõõ„ÇäÁ∑öÔºàÁü≠„ÅÑÊ®™Á∑öÔºâ
                ctx.beginPath();
                ctx.moveTo(5, screenPos.y);
                ctx.lineTo(15, screenPos.y);
                ctx.stroke();
                
                // Êï∞ÂÄ§Ë°®Á§∫Ôºà„Ç∞„É™„ÉÉ„ÉâË®≠ÂÆöÂÄ§„Å®Âêå„ÅòÂ∞èÊï∞ÁÇπ‰ª•‰∏ãÊ°ÅÊï∞Ôºâ
                ctx.textAlign = 'right';
                ctx.fillText(y.toFixed(decimalPlaces), 50, screenPos.y + 3);
            }
        }
        
        ctx.restore();
    };

    const drawStructure = (ctx, transform, nodes, members, color, showNodeNumbers = true, showMemberNumbers = true, showCoordinateAxes = false, drawingContext = null, fontScale = 1.0) => { 
        ctx.strokeStyle = color; 
        ctx.lineWidth = 2; 
        
        // Â∫ßÊ®ôËª∏„ÇíÊèèÁîªÔºàÂøÖË¶Å„Å™Â†¥ÂêàÔºâ
        if (showCoordinateAxes && drawingContext) {
            const canvas = ctx.canvas;
            drawCoordinateAxes(ctx, transform, drawingContext.scale, drawingContext.offsetX, drawingContext.offsetY, canvas.width, canvas.height);
        }
        
        // 1. „Åæ„ÅöÈÉ®Êùê„ÅÆÁ∑ö„ÇíÊèèÁîª
        members.forEach((m) => { 
            const start = transform(nodes[m.i].x, nodes[m.i].y); 
            const end = transform(nodes[m.j].x, nodes[m.j].y); 
            ctx.beginPath(); 
            ctx.moveTo(start.x, start.y); 
            ctx.lineTo(end.x, end.y); 
            ctx.stroke(); 
        });

        // 2. Ê¨°„Å´ÁØÄÁÇπ„ÅÆÂÜÜ„ÇíÊèèÁîª
        nodes.forEach((n) => { 
            const pos = transform(n.x, n.y); 
            ctx.fillStyle = "#000"; 
            ctx.beginPath(); 
            ctx.arc(pos.x, pos.y, 4, 0, 2 * Math.PI); 
            ctx.fill(); 
        });

        // 3. ÈÉ®ÊùêÁï™Âè∑„ÇíÊèèÁîªÔºàÊúÄÂâçÈù¢Ôºâ
        if (showMemberNumbers) {
            // ÈÉ®ÊùêÁï™Âè∑„ÅÆË°®Á§∫‰ΩçÁΩÆ„ÇíË®àÁÆóÔºàÈáçË§áÂõûÈÅøÔºâ
            const memberLabelPositions = calculateMemberLabelPositions(members, nodes, transform, ctx);
            
            members.forEach((m, memberIndex) => {
                const labelInfo = memberLabelPositions.find(info => info.memberIndex === memberIndex);
                if (labelInfo) {
                    const memberText = (memberIndex + 1).toString();
                    
                    const fs = fontScale || (window.settings?.fontScales?.model || 1.0);
                    ctx.font = `${10 * fs}px Arial`;
                    ctx.textAlign = "center";
                    
                    // ÁôΩËÉåÊôØ„ÅÆÂõõËßí„ÇíÊèèÁîª
                    ctx.fillStyle = "#ffffff";
                    ctx.fillRect(labelInfo.x, labelInfo.y, labelInfo.width, labelInfo.height);
                    
                    // ËñÑ„ÅÑ„Ç∞„É¨„ÉºÊû†„ÇíÊèèÁîª
                    ctx.strokeStyle = "#cccccc";
                    ctx.lineWidth = 1;
                    ctx.strokeRect(labelInfo.x, labelInfo.y, labelInfo.width, labelInfo.height);
                    
                    // ÈÉ®ÊùêÁï™Âè∑„ÉÜ„Ç≠„Çπ„Éà„ÇíÈùí„ÅßÊèèÁîª
                    ctx.fillStyle = "#0056b3";
                    ctx.fillText(memberText, labelInfo.textX, labelInfo.textY + 2);
                    
                    // „Ç≥„É≥„ÉÜ„Ç≠„Çπ„ÉàË®≠ÂÆö„ÇíÂæ©ÂÖÉ
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 2;
                }
            });
        }
        
        // 4. ÁØÄÁÇπÁï™Âè∑„ÇíÊèèÁîªÔºàÊúÄÂâçÈù¢Ôºâ
        if (showNodeNumbers) { 
            nodes.forEach((n, i) => { 
                const pos = transform(n.x, n.y); 
                // ÁØÄÁÇπÁï™Âè∑„ÅØÈªí„ÅßË°®Á§∫Ôºà‰∏∏Âõ≤„ÅÑÔºâ
                const fs2 = fontScale || (window.settings?.fontScales?.model || 1.0);
                const fontSize = 10 * fs2; // 12 -> 10 „Å´Â§âÊõ¥
                ctx.font = `${fontSize}px Arial`;
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                
                const text = (i + 1).toString();
                // „ÉÜ„Ç≠„Çπ„Éà„Çµ„Ç§„Ç∫„Å´Âü∫„Å•„ÅÑ„Å¶ÂçäÂæÑ„ÇíË®àÁÆóÔºàÊúÄÂ∞è„Çµ„Ç§„Ç∫„ÇíÁ¢∫‰øùÔºâ
                const metrics = ctx.measureText(text);
                const radius = Math.max(metrics.width / 2 + 3 * fs2, fontSize / 2 + 2 * fs2);
                
                // ÁØÄÁÇπ„Åã„Çâ„ÅÆ„Ç™„Éï„Çª„ÉÉ„Éà‰ΩçÁΩÆÔºàÂè≥‰∏äÔºâ
                const offsetDist = 10 * fs2;
                const circleX = pos.x + offsetDist;
                const circleY = pos.y - offsetDist;
                
                // ÁôΩËÉåÊôØ„ÅÆÂÜÜ„ÇíÊèèÁîª
                ctx.fillStyle = "#ffffff";
                ctx.beginPath();
                ctx.arc(circleX, circleY, radius, 0, 2 * Math.PI);
                ctx.fill();
                
                // Èªí„ÅÑÊû†Á∑ö„ÇíÊèèÁîª
                ctx.strokeStyle = "#000000";
                ctx.lineWidth = 1;
                ctx.stroke();
                
                // Áï™Âè∑„ÇíÊèèÁîª
                ctx.fillStyle = "#000000";
                ctx.fillText(text, circleX, circleY);
            }); 
        } 
    };
    const drawConnections = (ctx, transform, nodes, members, labelManager, obstacles, fontScale = 1.0) => {
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';

        const showStiffness = document.getElementById('show-spring-stiffness')?.checked ?? true;

        const drawTranslationalSpring = (ctx, length, width) => {
            const coils = 4;
            const step = length / coils;
            ctx.beginPath(); ctx.moveTo(0, 0);
            for (let i = 0; i < coils; i++) {
                ctx.lineTo((i + 0.25) * step, width);
                ctx.lineTo((i + 0.75) * step, -width);
                ctx.lineTo((i + 1.00) * step, 0);
            }
            ctx.stroke();
        };

        const drawRotationalSpring = (ctx, radius) => {
            ctx.beginPath();
            const points = 40;
            const maxAngle = Math.PI * 2 * 2;
            for (let i = 0; i <= points; i++) {
                const angle = (i / points) * maxAngle;
                const r = radius * (0.3 + 0.7 * (i / points));
                const x = r * Math.cos(angle);
                const y = r * Math.sin(angle);
                if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
            }
            ctx.stroke();
        };

        // „Éï„Ç©„Éº„Éû„ÉÉ„ÉàÈñ¢Êï∞ÔºàÂçò‰Ωç‰ªò„ÅçÔºâ
        const fmt = (val, unit) => {
            const uiVal = val / 1000; // ÂÜÖÈÉ®(kN/m) -> UI(kN/mm)
            
            // ‚ñº‚ñº‚ñº ‰øÆÊ≠£: ÂæÆÂ∞èÂÄ§(Ë®àÁÆó‰∏ä„ÅÆEPSÂê´„ÇÄ)„ÅØ 0 „Å®„Åó„Å¶Ë°®Á§∫ ‚ñº‚ñº‚ñº
            if (Math.abs(uiVal) < 1e-6) return `0${unit}`;

            let numStr;
            if (Math.abs(uiVal) < 0.001) numStr = uiVal.toExponential(1);
            else if (Math.abs(uiVal) >= 1000) numStr = Math.round(uiVal).toString();
            else numStr = parseFloat(uiVal.toFixed(2)).toString();
            return `${numStr}${unit}`; 
        };
        
        const fmtKr = (val) => {
            const uiVal = val * 1000; // ÂÜÖÈÉ®(kN¬∑m/rad) -> UI(kN¬∑mm/rad)
            
            // ‚ñº‚ñº‚ñº ‰øÆÊ≠£: ÂæÆÂ∞èÂÄ§„ÅØ 0 „Å®„Åó„Å¶Ë°®Á§∫ ‚ñº‚ñº‚ñº
            if (Math.abs(uiVal) < 1e-6) return `0kN¬∑mm`;

            let numStr;
            if (Math.abs(uiVal) < 0.1) numStr = uiVal.toExponential(1);
            else numStr = parseFloat(uiVal.toFixed(1)).toString();
            return `${numStr}kN¬∑mm`;
        };

        members.forEach((m) => {
            const n_i = nodes[m.i];
            const n_j = nodes[m.j];
            const p_i = transform(n_i.x, n_i.y);
            const p_j = transform(n_j.x, n_j.y);
            const dx = p_j.x - p_i.x;
            const dy = p_j.y - p_i.y;
            const angle = Math.atan2(dy, dx);

            // „Éî„É≥Êé•Âêà
            const pinRadius = 4;
            if (m.i_conn === 'pinned') {
                ctx.fillStyle = 'white'; ctx.strokeStyle = '#333'; ctx.lineWidth = 1.5;
                ctx.beginPath(); ctx.arc(p_i.x, p_i.y, pinRadius, 0, 2 * Math.PI); ctx.fill(); ctx.stroke();
            }
            if (m.j_conn === 'pinned') {
                ctx.fillStyle = 'white'; ctx.strokeStyle = '#333'; ctx.lineWidth = 1.5;
                ctx.beginPath(); ctx.arc(p_j.x, p_j.y, pinRadius, 0, 2 * Math.PI); ctx.fill(); ctx.stroke();
            }

            // „Éê„ÉçÊé•Âêà
            const drawEndSprings = (end, point, isStart) => {
                const connType = end === 'i' ? m.i_conn : m.j_conn;
                if (connType !== 'spring') return;
                const springData = end === 'i' ? m.spring_i : m.spring_j;
                if (!springData) return;

                const { Kx=0, Ky=0, Kr=0, rigidKx, rigidKy, rigidKr } = springData;
                if (rigidKx && rigidKy && rigidKr) return;

                ctx.save();
                ctx.translate(point.x, point.y);
                const currentAngle = isStart ? angle : angle + Math.PI;
                ctx.rotate(currentAngle);

                const springColor = '#e65100';
                const rotateColor = '#0277bd';
                const springLen = 12;
                const springW = 3;
                
                // „ÉÜ„Ç≠„Çπ„ÉàÊèèÁîªÁî®ÊÉÖÂ†±„ÅÆÂèéÈõÜ
                const cos = Math.cos(currentAngle);
                const sin = Math.sin(currentAngle);
                const labelsToDraw = [];

                // --- Kx (Ëª∏ÊñπÂêë) ---
                if (!rigidKx) {
                    ctx.strokeStyle = springColor; ctx.lineWidth = 1.5;
                    ctx.save(); ctx.translate(3, 0);
                    drawTranslationalSpring(ctx, springLen, springW);
                    ctx.beginPath(); ctx.moveTo(springLen, -4); ctx.lineTo(springLen, 4); ctx.stroke();
                    ctx.restore();

                    // „Ç¢„É≥„Ç´„ÉºÁÇπ: „Éê„Éç„ÅÆ‰∏≠Â§Æ
                    const lx = 3 + springLen / 2, ly = 0;
                    labelsToDraw.push({ 
                        text: `Kx:${fmt(Kx, 'kN/mm')}`, 
                        x: point.x + lx*cos - ly*sin, 
                        y: point.y + lx*sin + ly*cos,
                        // ‰∏¶ÈÄ≤„Éê„ÉçËâ≤„Å´Âêà„Çè„Åõ„Çã
                        color: springColor
                    });
                }

                // --- Ky („Åõ„ÇìÊñ≠ÊñπÂêë) ---
                if (!rigidKy) {
                    ctx.strokeStyle = springColor; ctx.lineWidth = 1.5;
                    ctx.save(); ctx.translate(0, -4); ctx.rotate(-Math.PI / 2);
                    drawTranslationalSpring(ctx, springLen, springW);
                    ctx.beginPath(); ctx.moveTo(springLen, -4); ctx.lineTo(springLen, 4); ctx.stroke();
                    ctx.restore();

                    // „Ç¢„É≥„Ç´„ÉºÁÇπ: „Éê„Éç„ÅÆ‰∏≠Â§Æ
                    const lx = 0, ly = -4 - springLen / 2;
                    labelsToDraw.push({ 
                        text: `Ky:${fmt(Ky, 'kN/mm')}`, 
                        x: point.x + lx*cos - ly*sin, 
                        y: point.y + lx*sin + ly*cos,
                        // ‰∏¶ÈÄ≤„Éê„ÉçËâ≤„Å´Âêà„Çè„Åõ„Çã
                        color: springColor
                    });
                }

                // --- Kr (ÂõûËª¢) ---
                if (!rigidKr) {
                    ctx.strokeStyle = rotateColor; ctx.lineWidth = 1.5;
                    ctx.save(); drawRotationalSpring(ctx, 7); ctx.restore();

                    // „Ç¢„É≥„Ç´„ÉºÁÇπ: Ê∏¶Â∑ª„Åç„ÅÆÂè≥Êñú„ÇÅ‰∏ä
                    const lx = 5, ly = 5;
                    labelsToDraw.push({ 
                        text: `Kr:${fmtKr(Kr)}`, 
                        x: point.x + lx*cos - ly*sin, 
                        y: point.y + lx*sin + ly*cos,
                        color: rotateColor
                    });
                }

                ctx.restore(); // Â∫ßÊ®ôÁ≥ª„ÇíÊàª„Åô

                // „ÉÜ„Ç≠„Çπ„Éà„ÅÆÊèèÁîª (LabelManager„Çí‰ΩøÁî®)
                if (showStiffness && labelManager && labelsToDraw.length > 0) {
                    labelsToDraw.forEach(l => {
                        labelManager.draw(ctx, l.text, l.x, l.y, obstacles, {
                            drawLeaderLine: true,
                            color: l.color
                        });
                    });
                }
            };

            drawEndSprings('i', p_i, true);
            drawEndSprings('j', p_j, false);
        });
    };
    const drawBoundaryConditions = (ctx, transform, nodes, members = []) => { 
        const size = 10; 
        nodes.forEach((node, index) => { 
            // s„Éó„É≠„Éë„ÉÜ„Ç£„Åæ„Åü„ÅØsupport„Éó„É≠„Éë„ÉÜ„Ç£„Çí„ÉÅ„Çß„ÉÉ„ÇØ
            const support = node.s || node.support;
            if (support === 'free' || support === 'f') return; 
            
            const pos = transform(node.x, node.y); 
            ctx.strokeStyle = '#008000'; 
            ctx.fillStyle = '#008000'; 
            ctx.lineWidth = 1.5; 
            ctx.beginPath(); 
            
            if (support === 'fixed' || support === 'x' || support === 'fixed-x' || support === 'fixed-top') { 
                // Âõ∫ÂÆöÊîØÁÇπ„ÅÆÂêë„Åç„ÇíËá™ÂãïÂà§ÂÆö
                let direction = 'floor'; // „Éá„Éï„Ç©„É´„Éà: Â∫äÂõ∫ÂÆö(‰∏ãÂêë„Åç)
                
                // ÁØÄÁÇπ„Å´Êé•Á∂ö„Åô„ÇãÈÉ®Êùê„ÇíÊé¢„Åô
                const connectedMembers = members.filter(m => m.i === index || m.j === index);
                
                if (connectedMembers.length > 0) {
                    let allDown = true;
                    let allRight = true;
                    let allLeft = true;
                    let isHorizontal = true;

                    for (const m of connectedMembers) {
                        const otherNodeIndex = (m.i === index) ? m.j : m.i;
                        const otherNode = nodes[otherNodeIndex];
                        
                        const dx = otherNode.x - node.x;
                        const dy = otherNode.y - node.y;
                        
                        // Êï∞Â≠¶Â∫ßÊ®ôÁ≥ª(‰∏äÂêë„ÅçÊ≠£)„Åß„ÅÆÂà§ÂÆö
                        if (dy > 1e-5) allDown = false; // ‰∏ä„Å´„ÅÇ„ÇãÈÉ®Êùê„Åå„ÅÇ„Çã
                        if (dx < -1e-5) allRight = false; // Â∑¶„Å´„ÅÇ„ÇãÈÉ®Êùê„Åå„ÅÇ„Çã
                        if (dx > 1e-5) allLeft = false; // Âè≥„Å´„ÅÇ„ÇãÈÉ®Êùê„Åå„ÅÇ„Çã
                        
                        // Ê∞¥Âπ≥Âà§ÂÆö: ÂûÇÁõ¥ÊàêÂàÜ„ÅåÊ∞¥Âπ≥ÊàêÂàÜ„ÅÆÂçäÂàÜ‰ª•‰∏ã„Å™„ÇâÊ∞¥Âπ≥„Å®„Åø„Å™„Åô
                        if (Math.abs(dy) > Math.abs(dx) * 0.5) isHorizontal = false;
                    }

                    if (allDown && !isHorizontal) direction = 'ceiling';
                    else if (allRight && isHorizontal) direction = 'left-wall';
                    else if (allLeft && isHorizontal) direction = 'right-wall';
                }

                if (direction === 'floor') {
                    // Â∫äÂõ∫ÂÆö (‰∏ãÂêë„Åç)
                    ctx.moveTo(pos.x - size, pos.y + size); 
                    ctx.lineTo(pos.x + size, pos.y + size); 
                    for(let i=0; i <= 5; i++){ 
                        ctx.moveTo(pos.x - size + i*size/2.5, pos.y + size); 
                        ctx.lineTo(pos.x - size + i*size/2.5 - size/2, pos.y + size + size/2); 
                    } 
                } else if (direction === 'left-wall') {
                    // Â∑¶Â£ÅÂõ∫ÂÆö (Âè≥Âêë„Åç) - Â£Å„ÅåÂ∑¶„Å´„ÅÇ„Çã
                    ctx.moveTo(pos.x - size, pos.y - size);
                    ctx.lineTo(pos.x - size, pos.y + size);
                    for(let i=0; i <= 5; i++){
                        ctx.moveTo(pos.x - size, pos.y - size + i*size/2.5);
                        ctx.lineTo(pos.x - size - size/2, pos.y - size + i*size/2.5 + size/2);
                    }
                } else if (direction === 'right-wall') {
                    // Âè≥Â£ÅÂõ∫ÂÆö (Â∑¶Âêë„Åç) - Â£Å„ÅåÂè≥„Å´„ÅÇ„Çã
                    ctx.moveTo(pos.x + size, pos.y - size);
                    ctx.lineTo(pos.x + size, pos.y + size);
                    for(let i=0; i <= 5; i++){
                        ctx.moveTo(pos.x + size, pos.y - size + i*size/2.5);
                        ctx.lineTo(pos.x + size + size/2, pos.y - size + i*size/2.5 + size/2);
                    }
                } else if (direction === 'ceiling') {
                    // Â§©‰∫ïÂõ∫ÂÆö (‰∏äÂêë„Åç)
                    ctx.moveTo(pos.x - size, pos.y - size);
                    ctx.lineTo(pos.x + size, pos.y - size);
                    for(let i=0; i <= 5; i++){
                        ctx.moveTo(pos.x - size + i*size/2.5, pos.y - size);
                        ctx.lineTo(pos.x - size + i*size/2.5 - size/2, pos.y - size - size/2);
                    }
                }
            } else if (support === 'pinned' || support === 'p') { 
                ctx.moveTo(pos.x, pos.y); 
                ctx.lineTo(pos.x - size, pos.y + size); 
                ctx.lineTo(pos.x + size, pos.y + size); 
                ctx.closePath(); 
                ctx.stroke(); 
                ctx.moveTo(pos.x - size*1.2, pos.y + size); 
                ctx.lineTo(pos.x + size*1.2, pos.y + size); 
            } else if (support === 'roller' || support === 'r' || support === 'roller_y_fixed') { 
                // Ê∞¥Âπ≥Ëá™Áî± (Â∫ä„É≠„Éº„É©„Éº)
                ctx.moveTo(pos.x, pos.y); 
                ctx.lineTo(pos.x - size, pos.y + size); 
                ctx.lineTo(pos.x + size, pos.y + size); 
                ctx.closePath(); 
                ctx.stroke(); 
                ctx.moveTo(pos.x - size, pos.y + size + 3); 
                ctx.lineTo(pos.x + size, pos.y + size + 3); 
            } else if (support === 'roller_x_fixed') {
                // ÂûÇÁõ¥Ëá™Áî± (Â£Å„É≠„Éº„É©„Éº) - 90Â∫¶ÂõûËª¢„Åó„Å¶ÊèèÁîª
                // Âè≥ÂÅ¥„Å´Â£Å„Åå„ÅÇ„Çã„Ç§„É°„Éº„Ç∏„ÅßÊèèÁîª
                ctx.moveTo(pos.x, pos.y);
                ctx.lineTo(pos.x + size, pos.y - size);
                ctx.lineTo(pos.x + size, pos.y + size);
                ctx.closePath();
                ctx.stroke();
                // „É≠„Éº„É©„Éº„ÅÆÁ∑ö
                ctx.moveTo(pos.x + size + 3, pos.y - size);
                ctx.lineTo(pos.x + size + 3, pos.y + size);
            }
            ctx.stroke(); 
        }); 
    };
    const drawDimensions = (ctx, transform, nodes, members, labelManager, obstacles, fontScale = 1.0) => { 
        const offset = 15; 
        ctx.strokeStyle = '#0000ff'; 
        ctx.lineWidth = 1; 
        
        // ÈÉ®ÊùêÂØ∏Ê≥ïË°®Á§∫„ÅÆÂà∂Âæ°
        const showMemberDimensions = document.getElementById('show-member-dimensions')?.checked ?? true;
        if (!showMemberDimensions) {
            return;
        }
        
        members.forEach(m => { 
            const n1 = nodes[m.i]; 
            const n2 = nodes[m.j]; 
            const p1 = transform(n1.x, n1.y); 
            const p2 = transform(n2.x, n2.y); 
            const midX = (p1.x + p2.x) / 2; 
            const midY = (p1.y + p2.y) / 2; 
            const angle = Math.atan2(p2.y - p1.y, p2.x - p1.x); 
            const offsetX = offset * Math.sin(angle); 
            const offsetY = -offset * Math.cos(angle); 
            const labelTargetX = midX + offsetX; 
            const labelTargetY = midY + offsetY; 
            const labelText = `${m.length.toFixed(2)}m`; 
            ctx.fillStyle = '#0000ff'; 
            labelManager.draw(ctx, labelText, labelTargetX, labelTargetY, obstacles); 
        }); 
    };
    const drawExternalLoads = (ctx, transform, nodes, members, nodeLoads, memberLoads, memberSelfWeights, nodeSelfWeights, labelManager, obstacles, fontScale = 1.0) => { 
        const arrowSize = 10; 
        const loadScale = 3; 
        
        // Ë°®Á§∫Âà∂Âæ°Áî®„ÉÅ„Çß„ÉÉ„ÇØ„Éú„ÉÉ„ÇØ„Çπ„ÅÆÁä∂ÊÖã„ÇíÂèñÂæó
        const showExternalLoads = document.getElementById('show-external-loads')?.checked ?? true;
        const showSelfWeight = document.getElementById('show-self-weight')?.checked ?? true;
        const showMemberDimensions = document.getElementById('show-member-dimensions')?.checked ?? true;
        
        // ‰∏°Êñπ„ÅÆ„ÉÅ„Çß„ÉÉ„ÇØ„ÅåÂ§ñ„Çå„Å¶„ÅÑ„ÇãÂ†¥Âêà„ÅØ‰Ωï„ÇÇÊèèÁîª„Åó„Å™„ÅÑ
        if (!showExternalLoads && !showSelfWeight) {
            return;
        }
        
        ctx.strokeStyle = '#ff4500'; 
        ctx.fillStyle = '#ff4500'; 
        ctx.lineWidth = 1.5; 
        
        // ÂàÜÂ∏ÉËç∑Èáç„ÅÆ„ÉÜ„Ç≠„Çπ„ÉàÈ†òÂüü„ÇíÈöúÂÆ≥Áâ©„Å®„Åó„Å¶ËøΩÂä†
        const loadObstacles = [...obstacles];
        
        // „Åæ„ÅöÂàÜÂ∏ÉËç∑Èáç„ÇíÊèèÁîª„Åó„Å¶„ÄÅ„Åù„ÅÆ„ÉÜ„Ç≠„Çπ„ÉàÈ†òÂüü„Å®Áü¢Âç∞È†òÂüü„ÇíÈöúÂÆ≥Áâ©„Å´ËøΩÂä†
        memberLoads.forEach(load => { 
            if (load.w === 0) return; 
            
            // Ëç∑Èáç„Çø„Ç§„Éó„Å´Âøú„Åò„ÅüË°®Á§∫Âà∂Âæ°
            if (load.isFromSelfWeight) {
                // Ëá™ÈáçËç∑Èáç„ÅÆÂ†¥Âêà
                if (!showSelfWeight) return;
            } else {
                // Â§ñÈÉ®Ëç∑Èáç„ÅÆÂ†¥Âêà
                if (!showExternalLoads) return;
            }
            
            // ÊóßÊù•„ÅÆself-weight„ÉÅ„Çß„ÉÉ„ÇØ„Éú„ÉÉ„ÇØ„Çπ„Å®„ÅÆ‰∫íÊèõÊÄß„Çí‰øùÊåÅ
            const considerSelfWeightCheckbox = document.getElementById('consider-self-weight');
            const isSelfWeightChecked = considerSelfWeightCheckbox && considerSelfWeightCheckbox.checked;
            
            // Ëá™ÈáçËç∑Èáç„Åß„ÉÅ„Çß„ÉÉ„ÇØ„Éú„ÉÉ„ÇØ„Çπ„ÅåOFF„ÅÆÂ†¥Âêà„ÅØ„Çπ„Ç≠„ÉÉ„Éó
            if (load.isFromSelfWeight && !isSelfWeightChecked) {
                return;
            }
            
            const member = members[load.memberIndex]; 
            const p1 = transform(nodes[member.i].x, nodes[member.i].y); 
            const p2 = transform(nodes[member.j].x, nodes[member.j].y); 
            const angle = Math.atan2(p2.y - p1.y, p2.x - p1.x); 
            const numArrows = 5; 
            const arrowLength = arrowSize * 1.5; 
            const arrowHeadSize = 5; 
            const dir = Math.sign(load.w); 
            const perpVecX = Math.sin(angle); 
            const perpVecY = -Math.cos(angle); 
            const firstArrowTipX = p1.x + dir * arrowLength * perpVecX; 
            const firstArrowTipY = p1.y + dir * arrowLength * perpVecY; 
            const lastArrowTipX = p2.x + dir * arrowLength * perpVecX; 
            const lastArrowTipY = p2.y + dir * arrowLength * perpVecY; 
            
            // ÂàÜÂ∏ÉËç∑Èáç„ÅÆÁü¢Âç∞È†òÂüü„Çí‰∫ãÂâç„Å´Ë®àÁÆó„Åó„Å¶ÈöúÂÆ≥Áâ©„Å®„Åó„Å¶ËøΩÂä†
            const arrowMinX = Math.min(p1.x, p2.x, firstArrowTipX, lastArrowTipX);
            const arrowMaxX = Math.max(p1.x, p2.x, firstArrowTipX, lastArrowTipX);
            const arrowMinY = Math.min(p1.y, p2.y, firstArrowTipY, lastArrowTipY);
            const arrowMaxY = Math.max(p1.y, p2.y, firstArrowTipY, lastArrowTipY);
            const arrowPadding = 5;
            const arrowObstacle = {
                x1: arrowMinX - arrowPadding,
                y1: arrowMinY - arrowPadding,
                x2: arrowMaxX + arrowPadding,
                y2: arrowMaxY + arrowPadding
            };
            loadObstacles.push(arrowObstacle);
            
            ctx.beginPath(); 
            ctx.moveTo(firstArrowTipX, firstArrowTipY); 
            ctx.lineTo(lastArrowTipX, lastArrowTipY); 
            ctx.stroke(); 
            
            for (let i = 0; i <= numArrows; i++) { 
                const ratio = i / numArrows; 
                const memberX = p1.x + (p2.x - p1.x) * ratio; 
                const memberY = p1.y + (p2.y - p1.y) * ratio; 
                const baseX = memberX + dir * arrowLength * perpVecX; 
                const baseY = memberY + dir * arrowLength * perpVecY; 
                ctx.beginPath(); 
                ctx.moveTo(baseX, baseY); 
                ctx.lineTo(memberX, memberY); 
                const headAngle = Math.atan2(memberY - baseY, memberX - baseX); 
                ctx.moveTo(memberX, memberY); 
                ctx.lineTo(memberX - arrowHeadSize * Math.cos(headAngle - Math.PI / 6), memberY - arrowHeadSize * Math.sin(headAngle - Math.PI / 6)); 
                ctx.moveTo(memberX, memberY); 
                ctx.lineTo(memberX - arrowHeadSize * Math.cos(headAngle + Math.PI / 6), memberY - arrowHeadSize * Math.sin(headAngle + Math.PI / 6)); 
                ctx.stroke(); 
            } 
            const textOffset = arrowLength + 10; 
            const textX = (p1.x + p2.x) / 2 + dir * textOffset * perpVecX; 
            const textY = (p1.y + p2.y) / 2 + dir * textOffset * perpVecY; 
            ctx.fillStyle = '#ff4500'; 
            
            // Á≠âÂàÜÂ∏ÉËç∑Èáç„ÅÆ„ÉÜ„Ç≠„Çπ„ÉàË°®Á§∫ÔºàËá™Èáç„Åß„Å™„ÅÑËç∑Èáç„ÅÆ„ÅøÔºâ
            const loadText = `${Math.abs(load.w).toFixed(2)}kN/m`;
            labelManager.draw(ctx, loadText, textX, textY, [...obstacles, arrowObstacle], {
                type: 'member-load-w',
                index: load.memberIndex,
                value: load.w
            }); 
            
            // ÂàÜÂ∏ÉËç∑Èáç„ÅÆ„ÉÜ„Ç≠„Çπ„ÉàÈ†òÂüü„ÇíÈöúÂÆ≥Áâ©„Å®„Åó„Å¶ËøΩÂä†
            const displayText = loadText;
            const metrics = ctx.measureText(displayText);
            const w = metrics.width;
            const h = 12;
            const padding = 6;
            loadObstacles.push({
                x1: textX - w/2 - padding,
                y1: textY - h - padding,
                x2: textX + w/2 + padding,
                y2: textY + padding
            });
        }); 
        
        // Á≠âÂàÜÂ∏ÉËç∑ÈáçÊèèÁîªÂæå„Å´Ëâ≤„Çí„É™„Çª„ÉÉ„Éà
        ctx.strokeStyle = '#ff4500';
        ctx.fillStyle = '#ff4500';
        
        // Ëá™ÈáçËç∑Èáç„ÇíÁã¨Á´ã„Åó„Å¶ÊèèÁîªÔºàË°®Á§∫Âà∂Âæ°„ÉÅ„Çß„ÉÉ„ÇØ„Éú„ÉÉ„ÇØ„Çπ„ÅåON„ÅÆÂ†¥Âêà„ÅÆ„ÅøÔºâ
        const isSelfWeightChecked = document.getElementById('consider-self-weight-checkbox')?.checked;
        if (showSelfWeight && isSelfWeightChecked && memberSelfWeights && memberSelfWeights.length > 0) {
            ctx.strokeStyle = '#00aa00'; // Ëá™Èáç„ÅØÁ∑ëËâ≤„ÅßË°®Á§∫
            ctx.fillStyle = '#00aa00';
            
            memberSelfWeights.forEach(load => {
                const member = members[load.memberIndex];
                const n1 = nodes[member.i], n2 = nodes[member.j];
                const p1 = transform(n1.x, n1.y), p2 = transform(n2.x, n2.y);
                const memberNumber = load.memberIndex + 1;
                
                if (load.loadType === 'distributed') {
                    // Ê∞¥Âπ≥ÈÉ®ÊùêÔºöÁ≠âÂàÜÂ∏ÉËç∑Èáç„Å®„Åó„Å¶ÊèèÁîª
                    if (load.w === 0) return;
                    
                    const L = Math.sqrt((p2.x - p1.x)**2 + (p2.y - p1.y)**2);
                    const arrowSpacing = 20, numArrows = Math.max(2, Math.floor(L / arrowSpacing));
                    const arrowLength = 15; // arrowLength„ÇíÂ§ñÂÅ¥„ÅßÂÆöÁæ©
                    
                    // ÂûÇÁõ¥‰∏ãÂêë„Åç„ÅÆÁü¢Âç∞„ÇíÊèèÁîª
                    for (let i = 0; i <= numArrows; i++) {
                        const t = i / numArrows;
                        const x = p1.x + t * (p2.x - p1.x);
                        const y = p1.y + t * (p2.y - p1.y);
                        
                        ctx.beginPath();
                        ctx.moveTo(x, y - arrowLength);
                        ctx.lineTo(x, y);
                        ctx.lineTo(x - 3, y - 5);
                        ctx.moveTo(x, y);
                        ctx.lineTo(x + 3, y - 5);
                        ctx.stroke();
                    }
                    
                    // Ê∞¥Âπ≥Á∑ö„ÇíÊèèÁîª
                    ctx.beginPath();
                    ctx.moveTo(p1.x, p1.y - arrowLength);
                    ctx.lineTo(p2.x, p2.y - arrowLength);
                    ctx.stroke();
                    
                    const textX = (p1.x + p2.x) / 2;
                    const textY = (p1.y + p2.y) / 2 - 25;
                    const loadText = `ÈÉ®Êùê${memberNumber}Ëá™ÈáçÔºö${Math.abs(load.w).toFixed(2)}kN/m`;
                    labelManager.draw(ctx, loadText, textX, textY, loadObstacles);
                    
                } else if (load.loadType === 'concentrated') {
                    // ÂûÇÁõ¥ÈÉ®ÊùêÔºöÈõÜ‰∏≠Ëç∑Èáç„Å®„Åó„Å¶ÊèèÁîª
                    const lowerY = Math.max(p1.y, p2.y);
                    const nodeX = p1.y > p2.y ? p1.x : p2.x;
                    const arrowLength = 20;
                    const arrowSize = 8;
                    
                    // ÂûÇÁõ¥‰∏ãÂêë„Åç„ÅÆÈõÜ‰∏≠Ëç∑ÈáçÁü¢Âç∞
                    ctx.beginPath();
                    ctx.moveTo(nodeX, lowerY - arrowLength);
                    ctx.lineTo(nodeX, lowerY);
                    ctx.lineTo(nodeX - arrowSize/2, lowerY - arrowSize);
                    ctx.moveTo(nodeX, lowerY);
                    ctx.lineTo(nodeX + arrowSize/2, lowerY - arrowSize);
                    ctx.stroke();
                    
                    const textX = nodeX + 15;
                    const textY = lowerY - arrowLength/2;
                    // ÈõÜ‰∏≠Ëç∑Èáç„ÅÆÂÄãÂà•Ë°®Á§∫„ÅØÂâäÈô§ÔºàÁØÄÁÇπÂêàË®à„ÅßË°®Á§∫Ôºâ
                    // const loadText = `ÈÉ®Êùê${memberNumber}Ëá™ÈáçÔºö${load.totalWeight.toFixed(2)}kN`;
                    // labelManager.draw(ctx, loadText, textX, textY, loadObstacles);
                    
                } else if (load.loadType === 'mixed') {
                    // Êñú„ÇÅÈÉ®ÊùêÔºöÊ∑∑ÂêàËç∑Èáç„Å®„Åó„Å¶ÊèèÁîª
                    
                    // ÂûÇÁõ¥ÊàêÂàÜÔºàÁ≠âÂàÜÂ∏ÉËç∑ÈáçÔºâ„ÅÆÊèèÁîª
                    if (load.w > 0) {
                        const L = Math.sqrt((p2.x - p1.x)**2 + (p2.y - p1.y)**2);
                        const arrowSpacing = 20, numArrows = Math.max(2, Math.floor(L / arrowSpacing));
                        
                        for (let i = 0; i <= numArrows; i++) {
                            const t = i / numArrows;
                            const x = p1.x + t * (p2.x - p1.x);
                            const y = p1.y + t * (p2.y - p1.y);
                            const arrowLength = 12;
                            
                            // ÂûÇÁõ¥‰∏ãÂêë„Åç„ÅÆÁü¢Âç∞
                            ctx.beginPath();
                            ctx.moveTo(x, y - arrowLength);
                            ctx.lineTo(x, y);
                            ctx.lineTo(x - 2, y - 4);
                            ctx.moveTo(x, y);
                            ctx.lineTo(x + 2, y - 4);
                            ctx.stroke();
                        }
                    }
                    
                    // Ê∞¥Âπ≥ÊàêÂàÜÔºàÁØÄÁÇπËç∑ÈáçÔºâ„ÅÆÊèèÁîª
                    if (load.horizontalComponent > 0) {
                        const arrowLength = 15;
                        const arrowSize = 6;
                        const horizontalDir = (p2.x - p1.x) > 0 ? 1 : -1;
                        
                        // ‰∏°Á´ØÁØÄÁÇπ„Å´Ê∞¥Âπ≥Áü¢Âç∞
                        [p1, p2].forEach((point, idx) => {
                            ctx.beginPath();
                            ctx.moveTo(point.x - arrowLength * horizontalDir, point.y);
                            ctx.lineTo(point.x, point.y);
                            ctx.lineTo(point.x - arrowSize * horizontalDir, point.y - arrowSize/2);
                            ctx.moveTo(point.x, point.y);
                            ctx.lineTo(point.x - arrowSize * horizontalDir, point.y + arrowSize/2);
                            ctx.stroke();
                        });
                    }
                    
                    const textX = (p1.x + p2.x) / 2;
                    const textY = (p1.y + p2.y) / 2 - 20;
                    // Ê∑∑ÂêàËç∑Èáç„ÅÆÂÄãÂà•Ë°®Á§∫„ÅØÂâäÈô§ÔºàÁØÄÁÇπÂêàË®à„ÅßË°®Á§∫Ôºâ
                    // const loadText = `ÈÉ®Êùê${memberNumber}Ëá™ÈáçÔºö${load.totalWeight.toFixed(2)}kN (Ê∑∑Âêà)`;
                    // labelManager.draw(ctx, loadText, textX, textY, loadObstacles);
                }
                
                // Ëá™ÈáçËç∑Èáç„ÅÆ„ÉÜ„Ç≠„Çπ„ÉàÈ†òÂüü„ÇíÈöúÂÆ≥Áâ©„Å®„Åó„Å¶ËøΩÂä†ÔºàÁ≠âÂàÜÂ∏ÉËç∑Èáç„ÅÆ„ÅøÔºâ
                if (load.loadType === 'distributed') {
                    const displayText = `ÈÉ®Êùê${memberNumber}Ëá™ÈáçÔºö${Math.abs(load.w).toFixed(2)}kN/m`;
                    const metrics = ctx.measureText(displayText);
                    const w = metrics.width;
                    const h = 12;
                    const padding = 6;
                    const textX = (p1.x + p2.x) / 2;
                    const textY = (p1.y + p2.y) / 2 - 25;
                    loadObstacles.push({
                        x1: textX - w/2 - padding,
                        y1: textY - h - padding,
                        x2: textX + w/2 + padding,
                        y2: textY + padding
                    });
                }
            });
        }
        
        // Ê¨°„Å´Â§ñÈÉ®Ëç∑Èáç„Å´„Çà„ÇãÈõÜ‰∏≠Ëç∑Èáç„ÇíËµ§Ëâ≤„ÅßÊèèÁîª
        console.log(`üîç Â§ñÈÉ®Ëç∑ÈáçÊèèÁîª„ÉÅ„Çß„ÉÉ„ÇØ: showExternalLoads=${showExternalLoads}, nodeLoadsÊï∞=${nodeLoads.length}`);
        if (showExternalLoads) {
            nodeLoads.forEach(load => { 
                console.log(`üîç Â§ñÈÉ®Ëç∑ÈáçÂá¶ÁêÜ: ÁØÄÁÇπ${load.nodeIndex + 1}, px=${load.px}, py=${load.py}, mz=${load.mz}`);
                if (load.px === 0 && load.py === 0 && load.mz === 0) return; 
                const node = nodes[load.nodeIndex]; 
                const pos = transform(node.x, node.y); 
                
                // Â§ñÈÉ®Ëç∑ÈáçÁî®„ÅÆËµ§Ëâ≤„ÅßÊèèÁîª
                ctx.strokeStyle = '#ff4500';
                ctx.fillStyle = '#ff4500';
            
            if(load.px !== 0){ 
                console.log(`üîç Ê∞¥Âπ≥Ëç∑ÈáçÊèèÁîª: ÁØÄÁÇπ${load.nodeIndex + 1}, px=${load.px}, pos=(${pos.x}, ${pos.y})`);
                const dir = Math.sign(load.px); 
                ctx.beginPath(); 
                ctx.moveTo(pos.x - arrowSize * loadScale * dir, pos.y); 
                ctx.lineTo(pos.x, pos.y); 
                ctx.lineTo(pos.x - arrowSize * dir, pos.y - arrowSize/2); 
                ctx.moveTo(pos.x, pos.y); 
                ctx.lineTo(pos.x - arrowSize * dir, pos.y + arrowSize/2); 
                ctx.stroke(); 
                
                // Ëç∑ÈáçÂÄ§„ÅÆ„ÉÜ„Ç≠„Çπ„ÉàË°®Á§∫„ÇíÁü¢Âç∞„ÅÆÂÖàÁ´ØËøë„Åè„Å´ÈÖçÁΩÆ
                const textX = pos.x - (arrowSize * loadScale * 0.7) * dir;
                const textY = pos.y;
                ctx.fillStyle = '#ff4500';
                labelManager.draw(ctx, `${load.px}kN`, textX, textY, loadObstacles, {
                    type: 'node-load-px',
                    index: load.nodeIndex,
                    value: load.px
                });
            } 
            
            if(load.py !== 0){ 
                const dir = Math.sign(load.py); 
                ctx.beginPath(); 
                ctx.moveTo(pos.x, pos.y + arrowSize * loadScale * dir); 
                ctx.lineTo(pos.x, pos.y); 
                ctx.lineTo(pos.x - arrowSize/2, pos.y + arrowSize * dir); 
                ctx.moveTo(pos.x, pos.y); 
                ctx.lineTo(pos.x + arrowSize/2, pos.y + arrowSize * dir); 
                ctx.stroke(); 
                
                // Ëç∑ÈáçÂÄ§„ÅÆ„ÉÜ„Ç≠„Çπ„ÉàË°®Á§∫„ÇíÁü¢Âç∞„ÅÆÂÖàÁ´ØËøë„Åè„Å´ÈÖçÁΩÆ
                const textX = pos.x;
                const textY = pos.y + (arrowSize * loadScale * 0.8) * dir;
                ctx.fillStyle = '#ff4500';
                labelManager.draw(ctx, `${load.py}kN`, textX, textY, loadObstacles, {
                    type: 'node-load-py',
                    index: load.nodeIndex,
                    value: load.py
                });
            } 
            
            if(load.mz !== 0){ 
                const dir = -Math.sign(load.mz); 
                const r = arrowSize * 1.5; 
                const arrowHeadSize = 5; 
                const startAngle = Math.PI; 
                const endAngle = Math.PI * 2.5; 
                ctx.beginPath(); 
                ctx.arc(pos.x, pos.y, r, startAngle, endAngle, dir < 0); 
                ctx.stroke(); 
                const endX = pos.x + r * Math.cos(endAngle); 
                const endY = pos.y + r * Math.sin(endAngle); 
                const smallAngleOffset = 0.05 * (dir > 0 ? -1 : 1); 
                const beforeX = pos.x + r * Math.cos(endAngle + smallAngleOffset); 
                const beforeY = pos.y + r * Math.sin(endAngle + smallAngleOffset); 
                const tangentAngle = Math.atan2(endY - beforeY, endX - beforeX); 
                ctx.beginPath(); 
                ctx.moveTo(endX, endY); 
                ctx.lineTo(endX - arrowHeadSize * Math.cos(tangentAngle - Math.PI / 6), endY - arrowHeadSize * Math.sin(tangentAngle - Math.PI / 6)); 
                ctx.lineTo(endX - arrowHeadSize * Math.cos(tangentAngle + Math.PI / 6), endY - arrowHeadSize * Math.sin(tangentAngle + Math.PI / 6)); 
                ctx.closePath(); 
                ctx.fill(); 
                
                // „É¢„Éº„É°„É≥„ÉàËç∑ÈáçÂÄ§„ÅÆ„ÉÜ„Ç≠„Çπ„ÉàË°®Á§∫„ÇíÁü¢Âç∞„ÅÆËøë„Åè„Å´ÈÖçÁΩÆ
                const textX = pos.x;
                const textY = pos.y - r * 0.7;
                ctx.fillStyle = '#ff4500';
                labelManager.draw(ctx, `${load.mz}kN¬∑m`, textX, textY, loadObstacles, {
                    type: 'node-load-mz',
                    index: load.nodeIndex,
                    value: load.mz
                });
            } 
            });
        }
        
        // Ëá™Èáç„Å´„Çà„ÇãÈõÜ‰∏≠Ëç∑Èáç„ÇíÁ∑ëËâ≤„ÅßÊèèÁîª
        if (showSelfWeight) {
            // 1. ÂÄãÂà•„ÅÆÁü¢Âç∞ÊèèÁîª
            nodeSelfWeights.forEach(load => { 
                if (load.px === 0 && load.py === 0 && load.mz === 0) return; 
                const node = nodes[load.nodeIndex]; 
                const pos = transform(node.x, node.y); 
                
                // Ëá™ÈáçËç∑ÈáçÁî®„ÅÆÁ∑ëËâ≤„ÅßÊèèÁîª
                ctx.strokeStyle = '#32CD32';
                ctx.fillStyle = '#32CD32';
            
            if(load.px !== 0){ 
                const dir = Math.sign(load.px); 
                ctx.beginPath(); 
                ctx.moveTo(pos.x - arrowSize * loadScale * dir, pos.y); 
                ctx.lineTo(pos.x, pos.y); 
                ctx.lineTo(pos.x - arrowSize * dir, pos.y - arrowSize/2); 
                ctx.moveTo(pos.x, pos.y); 
                ctx.lineTo(pos.x - arrowSize * dir, pos.y + arrowSize/2); 
                ctx.stroke(); 
            } 
            
            if(load.py !== 0){ 
                const dir = Math.sign(load.py); 
                ctx.beginPath(); 
                ctx.moveTo(pos.x, pos.y + arrowSize * loadScale * dir); 
                ctx.lineTo(pos.x, pos.y); 
                ctx.lineTo(pos.x - arrowSize/2, pos.y + arrowSize * dir); 
                ctx.moveTo(pos.x, pos.y); 
                ctx.lineTo(pos.x + arrowSize/2, pos.y + arrowSize * dir); 
                ctx.stroke(); 
            } 
            
            if(load.mz !== 0){ 
                const dir = -Math.sign(load.mz); 
                const r = arrowSize * 1.5; 
                const arrowHeadSize = 5; 
                const startAngle = Math.PI; 
                const endAngle = Math.PI * 2.5; 
                ctx.beginPath(); 
                ctx.arc(pos.x, pos.y, r, startAngle, endAngle, dir < 0); 
                ctx.stroke(); 
                const endX = pos.x + r * Math.cos(endAngle); 
                const endY = pos.y + r * Math.sin(endAngle); 
                const smallAngleOffset = 0.05 * (dir > 0 ? -1 : 1); 
                const beforeX = pos.x + r * Math.cos(endAngle + smallAngleOffset); 
                const beforeY = pos.y + r * Math.sin(endAngle + smallAngleOffset); 
                const tangentAngle = Math.atan2(endY - beforeY, endX - beforeX); 
                ctx.beginPath(); 
                ctx.moveTo(endX, endY); 
                ctx.lineTo(endX - arrowHeadSize * Math.cos(tangentAngle - Math.PI / 6), endY - arrowHeadSize * Math.sin(tangentAngle - Math.PI / 6)); 
                ctx.lineTo(endX - arrowHeadSize * Math.cos(tangentAngle + Math.PI / 6), endY - arrowHeadSize * Math.sin(tangentAngle + Math.PI / 6)); 
                ctx.closePath(); 
                ctx.fill(); 
            }
        });
        
        // 2. ÁØÄÁÇπ„Åî„Å®„ÅÆÂêàË®àËç∑Èáç„ÇíË®àÁÆó„Åó„Å¶„É©„Éô„É´Ë°®Á§∫
        const nodeWeightSummary = new Map();
        console.log('üìä nodeSelfWeightsË©≥Á¥∞:');
        nodeSelfWeights.forEach((load, idx) => {
            console.log(`  [${idx}] ÁØÄÁÇπ${load.nodeIndex + 1}: px=${load.px.toFixed(3)}, py=${load.py.toFixed(3)}, mz=${load.mz.toFixed(3)}`);
            
            const nodeIndex = load.nodeIndex;
            if (!nodeWeightSummary.has(nodeIndex)) {
                nodeWeightSummary.set(nodeIndex, { px: 0, py: 0, mz: 0 });
            }
            
            const summary = nodeWeightSummary.get(nodeIndex);
            summary.px += load.px;
            summary.py += load.py;
            summary.mz += load.mz;
        });
        
        // „Éá„Éê„ÉÉ„Ç∞„É≠„Ç∞
        console.log('üìä ÁØÄÁÇπËá™ÈáçË°®Á§∫Âá¶ÁêÜ:');
        console.log('  ÂØæË±°ÁØÄÁÇπËç∑ÈáçÊï∞:', nodeSelfWeights.length);
        console.log('  Ë°®Á§∫‰∫àÂÆöÁØÄÁÇπÊï∞:', nodeWeightSummary.size);
        nodeWeightSummary.forEach((totalLoad, nodeIndex) => {
            const totalForce = Math.sqrt(totalLoad.px * totalLoad.px + totalLoad.py * totalLoad.py);
            console.log(`  ÁØÄÁÇπ${nodeIndex + 1}: ÂêàÂäõ=${totalForce.toFixed(3)}kN, px=${totalLoad.px.toFixed(3)}, py=${totalLoad.py.toFixed(3)}, mz=${totalLoad.mz.toFixed(3)}`);
        });
        
        // 3. ÂêàË®à„É©„Éô„É´„ÇíÊèèÁîª
        nodeWeightSummary.forEach((totalLoad, nodeIndex) => {
            const node = nodes[nodeIndex];
            const pos = transform(node.x, node.y);
            const nodeNumber = nodeIndex + 1;
            
            // ÂêàË®àËç∑Èáç„ÇíË®àÁÆó
            const totalForce = Math.sqrt(totalLoad.px * totalLoad.px + totalLoad.py * totalLoad.py);
            const hasMoment = Math.abs(totalLoad.mz) > 0.001;
            
            // „Éá„Éê„ÉÉ„Ç∞„É≠„Ç∞
            console.log(`  ÁØÄÁÇπ${nodeNumber}Âá¶ÁêÜ‰∏≠: ÂêàÂäõ=${totalForce.toFixed(3)}, „É¢„Éº„É°„É≥„Éà=${hasMoment}, px=${totalLoad.px.toFixed(3)}, py=${totalLoad.py.toFixed(3)}`);
            
            // Ë°®Á§∫„ÅÆ„Åó„Åç„ÅÑÂÄ§„Çí„Çà„Çä‰Ωé„ÅèË®≠ÂÆö
            if (totalForce < 0.001 && !hasMoment) {
                console.log(`  ÁØÄÁÇπ${nodeNumber}: „Åó„Åç„ÅÑÂÄ§Êú™Ê∫Ä„Åß„Çπ„Ç≠„ÉÉ„Éó (ÂêàÂäõ=${totalForce.toFixed(6)}, „É¢„Éº„É°„É≥„Éà=${Math.abs(totalLoad.mz).toFixed(6)})`);
                return;
            }
            
            // Ë°®Á§∫‰ΩçÁΩÆ„ÇíÊ±∫ÂÆöÔºàÊúÄ„ÇÇÂ§ß„Åç„Å™Ëç∑ÈáçÊàêÂàÜ„ÅÆ‰ΩçÁΩÆ„ÇíÂü∫Ê∫ñÔºâ
            let textX, textY;
            const maxPx = Math.abs(totalLoad.px);
            const maxPy = Math.abs(totalLoad.py);
            const maxMz = Math.abs(totalLoad.mz);
            
            if (maxPx >= maxPy && maxPx >= maxMz && totalLoad.px !== 0) {
                // XÊñπÂêëËç∑Èáç„ÅåÊúÄÂ§ß„ÅÆÂ†¥Âêà
                const dir = Math.sign(totalLoad.px);
                textX = pos.x - (arrowSize * loadScale * 0.9) * dir;
                textY = pos.y - 8;
            } else if (maxPy >= maxPx && maxPy >= maxMz && totalLoad.py !== 0) {
                // YÊñπÂêëËç∑Èáç„ÅåÊúÄÂ§ß„ÅÆÂ†¥Âêà
                const dir = Math.sign(totalLoad.py);
                textX = pos.x + 8;
                textY = pos.y + (arrowSize * loadScale * 0.9) * dir;
            } else if (totalLoad.mz !== 0) {
                // „É¢„Éº„É°„É≥„ÉàËç∑Èáç„Åå„ÅÇ„ÇãÂ†¥Âêà
                const r = arrowSize * 1.5;
                textX = pos.x + r * 0.8;
                textY = pos.y - r * 0.5;
            } else {
                // „Éá„Éï„Ç©„É´„Éà‰ΩçÁΩÆ
                textX = pos.x + 8;
                textY = pos.y - 8;
            }
            
            // ÂêàË®àËç∑ÈáçÂÄ§„ÅÆ„ÉÜ„Ç≠„Çπ„ÉàË°®Á§∫
            ctx.fillStyle = '#32CD32';
            let labelText;
            if (hasMoment && totalForce > 0.001) {
                // Âäõ„Å®„É¢„Éº„É°„É≥„Éà„ÅÆ‰∏°Êñπ„Åå„ÅÇ„ÇãÂ†¥Âêà
                labelText = `ÁØÄÁÇπ${nodeNumber}Ëá™ÈáçÔºö${totalForce.toFixed(2)}kN, ${Math.abs(totalLoad.mz).toFixed(2)}kN¬∑m`;
            } else if (hasMoment) {
                // „É¢„Éº„É°„É≥„Éà„ÅÆ„Åø„ÅÆÂ†¥Âêà
                labelText = `ÁØÄÁÇπ${nodeNumber}Ëá™ÈáçÔºö${Math.abs(totalLoad.mz).toFixed(2)}kN¬∑m`;
            } else {
                // Âäõ„ÅÆ„Åø„ÅÆÂ†¥Âêà
                labelText = `ÁØÄÁÇπ${nodeNumber}Ëá™ÈáçÔºö${totalForce.toFixed(2)}kN`;
            }
            
            console.log(`  ÁØÄÁÇπ${nodeNumber}: "${labelText}" „Çí‰ΩçÁΩÆ (${textX.toFixed(1)}, ${textY.toFixed(1)}) „Å´Ë°®Á§∫`);
            labelManager.draw(ctx, labelText, textX, textY, loadObstacles);
        }); 
        }

        // ==========================================================
        // ‚ñº‚ñº‚ñº „Åì„Åì„Åã„Çâ„ÅåÂº∑Âà∂Â§â‰Ωç„ÇíÊèèÁîª„Åô„Çã„Åü„ÇÅ„ÅÆËøΩÂä†„Ç≥„Éº„Éâ„Åß„Åô ‚ñº‚ñº‚ñº
        // ==========================================================
        const dispArrowSize = 8;
        const dispScale = 2.5;

        // Âº∑Âà∂Â§â‰ΩçÁî®„Å´Ëâ≤„Å®Á∑ö„ÅÆÂ§™„Åï„ÇíË®≠ÂÆö (Á¥´)
        ctx.strokeStyle = '#8e44ad';
        ctx.fillStyle = '#8e44ad';
        ctx.lineWidth = 2.0;

        nodes.forEach((node, i) => {
            const dx = node.dx_forced || 0; // m
            const dy = node.dy_forced || 0; // m
            const r = node.r_forced || 0;  // rad

            if (dx === 0 && dy === 0 && r === 0) return;

            const pos = transform(node.x, node.y);

            // XÊñπÂêë„ÅÆÂº∑Âà∂Â§â‰Ωç„ÇíÊèèÁîª
            if (dx !== 0) {
                const dir = Math.sign(dx);
                const text = `${(dx * 1000).toFixed(1)}mm`;
                ctx.beginPath();
                ctx.moveTo(pos.x - dispArrowSize * dispScale * dir, pos.y);
                ctx.lineTo(pos.x, pos.y);
                ctx.stroke();
                // Ëç∑Èáç„Å®Âå∫Âà•„Åô„Çã„Åü„ÇÅ„ÅÆ‰∫åÈáçÁü¢Âç∞
                ctx.beginPath();
                ctx.moveTo(pos.x - dispArrowSize * dir, pos.y - dispArrowSize / 2);
                ctx.lineTo(pos.x, pos.y);
                ctx.lineTo(pos.x - dispArrowSize * dir, pos.y + dispArrowSize / 2);
                ctx.moveTo(pos.x - dispArrowSize * 0.5 * dir, pos.y - dispArrowSize * 0.3);
                ctx.lineTo(pos.x, pos.y);
                ctx.lineTo(pos.x - dispArrowSize * 0.5 * dir, pos.y + dispArrowSize * 0.3);
                ctx.stroke();
                const textX = pos.x - (dispArrowSize * dispScale * 0.7) * dir;
                labelManager.draw(ctx, text, textX, pos.y, loadObstacles);
            }

            // YÊñπÂêë„ÅÆÂº∑Âà∂Â§â‰Ωç„ÇíÊèèÁîª
            if (dy !== 0) {
                const dir = Math.sign(dy);
                const text = `${(dy * 1000).toFixed(1)}mm`;
                ctx.beginPath();
                ctx.moveTo(pos.x, pos.y + dispArrowSize * dispScale * dir);
                ctx.lineTo(pos.x, pos.y);
                ctx.stroke();
                // Ëç∑Èáç„Å®Âå∫Âà•„Åô„Çã„Åü„ÇÅ„ÅÆ‰∫åÈáçÁü¢Âç∞
                ctx.beginPath();
                ctx.moveTo(pos.x - dispArrowSize / 2, pos.y + dispArrowSize * dir);
                ctx.lineTo(pos.x, pos.y);
                ctx.lineTo(pos.x + dispArrowSize / 2, pos.y + dispArrowSize * dir);
                ctx.moveTo(pos.x - dispArrowSize * 0.3, pos.y + dispArrowSize * 0.5 * dir);
                ctx.lineTo(pos.x, pos.y);
                ctx.lineTo(pos.x + dispArrowSize * 0.3, pos.y + dispArrowSize * 0.5 * dir);
                ctx.stroke();
                const textY = pos.y + (dispArrowSize * dispScale * 0.8) * dir;
                labelManager.draw(ctx, text, pos.x, textY, loadObstacles);
            }

            // Âº∑Âà∂ÂõûËª¢„ÇíÊèèÁîª
            if (r !== 0) {
                const dir = -Math.sign(r);
                const radius = dispArrowSize * 1.8;
                const arrowHeadSize = 6;
                const startAngle = Math.PI, endAngle = Math.PI * 2.5;
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, radius, startAngle, endAngle, dir < 0);
                ctx.stroke();
                const endX = pos.x + radius * Math.cos(endAngle), endY = pos.y + radius * Math.sin(endAngle);
                const smallAngleOffset = 0.05 * (dir > 0 ? -1 : 1);
                const beforeX = pos.x + radius * Math.cos(endAngle + smallAngleOffset), beforeY = pos.y + radius * Math.sin(endAngle + smallAngleOffset);
                const tangentAngle = Math.atan2(endY - beforeY, endX - beforeX);
                ctx.beginPath();
                ctx.moveTo(endX, endY);
                ctx.lineTo(endX - arrowHeadSize * Math.cos(tangentAngle - Math.PI / 4), endY - arrowHeadSize * Math.sin(tangentAngle - Math.PI / 4));
                ctx.moveTo(endX, endY);
                ctx.lineTo(endX - arrowHeadSize * Math.cos(tangentAngle + Math.PI / 4), endY - arrowHeadSize * Math.sin(tangentAngle + Math.PI / 4));
                ctx.stroke();
                const textY = pos.y - radius * 1.2;
                labelManager.draw(ctx, `${r.toFixed(3)}rad`, pos.x, textY, loadObstacles);
            }
        });
        // ==========================================================
        // ‚ñ≤‚ñ≤‚ñ≤ „Åì„Åì„Åæ„Åß„ÅåËøΩÂä†„Ç≥„Éº„Éâ„Åß„Åô ‚ñ≤‚ñ≤‚ñ≤
        // ==========================================================
    };
    const drawGrid = (ctx, transform, width, height) => { const { x: minX, y: maxY } = inverseTransform(0,0); const { x: maxX, y: minY } = inverseTransform(width, height); const spacing = parseFloat(elements.gridSpacing.value); if (isNaN(spacing) || spacing <= 0) return; ctx.strokeStyle = '#e9e9e9'; ctx.lineWidth = 1; const startX = Math.floor(minX / spacing) * spacing; for (let x = startX; x <= maxX; x += spacing) { const p1 = transform(x, minY); const p2 = transform(x, maxY); ctx.beginPath(); ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y); ctx.stroke(); } const startY = Math.floor(minY / spacing) * spacing; for (let y = startY; y <= maxY; y += spacing) { const p1 = transform(minX, y); const p2 = transform(maxX, y); ctx.beginPath(); ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y); ctx.stroke(); } };
    // LabelManager accepts a font scale so each diagram can control label sizing
    const LabelManager = (contextFontScale = 1.0) => {
        const drawnLabels = [];
        const isOverlapping = (rect1, rect2) => !(rect1.x2 < rect2.x1 || rect1.x1 > rect2.x2 || rect1.y2 < rect2.y1 || rect1.y1 > rect2.y2);

        return {
            draw: (ctx, text, targetX, targetY, obstacles = [], options = {}) => {
                // font scale: prefer passed contextFontScale, fallback to model scale
                const fontScale = contextFontScale || window.settings?.fontScales?.model || 1.0;
                
                const bounds = options.bounds || null;
                const drawLeaderLine = options.drawLeaderLine || false;
                const color = options.color || '#333';

                // ‚ñº‚ñº‚ñº ‰øÆÊ≠£: „Éï„Ç©„É≥„Éà„Çµ„Ç§„Ç∫„ÅÆË®≠ÂÆö ‚ñº‚ñº‚ñº
                const baseSize = options.baseSize || 10;
                const fontSize = baseSize * fontScale;
                const fontStyle = options.fontStyle || 'Arial';
                ctx.font = `${fontSize}px ${fontStyle}`;

                const metrics = ctx.measureText(text);
                const w = metrics.width;
                const h = fontSize * 1.2;
                
                // ‚ñº‚ñº‚ñº ‰øÆÊ≠£: Ë∑ùÈõ¢„Å®„Éë„Éá„Ç£„É≥„Ç∞„ÇÇ„Çπ„Ç±„Éº„É´ ‚ñº‚ñº‚ñº
                const dist = (drawLeaderLine ? 25 : 12) * fontScale;
                const padding = 2 * fontScale;

                const candidates = [
                    [dist, -dist, 'left', 'bottom'],
                    [-dist, -dist, 'right', 'bottom'],
                    [dist, dist, 'left', 'top'],
                    [-dist, dist, 'right', 'top'],
                    [dist * 1.5, -dist * 1.5, 'left', 'bottom'],
                    [-dist * 1.5, -dist * 1.5, 'right', 'bottom'],
                    [dist * 1.5, dist * 1.5, 'left', 'top'],
                    [-dist * 1.5, dist * 1.5, 'right', 'top'],
                    [0, -dist * 1.2, 'center', 'bottom'],
                    [0, dist * 1.2, 'center', 'top'],
                    [dist * 1.5, 0, 'left', 'middle'],
                    [-dist * 1.5, 0, 'right', 'middle']
                ];

                for (const cand of candidates) {
                    const x = targetX + cand[0];
                    const y = targetY + cand[1];
                    
                    // „ÉÜ„Ç≠„Çπ„Éà„ÅÆÁü©ÂΩ¢Ë®àÁÆó
                    let rect;
                    if (cand[2] === 'left') rect = { x1: x, x2: x + w };
                    else if (cand[2] === 'right') rect = { x1: x - w, x2: x };
                    else rect = { x1: x - w/2, x2: x + w/2 };

                    if (cand[3] === 'bottom') rect = { ...rect, y1: y - h, y2: y };
                    else if (cand[3] === 'top') rect = { ...rect, y1: y, y2: y + h };
                    else rect = { ...rect, y1: y - h/2, y2: y + h/2 };

                    const paddedRect = {
                        x1: rect.x1 - padding, y1: rect.y1 - padding, 
                        x2: rect.x2 + padding, y2: rect.y2 + padding
                    };

                    let isInvalid = false;
                    if (bounds) {
                        if (paddedRect.x1 < bounds.x1 || paddedRect.x2 > bounds.x2 || paddedRect.y1 < bounds.y1 || paddedRect.y2 > bounds.y2) isInvalid = true;
                    }
                    if (!isInvalid) {
                        for (const existing of [...drawnLabels.map(l => l.rect), ...obstacles]) {
                            if (isOverlapping(paddedRect, existing)) { isInvalid = true; break; }
                        }
                    }
                    if (isInvalid) continue;

                    // ÊåáÁ§∫Á∑ö (Leader Line)
                    if (drawLeaderLine) {
                        ctx.save();
                        ctx.strokeStyle = '#999';
                        ctx.lineWidth = 1 * fontScale;
                        ctx.beginPath();
                        ctx.moveTo(targetX, targetY);
                        ctx.lineTo(x, y);
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.arc(targetX, targetY, 1.5 * fontScale, 0, 2 * Math.PI);
                        ctx.fillStyle = '#999';
                        ctx.fill();
                        ctx.restore();
                    }

                    // „ÉÜ„Ç≠„Çπ„ÉàÔºàÁôΩÁ∏ÅÂèñ„Çä‰ªò„ÅçÔºâ
                    ctx.save();
                    ctx.font = `${fontSize}px ${fontStyle}`;
                    ctx.textAlign = cand[2];
                    ctx.textBaseline = cand[3];
                    ctx.lineJoin = 'round';
                    ctx.lineWidth = 3 * fontScale;
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)';
                    ctx.strokeText(text, x, y);
                    ctx.fillStyle = color;
                    ctx.fillText(text, x, y);
                    ctx.restore();

                    drawnLabels.push({
                        rect: paddedRect,
                        center: { x: (rect.x1+rect.x2)/2, y: (rect.y1+rect.y2)/2 },
                        width: rect.x2 - rect.x1,
                        value: options.value, type: options.type, index: options.index
                    });
                    return;
                }

                // „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ
                const cand = candidates[0];
                const x = targetX + cand[0];
                const y = targetY + cand[1];
                ctx.save();
                ctx.font = `${(options.baseSize || 10) * (window.settings?.fontScale || 1.0)}px ${options.fontStyle || 'Arial'}`;
                ctx.textAlign = cand[2];
                ctx.textBaseline = cand[3];
                ctx.fillStyle = color;
                ctx.fillText(text, x, y);
                ctx.restore();
            },
            getLabelAt: (x, y) => {
                for (let i = drawnLabels.length - 1; i >= 0; i--) {
                    const label = drawnLabels[i];
                    if (x >= label.rect.x1 && x <= label.rect.x2 && y >= label.rect.y1 && y <= label.rect.y2) return label;
                }
                return null;
            },
            clear: () => { drawnLabels.length = 0; }
        };
    };
    const drawOnCanvas = () => {
        const drawingCtx = getDrawingContext(elements.modelCanvas);
        if (!drawingCtx) return; // Should not happen with the modified getDrawingContext

        lastDrawingContext = drawingCtx;
        window.lastDrawingContext = drawingCtx;
        const { ctx, transform } = drawingCtx;
        try {
            if (elements.gridToggle.checked) {
                drawGrid(ctx, transform, elements.modelCanvas.clientWidth, elements.modelCanvas.clientHeight);
            }
            const { nodes, members, nodeLoads, memberLoads, memberSelfWeights, nodeSelfWeights } = parseInputs();
            if (nodes.length > 0) {
                const modelFontScale = window.settings?.fontScales?.model || 1.0;
                const labelManager = LabelManager(modelFontScale);
                window.lastLabelManager = labelManager; // „Ç∞„É≠„Éº„Éê„É´„Å´„Ç¢„ÇØ„Çª„ÇπÂèØËÉΩ„Å´„Åô„Çã
                const nodeObstacles = nodes.map(n => {
                    const pos = transform(n.x, n.y);
                    const metrics = ctx.measureText(nodes.indexOf(n) + 1);
                    const textWidth = metrics.width;
                    return { x1: pos.x - 12, y1: pos.y - 12 - 16, x2: pos.x + 12 + textWidth, y2: pos.y + 12 }; // ÈöúÂÆ≥Áâ©„Çµ„Ç§„Ç∫„ÇíÊã°Â§ß
                });
                drawStructure(ctx, transform, nodes, members, '#333', true, true, true, drawingCtx, modelFontScale);
                // pass labelManager and nodeObstacles so drawConnections can register labels
                drawConnections(ctx, transform, nodes, members, labelManager, nodeObstacles, modelFontScale);
                drawBoundaryConditions(ctx, transform, nodes, members);
                drawDimensions(ctx, transform, nodes, members, labelManager, nodeObstacles, modelFontScale);
                drawExternalLoads(ctx, transform, nodes, members, nodeLoads, memberLoads, memberSelfWeights, nodeSelfWeights, labelManager, nodeObstacles, modelFontScale);
                if (canvasMode === 'addMember' && firstMemberNode !== null) {
                    const node = nodes[firstMemberNode];
                    const pos = transform(node.x, node.y);
                    ctx.fillStyle = 'rgba(255, 165, 0, 0.5)';
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, 8, 0, 2 * Math.PI);
                    ctx.fill();
                }
                
                // ÈÉ®ÊùêËøΩÂä†„É¢„Éº„Éâ„Åß„ÅÆË¶ñË¶öÁöÑ„Éï„Ç£„Éº„Éâ„Éê„ÉÉ„ÇØ
                if (canvasMode === 'addMember') {
                    ctx.strokeStyle = 'rgba(0, 150, 255, 0.8)';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.arc(currentMouseX, currentMouseY, 12, 0, 2 * Math.PI);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    
                    // Êñ∞Ë¶èÁØÄÁÇπ‰ΩúÊàê‰∫àÂÆö„ÇíÁ§∫„Åô„ÉÜ„Ç≠„Çπ„Éà
                    ctx.fillStyle = 'rgba(0, 150, 255, 0.9)';
                    const fontScale = window.settings?.fontScale || 1.0;
                    ctx.font = `bold ${12 * fontScale}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.fillText('„ÇØ„É™„ÉÉ„ÇØ„ÅßÁØÄÁÇπÈÅ∏Êäû„Åæ„Åü„ÅØÊñ∞Ë¶è‰ΩúÊàê', currentMouseX, currentMouseY - 20);
                }
            }
        } catch (e) {
            console.error("Drawing error:", e);
        }
        
        // Ë§áÊï∞ÈÅ∏Êäû„Åï„Çå„ÅüË¶ÅÁ¥†„ÇíÂº∑Ë™øË°®Á§∫
        highlightSelectedElements();

        // ‰∏çÂÆâÂÆöË¶ÅÁ¥†„Çí„Éè„Ç§„É©„Ç§„ÉàË°®Á§∫
        highlightInstabilityElements(ctx, transform);

        drawSelectionRectangle(ctx);

        // 3D„Éì„É•„Éº„Ç¢„Å´„É¢„Éá„É´„Éá„Éº„Çø„ÇíÈÄÅ‰ø°
        sendModelToViewer();
    };
    
    // Make drawOnCanvas globally accessible
    window.drawOnCanvas = drawOnCanvas;
    
    const drawDisplacementDiagram = (nodes, members, D_global, memberLoads, manualScale = null) => {
        const drawingCtx = getDrawingContext(elements.displacementCanvas);
        if (!drawingCtx) return;
        const { ctx, transform, scale, offsetX, offsetY } = drawingCtx;
        
        // D_global„ÅåÊú™ÂÆöÁæ©„Åæ„Åü„ÅØÁ©∫„ÅÆÂ†¥Âêà„ÅØÊèèÁîª„Çí„Çπ„Ç≠„ÉÉ„Éó
        if (!D_global || !Array.isArray(D_global) || D_global.length === 0) {
            console.warn('Â§â‰ΩçÂõ≥: D_global„ÅåÊú™ÂÆöÁæ©„Åæ„Åü„ÅØÁ©∫„Åß„Åô');
            return;
        }
        
        console.log('Â§â‰ΩçÂõ≥: ÊèèÁîªÈñãÂßã', { 
            hasNodes: !!nodes, 
            hasMembers: !!members, 
            d_global_length: D_global.length,
            displacement_state: resultPanZoomStates.displacement
        });
        
        let dispScale = 0;
        if (D_global.length > 0) {
            if (manualScale !== null) {
                dispScale = manualScale;
            } else {
                let max_dx = 0, max_dy = 0;

                // Â§âÂΩ¢ÂæåÂΩ¢Áä∂„Åå„Ç≠„É£„É≥„Éê„ÇπÁØÑÂõ≤„Å´Âèé„Åæ„Çã„Åü„ÇÅ„ÅÆ„Äå‰∏äÈôêÂÄçÁéá„Äç„ÇíÂêåÊôÇ„Å´Ë®àÁÆó
                // Ôºà„É¢„Éá„É´„ÅåÁ´Ø„Å´Ëøë„ÅÑÂ†¥Âêà„ÄÅÂæìÊù•„ÅÆ TARGET_MAX_DISP_PIXELS Âü∫Ê∫ñ„Å†„Åë„Å†„Å®È£õ„Å≥Âá∫„Åô„Åì„Å®„Åå„ÅÇ„ÇãÔºâ
                let fitUpperScale = Infinity;
                const canvasRect = elements.displacementCanvas.getBoundingClientRect();
                const fitPadding = { left: 20, right: 20, top: 40, bottom: 20 };
                const canFit = (canvasRect.width > (fitPadding.left + fitPadding.right)) && (canvasRect.height > (fitPadding.top + fitPadding.bottom)) && (scale > 1e-12);
                const xMinAllowed = canFit ? (fitPadding.left - offsetX) / scale : 0;
                const xMaxAllowed = canFit ? (canvasRect.width - fitPadding.right - offsetX) / scale : 0;
                const yMaxAllowed = canFit ? (offsetY - fitPadding.top) / scale : 0;
                const yMinAllowed = canFit ? (offsetY - (canvasRect.height - fitPadding.bottom)) / scale : 0;

                const updateFitUpperForAxis = (base, disp, minAllowed, maxAllowed) => {
                    if (!canFit) return;
                    if (!isFinite(disp) || Math.abs(disp) < 1e-15) return;

                    // base + disp * s ‚àà [minAllowed, maxAllowed] „ÇíÊ∫Ä„Åü„Åô s>=0 „ÅÆ‰∏äÈôê„ÇíÊ±Ç„ÇÅ„Çã
                    const aMin = (minAllowed - base) / disp;
                    const aMax = (maxAllowed - base) / disp;
                    let lower = -Infinity;
                    let upper = Infinity;
                    if (disp > 0) {
                        lower = Math.max(lower, aMin);
                        upper = Math.min(upper, aMax);
                    } else {
                        // disp < 0 „ÅÆÂ†¥Âêà„ÅØ‰∏çÁ≠âÂè∑„ÅåÂèçËª¢
                        lower = Math.max(lower, aMax);
                        upper = Math.min(upper, aMin);
                    }
                    // s>=0 „Å´Âà∂Èôê
                    lower = Math.max(lower, 0);
                    if (!isFinite(upper)) return;
                    if (upper < lower) {
                        fitUpperScale = 0;
                        return;
                    }
                    fitUpperScale = Math.min(fitUpperScale, Math.max(0, upper));
                };

                // ÊúÄÂ§ßÂ§â‰ΩçÈáè„ÅØÂ∏∏„Å´ÈõÜË®à„ÄÇ„Éï„Ç£„ÉÉ„Éà‰∏äÈôê„ÅØÂèØËÉΩ„Å™Â†¥Âêà„ÅÆ„ÅøÂêåÊôÇÈõÜË®à„ÄÇ
                members.forEach((m, idx) => {
                    const L = m.length, c = m.c, s = m.s;
                    const ni = nodes[m.i];
                    const d_global_member_vec = [ ...D_global.slice(m.i * 3, m.i * 3 + 3), ...D_global.slice(m.j * 3, m.j * 3 + 3) ];
                    const d_local_vec = mat.multiply(m.T, d_global_member_vec);
                    const [ui, vi, thi, uj, vj, thj] = d_local_vec.map(v => v[0]);
                    const load = memberLoads.find(l => l.memberIndex === idx), w = load ? load.w : 0, E = m.E, I = m.I;

                    for (let k = 0; k <= 20; k++) {
                        const x = (k / 20) * L, xi = x / L;
                        const N1 = 1 - 3*xi**2 + 2*xi**3, N2 = x * (1 - xi)**2, N3 = 3*xi**2 - 2*xi**3, N4 = (x**2 / L) * (xi - 1);
                        const u_local = (1 - xi) * ui + xi * uj;
                        const v_homogeneous = N1*vi + N2*thi + N3*vj + N4*thj;
                        let v_particular = 0;
                        if (w !== 0 && E > 0 && I > 0) {
                            if (m.i_conn === 'rigid' && m.j_conn === 'rigid') v_particular = (w * x**2 * (L - x)**2) / (24 * E * I);
                            else if (m.i_conn === 'pinned' && m.j_conn === 'pinned') v_particular = (w * x * (L**3 - 2 * L * x**2 + x**3)) / (24 * E * I);
                            else if (m.i_conn === 'rigid' && m.j_conn === 'pinned') v_particular = (w * x**2 * (3 * L**2 - 5 * L * x + 2 * x**2)) / (48 * E * I);
                            else if (m.i_conn === 'pinned' && m.j_conn === 'rigid') v_particular = (w * x * (L**3 - 3 * L * x**2 + 2 * x**3)) / (48 * E * I);
                        }
                        const v_local = v_homogeneous - v_particular;
                        const disp_x_global = u_local * c - v_local * s;
                        const disp_y_global = u_local * s + v_local * c;

                        max_dx = Math.max(max_dx, Math.abs(disp_x_global));
                        max_dy = Math.max(max_dy, Math.abs(disp_y_global));

                        const baseX = ni.x + x * c;
                        const baseY = ni.y + x * s;
                        updateFitUpperForAxis(baseX, disp_x_global, xMinAllowed, xMaxAllowed);
                        updateFitUpperForAxis(baseY, disp_y_global, yMinAllowed, yMaxAllowed);
                    }
                });

                // „É¢„Éá„É´„ÅÆÊúÄÂ§ßÂ§â‰ΩçÈáè („É¢„Éá„É´Âçò‰Ωç)
                const max_model_disp = Math.max(max_dx, max_dy);

                // ÁõÆÊ®ô„Å®„Åô„ÇãÁîªÈù¢‰∏ä„ÅÆÊúÄÂ§ßÂ§â‰Ωç„Éî„ÇØ„Çª„É´Êï∞ („Åì„ÅÆÂÄ§„ÇíÂ§â„Åà„Çã„Å®„ÄÅÂ§â‰ΩçÂõ≥„ÅÆË¶ã„ÅüÁõÆ„ÅÆÂ§ß„Åç„Åï„ÅåÂ§â„Çè„Çä„Åæ„Åô)
                const TARGET_MAX_DISP_PIXELS = 40;

                if (max_model_disp > 1e-12 && scale > 1e-12) {
                    // Ë°®Á§∫ÂÄçÁéá = (ÁõÆÊ®ô„Éî„ÇØ„Çª„É´Êï∞) / („É¢„Éá„É´Âçò‰Ωç„ÅÆÊúÄÂ§ßÂ§â‰ΩçÈáè * ÊèèÁîª„Çπ„Ç±„Éº„É´)
                    const autoScale = TARGET_MAX_DISP_PIXELS / (max_model_disp * scale);
                    // „Åæ„Åö„ÅØÂæìÊù•„ÅÆË¶ã„ÅüÁõÆÂü∫Ê∫ñ„ÅßÊ±∫ÂÆö
                    dispScale = isFinite(autoScale) ? Math.max(0.1, Math.min(autoScale, 5000)) : 0;

                    // Â§âÂΩ¢ÂæåÂΩ¢Áä∂„ÅåÊèèÁîªÁØÑÂõ≤„Å´Âèé„Åæ„Çã‰∏äÈôê„ÅßÊäë„Åà„Çã
                    if (isFinite(fitUpperScale) && fitUpperScale >= 0) {
                        // „Åª„Çì„ÅÆÂ∞ë„Åó‰ΩôË£ï„ÇíÊåÅ„Åü„Åõ„Çã
                        dispScale = Math.min(dispScale, fitUpperScale * 0.95);
                    }
                } else {
                    dispScale = 0;
                }
                lastDisplacementScale = dispScale;
                dispScaleInput.value = dispScale.toFixed(2);
            }
        }
        // „Çπ„Ç±„Éº„É™„É≥„Ç∞: displacement Âõ≥Â∞ÇÁî®„ÅÆ„Éï„Ç©„É≥„Éà„Çπ„Ç±„Éº„É´„ÇíÂèñÂæó
        const fontScale = window.settings?.fontScales?.displacement || 1.0;
        const labelManager = LabelManager(fontScale);
        // ÊßãÈÄ†ÊèèÁîªÔºà„É©„Éô„É´„Å™„ÅóÔºâ
        drawStructure(ctx, transform, nodes, members, '#ccc', false, false, false, null, fontScale);
        ctx.fillStyle = '#333'; ctx.textAlign = 'left'; ctx.font = `${12 * fontScale}px Arial`; ctx.fillText(`Ë°®Á§∫ÂÄçÁéá: ${dispScale.toFixed(2)} ÂÄç`, 10, 20);
        ctx.strokeStyle = 'red'; ctx.lineWidth = 2;
        const maxIntermediateLabels = [];
        members.forEach((m, idx) => {
            const L = m.length, c = m.c, s = m.s, ni = nodes[m.i];
            const d_global_member_vec = [ ...D_global.slice(m.i * 3, m.i * 3 + 3), ...D_global.slice(m.j * 3, m.j * 3 + 3) ];
            const d_local_vec = mat.multiply(m.T, d_global_member_vec), [ui, vi, thi, uj, vj, thj] = d_local_vec.map(v => v[0]);
            const load = memberLoads.find(l => l.memberIndex === idx), w = load ? load.w : 0, E = m.E, I = m.I;
            let maxDispMag = 0, maxDispPoint = null;
            ctx.beginPath();
            for (let k = 0; k <= 20; k++) {
                const x = (k / 20) * L, xi = x / L;
                const N1=1-3*xi**2+2*xi**3, N2=x*(1-xi)**2, N3=3*xi**2-2*xi**3, N4=(x**2/L)*(xi-1);
                const u_local = (1-xi)*ui+xi*uj, v_homogeneous = N1*vi+N2*thi+N3*vj+N4*thj;
                let v_particular = 0;
                if (w !== 0 && E > 0 && I > 0) {
                    if (m.i_conn==='rigid'&&m.j_conn==='rigid') v_particular=(w*x**2*(L-x)**2)/(24*E*I);
                    else if(m.i_conn==='pinned'&&m.j_conn==='pinned')v_particular=(w*x*(L**3-2*L*x**2+x**3))/(24*E*I);
                    else if(m.i_conn==='rigid'&&m.j_conn==='pinned')v_particular=(w*x**2*(3*L**2-5*L*x+2*x**2))/(48*E*I);
                    else if(m.i_conn==='pinned'&&m.j_conn==='rigid')v_particular=(w*x*(L**3-3*L*x**2+2*x**3))/(48*E*I);
                }
                const v_local = v_homogeneous - v_particular;
                const disp_x_global=u_local*c-v_local*s, disp_y_global=u_local*s+v_local*c, dispMag=Math.sqrt(disp_x_global**2+disp_y_global**2);
                if (dispMag > maxDispMag) { maxDispMag=dispMag; const original_x=ni.x+x*c, original_y=ni.y+x*s; maxDispPoint={x:original_x,y:original_y,dx:disp_x_global,dy:disp_y_global,mag:maxDispMag}; }
                const p = transform(ni.x+x*c+disp_x_global*dispScale, ni.y+x*s+disp_y_global*dispScale);
                if (k === 0) ctx.moveTo(p.x, p.y); else ctx.lineTo(p.x, p.y);
            }
            ctx.stroke();
            const disp_i_mag = Math.sqrt(D_global[m.i*3][0]**2 + D_global[m.i*3+1][0]**2);
            const disp_j_mag = Math.sqrt(D_global[m.j*3][0]**2 + D_global[m.j*3+1][0]**2);
            if (maxDispPoint && maxDispMag > disp_i_mag && maxDispMag > disp_j_mag) { maxIntermediateLabels.push({x:maxDispPoint.x+maxDispPoint.dx*dispScale,y:maxDispPoint.y+maxDispPoint.dy*dispScale,label:`${(maxDispPoint.mag*1000).toFixed(2)}mm`}); }
        });
        const allObstacles = [];
        const rect = elements.displacementCanvas.getBoundingClientRect(), canvasBounds = { x1: 5, y1: 25, x2: rect.width - 5, y2: rect.height - 5 };
        nodes.forEach((n,i) => { const dx=D_global[i*3][0], dy=D_global[i*3+1][0]; const p_def = transform(n.x+dx*dispScale, n.y+dy*dispScale); allObstacles.push({x1:p_def.x-12,y1:p_def.y-12,x2:p_def.x+12,y2:p_def.y+12}); const p_orig = transform(n.x,n.y); const metrics = ctx.measureText(`${i+1}`); allObstacles.push({x1:p_orig.x+12,y1:p_orig.y-12-16,x2:p_orig.x+12+metrics.width,y2:p_orig.y+12}); });
        // ÁØÄÁÇπÂ§â‰Ωç„É©„Éô„É´„ÅØ 24px „Éô„Éº„Çπ„Åß„Çπ„Ç±„Éº„É™„É≥„Ç∞„ÇíÈÅ©Áî®
        ctx.fillStyle='#00008b'; ctx.font=`bold ${24 * fontScale}px Arial`;
        nodes.forEach((n, i) => { const dx_mm=D_global[i*3][0]*1000, dy_mm=D_global[i*3+1][0]*1000; if (Math.sqrt(dx_mm**2+dy_mm**2)>1e-3) { const dx=D_global[i*3][0], dy=D_global[i*3+1][0]; const p_def=transform(n.x+dx*dispScale,n.y+dy*dispScale); const labelText=`(${dx_mm.toFixed(2)}, ${dy_mm.toFixed(2)})mm`; labelManager.draw(ctx,labelText,p_def.x,p_def.y,allObstacles,canvasBounds); } });
        // ÊúÄÂ§ßÂ§â‰Ωç„É©„Éô„É´„ÇÇ 24px „Éô„Éº„Çπ
        ctx.fillStyle='#8b0000'; ctx.font=`bold ${24 * fontScale}px Arial`;
        maxIntermediateLabels.forEach(lbl => { const p_def=transform(lbl.x,lbl.y); allObstacles.push({x1:p_def.x-12,y1:p_def.y-12,x2:p_def.x+12,y2:p_def.y+12}); labelManager.draw(ctx,lbl.label,p_def.x,p_def.y,allObstacles,canvasBounds); });

        // ÊúÄÂæå„Å´ÁØÄÁÇπÁï™Âè∑„ÉªÈÉ®ÊùêÁï™Âè∑„ÇíÊèèÁîªÔºàÊúÄÂâçÈù¢Ôºâ
        drawStructure(ctx, transform, nodes, members, 'rgba(0,0,0,0)', true, true, false, null, fontScale);
    };

    // Êõ≤„Åí„É¢„Éº„É°„É≥„ÉàÂõ≥Â∞ÇÁî®„ÅÆ„É©„Éô„É´ÊèèÁîªÈñ¢Êï∞
    const drawNodeMomentLabel = (ctx, nodeIndex, text, nodeX, nodeY, nodeLabels, drawnLabels, memberIndex, memberEnd, memberDirection, memberLineStart, memberLineEnd) => {
        const metrics = ctx.measureText(text);
        const w = metrics.width;
        const h = 24; // „Éï„Ç©„É≥„Éà„Çµ„Ç§„Ç∫
        const padding = 12; // „Éë„Éá„Ç£„É≥„Ç∞„ÇíÂ¢ó„ÇÑ„Åó„Å¶Èáç„Å™„Çä„ÇíÈò≤„Åê
        
        // ÁØÄÁÇπ„ÅÆ„É¢„Éº„É°„É≥„ÉàÊÉÖÂ†±„ÇíÁÆ°ÁêÜÔºàÈÉ®Êùê„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ„Å®Á´ØÈÉ®ÊÉÖÂ†±„ÇíÂê´„ÇÄÔºâ
        const momentKey = `${nodeIndex}_${memberIndex}_${memberEnd}`;
        
        // ÈÉ®Êùê„É©„Ç§„É≥‰∏ä„Åß„ÅÆ‰ΩçÁΩÆ„ÇíË®àÁÆó
        let labelX, labelY;
        
        if (memberLineStart && memberLineEnd) {
            // ÈÉ®Êùê„É©„Ç§„É≥‰∏ä„ÅßÁØÄÁÇπ„Åã„ÇâÂ∞ë„ÅóÈõ¢„Çå„Åü‰ΩçÁΩÆ„Å´ÈÖçÁΩÆ
            const memberLength = Math.sqrt((memberLineEnd.x - memberLineStart.x) ** 2 + (memberLineEnd.y - memberLineStart.y) ** 2);
            const offsetFromNode = 30; // ÁØÄÁÇπ„Åã„Çâ30„Éî„ÇØ„Çª„É´Èõ¢„Çå„Åü‰ΩçÁΩÆ„Å´Â§âÊõ¥
            
            if (memberEnd === 'i') {
                // ÁØÄÁÇπiÂÅ¥„ÅÆÂ†¥Âêà„ÄÅÈÉ®Êùê„É©„Ç§„É≥‰∏ä„ÅßÁØÄÁÇπ„Åã„ÇâÂ∞ë„ÅóÈõ¢„Çå„Åü‰ΩçÁΩÆ
                const ratio = Math.min(offsetFromNode / memberLength, 0.25); // ÊúÄÂ§ß25%„ÅÆ‰ΩçÁΩÆ„Åæ„Åß
                labelX = memberLineStart.x + (memberLineEnd.x - memberLineStart.x) * ratio;
                labelY = memberLineStart.y + (memberLineEnd.y - memberLineStart.y) * ratio;
            } else {
                // ÁØÄÁÇπjÂÅ¥„ÅÆÂ†¥Âêà„ÄÅÈÉ®Êùê„É©„Ç§„É≥‰∏ä„ÅßÁØÄÁÇπ„Åã„ÇâÂ∞ë„ÅóÈõ¢„Çå„Åü‰ΩçÁΩÆ
                const ratio = Math.max(1 - offsetFromNode / memberLength, 0.75); // ÊúÄÂ∞è75%„ÅÆ‰ΩçÁΩÆ„Åã„Çâ
                labelX = memberLineStart.x + (memberLineEnd.x - memberLineStart.x) * ratio;
                labelY = memberLineStart.y + (memberLineEnd.y - memberLineStart.y) * ratio;
            }
        } else {
            // „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ: ÁØÄÁÇπ‰ΩçÁΩÆ„Çí‰ΩøÁî®
            labelX = nodeX;
            labelY = nodeY - h - padding;
        }
        
        // ÈáçË§á„ÉÅ„Çß„ÉÉ„ÇØ„Å®‰ΩçÁΩÆË™øÊï¥
        let finalLabelX = labelX;
        let finalLabelY = labelY;
        const rect = { x1: labelX - w/2, y1: labelY - h/2, x2: labelX + w/2, y2: labelY + h/2 };
        const paddedRect = { x1: rect.x1 - padding, y1: rect.y1 - padding, x2: rect.x2 + padding, y2: rect.y2 + padding };
        
        // Êó¢Â≠ò„ÅÆ„É©„Éô„É´„Å®„ÅÆÈáçË§á„Çí„ÉÅ„Çß„ÉÉ„ÇØ
        let isOverlapping = false;
        for (const existing of drawnLabels) {
            if (!(paddedRect.x2 < existing.x1 || paddedRect.x1 > existing.x2 || paddedRect.y2 < existing.y1 || paddedRect.y1 > existing.y2)) {
                isOverlapping = true;
                break;
            }
        }
        
        // ÈáçË§á„Åó„Å¶„ÅÑ„ÇãÂ†¥Âêà„ÅØ‰ΩçÁΩÆ„ÇíË™øÊï¥
        if (isOverlapping && memberLineStart && memberLineEnd) {
            // ÈÉ®Êùê„É©„Ç§„É≥‰∏ä„Åß„Çà„ÇäÈõ¢„Çå„Åü‰ΩçÁΩÆ„ÇíË©¶„Åô
            const memberLength = Math.sqrt((memberLineEnd.x - memberLineStart.x) ** 2 + (memberLineEnd.y - memberLineStart.y) ** 2);
            const extendedOffset = 50; // „Çà„ÇäÈõ¢„Çå„Åü‰ΩçÁΩÆ
            
            if (memberEnd === 'i') {
                const ratio = Math.min(extendedOffset / memberLength, 0.4);
                finalLabelX = memberLineStart.x + (memberLineEnd.x - memberLineStart.x) * ratio;
                finalLabelY = memberLineStart.y + (memberLineEnd.y - memberLineStart.y) * ratio;
            } else {
                const ratio = Math.max(1 - extendedOffset / memberLength, 0.6);
                finalLabelX = memberLineStart.x + (memberLineEnd.x - memberLineStart.x) * ratio;
                finalLabelY = memberLineStart.y + (memberLineEnd.y - memberLineStart.y) * ratio;
            }
        }
        
        // „ÉÜ„Ç≠„Çπ„Éà„ÇíÊèèÁîªÔºàÂõõËßíÂõ≤„ÅÑ„Å™„ÅóÔºâ
        ctx.fillStyle = '#333';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(text, finalLabelX, finalLabelY);
        
        // ÊèèÁîªÊ∏à„Åø„É©„Éô„É´„Å®„Åó„Å¶ÁôªÈå≤ÔºàÈáçË§á„ÉÅ„Çß„ÉÉ„ÇØÁî®Ôºâ
        const finalRect = { x1: finalLabelX - w/2, y1: finalLabelY - h/2, x2: finalLabelX + w/2, y2: finalLabelY + h/2 };
        const finalPaddedRect = { x1: finalRect.x1 - padding, y1: finalRect.y1 - padding, x2: finalRect.x2 + padding, y2: finalRect.y2 + padding };
        drawnLabels.push(finalPaddedRect);
        
        nodeLabels.set(momentKey, {
            text: text,
            position: { x: finalLabelX, y: finalLabelY },
            nodePosition: { x: nodeX, y: nodeY }
        });
    };

    const drawIntermediateMomentLabel = (ctx, text, x, y, drawnLabels, memberIndex, memberEnd) => {
        const metrics = ctx.measureText(text);
        const w = metrics.width;
        const h = 24;
        const padding = 8;
        
        const candidates = [
            [0, -h - padding, 'center', 'bottom'],
            [w/2 + padding, -padding, 'left', 'bottom'],
            [-w/2 - padding, -padding, 'right', 'bottom'],
            [0, h + padding, 'center', 'top'],
            [w/2 + padding, h + padding, 'left', 'top'],
            [-w/2 - padding, h + padding, 'right', 'top']
        ];
        
        for (const cand of candidates) {
            const labelX = x + cand[0];
            const labelY = y + cand[1];
            let rect;
            if (cand[2] === 'left') rect = { x1: labelX, y1: labelY - h, x2: labelX + w, y2: labelY };
            else if (cand[2] === 'right') rect = { x1: labelX - w, y1: labelY - h, x2: labelX, y2: labelY };
            else rect = { x1: labelX - w/2, y1: labelY - h, x2: labelX + w/2, y2: labelY };
            
            const paddedRect = { x1: rect.x1 - padding, y1: rect.y1 - padding, x2: rect.x2 + padding, y2: rect.y2 + padding };
            
            // ÈáçË§á„ÉÅ„Çß„ÉÉ„ÇØ
            let isOverlapping = false;
            for (const existing of drawnLabels) {
                if (!(paddedRect.x2 < existing.x1 || paddedRect.x1 > existing.x2 || paddedRect.y2 < existing.y1 || paddedRect.y1 > existing.y2)) {
                    isOverlapping = true;
                    break;
                }
            }
            
            if (!isOverlapping) {
                // „ÉÜ„Ç≠„Çπ„Éà„ÅÆ„ÅøÊèèÁîªÔºàÂõõËßíÂõ≤„ÅÑ„Å™„ÅóÔºâ
                ctx.fillStyle = '#333';
                ctx.textAlign = cand[2];
                ctx.textBaseline = cand[3];
                ctx.fillText(text, labelX, labelY);
                
                // Êé•Á∂öÁ∑ö„ÇíÊèèÁîªÔºà„É¢„Éº„É°„É≥„ÉàÊèèÁîªÈÉ®ÂàÜ„Åã„Çâ„É©„Éô„É´„Å∏Ôºâ
                ctx.strokeStyle = '#666';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(labelX, labelY);
                ctx.stroke();
                
                // ÊèèÁîªÊ∏à„Åø„É©„Éô„É´„Å®„Åó„Å¶ÁôªÈå≤
                drawnLabels.push(paddedRect);
                return;
            }
        }
        
        // „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ: Âº∑Âà∂ÊèèÁîª
        const labelX = x;
        const labelY = y - h - padding;
        const rect = { x1: labelX - w/2, y1: labelY - h, x2: labelX + w/2, y2: labelY };
        const paddedRect = { x1: rect.x1 - padding, y1: rect.y1 - padding, x2: rect.x2 + padding, y2: rect.y2 + padding };
        
        ctx.fillStyle = '#333';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'bottom';
        ctx.fillText(text, labelX, labelY);
        
        // Êé•Á∂öÁ∑ö„ÇíÊèèÁîª
        ctx.strokeStyle = '#666';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(labelX, labelY);
        ctx.stroke();
        
        drawnLabels.push(paddedRect);
    };

    const drawMomentDiagram = (nodes, members, forces, memberLoads) => { 
        const drawingCtx = getDrawingContext(elements.momentCanvas); 
        if (!drawingCtx) return; 
        const { ctx, transform, scale } = drawingCtx; 
        const momentFontScale = window.settings?.fontScales?.moment || 1.0;
        const labelManager = LabelManager(momentFontScale);
        
        // ÊßãÈÄ†ÊèèÁîªÔºà„É©„Éô„É´„Å™„ÅóÔºâ
        drawStructure(ctx, transform, nodes, members, '#ccc', false, false, false, null, momentFontScale); 
        
        // Êõ≤„Åí„É¢„Éº„É°„É≥„ÉàÂõ≥Â∞ÇÁî®„ÅÆ„É©„Éô„É´ÁÆ°ÁêÜ„Ç∑„Çπ„ÉÜ„É†
        const nodeLabels = new Map(); // ÁØÄÁÇπ„Åî„Å®„ÅÆ„É©„Éô„É´ÊÉÖÂ†±„ÇíÁÆ°ÁêÜ
        const drawnLabels = []; // ÊèèÁîªÊ∏à„Åø„É©„Éô„É´„ÅÆ‰ΩçÁΩÆÊÉÖÂ†±
        
        // ÁØÄÁÇπÈöúÂÆ≥Áâ©„ÅÆË®≠ÂÆö
        const nodeObstacles = nodes.map(n => { 
            const pos = transform(n.x, n.y); 
            return {x1: pos.x - 20, y1: pos.y - 20, x2: pos.x + 20, y2: pos.y + 20}; 
        }); 
        let maxMoment = 0; 
        forces.forEach((f, idx) => { 
            const member = members[idx]; 
            const load = memberLoads.find(l => l.memberIndex === idx); 
            const w = load ? load.w : 0; 
            const L = member.length; 
            let localMax = Math.max(Math.abs(f.M_i), Math.abs(f.M_j)); 
            if (w !== 0 && Math.abs(f.Q_i) > 1e-9) { 
                const x_q_zero = f.Q_i / w; 
                if (x_q_zero > 0 && x_q_zero < L) { 
                    const M_max_parabolic = -f.M_i * (1 - x_q_zero / L) + f.M_j * (x_q_zero / L) + w * L * x_q_zero / 2 - w * x_q_zero**2 / 2; 
                    localMax = Math.max(localMax, Math.abs(M_max_parabolic)); 
                } 
            } 
            maxMoment = Math.max(maxMoment, localMax); 
        }); 
        const maxOffsetPixels = 60; 
        let momentScale = 0; 
        if (scale > 0 && maxMoment > 1e-9) { 
            const maxOffsetModelUnits = maxOffsetPixels / scale; 
            momentScale = maxOffsetModelUnits / maxMoment; 
        } 
        members.forEach((m, idx) => { 
            const force = forces[idx]; 
            const load = memberLoads.find(l => l.memberIndex === idx); 
            const w = load ? load.w : 0; 
            const n_i = nodes[m.i], n_j = nodes[m.j]; 
            ctx.beginPath(); 
            const start = transform(n_i.x, n_i.y); 
            ctx.moveTo(start.x, start.y); 
            const numPoints = 20; 
            for (let i = 0; i <= numPoints; i++) { 
                const x_local = (i / numPoints) * m.length, M_linear = -force.M_i * (1 - x_local / m.length) + force.M_j * (x_local / m.length), M_parabolic = w * m.length * x_local / 2 - w * x_local**2 / 2; 
                const m_local = M_linear + M_parabolic, offset = -m_local * momentScale; 
                const globalX = n_i.x + x_local * m.c - offset * m.s, globalY = n_i.y + x_local * m.s + offset * m.c; 
                const pt = transform(globalX, globalY); 
                ctx.lineTo(pt.x, pt.y); 
            } 
            const end = transform(n_j.x, n_j.y); 
            ctx.lineTo(end.x, end.y); 
            ctx.fillStyle = 'rgba(255, 0, 0, 0.2)'; 
            ctx.strokeStyle = 'red'; 
            ctx.lineWidth = 1; 
            ctx.closePath(); 
            ctx.fill(); 
            ctx.stroke(); 
            ctx.fillStyle = '#333';
            ctx.font = `bold ${24 * momentFontScale}px Arial`;
            
            // ÁØÄÁÇπ„É¢„Éº„É°„É≥„ÉàÂÄ§„ÇíË°®Á§∫ÔºàÂ∞ÇÁî®„ÅÆ„É©„Éô„É´ÁÆ°ÁêÜ„Ç∑„Çπ„ÉÜ„É†„Çí‰ΩøÁî®Ôºâ
            if (Math.abs(force.M_i) > 1e-3) {
                // ÁØÄÁÇπi„Åß„ÅÆ„É¢„Éº„É°„É≥„ÉàÊèèÁîª‰ΩçÁΩÆ„ÇíË®àÁÆóÔºà„Ç™„Éï„Çª„ÉÉ„ÉàÈÅ©Áî®Ôºâ
                const offset_i = -force.M_i * momentScale;
                const momentPos_i = transform(n_i.x - offset_i * m.s, n_i.y + offset_i * m.c);
                // ÈÉ®Êùê„ÅÆÊñπÂêëÊÉÖÂ†±„Å®„É©„Ç§„É≥ÊÉÖÂ†±„ÇíÊ∏°„Åô
                const memberDirection = { c: m.c, s: m.s };
                const memberLineStart = start; // ÈÉ®Êùê„É©„Ç§„É≥„ÅÆÈñãÂßãÁÇπ
                const memberLineEnd = end; // ÈÉ®Êùê„É©„Ç§„É≥„ÅÆÁµÇ‰∫ÜÁÇπ
                drawNodeMomentLabel(ctx, m.i, `${force.M_i.toFixed(2)}`, momentPos_i.x, momentPos_i.y, nodeLabels, drawnLabels, idx, 'i', memberDirection, memberLineStart, memberLineEnd);
            }
            if (Math.abs(force.M_j) > 1e-3) {
                // ÁØÄÁÇπj„Åß„ÅÆ„É¢„Éº„É°„É≥„ÉàÊèèÁîª‰ΩçÁΩÆ„ÇíË®àÁÆóÔºà„Ç™„Éï„Çª„ÉÉ„ÉàÈÅ©Áî®Ôºâ
                const offset_j = -force.M_j * momentScale;
                const momentPos_j = transform(n_j.x - offset_j * m.s, n_j.y + offset_j * m.c);
                // ÈÉ®Êùê„ÅÆÊñπÂêëÊÉÖÂ†±„Å®„É©„Ç§„É≥ÊÉÖÂ†±„ÇíÊ∏°„Åô
                const memberDirection = { c: m.c, s: m.s };
                const memberLineStart = start; // ÈÉ®Êùê„É©„Ç§„É≥„ÅÆÈñãÂßãÁÇπ
                const memberLineEnd = end; // ÈÉ®Êùê„É©„Ç§„É≥„ÅÆÁµÇ‰∫ÜÁÇπ
                drawNodeMomentLabel(ctx, m.j, `${force.M_j.toFixed(2)}`, momentPos_j.x, momentPos_j.y, nodeLabels, drawnLabels, idx, 'j', memberDirection, memberLineStart, memberLineEnd);
            } 
            if (w !== 0 && Math.abs(force.Q_i) > 1e-9) { 
                const x_max = force.Q_i / w; 
                if (x_max > 1e-6 && x_max < m.length - 1e-6) { 
                    const M_linear = -force.M_i*(1-x_max/m.length)+force.M_j*(x_max/m.length), M_parabolic=w*m.length*x_max/2-w*x_max**2/2; 
                    const M_max=M_linear+M_parabolic, offset=-M_max*momentScale; 
                    const globalX=n_i.x+x_max*m.c-offset*m.s, globalY=n_i.y+x_max*m.s+offset*m.c; 
                    const pt=transform(globalX,globalY); 
                    ctx.font = `bold ${24 * momentFontScale}px Arial`;
                    drawIntermediateMomentLabel(ctx, `${M_max.toFixed(2)}`, pt.x, pt.y, drawnLabels, idx, 'max'); 
                } 
            } 
        }); 

        // ÊúÄÂæå„Å´ÁØÄÁÇπÁï™Âè∑„ÉªÈÉ®ÊùêÁï™Âè∑„ÇíÊèèÁîªÔºàÊúÄÂâçÈù¢Ôºâ
        drawStructure(ctx, transform, nodes, members, 'rgba(0,0,0,0)', true, true, false, null, momentFontScale);
    };
    const drawAxialForceDiagram = (nodes, members, forces) => { 
        const drawingCtx = getDrawingContext(elements.axialCanvas); 
        if (!drawingCtx) return; 
        const { ctx, transform, scale } = drawingCtx; 
        // „Éï„Ç©„É≥„Éà„Çπ„Ç±„Éº„É´Ôºà24px „Éô„Éº„ÇπÔºâ„ÇíÂèñÂæó„Åó„Å¶ LabelManager „Å´Ê∏°„Åô
        const fontScale = window.settings?.fontScales?.axial || 1.0;
        const labelManager = LabelManager(fontScale);
        
        // ÊßãÈÄ†ÊèèÁîªÔºà„É©„Éô„É´„Å™„ÅóÔºâ
        drawStructure(ctx, transform, nodes, members, '#ccc', false, false, false, null, fontScale); 
        
        // „Çà„ÇäË©≥Á¥∞„Å™ÈöúÂÆ≥Áâ©ÁÆ°ÁêÜ
        const nodeObstacles = nodes.map(n => { 
            const pos = transform(n.x, n.y); 
            return {x1: pos.x - 16, y1: pos.y - 16, x2: pos.x + 16, y2: pos.y + 16}; 
        });
        const allObstacles = [...nodeObstacles]; 
        let maxAxial = 0; 
        forces.forEach(f => maxAxial = Math.max(maxAxial, Math.abs(f.N_i), Math.abs(f.N_j))); 
        const maxOffsetPixels = 40; 
        let axialScale = 0; 
        if (scale > 0 && maxAxial > 0) { 
            const maxOffsetModelUnits = maxOffsetPixels / scale; 
            axialScale = maxOffsetModelUnits / maxAxial; 
        } 
        members.forEach((m, idx) => { 
            const N = -forces[idx].N_i, offset = -N * axialScale; 
            const n_i = nodes[m.i], n_j = nodes[m.j]; 
            const p1_offset_x = -offset*m.s, p1_offset_y = offset*m.c; 
            const p1 = transform(n_i.x+p1_offset_x, n_i.y+p1_offset_y), p2=transform(n_j.x+p1_offset_x, n_j.y+p1_offset_y); 
            const p_start=transform(n_i.x,n_i.y), p_end=transform(n_j.x,n_j.y); 
            ctx.beginPath(); 
            ctx.moveTo(p_start.x, p_start.y); 
            ctx.lineTo(p1.x, p1.y); 
            ctx.lineTo(p2.x, p2.y); 
            ctx.lineTo(p_end.x, p_end.y); 
            ctx.closePath(); 
            ctx.fillStyle = N > 0 ? 'rgba(255,0,0,0.2)' : 'rgba(0,0,255,0.2)'; 
            ctx.strokeStyle = N > 0 ? 'red' : 'blue'; 
            ctx.fill(); 
            ctx.stroke(); 
            ctx.fillStyle = '#333';
            ctx.font = `bold ${24 * fontScale}px Arial`;
            if (Math.abs(N) > 1e-3) { 
                const mid_offset_x=p1_offset_x*0.5, mid_offset_y=p1_offset_y*0.5; 
                const mid_pos=transform((n_i.x+n_j.x)/2+mid_offset_x, (n_i.y+n_j.y)/2+mid_offset_y); 
                labelManager.draw(ctx,`${N.toFixed(2)}`,mid_pos.x,mid_pos.y,allObstacles);
                // ÊèèÁîª„Åó„Åü„É©„Éô„É´„ÅÆ‰ΩçÁΩÆ„ÇíÈöúÂÆ≥Áâ©„Å®„Åó„Å¶ËøΩÂä†
                const labelMetrics = ctx.measureText(`${N.toFixed(2)}`);
                const labelWidth = labelMetrics.width;
                const labelHeight = 24;
                allObstacles.push({
                    x1: mid_pos.x - labelWidth/2 - 8, 
                    y1: mid_pos.y - labelHeight - 8, 
                    x2: mid_pos.x + labelWidth/2 + 8, 
                    y2: mid_pos.y + 8
                });
            } 
        }); 

        // ÊúÄÂæå„Å´ÁØÄÁÇπÁï™Âè∑„ÉªÈÉ®ÊùêÁï™Âè∑„ÇíÊèèÁîªÔºàÊúÄÂâçÈù¢Ôºâ
        drawStructure(ctx, transform, nodes, members, 'rgba(0,0,0,0)', true, true, false, null, fontScale);
    };
    const drawShearForceDiagram = (nodes, members, forces, memberLoads) => { 
        const drawingCtx = getDrawingContext(elements.shearCanvas); 
        if (!drawingCtx) return; 
        const { ctx, transform, scale } = drawingCtx; 
        // „Éï„Ç©„É≥„Éà„Çπ„Ç±„Éº„É´Ôºà24px „Éô„Éº„ÇπÔºâ„ÇíÂèñÂæó„Åó„Å¶ LabelManager „Å´Ê∏°„Åô
        const fontScale = window.settings?.fontScales?.shear || 1.0;
        const labelManager = LabelManager(fontScale);
        
        // ÊßãÈÄ†ÊèèÁîªÔºà„É©„Éô„É´„Å™„ÅóÔºâ
        drawStructure(ctx, transform, nodes, members, '#ccc', false, false, false, null, fontScale); 
        
        // „Çà„ÇäË©≥Á¥∞„Å™ÈöúÂÆ≥Áâ©ÁÆ°ÁêÜ
        const nodeObstacles = nodes.map(n => { 
            const pos = transform(n.x, n.y); 
            return {x1: pos.x - 16, y1: pos.y - 16, x2: pos.x + 16, y2: pos.y + 16}; 
        });
        const allObstacles = [...nodeObstacles]; 
        let maxShear = 0; 
        forces.forEach(f => maxShear = Math.max(maxShear, Math.abs(f.Q_i), Math.abs(f.Q_j))); 
        const maxOffsetPixels = 50; 
        let shearScale = 0; 
        if (scale > 0 && maxShear > 0) { 
            const maxOffsetModelUnits = maxOffsetPixels / scale; 
            shearScale = maxOffsetModelUnits / maxShear; 
        } 
        members.forEach((m, idx) => { 
            const Q_i = forces[idx].Q_i, Q_j = -forces[idx].Q_j; 
            const load=memberLoads.find(l=>l.memberIndex===idx), w=load?load.w:0; 
            const n_i=nodes[m.i], n_j=nodes[m.j]; 
            const offset_i=-Q_i*shearScale; 
            const p1_offset_x=-offset_i*m.s, p1_offset_y=offset_i*m.c; 
            const p1=transform(n_i.x+p1_offset_x, n_i.y+p1_offset_y); 
            const p_start=transform(n_i.x,n_i.y), p_end=transform(n_j.x,n_j.y); 
            ctx.beginPath(); 
            ctx.moveTo(p_start.x, p_start.y); 
            ctx.lineTo(p1.x, p1.y); 
            let p2; 
            if (w === 0) { 
                const offset_j=-Q_j*shearScale; 
                const p2_offset_x=-offset_j*m.s, p2_offset_y=offset_j*m.c; 
                p2=transform(n_j.x+p2_offset_x, n_j.y+p2_offset_y); 
                ctx.lineTo(p2.x, p2.y); 
            } else { 
                const numPoints = 10; 
                for(let i=1; i<=numPoints; i++){ 
                    const x_local=(i/numPoints)*m.length, Q_local=Q_i-w*x_local, offset_local=-Q_local*shearScale; 
                    const globalX=n_i.x+x_local*m.c-offset_local*m.s, globalY=n_i.y+x_local*m.s+offset_local*m.c; 
                    p2=transform(globalX, globalY); 
                    ctx.lineTo(p2.x, p2.y); 
                } 
            } 
            ctx.lineTo(p_end.x, p_end.y); 
            ctx.closePath(); 
            ctx.fillStyle = Q_i > 0 ? 'rgba(0,128,0,0.2)' : 'rgba(255,165,0,0.2)'; 
            ctx.strokeStyle = Q_i > 0 ? 'green' : 'orange'; 
            ctx.fill(); 
            ctx.stroke(); 
            ctx.fillStyle = '#333';
            ctx.font = `bold ${24 * fontScale}px Arial`;
            if(Math.abs(Q_i)>1e-3) {
                labelManager.draw(ctx,`${Q_i.toFixed(2)}`,p1.x,p1.y,allObstacles, { drawLeaderLine: true });
                // ÊèèÁîª„Åó„Åü„É©„Éô„É´„ÅÆ‰ΩçÁΩÆ„ÇíÈöúÂÆ≥Áâ©„Å®„Åó„Å¶ËøΩÂä†
                const labelMetrics = ctx.measureText(`${Q_i.toFixed(2)}`);
                const labelWidth = labelMetrics.width;
                const labelHeight = 24;
                allObstacles.push({
                    x1: p1.x - labelWidth/2 - 8, 
                    y1: p1.y - labelHeight - 8, 
                    x2: p1.x + labelWidth/2 + 8, 
                    y2: p1.y + 8
                });
            }
            if(Math.abs(Q_j)>1e-3) {
                labelManager.draw(ctx,`${Q_j.toFixed(2)}`,p2.x,p2.y,allObstacles, { drawLeaderLine: true });
                // ÊèèÁîª„Åó„Åü„É©„Éô„É´„ÅÆ‰ΩçÁΩÆ„ÇíÈöúÂÆ≥Áâ©„Å®„Åó„Å¶ËøΩÂä†
                const labelMetrics = ctx.measureText(`${Q_j.toFixed(2)}`);
                const labelWidth = labelMetrics.width;
                const labelHeight = 24;
                allObstacles.push({
                    x1: p2.x - labelWidth/2 - 8, 
                    y1: p2.y - labelHeight - 8, 
                    x2: p2.x + labelWidth/2 + 8, 
                    y2: p2.y + 8
                });
            } 
        }); 

        // ÊúÄÂæå„Å´ÁØÄÁÇπÁï™Âè∑„ÉªÈÉ®ÊùêÁï™Âè∑„ÇíÊèèÁîªÔºàÊúÄÂâçÈù¢Ôºâ
        drawStructure(ctx, transform, nodes, members, 'rgba(0,0,0,0)', true, true, false, null, fontScale);
    };

// --- ÂøúÂäõÂ∫¶„ÅÆË®àÁÆó„Å®„Ç´„É©„Éº„Éû„ÉÉ„Éî„É≥„Ç∞ ---
    const calculateCombinedStress = (force, sectionData) => {
        const { N_i, M_i, N_j, M_j } = force;
        const { A, Iy } = sectionData;
        
        // ÈÉ®Êùê‰∏°Á´Ø„Åß„ÅÆÂøúÂäõÂ∫¶„ÇíË®àÁÆó
        const stress_i = {
            axial: N_i / A,
            bending_top: Math.abs(M_i) / Iy * (sectionData.H / 2),  // ‰∏äÁ´Ø„Åß„ÅÆÊõ≤„ÅíÂøúÂäõ
            bending_bottom: Math.abs(M_i) / Iy * (sectionData.H / 2) // ‰∏ãÁ´Ø„Åß„ÅÆÊõ≤„ÅíÂøúÂäõ
        };
        
        const stress_j = {
            axial: N_j / A,
            bending_top: Math.abs(M_j) / Iy * (sectionData.H / 2),
            bending_bottom: Math.abs(M_j) / Iy * (sectionData.H / 2)
        };
        
        // ÂêàÊàêÂøúÂäõÂ∫¶ÔºàÊúÄÂ§ßÂÄ§Ôºâ
        const combined_i = Math.max(
            Math.abs(stress_i.axial + stress_i.bending_top),
            Math.abs(stress_i.axial - stress_i.bending_bottom)
        );
        
        const combined_j = Math.max(
            Math.abs(stress_j.axial + stress_j.bending_top),
            Math.abs(stress_j.axial - stress_j.bending_bottom)
        );
        
        return Math.max(combined_i, combined_j);
    };

    const getStressColor = (stress, maxStress) => {
        if (maxStress === 0) return 'rgb(0, 0, 255)'; // Èùí
        
        const ratio = Math.min(stress / maxStress, 1.0);
        
        // 4ÊÆµÈöé„ÅÆËâ≤Áõ∏Â§âÂåñÔºöÈùí‚ÜíÁ∑ë‚ÜíÈªÑ‚ÜíËµ§
        if (ratio <= 0.33) {
            // Èùí„Åã„ÇâÁ∑ë„Å∏ (0-33%)
            const localRatio = ratio / 0.33;
            const r = 0;
            const g = Math.round(255 * localRatio);
            const b = Math.round(255 * (1 - localRatio));
            return `rgb(${r}, ${g}, ${b})`;
        } else if (ratio <= 0.66) {
            // Á∑ë„Åã„ÇâÈªÑ„Å∏ (33-66%)
            const localRatio = (ratio - 0.33) / 0.33;
            const r = Math.round(255 * localRatio);
            const g = 255;
            const b = 0;
            return `rgb(${r}, ${g}, ${b})`;
        } else {
            // ÈªÑ„Åã„ÇâËµ§„Å∏ (66-100%)
            const localRatio = (ratio - 0.66) / 0.34;
            const r = 255;
            const g = Math.round(255 * (1 - localRatio));
            const b = 0;
            return `rgb(${r}, ${g}, ${b})`;
        }
    };

    const drawStressContour = (nodes, members, forces, sections) => {
        console.log('=== DRAWING STRESS CONTOUR START ===');
        console.log('Received parameters:', {
            nodesCount: nodes ? nodes.length : 'null',
            membersCount: members ? members.length : 'null',
            forcesCount: forces ? forces.length : 'null',
            sectionsCount: sections ? sections.length : 'null'
        });
        
        if (!elements.stressCanvas) {
            console.error('‚ùå Stress canvas element not found!');
            return;
        }
        
        console.log('‚úÖ Stress canvas element found:', elements.stressCanvas);
        
        const drawingCtx = getDrawingContext(elements.stressCanvas);
        if (!drawingCtx) {
            console.log('‚ùå Failed to get drawing context for stress canvas');
            return;
        }
        
        const { ctx, transform, scale } = drawingCtx;
        console.log('‚úÖ Drawing context obtained successfully');
        
        // „Ç≠„É£„É≥„Éê„Çπ„Çí„ÇØ„É™„Ç¢
        ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
        console.log('‚úÖ Canvas cleared');
        
        // ÊúÄÂ§ßÂøúÂäõÂ∫¶„ÇíË®àÁÆó
        let maxStress = 0;
        const memberStresses = [];
        
        members.forEach((member, idx) => {
            const force = forces[idx];
            const sectionData = sections[member.sectionIndex];
            
            if (sectionData) {
                const stress = calculateCombinedStress(force, sectionData);
                memberStresses[idx] = stress;
                maxStress = Math.max(maxStress, stress);
            } else {
                memberStresses[idx] = 0;
            }
        });
        
        console.log(`Maximum stress: ${maxStress.toFixed(2)} N/mm¬≤`);
        console.log('Member stresses:', memberStresses.slice(0, 5)); // ÊúÄÂàù„ÅÆ5„Å§„ÇíË°®Á§∫
        
        // ÂêÑÈÉ®Êùê„ÇíÂøúÂäõÂ∫¶„Å´Âøú„Åò„Å¶Ëâ≤ÂàÜ„Åë„Åó„Å¶ÊèèÁîª
        let drawnMembers = 0;
        members.forEach((member, idx) => {
            const stress = memberStresses[idx];
            const color = getStressColor(stress, maxStress);
            const n_i = nodes[member.i];
            const n_j = nodes[member.j];
            
            if (!n_i || !n_j) {
                console.log(`Missing nodes for member ${idx}:`, { i: member.i, j: member.j });
                return;
            }
            
            const start = transform(n_i.x, n_i.y);
            const end = transform(n_j.x, n_j.y);
            
            ctx.beginPath();
            ctx.moveTo(start.x, start.y);
            ctx.lineTo(end.x, end.y);
            ctx.strokeStyle = color;
            ctx.lineWidth = 4; // Â§™„ÅÑÁ∑ö„ÅßË°®Á§∫
            ctx.stroke();
            
            drawnMembers++;
            
            // ÊúÄÂàù„ÅÆ3„Å§„ÅÆÈÉ®Êùê„ÅÆÊÉÖÂ†±„Çí„É≠„Ç∞Âá∫Âäõ
            if (idx < 3) {
                console.log(`Member ${idx}: stress=${stress.toFixed(2)}, color=${color}, start=(${start.x.toFixed(1)},${start.y.toFixed(1)}), end=(${end.x.toFixed(1)},${end.y.toFixed(1)})`);
            }
        });
        
        console.log(`Drew ${drawnMembers} members`);
        
        // ÁØÄÁÇπ„ÇíÊèèÁîª
        let drawnNodes = 0;
        nodes.forEach((node, idx) => {
            const pos = transform(node.x, node.y);
            ctx.beginPath();
            ctx.arc(pos.x, pos.y, 4, 0, 2 * Math.PI);
            ctx.fillStyle = '#333';
            ctx.fill();
            drawnNodes++;
        });
        
        console.log(`Drew ${drawnNodes} nodes`);
        
        // Âá°‰æã„ÇíÊèèÁîª
        drawStressLegend(ctx, maxStress);
        console.log('Legend drawn');
        
        // ÁØÄÁÇπÁï™Âè∑„ÉªÈÉ®ÊùêÁï™Âè∑„ÇíÊèèÁîªÔºàÊúÄÂâçÈù¢Ôºâ
        const fontScale = window.settings?.fontScales?.stress || 1.0;
        drawStructure(ctx, transform, nodes, members, 'rgba(0,0,0,0)', true, true, false, null, fontScale);

        console.log('=== DRAWING STRESS CONTOUR COMPLETED ===');
    };

    const drawStressLegend = (ctx, maxStress) => {
        const legendX = 20;
        const legendY = 20;
        const legendWidth = 200;
        const legendHeight = 20;
        
        // ËÉåÊôØ
        ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
        ctx.fillRect(legendX - 5, legendY - 5, legendWidth + 60, legendHeight + 30);
        ctx.strokeStyle = '#333';
        ctx.strokeRect(legendX - 5, legendY - 5, legendWidth + 60, legendHeight + 30);
        
        // „Ç∞„É©„Éá„Éº„Ç∑„Éß„É≥
        for (let i = 0; i <= legendWidth; i++) {
            const ratio = i / legendWidth;
            const color = getStressColor(ratio * maxStress, maxStress);
            ctx.strokeStyle = color;
            ctx.beginPath();
            ctx.moveTo(legendX + i, legendY);
            ctx.lineTo(legendX + i, legendY + legendHeight);
            ctx.stroke();
        }
        
        // „É©„Éô„É´
        ctx.fillStyle = '#333';
        const fontScale = window.settings?.fontScale || 1.0;
        ctx.font = `${12 * fontScale}px Arial`;
        ctx.fillText('0', legendX - 2, legendY + legendHeight + 15);
        ctx.fillText(`${maxStress.toFixed(1)} N/mm¬≤`, legendX + legendWidth - 30, legendY + legendHeight + 15);
        ctx.fillText('ÂøúÂäõÂ∫¶„Ç≥„É≥„Çø„Éº', legendX + 70, legendY - 10);
    };

    // ÂøúÂäõÂ∫¶Èñ¢Êï∞„ÇíwindowÂ§âÊï∞„Å®„Åó„Å¶ÁôªÈå≤Ôºà„ÇØ„É≠„Çπ„Çπ„Ç≥„Éº„Éó„Ç¢„ÇØ„Çª„ÇπÁî®Ôºâ
    window.calculateCombinedStress = calculateCombinedStress;
    window.getStressColor = getStressColor;
    window.drawStressContour = drawStressContour;
    window.drawStressLegend = drawStressLegend;

// --- ÂºæÊÄßÂ∫ßÂ±àËß£ÊûêÊ©üËÉΩ ---
    const calculateBucklingAnalysis = () => {
        if (!lastResults) return [];
        const { members, forces } = lastResults;
        const bucklingResults = [];

        members.forEach((member, idx) => {
            const { strengthProps, A, i_radius, ix, iy, E, length, i_conn, j_conn } = member;
            const force = forces[idx];
            
            // ÂøÖË¶Å„Å™Êñ≠Èù¢ÊÉÖÂ†±„ÅåÊèÉ„Å£„Å¶„ÅÑ„Çã„ÅãÁ¢∫Ë™ç„ÄÇi_radius „Åå„ÅÇ„Çå„Å∞„Åù„Çå„ÇíÂÑ™ÂÖà„Åó„Å¶‰ΩøÁî®
            const hasIRadius = (i_radius !== undefined && i_radius !== null && !isNaN(i_radius) && i_radius > 0);
            const hasIxIy = (ix !== undefined && iy !== undefined && !isNaN(ix) && !isNaN(iy) && ix > 0 && iy > 0);
            if (!A || (!hasIRadius && !hasIxIy) || isNaN(A) || (hasIxIy && (isNaN(ix) || isNaN(iy)))) {
                bucklingResults.push({
                    memberIndex: idx,
                    status: '„Éá„Éº„Çø‰∏çË∂≥',
                    criticalLoad: 'N/A',
                    bucklingMode: 'N/A',
                    bucklingLength: 'N/A',
                    slendernessRatio: 'N/A',
                    safetyFactor: 'N/A'
                });
                return;
            }

            // Â∫ßÂ±àÈï∑„ÅÆË®àÁÆóÔºàÈÉ®Êùê„Åî„Å®„ÅÆÂ∫ßÂ±à‰øÇÊï∞ K „ÇíÂÑ™ÂÖà„Åó„ÄÅÊú™ÊåáÂÆö„Å™„ÇâÊé•ÂêàÊù°‰ª∂„Åã„ÇâËá™ÂãïÂà§ÂÆöÔºâ
            let bucklingLengthFactor = 1.0;
            if (member.bucklingK !== null && member.bucklingK !== undefined && !isNaN(member.bucklingK)) {
                bucklingLengthFactor = Number(member.bucklingK);
            } else {
                if (i_conn === 'rigid' && j_conn === 'rigid') {
                    bucklingLengthFactor = 0.5; // ‰∏°Á´ØÂõ∫ÂÆö
                } else if ((i_conn === 'rigid' && j_conn === 'pinned') || 
                          (i_conn === 'pinned' && j_conn === 'rigid')) {
                    bucklingLengthFactor = 0.7; // ‰∏ÄÁ´ØÂõ∫ÂÆö„Éª‰∏ÄÁ´Ø„Éî„É≥
                } else if (i_conn === 'pinned' && j_conn === 'pinned') {
                    bucklingLengthFactor = 1.0; // ‰∏°Á´Ø„Éî„É≥
                }
            }
            
            const bucklingLength = length * bucklingLengthFactor; // Â∫ßÂ±àÈï∑ (m)
            
            // ÊúÄÂ∞èÂõûËª¢ÂçäÂæÑ: i_radius „ÇíÂÑ™ÂÖà„ÄÅ„Å™„Åë„Çå„Å∞ ix/iy „ÅÆÊúÄÂ∞èÂÄ§„Çí‰ΩøÁî®
            const i_min = hasIRadius ? i_radius : Math.min(ix, iy); // ÊúÄÂ∞èÂõûËª¢ÂçäÂæÑ (m)
            const slendernessRatio = bucklingLength / i_min; // Á¥∞Èï∑ÊØî
            
            // --- AIJ Â∫ßÂ±àË®àÁÆó (ÈùûÂºæÊÄß„ÉªÈôç‰ºèËÄÉÊÖÆ) ---
            // E„ÅØkPaÂçò‰Ωç„ÅßÊ†ºÁ¥ç„Åï„Çå„Å¶„ÅÑ„Çã (parseInputs„Åß *1000 „Åï„Çå„Å¶„ÅÑ„Çã„Åü„ÇÅ)
            const E_Nmm2 = E / 1000; // kPa -> MPa (N/mm¬≤)
            
            // ÊùêÊñô„Çø„Ç§„Éó„ÅÆÂà§ÂÆö
            let materialType = 'steel';
            if (strengthProps && strengthProps.type === 'wood-type') {
                materialType = 'wood';
            } else {
                // „É§„É≥„Ç∞‰øÇÊï∞„Å´„Çà„ÇãÁ∞°ÊòìÂà§ÂÆö
                if (E_Nmm2 < 25000) materialType = 'wood';
                else if (E_Nmm2 < 100000) materialType = 'aluminum';
                else if (E_Nmm2 < 200000) materialType = 'stainless';
                else materialType = 'steel';
            }

            // Âü∫Ê∫ñÂº∑Â∫¶ F (N/mm¬≤)
            let F = 235; // „Éá„Éï„Ç©„É´„Éà (SS400„Å™„Å©)
            if (materialType === 'wood') {
                if (strengthProps && strengthProps.baseStrengths && strengthProps.baseStrengths.fc) {
                    F = strengthProps.baseStrengths.fc;
                } else {
                    F = 22.2; // Default wood Fc
                }
            } else {
                if (strengthProps && strengthProps.value) {
                    F = strengthProps.value;
                }
            }
            
            // ÈôêÁïåÁ¥∞Èï∑ÊØî Lambda „Å® Â∫ßÂ±àÂøúÂäõ sigma_cr „ÅÆË®àÁÆó
            let Lambda;
            let sigma_cr;
            let bucklingType = 'ÂºæÊÄßÂ∫ßÂ±à(„Ç™„Ç§„É©„Éº)';
            let formulaName = '';

            if (materialType === 'wood') {
                // Êú®Êùê (AIJ)
                // ÈôêÁïåÁ¥∞Èï∑ÊØî Œõ = œÄ * sqrt(E / (2/3 * Fc))
                Lambda = Math.PI * Math.sqrt(E_Nmm2 / ((2/3) * F));
                
                if (slendernessRatio <= Lambda) {
                    // ÈùûÂºæÊÄßÂ∫ßÂ±à (4Ê¨°Âºè)
                    // œÉcr = Fc * [1 - 1/3 * (Œª/Œõ)^4]
                    sigma_cr = F * (1 - (1/3) * Math.pow(slendernessRatio / Lambda, 4));
                    bucklingType = 'ÈùûÂºæÊÄßÂ∫ßÂ±à(Â°ëÊÄßÂüü)';
                    formulaName = '4Ê¨°Âºè (AIJÊú®Ë≥™)';
                } else {
                    // ÂºæÊÄßÂ∫ßÂ±à („Ç™„Ç§„É©„Éº)
                    sigma_cr = (Math.PI * Math.PI * E_Nmm2) / (slendernessRatio * slendernessRatio);
                    bucklingType = 'ÂºæÊÄßÂ∫ßÂ±à(„Ç™„Ç§„É©„Éº)';
                    formulaName = '„Ç™„Ç§„É©„ÉºÂºè';
                }
            } else if (materialType === 'aluminum') {
                // „Ç¢„É´„Éü„Éã„Ç¶„É† (AIJ)
                // ÊØî‰æãÈôêÂ∫¶„Çí0.5F„Å®‰ªÆÂÆö (AIJ„Ç¢„É´„Éü„Éã„Ç¶„É†ÊßãÈÄ†Ë®≠Ë®àË¶èÊ∫ñÁ≠â„ÇíÂèÇÁÖß)
                Lambda = Math.PI * Math.sqrt(E_Nmm2 / (0.5 * F));
                
                if (slendernessRatio <= Lambda) {
                    // „Ç∏„Éß„É≥„ÇΩ„É≥Âºè (‰øÇÊï∞0.5)
                    sigma_cr = F * (1 - 0.5 * Math.pow(slendernessRatio / Lambda, 2));
                    bucklingType = 'ÈùûÂºæÊÄßÂ∫ßÂ±à(Â°ëÊÄßÂüü)';
                    formulaName = '„Ç∏„Éß„É≥„ÇΩ„É≥Âºè (AIJ„Ç¢„É´„Éü„Éã„Ç¶„É†)';
                } else {
                    sigma_cr = (Math.PI * Math.PI * E_Nmm2) / (slendernessRatio * slendernessRatio);
                    bucklingType = 'ÂºæÊÄßÂ∫ßÂ±à(„Ç™„Ç§„É©„Éº)';
                    formulaName = '„Ç™„Ç§„É©„ÉºÂºè';
                }
            } else {
                // ÈãºÊùê„Éª„Çπ„ÉÜ„É≥„É¨„Çπ (AIJÈãºÊßãÈÄ†)
                // „Çπ„ÉÜ„É≥„É¨„Çπ„ÇÇÈãºÊßãÈÄ†„Å´Ê∫ñ„Åò„Å¶Ë®àÁÆó (ÊØî‰æãÈôêÂ∫¶0.6F)
                Lambda = Math.PI * Math.sqrt(E_Nmm2 / (0.6 * F));
                
                if (slendernessRatio <= Lambda) {
                    // „Ç∏„Éß„É≥„ÇΩ„É≥Âºè (‰øÇÊï∞0.4)
                    sigma_cr = F * (1 - 0.4 * Math.pow(slendernessRatio / Lambda, 2));
                    bucklingType = 'ÈùûÂºæÊÄßÂ∫ßÂ±à(Â°ëÊÄßÂüü)';
                    formulaName = '„Ç∏„Éß„É≥„ÇΩ„É≥Âºè (AIJÈãºÊßãÈÄ†)';
                } else {
                    sigma_cr = (Math.PI * Math.PI * E_Nmm2) / (slendernessRatio * slendernessRatio);
                    bucklingType = 'ÂºæÊÄßÂ∫ßÂ±à(„Ç™„Ç§„É©„Éº)';
                    formulaName = '„Ç™„Ç§„É©„ÉºÂºè';
                }
            }
            
            // Â∫ßÂ±àËç∑Èáç P_cr (N)
            // A„ÅØm¬≤ -> mm¬≤„Å´Â§âÊèõ (x 10^6)
            const criticalLoadN = sigma_cr * (A * 1000000);
            
            // ÁèæÂú®„ÅÆËª∏ÂäõÔºàË≤†„ÅÆÂÄ§„ÇíÂúßÁ∏Æ„Å®„Åó„Å¶Êâ±„ÅÜÔºâ
            const N_i = force.N_i; // Ëß£ÊûêÁµêÊûú„Åù„ÅÆ„Åæ„Åæ
            const N_j = force.N_j; // Ëß£ÊûêÁµêÊûú„Åù„ÅÆ„Åæ„Åæ
            
            // „Çà„ÇäÂ§ß„Åç„Å™Ëª∏Âäõ„ÇíÈÅ∏Êäû
            const axialForceKN = (Math.abs(N_i) > Math.abs(N_j)) ? N_i : N_j; // kNÂçò‰Ωç„Åß„ÅÆËª∏Âäõ
            const compressionForce = axialForceKN < 0 ? Math.abs(axialForceKN) * 1000 : 0; // Ë≤†„ÅÆÂÄ§„ÇíÂúßÁ∏ÆÂäõ„Å®„Åó„Å¶ÊäΩÂá∫„ÄÅNÂçò‰Ωç„Å´Â§âÊèõ
            
            // Â∫ßÂ±à„É¢„Éº„Éâ„ÅÆÂà§ÂÆö: i_radius „ÅåÊòéÁ§∫„Åï„Çå„Å¶„ÅÑ„Çå„Å∞„ÄåÊúÄÂ∞èÊñ≠Èù¢2Ê¨°ÂçäÂæÑËª∏„Åæ„Çè„Çä„Äç„Å®„Åô„Çã
            let bucklingMode = 'ÊúÄÂ∞èÊñ≠Èù¢2Ê¨°ÂçäÂæÑËª∏„Åæ„Çè„Çä';
            if (!hasIRadius) {
                if (ix < iy) {
                    bucklingMode = 'XËª∏„Åæ„Çè„ÇäÂ∫ßÂ±àÔºàÂº∑Ëª∏Ôºâ';
                } else if (iy < ix) {
                    bucklingMode = 'YËª∏„Åæ„Çè„ÇäÂ∫ßÂ±àÔºàÂº±Ëª∏Ôºâ';
                } else {
                    bucklingMode = 'Á≠âÊñπÊÄßÊñ≠Èù¢';
                }
            }
            
            // ÂÆâÂÖ®Áéá„ÅÆË®àÁÆó
            let safetyFactor = 'N/A';
            let status = 'ÂÆâÂÖ®';
            
            if (compressionForce > 0) { // ÂúßÁ∏ÆÂäõ„Åå„ÅÇ„ÇãÂ†¥ÂêàÔºàË≤†„ÅÆËª∏Âäõ„ÇíÂúßÁ∏Æ„Å®„Åó„Å¶Âà§ÂÆöÔºâ
                safetyFactor = criticalLoadN / compressionForce;
                if (safetyFactor < 1.0) {
                    status = 'Â∫ßÂ±àÂç±Èô∫';
                } else if (safetyFactor < 2.0) {
                    status = 'Ë¶ÅÊ≥®ÊÑè';
                } else {
                    status = 'ÂÆâÂÖ®';
                }
            } else if (axialForceKN > 0) {
                // ÂºïÂºµÊùê„ÅÆÂ†¥Âêà
                status = 'ÂºïÂºµÊùêÔºàÂ∫ßÂ±à„Å™„ÅóÔºâ';
                safetyFactor = '‚àû';
            } else {
                // Ëª∏Âäõ„Åå0„ÅÆÂ†¥Âêà
                status = 'Â∫ßÂ±à„Å™„Åó';
                safetyFactor = '‚àû';
            }

            bucklingResults.push({
                memberIndex: idx,
                status: status,
                criticalLoad: criticalLoadN / 1000, // kN„Å´Â§âÊèõ
                bucklingLoad: criticalLoadN / 1000, // kN„Å´Â§âÊèõÔºà„Ç®„ÇØ„Çª„É´Âá∫ÂäõÁî®Ôºâ
                bucklingMode: bucklingMode,
                bucklingType: bucklingType, // ËøΩÂä†
                formulaName: formulaName, // ËøΩÂä†
                materialType: materialType, // ËøΩÂä†
                bucklingLength: bucklingLength,
                slendernessRatio: slendernessRatio,
                criticalSlendernessRatio: Lambda, // ËøΩÂä†
                safetyFactor: safetyFactor,
                axialForce: axialForceKN, // kNÂçò‰ΩçÔºàË≤†„ÅÆÂÄ§„ÅåÂúßÁ∏Æ„ÄÅÊ≠£„ÅÆÂÄ§„ÅåÂºïÂºµÔºâ
                bucklingLengthFactor: bucklingLengthFactor,
                connectionType: `i:${i_conn}, j:${j_conn}`,
                memberLength: length,
                momentOfInertia: i_min * i_min * A,
                radiusOfGyration: i_min,
                elasticModulus: E_Nmm2 // MPaÂçò‰Ωç
            });
        });

        return bucklingResults;
    };

// --- Section Check Logic and Drawing ---
    const calculateSectionCheck = (loadTerm) => {
        if (!lastResults) return [];
        const { members, forces, memberLoads } = lastResults;
        const results = [];
        members.forEach((member, idx) => {
            const { strengthProps, A, Z, ix, iy, E, length } = member;
            if(!strengthProps || !A || !Z || isNaN(A) || isNaN(Z)) {
                results.push({ maxRatio: 'N/A', N: 0, M: 0, checkType: '„Éá„Éº„Çø‰∏çË∂≥', status: 'error', ratios: Array(21).fill(0)});
                return;
            }
            let ft, fc, fb, fs;
            const termIndex = (loadTerm === 'long') ? 0 : 1;
            
            switch(strengthProps.type) {
                case 'F-value': case 'F-stainless': case 'F-aluminum':
                    const F = strengthProps.value;
                    if (!F || isNaN(F)) { results.push({ maxRatio: 'N/A', N: 0, M: 0, checkType: 'FÂÄ§ÁÑ°Âäπ', status: 'error', ratios: Array(21).fill(0)}); return; }
                    const factor = (loadTerm === 'long') ? 1.5 : 1.0;
                    ft = F / factor; fb = F / factor; fs = F / (factor * Math.sqrt(3));
                    const lk = length, i_min = Math.min(ix, iy);
                    fc = ft;
                    if (i_min > 1e-9) {
                        const lambda = lk / i_min, E_n_mm2 = E * 1e-3;
                        const lambda_p = Math.PI * Math.sqrt(E_n_mm2 / (0.6 * F));
                        if (lambda <= lambda_p) { fc = (1 - 0.4 * (lambda / lambda_p)**2) * F / factor; } 
                        else { fc = (0.277 * F) / ((lambda / lambda_p)**2); }
                    }
                    break;
                case 'wood-type': {
                    let baseStresses;
                    if (strengthProps.preset === 'custom') {
                        baseStresses = strengthProps.baseStrengths;
                        if (!baseStresses || isNaN(baseStresses.ft) || isNaN(baseStresses.fc) || isNaN(baseStresses.fb) || isNaN(baseStresses.fs)) {
                            results.push({ maxRatio: 'N/A', N: 0, M: 0, checkType: 'Êú®ÊùêÂü∫Ê∫ñÂº∑Â∫¶ÁÑ°Âäπ', status: 'error', ratios: Array(21).fill(0) });
                            return; // continue forEach
                        }
                    } else {
                        baseStresses = WOOD_BASE_STRENGTH_DATA[strengthProps.preset];
                        if (!baseStresses) {
                            results.push({ maxRatio: 'N/A', N: 0, M: 0, checkType: 'Êú®Êùê„Éá„Éº„ÇøÁÑ°', status: 'error', ratios: Array(21).fill(0) });
                            return; // continue forEach
                        }
                    }
                    // „Éó„É™„Çª„ÉÉ„Éà„Éª‰ªªÊÑèÂÖ•ÂäõÂÖ±ÈÄö„ÅÆË®àÁÆó„É≠„Ç∏„ÉÉ„ÇØ
                    const factor = (loadTerm === 'long') ? (1.1 / 3) : (2 / 3);
                    ft = baseStresses.ft * factor;
                    fc = baseStresses.fc * factor;
                    fb = baseStresses.fb * factor;
                    fs = baseStresses.fs * factor;
                    break;
                }
                case 'Fc':
                default:
                    results.push({ maxRatio: 'N/A', N: 0, M: 0, checkType: 'Êú™ÂØæÂøúÊùêÊñô', status: 'error', ratios: Array(21).fill(0)});
                    return;
            }

            const force = forces[idx], load = memberLoads.find(l => l.memberIndex === idx), w = load ? load.w : 0;
            const L = length, N = -force.N_i, Z_mm3 = Z * 1e9, A_mm2 = A * 1e6;
            let maxRatio = 0, M_at_max = 0;
            const ratios = [];
            for (let k = 0; k <= 20; k++) {
                const x = (k / 20) * L, M_linear = -force.M_i * (1 - x/L) + force.M_j * (x/L), M_parabolic = w * L * x / 2 - w * x**2 / 2;
                const M_x = M_linear + M_parabolic, sigma_a = (N * 1000) / A_mm2, sigma_b = (Math.abs(M_x) * 1e6) / Z_mm3;
                let ratio_x = 0;
                if(isNaN(sigma_a) || isNaN(sigma_b) || !ft || !fc || !fb) { ratio_x = Infinity; }
                else if (sigma_a >= 0) { // ÂºïÂºµ
                    ratio_x = (sigma_a / ft) + (sigma_b / fb);
                } 
                else { // ÂúßÁ∏Æ
                    ratio_x = (Math.abs(sigma_a) / fc) + (sigma_b / fb);
                }
                ratios.push(ratio_x);
                if (ratio_x > maxRatio) { maxRatio = ratio_x; M_at_max = M_x; }
            }
            results.push({ maxRatio, N, M: M_at_max, checkType: 'ÁµÑÂêà„ÅõÂøúÂäõ', status: maxRatio > 1.0 ? 'NG' : 'OK', ratios });
        });
        return results;
    };

    const getDeflectionCheckSettings = () => {
        const fallback = window.settings?.deflectionCheck || { amplificationFactor: 1.0, allowableDeflectionMm: 10, spanRatio: 300 };

        const ampInput = document.getElementById('defl-amp-factor');
        const allowMmInput = document.getElementById('defl-allow-mm');
        const spanRatioInput = document.getElementById('defl-span-ratio');

        const amplificationFactorRaw = ampInput ? parseFloat(ampInput.value) : fallback.amplificationFactor;
        const allowableDeflectionMmRaw = allowMmInput ? parseFloat(allowMmInput.value) : fallback.allowableDeflectionMm;
        const spanRatioRaw = spanRatioInput ? parseFloat(spanRatioInput.value) : fallback.spanRatio;

        const amplificationFactor = (isFinite(amplificationFactorRaw) && amplificationFactorRaw >= 0) ? amplificationFactorRaw : 1.0;
        const allowableDeflectionMm = (isFinite(allowableDeflectionMmRaw) && allowableDeflectionMmRaw >= 0) ? allowableDeflectionMmRaw : 10;
        const spanRatio = (isFinite(spanRatioRaw) && spanRatioRaw >= 1) ? spanRatioRaw : 300;

        return { amplificationFactor, allowableDeflectionMm, spanRatio };
    };

    const getLtbCheckSettings = () => {
        const fallback = window.settings?.ltbCheck || { unbracedLengthFactor: 1.0, cb: 1.0, nu: 0.30 };

        const factorInput = document.getElementById('ltb-unbraced-factor');
        const cbInput = document.getElementById('ltb-cb');
        const nuInput = document.getElementById('ltb-nu');

        const unbracedLengthFactorRaw = factorInput ? parseFloat(factorInput.value) : fallback.unbracedLengthFactor;
        const cbRaw = cbInput ? parseFloat(cbInput.value) : fallback.cb;
        const nuRaw = nuInput ? parseFloat(nuInput.value) : fallback.nu;

        const unbracedLengthFactor = (isFinite(unbracedLengthFactorRaw) && unbracedLengthFactorRaw >= 0) ? unbracedLengthFactorRaw : 1.0;
        const cb = (isFinite(cbRaw) && cbRaw > 0) ? cbRaw : 1.0;
        const nu = (isFinite(nuRaw) && nuRaw >= 0 && nuRaw < 0.5) ? nuRaw : 0.30;

        return { unbracedLengthFactor, cb, nu };
    };

    const calculateLtbCheck = (loadTerm) => {
        if (!lastResults) return [];
        const { members, forces, memberLoads } = lastResults;
        const settings = getLtbCheckSettings();

        const results = [];
        const factor = (loadTerm === 'long') ? 1.5 : 1.0;

        members.forEach((member, idx) => {
            const { strengthProps, Z, E, length } = member;

            // Ê®™Â∫ßÂ±à„ÅØÂéüÂâá„Å®„Åó„Å¶ÈãºÊùêÔºàF-valueÁ≥ªÔºâ„ÇíÂØæË±°
            const isSteelLike = strengthProps && (strengthProps.type === 'F-value' || strengthProps.type === 'F-stainless' || strengthProps.type === 'F-aluminum');
            if (!isSteelLike) {
                results.push({ memberIndex: idx, status: 'N/A', message: 'ÂØæË±°Â§ñÊùêÊñô', ratio: NaN });
                return;
            }

            // Âº∑Ëª∏Êõ≤„Åí‰ª•Â§ñ„ÅØÁ∞°ÊòìÁöÑ„Å´ N/A Êâ±„ÅÑÔºàÂº±Ëª∏Êõ≤„Åí„ÅØÊ®™Â∫ßÂ±àÊîØÈÖç„Å´„Å™„Çä„Å´„Åè„ÅÑÔºâ
            // sectionAxis.mode „Åå strong/both „ÅÆÂ†¥Âêà„ÅÆ„ÅøË©ï‰æ°
            try {
                const axisMode = member.sectionAxis?.mode;
                if (axisMode && axisMode !== 'strong' && axisMode !== 'both') {
                    results.push({ memberIndex: idx, status: 'N/A', message: 'Âº±Ëª∏Êõ≤„ÅíÔºàÊ®™Â∫ßÂ±àÁúÅÁï•Ôºâ', ratio: NaN });
                    return;
                }
            } catch (_) { /* ignore */ }

            const F = strengthProps.value;
            if (!F || !isFinite(F)) {
                results.push({ memberIndex: idx, status: 'error', message: 'FÂÄ§ÁÑ°Âäπ', ratio: NaN });
                return;
            }
            if (!Z || !isFinite(Z) || Z <= 0) {
                results.push({ memberIndex: idx, status: 'error', message: 'Z„ÅåÁÑ°Âäπ', ratio: NaN });
                return;
            }
            if (!E || !isFinite(E) || E <= 0 || !length || !isFinite(length) || length <= 0) {
                results.push({ memberIndex: idx, status: 'error', message: 'E/Èï∑„Åï„ÅåÁÑ°Âäπ', ratio: NaN });
                return;
            }

            // ÂøÖË¶ÅÊñ≠Èù¢ÂÆöÊï∞ÔºàIy/J/IwÔºâ
            let Iy_m4 = member.Iy;
            let J_m4 = member.J;
            let Iw_m6 = member.Iw;

            // Âèñ„Çä„Åì„Åº„ÅóÂØæÁ≠ñ: sectionInfo „Åå„ÅÇ„ÇãÂ†¥Âêà„ÄÅsteel_data.js „Åã„ÇâËá™ÂãïË£úÂÆå
            const needBackfill = (!Iy_m4 || !isFinite(Iy_m4) || Iy_m4 <= 0 || !J_m4 || !isFinite(J_m4) || J_m4 <= 0 || !Iw_m6 || !isFinite(Iw_m6) || Iw_m6 <= 0);
            if (needBackfill) {
                try {
                    if (typeof lookupSteelDataPropertiesForSectionInfo === 'function' && member.sectionInfo) {
                        const props = lookupSteelDataPropertiesForSectionInfo(member.sectionInfo);
                        if (props && typeof props === 'object') {
                            const iyCm4 = (props.Iy !== undefined && props.Iy !== null && props.Iy !== '') ? parseFloat(props.Iy) : NaN;
                            const jCm4 = (props.J !== undefined && props.J !== null && props.J !== '') ? parseFloat(props.J) : NaN;
                            const iwCm6 = (props.Iw !== undefined && props.Iw !== null && props.Iw !== '') ? parseFloat(props.Iw) : NaN;

                            const Iy2 = Number.isFinite(iyCm4) ? (iyCm4 * 1e-8) : undefined; // m^4
                            const J2 = Number.isFinite(jCm4) ? (jCm4 * 1e-8) : undefined; // m^4
                            const Iw2 = Number.isFinite(iwCm6) ? (iwCm6 * 1e-12) : undefined; // m^6

                            if ((!Iy_m4 || !isFinite(Iy_m4) || Iy_m4 <= 0) && Iy2 && isFinite(Iy2) && Iy2 > 0) Iy_m4 = Iy2;
                            if ((!J_m4 || !isFinite(J_m4) || J_m4 <= 0) && J2 && isFinite(J2) && J2 > 0) J_m4 = J2;
                            if ((!Iw_m6 || !isFinite(Iw_m6) || Iw_m6 <= 0) && Iw2 && isFinite(Iw2) && Iw2 > 0) Iw_m6 = Iw2;

                            // member „Å´„ÇÇ‰øùÂ≠ò„Åó„Å¶‰ª•Èôç„ÅÆÂá¶ÁêÜ„ÅßÂà©Áî®„Åó„ÇÑ„Åô„Åè„Åô„Çã
                            if (Iy_m4 && isFinite(Iy_m4) && Iy_m4 > 0) member.Iy = Iy_m4;
                            if (J_m4 && isFinite(J_m4) && J_m4 > 0) member.J = J_m4;
                            if (Iw_m6 && isFinite(Iw_m6) && Iw_m6 > 0) member.Iw = Iw_m6;
                        }
                    }
                } catch (_) { /* ignore */ }
            }

            if (!Iy_m4 || !isFinite(Iy_m4) || Iy_m4 <= 0 || !J_m4 || !isFinite(J_m4) || J_m4 <= 0 || !Iw_m6 || !isFinite(Iw_m6) || Iw_m6 <= 0) {
                results.push({ memberIndex: idx, status: 'error', message: 'Iy/J/Iw „Éá„Éº„Çø‰∏çË∂≥', ratio: NaN });
                return;
            }

            // ‰ΩúÁî®Êõ≤„ÅíÔºöÈÉ®ÊùêÂÜÖ„ÅÆÊúÄÂ§ß |M| „Çí 21ÁÇπ„ÅßÊé¢Á¥¢ÔºàÊñ≠Èù¢ÁÆóÂÆö„Å®ÂêåÁ≠âÔºâ
            const force = forces[idx];
            const load = memberLoads.find(l => l.memberIndex === idx);
            const w = load ? load.w : 0;
            const L = length;

            let maxAbsM = 0;
            for (let k = 0; k <= 20; k++) {
                const x = (k / 20) * L;
                const M_linear = -force.M_i * (1 - x / L) + force.M_j * (x / L);
                const M_parabolic = w * L * x / 2 - w * x ** 2 / 2;
                const M_x = M_linear + M_parabolic;
                maxAbsM = Math.max(maxAbsM, Math.abs(M_x));
            }

            // Âçò‰ΩçÂ§âÊèõ
            const E_Nmm2 = E * 1e-3; // kPa -> N/mm^2
            const nu = settings.nu;
            const G_Nmm2 = E_Nmm2 / (2 * (1 + nu));

            const Z_mm3 = Z * 1e9; // m^3 -> mm^3
            const Iy_mm4 = Iy_m4 * 1e12; // m^4 -> mm^4
            const J_mm4 = J_m4 * 1e12; // m^4 -> mm^4
            const Iw_mm6 = Iw_m6 * 1e18; // m^6 -> mm^6

            const lb_m = Math.max(0, settings.unbracedLengthFactor) * L;
            const lb_mm = lb_m * 1000;
            if (!isFinite(lb_mm) || lb_mm <= 1e-9) {
                results.push({ memberIndex: idx, status: 'error', message: 'Lb„ÅåÁÑ°Âäπ', ratio: NaN });
                return;
            }

            // ÂºæÊÄßÊ®™Â∫ßÂ±àËá®Áïå„É¢„Éº„É°„É≥„Éà McrÔºàÁ∞°ÊòìÔºöÁ≠âÊñ≠Èù¢„Éª‰∏°ÂØæÁß∞IÂΩ¢„ÇíÊÉ≥ÂÆö„Åó„ÅüÂΩ¢Ôºâ
            // Mcr = Cb * (œÄ^2 E Iy / Lb^2) * sqrt( Iw/Iy + (Lb^2 G J)/(œÄ^2 E Iy) )
            const cb = settings.cb;
            const pi2 = Math.PI * Math.PI;
            const term1 = (pi2 * E_Nmm2 * Iy_mm4) / (lb_mm * lb_mm);
            const termInside = (Iw_mm6 / Iy_mm4) + ((lb_mm * lb_mm) * G_Nmm2 * J_mm4) / (pi2 * E_Nmm2 * Iy_mm4);
            const Mcr_Nmm = cb * term1 * Math.sqrt(Math.max(termInside, 0));
            const Mcr_kNm = Mcr_Nmm / 1e6; // (N*mm) -> (kN*m)

            const fcr_Nmm2 = (Z_mm3 > 0) ? (Mcr_Nmm / Z_mm3) : NaN;

            // Ë®±ÂÆπÂøúÂäõÂ∫¶Ë®≠Ë®àÔºàÈï∑Êúü/Áü≠Êúü„Åß‰øÇÊï∞„ÇíÂ§â„Åà„ÇãÈÅãÁî®Ôºâ„ÇíÊòéÁ¢∫Âåñ
            // Êó¢Â≠òÊñ≠Èù¢Ê§úÂÆö„Å®Êï¥ÂêàÔºöÁü≠Êúü=F/1.0„ÄÅÈï∑Êúü=F/1.5
            const fb_base = F / factor;
            const fb_ltb = (isFinite(fcr_Nmm2) && fcr_Nmm2 > 0) ? Math.min(fb_base, fcr_Nmm2 / factor) : fb_base;

            const sigma_b = (Z_mm3 > 0) ? ((maxAbsM * 1e6) / Z_mm3) : NaN; // kN*m -> N*mm
            const ratio = (isFinite(sigma_b) && isFinite(fb_ltb) && fb_ltb > 1e-12) ? (sigma_b / fb_ltb) : NaN;
            const status = isFinite(ratio) ? (ratio > 1.0 ? 'NG' : 'OK') : 'N/A';

            results.push({
                memberIndex: idx,
                L,
                Lb: lb_m,
                Cb: cb,
                nu,
                loadTerm,
                allowableFactor: factor,
                fb_base,
                Mmax: maxAbsM,
                Mcr: Mcr_kNm,
                sigma_b: sigma_b,
                fb_allow: fb_ltb,
                ratio,
                status,
                message: ''
            });
        });

        return results;
    };

    const displayLtbCheckResults = () => {
        if (!elements.ltbCheckResults) return;
        if (!lastLtbCheckResults || lastLtbCheckResults.length === 0) {
            elements.ltbCheckResults.innerHTML = '';
            return;
        }

        let html = `<thead><tr>`;
        html += `<th>ÈÉ®Êùê #</th>`;
        html += `<th>L (m)</th>`;
        html += `<th>Lb (m)</th>`;
        html += `<th>Ëç∑Èáç</th>`;
        html += `<th>‰øÇÊï∞</th>`;
        html += `<th>fbÂü∫Ê∫ñ (N/mm¬≤)</th>`;
        html += `<th>Cb</th>`;
        html += `<th>|M|max (kN¬∑m)</th>`;
        html += `<th>Mcr (kN¬∑m)</th>`;
        html += `<th>œÉb (N/mm¬≤)</th>`;
        html += `<th>fb(Ê®™Â∫ßÂ±à) (N/mm¬≤)</th>`;
        html += `<th>Ê§úÂÆöÊØî</th>`;
        html += `<th>Âà§ÂÆö</th>`;
        html += `</tr></thead><tbody>`;

        lastLtbCheckResults.forEach((res) => {
            const idx = (res.memberIndex ?? 0) + 1;
            const isNg = res.status === 'NG';
            const statusText = res.status === 'NG' ? '‚ùå NG' : (res.status === 'OK' ? '‚úÖ OK' : '‚Äî');
            const ratioText = (typeof res.ratio === 'number' && isFinite(res.ratio)) ? res.ratio.toFixed(3) : '‚Äî';

            const loadTermText = (res.loadTerm === 'long') ? 'Èï∑Êúü' : (res.loadTerm === 'short' ? 'Áü≠Êúü' : '‚Äî');
            const factorText = (typeof res.allowableFactor === 'number' && isFinite(res.allowableFactor)) ? res.allowableFactor.toFixed(2) : '‚Äî';
            const fbBaseText = (typeof res.fb_base === 'number' && isFinite(res.fb_base)) ? res.fb_base.toFixed(2) : '‚Äî';
            const cbText = (typeof res.Cb === 'number' && isFinite(res.Cb)) ? res.Cb.toFixed(2) : '‚Äî';

            const lText = (typeof res.L === 'number' && isFinite(res.L)) ? res.L.toFixed(2) : '‚Äî';
            const lbText = (typeof res.Lb === 'number' && isFinite(res.Lb)) ? res.Lb.toFixed(2) : '‚Äî';
            const mmaxText = (typeof res.Mmax === 'number' && isFinite(res.Mmax)) ? res.Mmax.toFixed(2) : '‚Äî';
            const mcrText = (typeof res.Mcr === 'number' && isFinite(res.Mcr)) ? res.Mcr.toFixed(2) : '‚Äî';
            const sigText = (typeof res.sigma_b === 'number' && isFinite(res.sigma_b)) ? res.sigma_b.toFixed(2) : (res.message || '‚Äî');
            const fbText = (typeof res.fb_allow === 'number' && isFinite(res.fb_allow)) ? res.fb_allow.toFixed(2) : '‚Äî';

            html += `<tr ${isNg ? 'style="background-color: #fdd;"' : ''}>`;
            html += `<td>${idx}</td>`;
            html += `<td>${lText}</td>`;
            html += `<td>${lbText}</td>`;
            html += `<td>${loadTermText}</td>`;
            html += `<td>${factorText}</td>`;
            html += `<td>${fbBaseText}</td>`;
            html += `<td>${cbText}</td>`;
            html += `<td>${mmaxText}</td>`;
            html += `<td>${mcrText}</td>`;
            html += `<td>${sigText}</td>`;
            html += `<td>${fbText}</td>`;
            html += `<td style="font-weight: bold; ${isNg ? 'color: red;' : ''}">${ratioText}</td>`;
            html += `<td>${statusText}</td>`;
            html += `</tr>`;
        });
        html += `</tbody>`;
        elements.ltbCheckResults.innerHTML = html;
    };

    const calculateDeflectionCheck = () => {
        if (!lastResults) return [];
        const { nodes, members, D, memberLoads } = lastResults;
        if (!D || !Array.isArray(D) || D.length === 0) return [];

        const settings = getDeflectionCheckSettings();
        const results = [];

        const distPointToLine = (ax, ay, bx, by, px, py) => {
            const vx = bx - ax;
            const vy = by - ay;
            const wx = px - ax;
            const wy = py - ay;
            const denom = Math.sqrt(vx * vx + vy * vy);
            if (denom < 1e-12) return 0;
            const cross = vx * wy - vy * wx;
            return Math.abs(cross) / denom;
        };

        members.forEach((m, idx) => {
            const ni = nodes[m.i];
            const nj = nodes[m.j];
            if (!ni || !nj) {
                results.push({
                    memberIndex: idx,
                    status: 'error',
                    message: 'ÁØÄÁÇπÊÉÖÂ†±„Åå„ÅÇ„Çä„Åæ„Åõ„Çì'
                });
                return;
            }

            const L = m.length;
            if (!isFinite(L) || L <= 0) {
                results.push({
                    memberIndex: idx,
                    status: 'error',
                    message: 'ÈÉ®ÊùêÈï∑„ÅåÁÑ°Âäπ„Åß„Åô'
                });
                return;
            }

            const load = (memberLoads || []).find(l => l.memberIndex === idx);
            const w = load ? load.w : 0;

            const dx_i = D[m.i * 3]?.[0] ?? 0;
            const dy_i = D[m.i * 3 + 1]?.[0] ?? 0;
            const dx_j = D[m.j * 3]?.[0] ?? 0;
            const dy_j = D[m.j * 3 + 1]?.[0] ?? 0;

            const ax = ni.x + dx_i;
            const ay = ni.y + dy_i;
            const bx = nj.x + dx_j;
            const by = nj.y + dy_j;

            const d_global_member_vec = [
                ...D.slice(m.i * 3, m.i * 3 + 3),
                ...D.slice(m.j * 3, m.j * 3 + 3)
            ];
            const d_local_vec = mat.multiply(m.T, d_global_member_vec);
            const [ui, vi, thi, uj, vj, thj] = d_local_vec.map(v => v[0]);

            let maxDeviation = 0;

            for (let k = 0; k <= 40; k++) {
                const x = (k / 40) * L;
                const xi = x / L;

                const N1 = 1 - 3 * xi ** 2 + 2 * xi ** 3;
                const N2 = x * (1 - xi) ** 2;
                const N3 = 3 * xi ** 2 - 2 * xi ** 3;
                const N4 = (x ** 2 / L) * (xi - 1);

                const u_local = (1 - xi) * ui + xi * uj;
                const v_homogeneous = N1 * vi + N2 * thi + N3 * vj + N4 * thj;

                let v_particular = 0;
                if (w !== 0 && m.E > 0 && m.I > 0) {
                    if (m.i_conn === 'rigid' && m.j_conn === 'rigid') v_particular = (w * x ** 2 * (L - x) ** 2) / (24 * m.E * m.I);
                    else if (m.i_conn === 'pinned' && m.j_conn === 'pinned') v_particular = (w * x * (L ** 3 - 2 * L * x ** 2 + x ** 3)) / (24 * m.E * m.I);
                    else if (m.i_conn === 'rigid' && m.j_conn === 'pinned') v_particular = (w * x ** 2 * (3 * L ** 2 - 5 * L * x + 2 * x ** 2)) / (48 * m.E * m.I);
                    else if (m.i_conn === 'pinned' && m.j_conn === 'rigid') v_particular = (w * x * (L ** 3 - 3 * L * x ** 2 + 2 * x ** 3)) / (48 * m.E * m.I);
                }

                const v_local = v_homogeneous - v_particular;

                const c = m.c;
                const s = m.s;
                const disp_x_global = u_local * c - v_local * s;
                const disp_y_global = u_local * s + v_local * c;

                const orig_x = ni.x + x * c;
                const orig_y = ni.y + x * s;
                const def_x = orig_x + disp_x_global;
                const def_y = orig_y + disp_y_global;

                const deviation = distPointToLine(ax, ay, bx, by, def_x, def_y);
                if (deviation > maxDeviation) maxDeviation = deviation;
            }

            const maxDeflectionMm = maxDeviation * 1000;
            const amplifiedDeflectionMm = maxDeflectionMm * settings.amplificationFactor;

            const spanBasedAllowableMm = (settings.spanRatio > 0) ? (L * 1000 / settings.spanRatio) : Infinity;
            const fixedAllowableMm = (settings.allowableDeflectionMm > 0) ? settings.allowableDeflectionMm : Infinity;
            const allowableMm = Math.min(spanBasedAllowableMm, fixedAllowableMm);

            const ratio = (isFinite(allowableMm) && allowableMm > 1e-12) ? (amplifiedDeflectionMm / allowableMm) : NaN;
            const status = (isFinite(ratio)) ? (ratio > 1.0 ? 'NG' : 'OK') : 'N/A';

            const actualSpanRatio = (amplifiedDeflectionMm > 1e-12) ? ((L * 1000) / amplifiedDeflectionMm) : Infinity;

            results.push({
                memberIndex: idx,
                length: L,
                maxDeflectionMm,
                amplifiedDeflectionMm,
                allowableMm,
                allowableBySpanRatioMm: spanBasedAllowableMm,
                allowableByFixedMm: fixedAllowableMm,
                spanRatioLimit: settings.spanRatio,
                actualSpanRatio,
                ratio,
                status
            });
        });

        return results;
    };

    const displayDeflectionCheckResults = () => {
        if (!elements.deflectionCheckResults) return;
        if (!lastDeflectionCheckResults || lastDeflectionCheckResults.length === 0) {
            elements.deflectionCheckResults.innerHTML = '';
            return;
        }

        const settings = getDeflectionCheckSettings();
        let html = `<thead><tr>`;
        html += `<th>ÈÉ®Êùê #</th>`;
        html += `<th>„Çπ„Éë„É≥ L (m)</th>`;
        html += `<th>ÊúÄÂ§ß„Åü„Çè„Åø (mm)</th>`;
        html += `<th>Â¢óÂ§ßÂæå (√ó${settings.amplificationFactor.toFixed(2)}) (mm)</th>`;
        html += `<th>Ë®±ÂÆπ„Åü„Çè„Åø (mm)</th>`;
        html += `<th>„Çπ„Éë„É≥ÊØî L/Œ¥</th>`;
        html += `<th>Ê§úÂÆöÊØî</th>`;
        html += `<th>Âà§ÂÆö</th>`;
        html += `</tr></thead><tbody>`;

        lastDeflectionCheckResults.forEach((res) => {
            const idx = (res.memberIndex ?? 0) + 1;
            const isNg = res.status === 'NG';
            const statusText = res.status === 'NG' ? '‚ùå NG' : (res.status === 'OK' ? '‚úÖ OK' : '‚Äî');
            const ratioText = (typeof res.ratio === 'number' && isFinite(res.ratio)) ? res.ratio.toFixed(3) : '‚Äî';
            const spanRatioText = (typeof res.actualSpanRatio === 'number' && isFinite(res.actualSpanRatio)) ? res.actualSpanRatio.toFixed(1) : '‚àû';

            html += `<tr ${isNg ? 'style="background-color: #fdd;"' : ''}>`;
            html += `<td>${idx}</td>`;
            html += `<td>${(res.length ?? 0).toFixed(2)}</td>`;
            html += `<td>${(res.maxDeflectionMm ?? 0).toFixed(2)}</td>`;
            html += `<td>${(res.amplifiedDeflectionMm ?? 0).toFixed(2)}</td>`;
            html += `<td>${(res.allowableMm ?? 0).toFixed(2)}</td>`;
            html += `<td>${spanRatioText}</td>`;
            html += `<td style="font-weight: bold; ${isNg ? 'color: red;' : ''}">${ratioText}</td>`;
            html += `<td>${statusText}</td>`;
            html += `</tr>`;
        });
        html += `</tbody>`;

        elements.deflectionCheckResults.innerHTML = html;
    };

    const displaySectionCheckResults = () => {
        if (!lastSectionCheckResults) { elements.sectionCheckResults.innerHTML = ''; return; }
        console.log("Êñ≠Èù¢ÁÆóÂÆö„ÅÆË®àÁÆóÁµêÊûú:", lastSectionCheckResults);
        let html = `<thead><tr><th>ÈÉ®Êùê #</th><th>Ëª∏Âäõ N (kN)</th><th>Êõ≤„Åí M (kN¬∑m)</th><th>Ê§úÂÆöÈ†ÖÁõÆ</th><th>Ê§úÂÆöÊØî (D/C)</th><th>Âà§ÂÆö</th><th>Ë©≥Á¥∞</th></tr></thead><tbody>`;
        lastSectionCheckResults.forEach((res, i) => {
            const is_ng = res.status === 'NG';
            const maxRatioText = (typeof res.maxRatio === 'number' && isFinite(res.maxRatio)) ? res.maxRatio.toFixed(2) : res.maxRatio;
            const statusText = is_ng ? '‚ùå NG' : '‚úÖ OK';
            html += `<tr ${is_ng ? 'style="background-color: #fdd;"' : ''}><td>${i + 1}</td><td>${res.N.toFixed(2)}</td><td>${res.M.toFixed(2)}</td><td>${res.checkType}</td><td style="font-weight: bold; ${is_ng ? 'color: red;' : ''}">${maxRatioText}</td><td>${statusText}</td><td><button onclick="showSectionCheckDetail(${i})">Ë©≥Á¥∞</button></td></tr>`;
        });
        html += `</tbody>`;
        elements.sectionCheckResults.innerHTML = html;
    };

    const showSectionCheckDetail = (memberIndex) => {
        const res = lastSectionCheckResults[memberIndex];
        if (!res || !res.ratios) return;

        const { members, forces, memberLoads } = lastResults;
        const member = members[memberIndex];
        const force = forces[memberIndex];
        const load = memberLoads.find(l => l.memberIndex === memberIndex);
        const w = load ? load.w : 0;
        const L = member.length;
        const numPoints = res.ratios.length;

        // ÊùêÊñôÁâπÊÄß„ÅÆÂèñÂæó
        const { strengthProps, A, Z, ix, iy, E } = member;
        let materialInfo = '';
        let allowableStresses = { ft: 0, fc: 0, fb: 0, fs: 0 };
        
        // ÈÉ®Êùê„Éá„Éº„Çø„Åã„ÇâÁõ¥Êé•ÊùêÊñôÂêç„ÇíÂèñÂæóÔºàÂºæÊÄß‰øÇÊï∞ÈÅ∏Êäû„ÅßÂèñÂæó„Åó„ÅüÊùêÊñôÂêç„Çí‰ΩøÁî®Ôºâ
        const materialName = member.material || `‰ªªÊÑèÊùêÊñô(E=${(E/1000).toLocaleString()}GPa)`;
        
        const selectedTerm = document.querySelector('input[name="load-term"]:checked').value;
        const termIndex = (selectedTerm === 'long') ? 0 : 1;
        
        switch(strengthProps.type) {
            case 'F-value':
            case 'F-stainless':
            case 'F-aluminum':
                const F = strengthProps.value;
                const factor = (selectedTerm === 'long') ? 1.5 : 1.0;
                materialInfo = `ÊùêÊñô: ${materialName} (F=${F} N/mm¬≤)`;
                allowableStresses.ft = F / factor;
                allowableStresses.fb = F / factor;
                allowableStresses.fs = F / (factor * Math.sqrt(3));
                
                // Â∫ßÂ±à„ÇíËÄÉÊÖÆ„Åó„ÅüÂúßÁ∏ÆË®±ÂÆπÂøúÂäõÂ∫¶
                const lk = L, i_min = Math.min(ix, iy);
                allowableStresses.fc = allowableStresses.ft;
                if (i_min > 1e-9) {
                    const lambda = lk / i_min, E_n_mm2 = E * 1e-3;
                    const lambda_p = Math.PI * Math.sqrt(E_n_mm2 / (0.6 * F));
                    if (lambda <= lambda_p) {
                        allowableStresses.fc = (1 - 0.4 * (lambda / lambda_p)**2) * F / factor;
                    } else {
                        allowableStresses.fc = (0.277 * F) / ((lambda / lambda_p)**2);
                    }
                }
                break;
            case 'wood-type':
                const woodPreset = strengthProps.preset;
                if (woodPreset === 'custom') {
                    materialInfo = `ÊùêÊñô: ${materialName} (‰ªªÊÑèÂÖ•Âäõ)`;
                    const customShortStresses = strengthProps.stresses;
                    if (selectedTerm === 'long') {
                        allowableStresses.ft = customShortStresses.ft * 1.1 / 2;
                        allowableStresses.fc = customShortStresses.fc * 1.1 / 2;
                        allowableStresses.fb = customShortStresses.fb * 1.1 / 2;
                        allowableStresses.fs = customShortStresses.fs * 1.1 / 2;
                    } else {
                        allowableStresses.ft = customShortStresses.ft;
                        allowableStresses.fc = customShortStresses.fc;
                        allowableStresses.fb = customShortStresses.fb;
                        allowableStresses.fs = customShortStresses.fs;
                    }
                } else {
                    const baseStresses = WOOD_BASE_STRENGTH_DATA[woodPreset];
                    materialInfo = `ÊùêÊñô: ${materialName} (${baseStresses.name})`;
                    const factor = (selectedTerm === 'long') ? (1.1 / 3) : (2 / 3);
                    allowableStresses.ft = baseStresses.ft * factor;
                    allowableStresses.fc = baseStresses.fc * factor;
                    allowableStresses.fb = baseStresses.fb * factor;
                    allowableStresses.fs = baseStresses.fs * factor;
                    materialInfo += `<br>Âü∫Ê∫ñÂº∑Â∫¶: Fc=${baseStresses.fc}, Ft=${baseStresses.ft}, Fb=${baseStresses.fb}, Fs=${baseStresses.fs} (N/mm¬≤)`;
                }
                break;
            default:
                materialInfo = `ÊùêÊñô: ${materialName}`;
        }

        let detailHtml = `
            <div style="font-family: Arial, sans-serif;">
                <h3>ÈÉ®Êùê ${memberIndex + 1} „ÅÆË©≥Á¥∞ÂøúÂäõÂ∫¶Ë®àÁÆóÁµêÊûú</h3>
                <div style="margin-bottom: 20px; padding: 10px; background-color: #f5f5f5; border-radius: 5px;">
                    <h4>ÈÉ®ÊùêÊÉÖÂ†±</h4>
                    <p><strong>${materialInfo}</strong></p>
                    <p>ÂºæÊÄß‰øÇÊï∞ E: ${(E/1000).toLocaleString()} N/mm¬≤</p>
                    <p>ÈÉ®ÊùêÈï∑: ${L.toFixed(2)} m</p>
                    <p>Êñ≠Èù¢Á©ç A: ${(A * 1e4).toFixed(2)} cm¬≤</p>
                    <p>Êñ≠Èù¢‰øÇÊï∞ Z: ${(Z * 1e6).toFixed(2)} cm¬≥</p>
                    <p>ÂõûËª¢ÂçäÂæÑ ix: ${(ix * 1e2).toFixed(2)} cm, iy: ${(iy * 1e2).toFixed(2)} cm</p>
                    ${w !== 0 ? `<p>Á≠âÂàÜÂ∏ÉËç∑Èáç: ${w} kN/m</p>` : ''}
                </div>
                <div style="margin-bottom: 20px; padding: 10px; background-color: #e8f4fd; border-radius: 5px;">
                    <h4>Ë®±ÂÆπÂøúÂäõÂ∫¶ (${selectedTerm === 'long' ? 'Èï∑Êúü' : 'Áü≠Êúü'})</h4>
                    <p>ÂºïÂºµË®±ÂÆπÂøúÂäõÂ∫¶ ft: ${allowableStresses.ft.toFixed(2)} N/mm¬≤</p>
                    <p>ÂúßÁ∏ÆË®±ÂÆπÂøúÂäõÂ∫¶ fc: ${allowableStresses.fc.toFixed(2)} N/mm¬≤</p>
                    <p>Êõ≤„ÅíË®±ÂÆπÂøúÂäõÂ∫¶ fb: ${allowableStresses.fb.toFixed(2)} N/mm¬≤</p>
                    <p>„Åõ„ÇìÊñ≠Ë®±ÂÆπÂøúÂäõÂ∫¶ fs: ${allowableStresses.fs.toFixed(2)} N/mm¬≤</p>
                </div>
                <div style="margin-bottom: 20px; padding: 10px; background-color: #fff2e8; border-radius: 5px;">
                    <h4>ÈÉ®ÊùêÁ´ØÂäõ</h4>
                    <p>iÁ´Ø: N = ${(-force.N_i).toFixed(2)} kN, Q = ${force.Q_i.toFixed(2)} kN, M = ${force.M_i.toFixed(2)} kN¬∑m</p>
                    <p>jÁ´Ø: N = ${force.N_j.toFixed(2)} kN, Q = ${(-force.Q_j).toFixed(2)} kN, M = ${force.M_j.toFixed(2)} kN¬∑m</p>
                </div>
                <table style="width: 100%; border-collapse: collapse; margin-top: 10px;">
                    <thead>
                        <tr style="background-color: #f0f0f0;">
                            <th style="border: 1px solid #ccc; padding: 8px;">‰ΩçÁΩÆ (m)</th>
                            <th style="border: 1px solid #ccc; padding: 8px;">Ëª∏Âäõ N (kN)</th>
                            <th style="border: 1px solid #ccc; padding: 8px;">„Åõ„ÇìÊñ≠Âäõ Q (kN)</th>
                            <th style="border: 1px solid #ccc; padding: 8px;">Êõ≤„Åí M (kN¬∑m)</th>
                            <th style="border: 1px solid #ccc; padding: 8px;">Ëª∏ÂøúÂäõÂ∫¶ œÉ_a (N/mm¬≤)</th>
                            <th style="border: 1px solid #ccc; padding: 8px;">„Åõ„ÇìÊñ≠ÂøúÂäõÂ∫¶ œÑ (N/mm¬≤)</th>
                            <th style="border: 1px solid #ccc; padding: 8px;">Êõ≤„ÅíÂøúÂäõÂ∫¶ œÉ_b (N/mm¬≤)</th>
                            <th style="border: 1px solid #ccc; padding: 8px;">Ê§úÂÆöÊØî (D/C)</th>
                            <th style="border: 1px solid #ccc; padding: 8px;">Âà§ÂÆö</th>
                        </tr>
                    </thead>
                    <tbody>`;

        for (let k = 0; k < numPoints; k++) {
            const x = (k / (numPoints - 1)) * L;
            const ratio = res.ratios[k];
            
            // ÂÆüÈöõ„ÅÆÊõ≤„Åí„É¢„Éº„É°„É≥„ÉàË®àÁÆóÔºàÁ≠âÂàÜÂ∏ÉËç∑Èáç„ÇíËÄÉÊÖÆÔºâ
            const M_linear = -force.M_i * (1 - x/L) + force.M_j * (x/L);
            const M_parabolic = w * L * x / 2 - w * x**2 / 2;
            const M_x = M_linear + M_parabolic;
            
            // „Åõ„ÇìÊñ≠Âäõ„ÅÆË®àÁÆóÔºàÁ≠âÂàÜÂ∏ÉËç∑Èáç„ÇíËÄÉÊÖÆÔºâ
            const Q_x = force.Q_i - w * x;
            
            const N = -force.N_i; // Ëª∏Âäõ„ÅØÈÉ®ÊùêÂÖ®‰Ωì„Åß‰∏ÄÂÆö
            const sigma_a = (N * 1000) / (A * 1e6);
            const sigma_b = (Math.abs(M_x) * 1e6) / (Z * 1e9);
            
            // „Åõ„ÇìÊñ≠ÂøúÂäõÂ∫¶„ÅÆË®àÁÆóÔºàœÑ = Q / AÔºâ
            const tau = (Math.abs(Q_x) * 1000) / (A * 1e6);
            
            // „Åõ„ÇìÊñ≠Ê§úÂÆöÊØî„ÅÆË®àÁÆó
            const shear_ratio = tau / allowableStresses.fs;
            
            // Á∑èÂêàÊ§úÂÆöÊØîÔºàÊõ≤„Åí+Ëª∏Âäõ„Å®„Åõ„ÇìÊñ≠„ÅÆÊúÄÂ§ßÂÄ§Ôºâ
            const combined_ratio = Math.max(ratio, shear_ratio);
            
            const status = combined_ratio > 1.0 ? '‚ùå NG' : '‚úÖ OK';
            const rowStyle = combined_ratio > 1.0 ? 'background-color: #fdd;' : '';
            
            detailHtml += `
                <tr style="${rowStyle}">
                    <td style="border: 1px solid #ccc; padding: 8px; text-align: center;">${x.toFixed(2)}</td>
                    <td style="border: 1px solid #ccc; padding: 8px; text-align: center;">${N.toFixed(2)}</td>
                    <td style="border: 1px solid #ccc; padding: 8px; text-align: center;">${Q_x.toFixed(2)}</td>
                    <td style="border: 1px solid #ccc; padding: 8px; text-align: center;">${M_x.toFixed(2)}</td>
                    <td style="border: 1px solid #ccc; padding: 8px; text-align: center;">${sigma_a.toFixed(2)}</td>
                    <td style="border: 1px solid #ccc; padding: 8px; text-align: center;">${tau.toFixed(2)}</td>
                    <td style="border: 1px solid #ccc; padding: 8px; text-align: center;">${sigma_b.toFixed(2)}</td>
                    <td style="border: 1px solid #ccc; padding: 8px; text-align: center; font-weight: bold;">${combined_ratio.toFixed(3)}</td>
                    <td style="border: 1px solid #ccc; padding: 8px; text-align: center;">${status}</td>
                </tr>`;
        }

        detailHtml += `
                    </tbody>
                </table>
                <div style="margin-top: 20px; padding: 10px; background-color: #f9f9f9; border-radius: 5px;">
                    <h4>Ê§úÂÆöÂºè</h4>
                    <p><strong>Êõ≤„Åí+Ëª∏Âäõ„ÅÆÊ§úÂÆö:</strong></p>
                    <p>Ëª∏Âäõ„ÅåÂºïÂºµ„ÅÆÂ†¥Âêà: D/C = œÉ_a/ft + œÉ_b/fb</p>
                    <p>Ëª∏Âäõ„ÅåÂúßÁ∏Æ„ÅÆÂ†¥Âêà: D/C = œÉ_a/fc + œÉ_b/fb</p>
                    <p><strong>„Åõ„ÇìÊñ≠„ÅÆÊ§úÂÆö:</strong></p>
                    <p>D/C = œÑ/fs</p>
                    <p><strong>Á∑èÂêàÊ§úÂÆöÊØî:</strong></p>
                    <p>D/C = max(Êõ≤„Åí+Ëª∏Âäõ„ÅÆÊ§úÂÆöÊØî, „Åõ„ÇìÊñ≠„ÅÆÊ§úÂÆöÊØî)</p>
                    <p>‚Äª œÉ_a = N/A, œÉ_b = |M|/Z, œÑ = |Q|/A</p>
                </div>
            </div>`;

        // „Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó„ÅßË°®Á§∫
        const popup = document.createElement('div');
        popup.style.position = 'fixed';
        popup.style.top = '50%';
        popup.style.left = '50%';
        popup.style.transform = 'translate(-50%, -50%)';
        popup.style.background = 'white';
        popup.style.border = '2px solid #ccc';
        popup.style.borderRadius = '10px';
        popup.style.zIndex = '1000';
        popup.style.width = '800px';
        popup.style.height = '600px';
        popup.style.minWidth = '400px';
        popup.style.minHeight = '300px';
        popup.style.maxHeight = '90vh';
        popup.style.maxWidth = '90vw';
        popup.style.overflow = 'hidden';
        popup.style.boxShadow = '0 4px 20px rgba(0,0,0,0.3)';
        
        // „Éâ„É©„ÉÉ„Ç∞„Éè„É≥„Éâ„É´„Çí‰ΩúÊàê
        const dragHandle = document.createElement('div');
        dragHandle.style.background = '#f0f0f0';
        dragHandle.style.padding = '10px 15px';
        dragHandle.style.borderBottom = '1px solid #ccc';
        dragHandle.style.borderRadius = '10px 10px 0 0';
        dragHandle.style.cursor = 'move';
        dragHandle.style.userSelect = 'none';
        dragHandle.style.position = 'relative';
        dragHandle.innerHTML = '<strong>Ë©≥Á¥∞ÂøúÂäõÂ∫¶Ë®àÁÆóÁµêÊûú - „Éâ„É©„ÉÉ„Ç∞„Åó„Å¶ÁßªÂãï„ÉªÂè≥‰∏ã„Åß„É™„Çµ„Ç§„Ç∫</strong>';
        
        // „Éâ„É©„ÉÉ„Ç∞Ê©üËÉΩ„ÅÆÂÆüË£Ö
        let isDragging = false;
        let dragOffset = { x: 0, y: 0 };
        
        dragHandle.addEventListener('mousedown', (e) => {
            isDragging = true;
            const rect = popup.getBoundingClientRect();
            dragOffset.x = e.clientX - rect.left;
            dragOffset.y = e.clientY - rect.top;
            popup.style.cursor = 'move';
            e.preventDefault();
        });
        
        document.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            
            const newX = e.clientX - dragOffset.x;
            const newY = e.clientY - dragOffset.y;
            
            // ÁîªÈù¢Â¢ÉÁïåÂÜÖ„Å´Âà∂Èôê
            const maxX = window.innerWidth - popup.offsetWidth;
            const maxY = window.innerHeight - popup.offsetHeight;
            
            popup.style.left = Math.max(0, Math.min(newX, maxX)) + 'px';
            popup.style.top = Math.max(0, Math.min(newY, maxY)) + 'px';
            popup.style.transform = 'none';
        });
        
        document.addEventListener('mouseup', () => {
            isDragging = false;
            popup.style.cursor = 'default';
        });
        
        const closeButton = document.createElement('button');
        closeButton.textContent = 'Èñâ„Åò„Çã';
        closeButton.style.marginTop = '20px';
        closeButton.style.padding = '10px 20px';
        closeButton.style.backgroundColor = '#007bff';
        closeButton.style.color = 'white';
        closeButton.style.border = 'none';
        closeButton.style.borderRadius = '5px';
        closeButton.style.cursor = 'pointer';
        closeButton.onclick = () => popup.remove();
        
        // „Ç≥„É≥„ÉÜ„É≥„ÉÑÈÉ®ÂàÜ„Çí‰ΩúÊàê
        const contentDiv = document.createElement('div');
        contentDiv.innerHTML = detailHtml;
        contentDiv.style.padding = '20px';
        contentDiv.style.overflowY = 'auto';
        contentDiv.style.height = 'calc(100% - 120px)'; // „Éò„ÉÉ„ÉÄ„Éº„Å®„Éú„Çø„É≥ÂàÜ„ÇíÈô§„Åè
        contentDiv.style.boxSizing = 'border-box';
        
        // „É™„Çµ„Ç§„Ç∫„Éè„É≥„Éâ„É´„ÇíËøΩÂä†
        const resizeHandle = document.createElement('div');
        resizeHandle.style.position = 'absolute';
        resizeHandle.style.bottom = '0';
        resizeHandle.style.right = '0';
        resizeHandle.style.width = '20px';
        resizeHandle.style.height = '20px';
        resizeHandle.style.background = 'linear-gradient(-45deg, transparent 30%, #ccc 30%, #ccc 70%, transparent 70%)';
        resizeHandle.style.cursor = 'nw-resize';
        resizeHandle.style.borderRadius = '0 0 10px 0';
        resizeHandle.style.zIndex = '1001';
        
        // „É™„Çµ„Ç§„Ç∫Ê©üËÉΩ„ÅÆÂÆüË£Ö
        let isResizing = false;
        let startX, startY, startWidth, startHeight, startLeft, startTop;
        
        resizeHandle.addEventListener('mousedown', (e) => {
            isResizing = true;
            startX = e.clientX;
            startY = e.clientY;
            startWidth = parseInt(window.getComputedStyle(popup).width, 10);
            startHeight = parseInt(window.getComputedStyle(popup).height, 10);
            startLeft = parseInt(window.getComputedStyle(popup).left, 10);
            startTop = parseInt(window.getComputedStyle(popup).top, 10);
            
            document.body.style.userSelect = 'none';
            e.preventDefault();
        });
        
        document.addEventListener('mousemove', (e) => {
            if (!isResizing) return;
            
            const deltaX = e.clientX - startX;
            const deltaY = e.clientY - startY;
            
            const newWidth = Math.max(400, Math.min(window.innerWidth * 0.9, startWidth + deltaX));
            const newHeight = Math.max(300, Math.min(window.innerHeight * 0.9, startHeight + deltaY));
            
            popup.style.width = newWidth + 'px';
            popup.style.height = newHeight + 'px';
        });
        
        document.addEventListener('mouseup', () => {
            if (isResizing) {
                isResizing = false;
                document.body.style.userSelect = '';
            }
        });
        
        // Ë¶ÅÁ¥†„ÇíÁµÑ„ÅøÁ´ã„Å¶
        popup.appendChild(dragHandle);
        popup.appendChild(contentDiv);
        popup.appendChild(closeButton);
        popup.appendChild(resizeHandle);
        document.body.appendChild(popup);
    };

    // „Ç∞„É≠„Éº„Éê„É´„Çπ„Ç≥„Éº„Éó„Å´Èñ¢Êï∞„ÇíÂÖ¨Èñã
    window.showSectionCheckDetail = showSectionCheckDetail;

    // Â∫ßÂ±àËß£ÊûêÁµêÊûúË°®Á§∫Èñ¢Êï∞
    let lastBucklingResults = null;
    
    const displayBucklingResults = () => {
        if (!lastBucklingResults) { 
            document.getElementById('buckling-analysis-results').innerHTML = ''; 
            return; 
        }
        
        console.log("Â∫ßÂ±àËß£Êûê„ÅÆË®àÁÆóÁµêÊûú:", lastBucklingResults);
        let html = `<thead><tr>
            <th>ÈÉ®Êùê #</th>
            <th>Ëª∏Âäõ (kN)</th>
            <th>Â∫ßÂ±àËç∑Èáç (kN)</th>
            <th>ÂÆâÂÖ®Áéá</th>
            <th>Â∫ßÂ±àÈï∑ (m)</th>
            <th>Á¥∞Èï∑ÊØî</th>
            <th>Â∫ßÂ±à„É¢„Éº„Éâ</th>
            <th>Êé•ÂêàÊù°‰ª∂</th>
            <th>Âà§ÂÆö</th>
            <th>Ë©≥Á¥∞</th>
        </tr></thead><tbody>`;
        
        lastBucklingResults.forEach((result, i) => {
            const isDangerous = result.status === 'Â∫ßÂ±àÂç±Èô∫';
            const isWarning = result.status === 'Ë¶ÅÊ≥®ÊÑè';
            let statusColor = '';
            let statusIcon = '';
            
            if (isDangerous) {
                statusColor = 'color: red; font-weight: bold;';
                statusIcon = '‚ùå';
            } else if (isWarning) {
                statusColor = 'color: orange; font-weight: bold;';
                statusIcon = '‚ö†Ô∏è';
            } else if (result.status === 'ÂÆâÂÖ®') {
                statusColor = 'color: green;';
                statusIcon = '‚úÖ';
            } else {
                statusColor = 'color: blue;';
                statusIcon = '‚ÑπÔ∏è';
            }
            
            const rowStyle = isDangerous ? 'style="background-color: #fdd;"' : 
                           isWarning ? 'style="background-color: #fff3cd;"' : '';
            
            html += `<tr ${rowStyle}>
                <td>${i + 1}</td>
                <td>${typeof result.axialForce === 'number' ? result.axialForce.toFixed(2) : result.axialForce}${typeof result.axialForce === 'number' && result.axialForce < 0 ? '(ÂúßÁ∏Æ)' : typeof result.axialForce === 'number' && result.axialForce > 0 ? '(ÂºïÂºµ)' : ''}</td>
                <td>${typeof result.criticalLoad === 'number' ? result.criticalLoad.toFixed(0) : result.criticalLoad}</td>
                <td>${typeof result.safetyFactor === 'number' ? result.safetyFactor.toFixed(2) : result.safetyFactor}</td>
                <td>${typeof result.bucklingLength === 'number' ? result.bucklingLength.toFixed(2) : result.bucklingLength}</td>
                <td>${typeof result.slendernessRatio === 'number' ? result.slendernessRatio.toFixed(1) : result.slendernessRatio}</td>
                <td>${result.bucklingMode}</td>
                <td>${result.connectionType}</td>
                <td style="${statusColor}">${statusIcon} ${result.status}</td>
                <td><button onclick="showBucklingDetail(${i})">Ë©≥Á¥∞</button></td>
            </tr>`;
        });
        html += `</tbody>`;
        document.getElementById('buckling-analysis-results').innerHTML = html;
    };

    const showBucklingDetail = (memberIndex) => {
        const result = lastBucklingResults[memberIndex];
        if (!result) return;

        const { members } = lastResults;
        const member = members[memberIndex];
        
        let detailHtml = `
            <div style="font-family: Arial, sans-serif;">
                <h3>ÈÉ®Êùê ${memberIndex + 1} „ÅÆÂ∫ßÂ±àËß£ÊûêË©≥Á¥∞</h3>
                <div style="margin-bottom: 20px; padding: 10px; background-color: #f5f5f5; border-radius: 5px;">
                    <h4>ÈÉ®ÊùêÊÉÖÂ†±</h4>
                    <p><strong>ÊùêÊñô:</strong> ${member.material || '‰∏çÊòé'}</p>
                    <p>ÂºæÊÄß‰øÇÊï∞ E: ${(member.E/1000).toLocaleString()} N/mm¬≤</p>
                    <p>ÈÉ®ÊùêÈï∑: ${member.length.toFixed(2)} m</p>
                    <p>Êñ≠Èù¢Á©ç A: ${(member.A * 1e4).toFixed(2)} cm¬≤</p>
                    <p>ÂõûËª¢ÂçäÂæÑ ix: ${(member.ix * 1e2).toFixed(2)} cm, iy: ${(member.iy * 1e2).toFixed(2)} cm</p>
                    <p>Êé•ÂêàÊù°‰ª∂: ${result.connectionType}</p>
                </div>
                <div style="margin-bottom: 20px; padding: 10px; background-color: #e8f4fd; border-radius: 5px;">
                    <h4>Â∫ßÂ±àËß£ÊûêÁµêÊûú</h4>
                    <p>Â∫ßÂ±àÈï∑: ${typeof result.bucklingLength === 'number' ? result.bucklingLength.toFixed(2) : result.bucklingLength} m</p>
                    <p>Â∫ßÂ±àÈï∑‰øÇÊï∞: ${result.bucklingLengthFactor}</p>
                    <p>Á¥∞Èï∑ÊØî Œª: ${typeof result.slendernessRatio === 'number' ? result.slendernessRatio.toFixed(1) : result.slendernessRatio}</p>
                    <p>ÈôêÁïåÁ¥∞Èï∑ÊØî Œõ: ${typeof result.criticalSlendernessRatio === 'number' ? result.criticalSlendernessRatio.toFixed(1) : '-'}</p>
                    <p>Â∫ßÂ±àËç∑Èáç: ${typeof result.criticalLoad === 'number' ? result.criticalLoad.toFixed(0) : result.criticalLoad} kN</p>
                    <p>Â∫ßÂ±àÂΩ¢Âºè: ${result.bucklingType || 'ÂºæÊÄßÂ∫ßÂ±à'}</p>
                    <p>ÁèæÂú®„ÅÆËª∏Âäõ: ${typeof result.axialForce === 'number' ? result.axialForce.toFixed(2) : result.axialForce} kN ${typeof result.axialForce === 'number' && result.axialForce < 0 ? '(ÂúßÁ∏Æ)' : result.axialForce > 0 ? '(ÂºïÂºµ)' : ''}</p>
                    <p>Â∫ßÂ±à„É¢„Éº„Éâ: ${result.bucklingMode}</p>
                </div>
                <div style="margin-bottom: 20px; padding: 10px; background-color: #fff2e8; border-radius: 5px;">
                    <h4>ÂÆâÂÖ®ÊÄßË©ï‰æ°</h4>
                    <p style="font-size: 1.1em;"><strong>ÂÆâÂÖ®Áéá: ${typeof result.safetyFactor === 'number' ? result.safetyFactor.toFixed(2) : result.safetyFactor}</strong></p>
                    <p><strong>Âà§ÂÆö: ${result.status}</strong></p>
                    ${result.status === 'Â∫ßÂ±àÂç±Èô∫' ? '<p style="color: red;"><strong>‚ö†Ô∏è Ë≠¶Âëä: Â∫ßÂ±à„ÅÆÂç±Èô∫„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇÊñ≠Èù¢„ÅÆË¶ãÁõ¥„Åó„ÅåÂøÖË¶Å„Åß„Åô„ÄÇ</strong></p>' : ''}
                    ${result.status === 'Ë¶ÅÊ≥®ÊÑè' ? '<p style="color: orange;"><strong>‚ö†Ô∏è Ê≥®ÊÑè: ÂÆâÂÖ®Áéá„Åå‰Ωé„ÅÑ„Åü„ÇÅ„ÄÅÊñ≠Èù¢„ÅÆÊ§úË®é„ÇíÊé®Â•®„Åó„Åæ„Åô„ÄÇ</strong></p>' : ''}
                </div>
                <div style="margin-bottom: 20px; padding: 10px; background-color: #f0f8ff; border-radius: 5px;">
                    <h4>Â∫ßÂ±àÁêÜË´ñÔºàÂèÇËÄÉÔºâ</h4>
                    <p><strong>Ë®àÁÆóÂü∫Ê∫ñ:</strong> ${
                        result.materialType === 'wood' ? 'Êó•Êú¨Âª∫ÁØâÂ≠¶‰ºöÔºàAIJÔºâÊú®Ë≥™ÊßãÈÄ†Ë®≠Ë®àË¶èÊ∫ñ' :
                        result.materialType === 'aluminum' ? 'Êó•Êú¨Âª∫ÁØâÂ≠¶‰ºöÔºàAIJÔºâ„Ç¢„É´„Éü„Éã„Ç¶„É†ÂêàÈáëÊßãÈÄ†Ë®≠Ë®àË¶èÊ∫ñ' :
                        'Êó•Êú¨Âª∫ÁØâÂ≠¶‰ºöÔºàAIJÔºâÈãºÊßãÈÄ†Ë®≠Ë®àË¶èÊ∫ñ'
                    }</p>
                    <p><strong>ÈôêÁïåÁ¥∞Èï∑ÊØî (Œõ):</strong> ${result.criticalSlendernessRatio ? result.criticalSlendernessRatio.toFixed(2) : '-'}</p>
                    <p><strong>ÈÉ®Êùê„ÅÆÁ¥∞Èï∑ÊØî (Œª):</strong> ${result.slendernessRatio ? result.slendernessRatio.toFixed(2) : '-'}</p>
                    <hr style="margin: 10px 0; border-top: 1px dashed #ccc;">
                    
                    <p><strong>Âà§ÂÆö„É≠„Ç∏„ÉÉ„ÇØ:</strong></p>
                    <ul style="padding-left: 20px; margin-top: 5px;">
                        <li><strong>Œª ‚â§ Œõ (ÈùûÂºæÊÄßÂ∫ßÂ±à/Â°ëÊÄßÂüü):</strong><br>
                        ${result.formulaName || '„Ç∏„Éß„É≥„ÇΩ„É≥Âºè'}<br>
                        ${
                            result.materialType === 'wood' ? 'œÉ<sub>cr</sub> = F √ó [1 - 1/3 √ó (Œª/Œõ)‚Å¥]' :
                            result.materialType === 'aluminum' ? 'œÉ<sub>cr</sub> = F √ó [1 - 0.5 √ó (Œª/Œõ)¬≤]' :
                            'œÉ<sub>cr</sub> = F √ó [1 - 0.4 √ó (Œª/Œõ)¬≤]'
                        }</li>
                        
                        <li style="margin-top: 8px;"><strong>Œª > Œõ (ÂºæÊÄßÂ∫ßÂ±à/„Ç™„Ç§„É©„ÉºÂüü):</strong><br>
                        „Ç™„Ç§„É©„ÉºÂºè„Çí‰ΩøÁî®„ÄÇ<br>
                        œÉ<sub>cr</sub> = œÄ¬≤E / Œª¬≤</li>
                    </ul>
                    
                    <p style="margin-top: 10px; font-size: 0.9em; color: #666;">
                        ‚Äª F: Âü∫Ê∫ñÂº∑Â∫¶, E: „É§„É≥„Ç∞‰øÇÊï∞<br>
                        ‚Äª Á¥∞Èï∑ÊØî Œª = lk / i (Â∫ßÂ±àÈï∑„Åï/Êñ≠Èù¢‰∫åÊ¨°ÂçäÂæÑ)<br>
                        ‚Äª Ëª∏Âäõ„ÅÆÁ¨¶Âè∑: „Éû„Ç§„Éä„Çπ„ÅåÂúßÁ∏Æ„ÄÅ„Éó„É©„Çπ„ÅåÂºïÂºµ
                    </p>
                </div>
            </div>
        `;

        const popup = window.open('', '_blank', 'width=800,height=600,scrollbars=yes');
        popup.document.write(`
            <html>
                <head><title>Â∫ßÂ±àËß£ÊûêË©≥Á¥∞ - ÈÉ®Êùê ${memberIndex + 1}</title></head>
                <body style="margin: 20px;">${detailHtml}</body>
            </html>
        `);
        popup.document.close();
    };

    window.showBucklingDetail = showBucklingDetail;

    const drawRatioDiagram = () => {
        const drawingCtx = getDrawingContext(elements.ratioCanvas);
        if (!drawingCtx || !lastResults || !lastSectionCheckResults) return;
        const { ctx, transform, scale } = drawingCtx;
        const { nodes, members } = lastResults;
        const ratioFontScale = window.settings?.fontScales?.ratio || 1.0;
        drawStructure(ctx, transform, nodes, members, '#ccc', false, false, false, null, ratioFontScale);
        const labelManager = LabelManager(ratioFontScale);
        const nodeObstacles = nodes.map(n => { const pos = transform(n.x, n.y); return {x1: pos.x - 12, y1: pos.y - 12, x2: pos.x + 12, y2: pos.y + 12}; });
        const maxOffsetPixels = 60, ratioScale = maxOffsetPixels / (scale * 2.0);
        members.forEach((m, idx) => {
            const res = lastSectionCheckResults[idx];
            if(res.status === 'error') return;
            const n_i = nodes[m.i], n_j = nodes[m.j];
            if (res.maxRatio > 1.0) {
                 ctx.beginPath();
                 const start = transform(n_i.x, n_i.y), end = transform(n_j.x, n_j.y);
                 ctx.moveTo(start.x, start.y);
                 for (let k = 0; k <= 20; k++) {
                    const ratio = res.ratios[k], offset = -ratio * ratioScale, x_local = (k/20) * m.length;
                    const globalX = n_i.x + x_local * m.c - offset * m.s, globalY = n_i.y + x_local * m.s + offset * m.c;
                    ctx.lineTo(transform(globalX, globalY).x, transform(globalX, globalY).y);
                 }
                 ctx.lineTo(end.x, end.y);
                 ctx.fillStyle = 'rgba(255, 0, 0, 0.3)'; ctx.strokeStyle = 'red'; ctx.lineWidth = 1; ctx.closePath(); ctx.fill(); ctx.stroke();
            }
            ctx.beginPath();
            const start = transform(n_i.x, n_i.y);
            ctx.moveTo(start.x, start.y);
            for (let k = 0; k <= 20; k++) {
                const ratio = Math.min(res.ratios[k], 1.0), offset = -ratio * ratioScale, x_local = (k/20) * m.length;
                const globalX = n_i.x + x_local * m.c - offset * m.s, globalY = n_i.y + x_local * m.s + offset * m.c;
                ctx.lineTo(transform(globalX, globalY).x, transform(globalX, globalY).y);
            }
            const end = transform(n_j.x, n_j.y);
            ctx.lineTo(end.x, end.y);
            ctx.fillStyle = 'rgba(0,0,255,0.2)'; ctx.strokeStyle = 'blue'; ctx.lineWidth = 1; ctx.closePath(); ctx.fill(); ctx.stroke();
            ctx.beginPath();
            const offset_1 = -1.0 * ratioScale;
            const p1_offset_x = -offset_1 * m.s, p1_offset_y = offset_1 * m.c;
            const p1 = transform(n_i.x+p1_offset_x, n_i.y+p1_offset_y), p2 = transform(n_j.x+p1_offset_x, n_j.y+p1_offset_y);
            ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y);
            ctx.strokeStyle = 'rgba(0,0,0,0.5)'; ctx.setLineDash([5, 5]); ctx.stroke(); ctx.setLineDash([]);
            // ÊúÄÂ§ßÊ§úÂÆöÊØî„ÅÆ‰ΩçÁΩÆ„ÇíË®àÁÆó
            let maxRatioPos = null;
            let maxRatioValue = 0;
            let maxRatioK = 0;
            
            // ÂêÑÈÉ®Êùê„ÅÆÊúÄÂ§ßÊ§úÂÆöÊØî„ÅÆ‰ΩçÁΩÆ„ÇíÁâπÂÆö
            for (let k = 0; k <= 20; k++) {
                if (res.ratios[k] > maxRatioValue) {
                    maxRatioValue = res.ratios[k];
                    maxRatioK = k;
                }
            }
            
            // ÊúÄÂ§ßÊ§úÂÆöÊØî„ÅÆ‰ΩçÁΩÆ„ÅÆÂ∫ßÊ®ô„ÇíË®àÁÆó
            const x_local_max = (maxRatioK/20) * m.length;
            const offset_max = -maxRatioValue * ratioScale;
            const globalX_max = n_i.x + x_local_max * m.c - offset_max * m.s;
            const globalY_max = n_i.y + x_local_max * m.s + offset_max * m.c;
            maxRatioPos = transform(globalX_max, globalY_max);
            
            // Ëµ§‰∏∏Âç∞„ÇíÊèèÁîªÔºà„Çµ„Ç§„Ç∫„ÇíÂçäÂàÜ„Å´Ôºâ
            ctx.beginPath();
            ctx.arc(maxRatioPos.x, maxRatioPos.y, 4, 0, 2 * Math.PI);
            ctx.fillStyle = 'red';
            ctx.fill();
            ctx.strokeStyle = 'darkred';
            ctx.lineWidth = 1;
            ctx.stroke();
            
            // Êï∞ÂÄ§„ÇíËµ§‰∏∏Âç∞„ÅÆËøëÂÇç„Å´Ë°®Á§∫Ôºà„Éï„Ç©„É≥„Éà„Çµ„Ç§„Ç∫„Çí„Çπ„Ç±„Éº„É™„É≥„Ç∞Ôºâ
            const originalFont = ctx.font;
            const localFontScale = window.settings?.fontScales?.ratio || ratioFontScale || 1.0;
            ctx.font = `bold ${28 * localFontScale}px Arial`;
            ctx.fillStyle = res.maxRatio > 1.0 ? 'red' : '#333';
            
            const text = res.maxRatio.toFixed(2);
            const metrics = ctx.measureText(text);
            const w = metrics.width;
            const h = metrics.fontBoundingBoxAscent ?? 12;
            const padding = 6;
            
            // Á∑ö„ÅÆÁµÇÁÇπ„ÇíÊ±∫ÂÆöÔºàËµ§‰∏∏Âç∞„Åã„ÇâÈÅ©Â∫¶„Å™Ë∑ùÈõ¢„ÅÆ‰ΩçÁΩÆÔºâ
            const lineLength = 35; // Á∑ö„ÅÆÈï∑„Åï„ÇíÂõ∫ÂÆö
            const lineEndX = maxRatioPos.x + lineLength;
            const lineEndY = maxRatioPos.y - lineLength * 0.4; // Â∞ë„Åó‰∏äÂêë„Åç
            
            // Ëµ§‰∏∏Âç∞„Åã„ÇâÁ∑ö„ÅÆÁµÇÁÇπ„Åæ„ÅßÁ∑ö„ÇíÊèèÁîª
            ctx.beginPath();
            ctx.moveTo(maxRatioPos.x, maxRatioPos.y);
            ctx.lineTo(lineEndX, lineEndY);
            ctx.strokeStyle = res.maxRatio > 1.0 ? 'red' : '#333';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Á∑ö„ÅÆÁµÇÁÇπ„Å´Êï∞ÂÄ§„ÇíÁõ¥Êé•ÊèèÁîªÔºàLabelManager„Çí‰Ωø„Çè„Åö„Å´Áõ¥Êé•ÊèèÁîªÔºâ
            ctx.textAlign = 'left';
            ctx.textBaseline = 'bottom';
            ctx.fillStyle = res.maxRatio > 1.0 ? 'red' : '#333';
            
            // ËÉåÊôØ„ÇíÁôΩ„ÅßÂ°ó„Çä„Å§„Å∂„Åó„Å¶Ë™≠„Åø„ÇÑ„Åô„Åè„Åô„Çã
            const bgPadding = 4;
            const bgX = lineEndX - bgPadding;
            const bgY = lineEndY - h - bgPadding;
            const bgWidth = w + bgPadding * 2;
            const bgHeight = h + bgPadding * 2;
            
            ctx.fillStyle = 'white';
            ctx.fillRect(bgX, bgY, bgWidth, bgHeight);
            ctx.strokeStyle = res.maxRatio > 1.0 ? 'red' : '#333';
            ctx.lineWidth = 1;
            ctx.strokeRect(bgX, bgY, bgWidth, bgHeight);
            
            // Êï∞ÂÄ§„ÇíÊèèÁîª
            ctx.fillStyle = res.maxRatio > 1.0 ? 'red' : '#333';
            ctx.fillText(text, lineEndX, lineEndY);
            
            // „Éï„Ç©„É≥„Éà„ÇíÂÖÉ„Å´Êàª„Åô
            ctx.font = originalFont;
        });

        // ÈÉ®ÊùêÁï™Âè∑„ÇíË°®Á§∫ÔºàÈáçË§áÂõûÈÅøÁâàÔºâ
        ctx.fillStyle = '#0066cc';
        const localLabelFont = window.settings?.fontScales?.ratio || ratioFontScale || 1.0;
        ctx.font = `bold ${14 * localLabelFont}px Arial`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        // Ê§úÂÆöÊØîË°®Á§∫Áî®„ÅÆÈÉ®ÊùêÁï™Âè∑‰ΩçÁΩÆË®àÁÆóÔºàÈÉ®Êùê‰∏ä„Å´Âà∂ÈôêÔºâ
        const ratioLabelPositions = [];
        members.forEach((m, idx) => {
            const n_i = nodes[m.i], n_j = nodes[m.j];
            const start_pos = transform(n_i.x, n_i.y);
            const end_pos = transform(n_j.x, n_j.y);
            
            const text = `${idx + 1}`;
            const textWidth = ctx.measureText(text).width;
            const textHeight = 14;
            const padding = 4;
            const boxWidth = textWidth + padding * 2;
            const boxHeight = textHeight + padding * 2;
            
            // ÈÉ®Êùê‰∏ä„ÅÆÂÄôË£ú‰ΩçÁΩÆ„ÇíÁîüÊàê
            const candidates = [];
            const numCandidates = 7;
            
            for (let i = 0; i < numCandidates; i++) {
                const t = i / (numCandidates - 1);
                const x = start_pos.x + (end_pos.x - start_pos.x) * t;
                const y = start_pos.y + (end_pos.y - start_pos.y) * t;
                
                candidates.push({ x, y, t });
            }
            
            // ÊúÄÈÅ©„Å™‰ΩçÁΩÆ„ÇíÈÅ∏Êäû
            let bestPosition = candidates[Math.floor(numCandidates / 2)]; // „Éá„Éï„Ç©„É´„Éà„ÅØ‰∏≠ÁÇπ
            let minOverlap = Infinity;
            
            for (const candidate of candidates) {
                const candidateBox = {
                    x: candidate.x - boxWidth / 2,
                    y: candidate.y - boxHeight / 2,
                    width: boxWidth,
                    height: boxHeight
                };
                
                let overlapCount = 0;
                let totalOverlapArea = 0;
                
                for (const existing of ratioLabelPositions) {
                    if (boxesOverlap(candidateBox, existing)) {
                        overlapCount++;
                        totalOverlapArea += calculateOverlapArea(candidateBox, existing);
                    }
                }
                
                // ‰∏≠ÂøÉÂØÑ„Çä„ÇíÂÑ™ÈÅá
                const centerBias = Math.abs(candidate.t - 0.5) * 200;
                const overlapScore = overlapCount * 1000 + totalOverlapArea + centerBias;
                
                if (overlapScore < minOverlap) {
                    minOverlap = overlapScore;
                    bestPosition = candidate;
                }
            }
            
            ratioLabelPositions.push({
                x: bestPosition.x - boxWidth / 2,
                y: bestPosition.y - boxHeight / 2,
                width: boxWidth,
                height: boxHeight,
                memberIndex: idx,
                textX: bestPosition.x,
                textY: bestPosition.y,
                text: text
            });
        });
        
        // ÈÉ®ÊùêÁï™Âè∑„ÇíÊèèÁîª
        ratioLabelPositions.forEach(labelInfo => {
            // ÈÉ®ÊùêÁï™Âè∑„ÅÆËÉåÊôØ„ÇíÊèèÁîªÔºàË¶ñË™çÊÄßÂêë‰∏ä„ÅÆ„Åü„ÇÅÔºâ
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.fillRect(labelInfo.x, labelInfo.y, labelInfo.width, labelInfo.height);

            // ÈÉ®ÊùêÁï™Âè∑„ÇíÊèèÁîª
            ctx.fillStyle = '#0066cc';
            ctx.fillText(labelInfo.text, labelInfo.textX, labelInfo.textY);
        });

        // ÈÅ∏ÊäûË¶ÅÁ¥†„ÅÆ„Éè„Ç§„É©„Ç§„ÉàË°®Á§∫
        console.log('drawOnCanvasÂÜÖ„Åß„Éè„Ç§„É©„Ç§„ÉàÈñ¢Êï∞„ÇíÂëº„Å≥Âá∫„Åó‰∏≠...');
        if (window.highlightSelectedElements) {
            window.highlightSelectedElements();
        } else {
            console.error('‚ùå window.highlightSelectedElements „ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì');
        }
    };
    const zoom = (factor, centerX, centerY) => {
        if (!panZoomState.isInitialized) return;
        const { scale, offsetX, offsetY } = panZoomState;
        const modelX = (centerX - offsetX) / scale;
        const modelY = (offsetY - centerY) / scale;
        const newScale = scale * factor;
        panZoomState.scale = newScale;
        panZoomState.offsetX = centerX - modelX * newScale;
        panZoomState.offsetY = centerY + modelY * newScale;
        drawOnCanvas();
    };

    // ÁµêÊûúÂõ≥Áî®„ÅÆ„Ç∫„Éº„É†Èñ¢Êï∞
    const zoomResultCanvas = (canvasId, factor, centerX, centerY) => {
        const canvas = document.getElementById(canvasId);
        if (!canvas) return;
        
        const state = resultPanZoomStates[canvasId.replace('-canvas', '')];
        if (!state.isInitialized) return;
        
        const { scale, offsetX, offsetY } = state;
        const modelX = (centerX - offsetX) / scale;
        const modelY = (offsetY - centerY) / scale;
        const newScale = scale * factor;
        
        state.scale = newScale;
        state.offsetX = centerX - modelX * newScale;
        state.offsetY = centerY + modelY * newScale;
        
        // Ë©≤ÂΩì„Åô„ÇãÁµêÊûúÂõ≥„ÇíÂÜçÊèèÁîª
        if (canvasId === 'displacement-canvas') {
            if (lastResults && lastResults.D && lastResults.D.length > 0) {
                console.log('Â§â‰ΩçÂõ≥: „Ç∫„Éº„É†Êìç‰Ωú„ÅßÂÜçÊèèÁîª', { hasLastResults: !!lastResults, hasD: !!lastResults.D, d_length: lastResults.D.length });
                drawDisplacementDiagram(lastResults.nodes, lastResults.members, lastResults.D, lastResults.memberLoads);
            } else {
                console.log('Â§â‰ΩçÂõ≥: „Éá„Éº„Çø‰∏çË∂≥„ÅßÂÜçÊèèÁîª„Çπ„Ç≠„ÉÉ„Éó', { hasLastResults: !!lastResults, hasD: lastResults ? !!lastResults.D : false });
            }
        } else if (canvasId === 'moment-canvas' && lastResults && lastResults.forces) {
            drawMomentDiagram(lastResults.nodes, lastResults.members, lastResults.forces, lastResults.memberLoads);
        } else if (canvasId === 'axial-canvas' && lastResults && lastResults.forces) {
            drawAxialForceDiagram(lastResults.nodes, lastResults.members, lastResults.forces);
        } else if (canvasId === 'shear-canvas' && lastResults && lastResults.forces) {
            drawShearForceDiagram(lastResults.nodes, lastResults.members, lastResults.forces, lastResults.memberLoads);
        } else if (canvasId === 'ratio-canvas') {
            drawRatioDiagram();
        }
    };

    // ÁµêÊûúÂõ≥Áî®„ÅÆ„Éë„É≥Èñ¢Êï∞
    const panResultCanvas = (canvasId, deltaX, deltaY) => {
        const state = resultPanZoomStates[canvasId.replace('-canvas', '')];
        if (!state.isInitialized) return;
        
        state.offsetX += deltaX;
        state.offsetY += deltaY;
        
        const canvas = document.getElementById(canvasId);
        if (!canvas) return;
        
        // Ë©≤ÂΩì„Åô„ÇãÁµêÊûúÂõ≥„ÇíÂÜçÊèèÁîª
        if (canvasId === 'displacement-canvas') {
            if (lastResults && lastResults.D && lastResults.D.length > 0) {
                console.log('Â§â‰ΩçÂõ≥: „Éë„É≥Êìç‰Ωú„ÅßÂÜçÊèèÁîª', { hasLastResults: !!lastResults, hasD: !!lastResults.D, d_length: lastResults.D.length });
                drawDisplacementDiagram(lastResults.nodes, lastResults.members, lastResults.D, lastResults.memberLoads);
            } else {
                console.log('Â§â‰ΩçÂõ≥: „Éá„Éº„Çø‰∏çË∂≥„ÅßÂÜçÊèèÁîª„Çπ„Ç≠„ÉÉ„Éó', { hasLastResults: !!lastResults, hasD: lastResults ? !!lastResults.D : false });
            }
        } else if (canvasId === 'moment-canvas' && lastResults && lastResults.forces) {
            drawMomentDiagram(lastResults.nodes, lastResults.members, lastResults.forces, lastResults.memberLoads);
        } else if (canvasId === 'axial-canvas' && lastResults && lastResults.forces) {
            drawAxialForceDiagram(lastResults.nodes, lastResults.members, lastResults.forces);
        } else if (canvasId === 'shear-canvas' && lastResults && lastResults.forces) {
            drawShearForceDiagram(lastResults.nodes, lastResults.members, lastResults.forces, lastResults.memberLoads);
        } else if (canvasId === 'ratio-canvas') {
            drawRatioDiagram();
        }
    };

    // ÁµêÊûúÂõ≥„ÅÆ„Ç≠„É£„É≥„Éê„Çπ„Å´„Éû„Ç¶„ÇπÊìç‰ΩúÊ©üËÉΩ„ÇíËøΩÂä†
    const addResultCanvasMouseControls = (canvasId) => {
        const canvas = document.getElementById(canvasId);
        if (!canvas) {
            console.error(`„Ç≠„É£„É≥„Éê„Çπ„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì: ${canvasId}`);
            return;
        }

        console.log(`„Éû„Ç¶„ÇπÊìç‰ΩúÊ©üËÉΩ„ÇíËøΩÂä†: ${canvasId}`, { canvas: canvas });

        let isDragging = false;
        let lastMouseX = 0;
        let lastMouseY = 0;

        // „Éû„Ç¶„Çπ„ÉÄ„Ç¶„É≥„Ç§„Éô„É≥„Éà
        canvas.addEventListener('mousedown', (e) => {
            if (e.button === 0) { // Â∑¶„ÇØ„É™„ÉÉ„ÇØ
                console.log(`„Éû„Ç¶„Çπ„ÉÄ„Ç¶„É≥: ${canvasId}`, { 
                    hasLastResults: !!lastResults, 
                    hasD: lastResults ? !!lastResults.D : false,
                    d_length: lastResults && lastResults.D ? lastResults.D.length : 0
                });
                isDragging = true;
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
                canvas.style.cursor = 'grabbing';
            }
        });

        // „Éû„Ç¶„ÇπÁßªÂãï„Ç§„Éô„É≥„Éà
        canvas.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const deltaX = e.clientX - lastMouseX;
                const deltaY = e.clientY - lastMouseY;
                panResultCanvas(canvasId, deltaX, deltaY);
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
            }
        });

        // „Éû„Ç¶„Çπ„Ç¢„ÉÉ„Éó„Ç§„Éô„É≥„Éà
        canvas.addEventListener('mouseup', (e) => {
            if (e.button === 0) {
                isDragging = false;
                canvas.style.cursor = 'grab';
            }
        });

        // „Éû„Ç¶„Çπ„É™„Éº„Éñ„Ç§„Éô„É≥„Éà
        canvas.addEventListener('mouseleave', () => {
            isDragging = false;
            canvas.style.cursor = 'grab';
        });

        // „Éõ„Ç§„Éº„É´„Ç§„Éô„É≥„ÉàÔºà„Ç∫„Éº„É†Ôºâ
        canvas.addEventListener('wheel', (e) => {
            // ÈÄöÂ∏∏„Éõ„Ç§„Éº„É´„ÅØ„Éö„Éº„Ç∏„Çπ„ÇØ„É≠„Éº„É´„ÇíÂÑ™ÂÖà„Åó„ÄÅCtrl/„Éî„É≥„ÉÅÊôÇ„ÅÆ„Åø„Ç∫„Éº„É†„Åô„Çã
            if (!(e.ctrlKey || e.metaKey)) return;
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const centerX = e.clientX - rect.left;
            const centerY = e.clientY - rect.top;
            const zoomFactor = e.deltaY < 0 ? 1.1 : 1 / 1.1;
            zoomResultCanvas(canvasId, zoomFactor, centerX, centerY);
        }, { passive: false });

        // „Ç´„Éº„ÇΩ„É´„Çπ„Çø„Ç§„É´„ÇíË®≠ÂÆö
        canvas.style.cursor = 'grab';
    };

    const animateDisplacement = (nodes, members, D_global, memberLoads) => {
        const drawingCtx = getDrawingContext(elements.modelCanvas);
        if (!drawingCtx) return;
        const { ctx, transform, scale } = drawingCtx;

        let dispScale = parseFloat(elements.animScaleInput.value);

        if (isNaN(dispScale)) {
            dispScale = lastDisplacementScale || 0;
            elements.animScaleInput.placeholder = `Ëá™Âãï(${dispScale.toFixed(2)})`;
        }
        
        const duration = 2000;
        let startTime = null;

        const animationFrame = (timestamp) => {
            if (!startTime) startTime = timestamp;
            const elapsedTime = timestamp - startTime;
            let progress = Math.min(elapsedTime / duration, 1);
            progress = progress < 0.5 ? 4 * progress * progress * progress : 1 - Math.pow(-2 * progress + 2, 3) / 2;

            const currentDrawingCtx = getDrawingContext(elements.modelCanvas);
            if (!currentDrawingCtx) return;
            
            const { ctx, transform } = currentDrawingCtx;
            if (elements.gridToggle.checked) { drawGrid(ctx, transform, elements.modelCanvas.clientWidth, elements.modelCanvas.clientHeight); }
            drawStructure(ctx, transform, nodes, members, '#ccc', true, true);
            drawBoundaryConditions(ctx, transform, nodes);
            
            ctx.strokeStyle = 'red';
            ctx.lineWidth = 2;
            members.forEach((m, idx) => {
                const L = m.length, c = m.c, s = m.s, ni = nodes[m.i];
                const d_global_member_vec = [ ...D_global.slice(m.i * 3, m.i * 3 + 3), ...D_global.slice(m.j * 3, m.j * 3 + 3) ];
                const d_local_vec = mat.multiply(m.T, d_global_member_vec);
                const [ui, vi, thi, uj, vj, thj] = d_local_vec.map(v => v[0]);
                const load = memberLoads.find(l => l.memberIndex === idx), w = load ? load.w : 0, E = m.E, I = m.I;
                ctx.beginPath();
                for (let k = 0; k <= 20; k++) {
                    const x = (k / 20) * L, xi = x / L;
                    const N1 = 1 - 3*xi**2 + 2*xi**3, N2 = x * (1 - xi)**2, N3 = 3*xi**2 - 2*xi**3, N4 = (x**2 / L) * (xi - 1);
                    const u_local = (1 - xi) * ui + xi * uj, v_homogeneous = N1*vi + N2*thi + N3*vj + N4*thj;
                    let v_particular = 0;
                    if (w !== 0 && E > 0 && I > 0) {
                        if (m.i_conn === 'rigid' && m.j_conn === 'rigid') v_particular = (w * x**2 * (L - x)**2) / (24 * E * I);
                        else if (m.i_conn === 'pinned' && m.j_conn === 'pinned') v_particular = (w * x * (L**3 - 2 * L * x**2 + x**3)) / (24 * E * I);
                        else if (m.i_conn === 'rigid' && m.j_conn === 'pinned') v_particular = (w * x**2 * (3 * L**2 - 5 * L * x + 2 * x**2)) / (48 * E * I);
                        else if (m.i_conn === 'pinned' && m.j_conn === 'rigid') v_particular = (w * x * (L**3 - 3 * L * x**2 + 2 * x**3)) / (48 * E * I);
                    }
                    const v_local = v_homogeneous - v_particular;
                    const p_deformed = { x: ni.x + (x*c - (v_local*dispScale*progress)*s) + (u_local*dispScale*progress*c), y: ni.y + (x*s + (v_local*dispScale*progress)*c) + (u_local*dispScale*progress*s) };
                    const p = transform(p_deformed.x, p_deformed.y);
                    if (k === 0) ctx.moveTo(p.x, p.y); else ctx.lineTo(p.x, p.y);
                }
                ctx.stroke();
            });

            if (progress < 1) { requestAnimationFrame(animationFrame); } 
            else { drawOnCanvas(); }
        };
        requestAnimationFrame(animationFrame);
    };

    // --- Canvas Interaction ---
    const getNodeAt = (canvasX, canvasY) => { 
        console.log('getNodeAt called:', { canvasX, canvasY, hasLastDrawingContext: !!lastDrawingContext });
        if (!lastDrawingContext) return -1; 
        try { 
            const { nodes } = parseInputs(); 
            console.log('getNodeAt nodes:', { nodeCount: nodes.length });
            const tolerance = 10; 
            for (let i = 0; i < nodes.length; i++) { 
                const nodePos = lastDrawingContext.transform(nodes[i].x, nodes[i].y); 
                const dist = Math.sqrt((canvasX - nodePos.x)**2 + (canvasY - nodePos.y)**2); 
                console.log(`getNodeAt node ${i}:`, { nodePos, dist, tolerance, hit: dist < tolerance });
                if (dist < tolerance) return i; 
            } 
        } catch(e) { 
            console.error('getNodeAt error:', e);
        } 
        return -1; 
    };
    const getMemberAt = (canvasX, canvasY) => { 
        console.log('getMemberAt called:', { canvasX, canvasY, hasLastDrawingContext: !!lastDrawingContext });
        if (!lastDrawingContext) return -1; 
        try { 
            const { nodes, members } = parseInputs(); 
            console.log('getMemberAt data:', { nodeCount: nodes.length, memberCount: members.length });
            const tolerance = 5; 
            for (let i = 0; i < members.length; i++) { 
                const member = members[i]; 
                const p1 = lastDrawingContext.transform(nodes[member.i].x, nodes[member.i].y);
                const p2 = lastDrawingContext.transform(nodes[member.j].x, nodes[member.j].y); 
                const dx = p2.x - p1.x, dy = p2.y - p1.y, lenSq = dx*dx + dy*dy; 
                if (lenSq === 0) continue; 
                let t = ((canvasX - p1.x) * dx + (canvasY - p1.y) * dy) / lenSq; 
                t = Math.max(0, Math.min(1, t)); 
                const closestX = p1.x + t * dx, closestY = p1.y + t * dy; 
                const dist = Math.sqrt((canvasX - closestX)**2 + (canvasY - closestY)**2); 
                console.log(`getMemberAt member ${i}:`, { p1, p2, dist, tolerance, hit: dist < tolerance });
                if (dist < tolerance) return i; 
            } 
        } catch (e) { 
            console.error('getMemberAt error:', e);
        } 
        return -1; 
    };
    const setCanvasMode = (newMode) => { canvasMode = newMode; firstMemberNode = null; const kebabCaseMode = newMode.replace(/[A-Z]/g, letter => `-${letter.toLowerCase()}`); document.querySelectorAll('.mode-btn').forEach(btn => btn.classList.remove('active')); document.getElementById(`mode-${kebabCaseMode}`).classList.add('active'); elements.modelCanvas.style.cursor = { select: 'default', addNode: 'crosshair', addMember: 'copy' }[newMode]; };

    elements.zoomInBtn.onclick = () => {
        const rect = elements.modelCanvas.getBoundingClientRect();
        zoom(1.2, rect.width / 2, rect.height / 2);
    };
    elements.zoomOutBtn.onclick = () => {
        const rect = elements.modelCanvas.getBoundingClientRect();
        zoom(1 / 1.2, rect.width / 2, rect.height / 2);
    };
    
    // Ëá™ÈáçËÄÉÊÖÆ„ÅÆË°®Á§∫„ÇíÊõ¥Êñ∞„Åô„ÇãÈñ¢Êï∞
    const updateSelfWeightDisplay = () => {
        const considerSelfWeightCheckbox = document.getElementById('consider-self-weight-checkbox');
        if (!considerSelfWeightCheckbox) return;
        
        const isChecked = considerSelfWeightCheckbox.checked;
        
        // Ê≥®: „Éò„ÉÉ„ÉÄ„Éº„ÅÆË°®Á§∫ÂàáÊõø„ÅØ updateMemberTableVisibility „Å´‰ªª„Åõ„Çã„Åü„ÇÅ„ÄÅ„Åì„Åì„Åß„ÅØÊìç‰Ωú„Åó„Åæ„Åõ„Çì
        
        // Êó¢Â≠ò„ÅÆÈÉ®ÊùêË°å„Å´ÂØÜÂ∫¶Âàó„ÇíËøΩÂä†/ÂâäÈô§
        const memberRows = elements.membersTable.rows;
        for (let i = 0; i < memberRows.length; i++) {
            const row = memberRows[i];
            
            if (isChecked) {
                // ÂØÜÂ∫¶Âàó„ÅåÂ≠òÂú®„Åó„Å™„ÅÑÂ†¥Âêà„ÅØËøΩÂä†ÔºàÈáçË§á„ÉÅ„Çß„ÉÉ„ÇØÂº∑ÂåñÔºâ
                let densityCell = row.querySelector('.density-cell');
                const existingDensityCells = row.querySelectorAll('.density-cell');
                
                // Ë§áÊï∞„ÅÆÂØÜÂ∫¶„Çª„É´„Åå„ÅÇ„ÇãÂ†¥Âêà„ÅØ‰ΩôÂàÜ„Å™„ÇÇ„ÅÆ„ÇíÂâäÈô§
                if (existingDensityCells.length > 1) {
                    for (let j = 1; j < existingDensityCells.length; j++) {
                        existingDensityCells[j].remove();
                    }
                    densityCell = existingDensityCells[0];
                }
                
                if (!densityCell) {
                    // ÊåøÂÖ•‰ΩçÁΩÆ„ÇíÂãïÁöÑ„Å´Ê±∫ÂÆöÔºàÊñ≠Èù¢‰øÇÊï∞Z„Çª„É´„ÅÆÂæåÔºâ
                    let insertPosition = 8; // ‰øùÂÆàÁöÑ„Å™„Éá„Éï„Ç©„É´„Éà
                    // „Çà„ÇäÂÆâÂÖ®„Å´„ÄÅZÂÄ§„Çª„É´„ÇíÊé¢„Åó„Å¶„Åù„ÅÆÂæå„Çç„Å´ÊåøÂÖ•
                    for (let k = 0; k < row.cells.length; k++) {
                        const cell = row.cells[k];
                        if (cell.querySelector('input[title*="Êñ≠Èù¢‰øÇÊï∞"]')) {
                            insertPosition = k + 1;
                            // KÂàó„Åå„ÅÇ„ÇãÂ†¥Âêà„ÅØ„Åù„ÅÆÊ¨°„Å∏ÊåøÂÖ•
                            if (row.querySelector('.buckling-k-input')) insertPosition = k + 2;
                            break;
                        }
                    }
                    
                    densityCell = row.insertCell(insertPosition);
                    // col-material„Å®density-column„ÅÆ‰∏°Êñπ„Çí‰ªò‰∏é„Åó„Å¶Ë°®Á§∫Âà∂Âæ°ÂØæË±°„Å´„Åô„Çã
                    // „Åì„Çå„Å´„Çà„Çä„ÄåÊùêÊñôÊÉÖÂ†±„Äç„Éà„Ç∞„É´„Å®„ÄåËá™ÈáçËÄÉÊÖÆ„Äç„ÉÅ„Çß„ÉÉ„ÇØ„Éú„ÉÉ„ÇØ„Çπ„ÅÆ‰∏°Êñπ„ÅÆÂΩ±Èüø„ÇíÂèó„Åë„Çã
                    densityCell.className = 'density-cell col-material density-column'; 
                    
                    // ÁèæÂú®„ÅÆEÂÄ§„Åã„ÇâÂØÜÂ∫¶„ÇíÊé®ÂÆö„Åó„Å¶Ë®≠ÂÆö
                    const eCell = row.cells[3];
                    const eSelect = eCell.querySelector('select');
                    const eValue = eSelect ? eSelect.value : '205000';
                    const density = MATERIAL_DENSITY_DATA[eValue] || MATERIAL_DENSITY_DATA['custom'];
                    
                    densityCell.innerHTML = createDensityInputHTML(`member-density-${i}`, density);
                }
            } else {
                // ÂØÜÂ∫¶Âàó„ÇíÂâäÈô§ÔºàDOM„Åã„ÇâÂâäÈô§„Åó„ÄÅË°®Á§∫Áä∂ÊÖã„ÅÆÊï¥ÂêàÊÄß„ÅØ updateMemberTableVisibility „Åß‰øù„Å§Ôºâ
                const densityCell = row.querySelector('.density-cell');
                if (densityCell) {
                    densityCell.remove();
                }
            }
        }
        
        // Âàó„ÅÆË°®Á§∫Áä∂ÊÖã„ÇíÂêåÊúüÔºàÈáçË¶ÅÔºöÂØÜÂ∫¶Âàó„ÇíËøΩÂä†/ÂâäÈô§„Åó„ÅüÂæå„Å´ÂøÖ„ÅöÂëº„Å∂Ôºâ
        updateMemberTableVisibility();
        
        // ÈÉ®Êùê„Éó„É≠„Éë„ÉÜ„Ç£„Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó„ÅåÈñã„ÅÑ„Å¶„ÅÑ„ÇãÂ†¥Âêà„ÅØ‰ΩçÁΩÆ„ÇíÂÜçË™øÊï¥
        if (elements.memberPropsPopup && elements.memberPropsPopup.style.display === 'block') {
            setTimeout(() => adjustPopupPosition(elements.memberPropsPopup), 0);
        }
        
        drawOnCanvas();
    };
    
    // Make updateSelfWeightDisplay globally accessible
    window.updateSelfWeightDisplay = updateSelfWeightDisplay;
    
    // Ëá™ÈáçËÄÉÊÖÆ„ÉÅ„Çß„ÉÉ„ÇØ„Éú„ÉÉ„ÇØ„Çπ„ÅÆ„Ç§„Éô„É≥„Éà„É™„Çπ„Éä„Éº
    elements.considerSelfWeightCheckbox.addEventListener('change', function() {
        updateSelfWeightDisplay();
    });
    
    // „Ç¶„Ç£„É≥„Éâ„Ç¶„Çµ„Ç§„Ç∫Â§âÊõ¥ÊôÇ„ÅÆ„Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó‰ΩçÁΩÆË™øÊï¥
    window.addEventListener('resize', () => {
        if (elements.memberPropsPopup && elements.memberPropsPopup.style.display === 'block') {
            setTimeout(() => adjustPopupPosition(elements.memberPropsPopup), 100);
        }
        if (elements.addMemberPopup && elements.addMemberPopup.style.display === 'block') {
            setTimeout(() => adjustPopupPosition(elements.addMemberPopup), 100);
        }
        if (elements.nodeLoadPopup && elements.nodeLoadPopup.style.display === 'block') {
            setTimeout(() => adjustPopupPosition(elements.nodeLoadPopup), 100);
        }
    });
    
    elements.modelCanvas.addEventListener('wheel', (e) => {
        // ÈÄöÂ∏∏„Éõ„Ç§„Éº„É´„ÅØ„Éö„Éº„Ç∏„Çπ„ÇØ„É≠„Éº„É´„ÇíÂÑ™ÂÖà„Åó„ÄÅCtrl/„Éî„É≥„ÉÅÊôÇ„ÅÆ„Åø„Ç∫„Éº„É†„Åô„Çã
        if (!(e.ctrlKey || e.metaKey)) return;
        e.preventDefault();
        const rect = elements.modelCanvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        const zoomFactor = e.deltaY < 0 ? 1.1 : 1 / 1.1;
        zoom(zoomFactor, mouseX, mouseY);
    }, { passive: false });
    
    // Êñ≠Èù¢ÈÅ∏Êäû„ÉÑ„Éº„É´„ÇíÈñã„ÅèÈñ¢Êï∞
    const openSteelSelector = (memberIndex, options = {}) => {
        const url = `steel_selector.html?targetMember=${memberIndex}`;
        const popup = window.open(url, 'SteelSelector', 'width=1200,height=800,scrollbars=yes,resizable=yes');

        if (!popup) {
            alert('„Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó„Éñ„É≠„ÉÉ„Ç´„Éº„Å´„Çà„ÇäÊñ≠Èù¢ÈÅ∏Êäû„ÉÑ„Éº„É´„ÇíÈñã„Åë„Åæ„Åõ„Çì„Åß„Åó„Åü„ÄÇ„Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó„ÇíË®±ÂèØ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ');
            return;
        }

        // ÂøÖË¶Å„Å´Âøú„Åò„Å¶„Ç™„Éó„Ç∑„Éß„É≥ÊÉÖÂ†±„ÇílocalStorage„Å´‰øùÂ≠ò
        if (options && Object.keys(options).length > 0) {
            sessionStorage.setItem('steelSelectorOptions', JSON.stringify(options));
        }
    };

    elements.membersTable.addEventListener('click', (e) => {
    if (e.target && e.target.classList.contains('select-props-btn')) {
        const row = e.target.closest('tr');
        if (row) {
            const memberIndex = Array.from(row.parentNode.children).indexOf(row);

            // ÊùêÊñôÊÉÖÂ†±„ÇíÂèñÂæó„Åó„Å¶Ê∏°„Åô
            const eSelect = row.cells[3].querySelector('select');
            const selectedOption = eSelect.options[eSelect.selectedIndex];
            let materialType = 'steel'; // „Éá„Éï„Ç©„É´„Éà
            if (selectedOption.textContent.includes('Êú®Êùê')) materialType = 'wood';
            else if (selectedOption.textContent.includes('„Ç≥„É≥„ÇØ„É™„Éº„Éà')) materialType = 'concrete';
            else if (selectedOption.textContent.includes('„Çπ„ÉÜ„É≥„É¨„Çπ')) materialType = 'stainless';
            else if (selectedOption.textContent.includes('„Ç¢„É´„Éü„Éã„Ç¶„É†')) materialType = 'aluminum';

            const strengthInputContainer = row.cells[4].firstElementChild;
            let strengthValue = '';
            if (strengthInputContainer.querySelector('input')) strengthValue = strengthInputContainer.querySelector('input').value;
            if (strengthInputContainer.querySelector('select')) strengthValue = strengthInputContainer.querySelector('select').value;

            openSteelSelector(memberIndex, {
                material: materialType,
                E: eSelect.value === 'custom' ? row.cells[3].querySelector('input[type="number"]').value : eSelect.value,
                strengthValue: strengthValue
            });
        }
    }
});

    elements.modeSelectBtn.onclick = () => setCanvasMode('select');
    elements.modeAddNodeBtn.onclick = () => setCanvasMode('addNode');
    elements.modeAddMemberBtn.onclick = () => {
        console.log('üîç ÈÉ®ÊùêËøΩÂä†„Éú„Çø„É≥„Åå„ÇØ„É™„ÉÉ„ÇØ„Åï„Çå„Åæ„Åó„Åü');
        
        // „Éù„ÉÉ„Éó„Ç¢„ÉÉ„ÉóÂÜÖ„ÅÆEÂÖ•ÂäõÊ¨Ñ„ÇíÁîüÊàê
        const eContainer = document.getElementById('add-popup-e-container');
        if (!eContainer) {
            console.error('‚ùå add-popup-e-containerË¶ÅÁ¥†„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì');
            return;
        }
        eContainer.innerHTML = createEInputHTML('add-popup-e', newMemberDefaults.E);

        // „Éù„ÉÉ„Éó„Ç¢„ÉÉ„ÉóÂÜÖ„ÅÆFÂÖ•ÂäõÊ¨Ñ„ÇíÁîüÊàê
        const fContainer = document.getElementById('add-popup-f-container');
        fContainer.innerHTML = '';
        fContainer.appendChild(createStrengthInputHTML('steel', 'add-popup-f', newMemberDefaults.F));

        // „Éù„ÉÉ„Éó„Ç¢„ÉÉ„ÉóÂÜÖ„ÅÆEÈÅ∏Êäû„Å´Âøú„Åò„Å¶FÂÖ•ÂäõÊ¨Ñ„ÇíÊõ¥Êñ∞„Åô„Çã„Ç§„Éô„É≥„Éà„É™„Çπ„Éä„Éº„ÇíËøΩÂä†
        const addPopupESelect = document.getElementById('add-popup-e-select');
        if (addPopupESelect) {
            addPopupESelect.addEventListener('change', () => {
                const selectedOpt = addPopupESelect.options[addPopupESelect.selectedIndex];
                let newMaterialType = 'steel';
                if (selectedOpt.textContent.includes('Êú®Êùê')) newMaterialType = 'wood';
                else if (selectedOpt.textContent.includes('„Çπ„ÉÜ„É≥„É¨„Çπ')) newMaterialType = 'stainless';
                else if (selectedOpt.textContent.includes('„Ç¢„É´„Éü„Éã„Ç¶„É†')) newMaterialType = 'aluminum';
                
                fContainer.innerHTML = '';
                fContainer.appendChild(createStrengthInputHTML(newMaterialType, 'add-popup-f'));
                
                // ÂØÜÂ∫¶„ÇÇÊõ¥Êñ∞ÔºàËá™ÈáçËÄÉÊÖÆ„Åå„Ç™„É≥„ÅÆÂ†¥ÂêàÔºâ
                const hasDensityColumn = document.querySelector('.density-column') && document.querySelector('.density-column').style.display !== 'none';
                if (hasDensityColumn) {
                    const addPopupEInput = document.getElementById('add-popup-e-input');
                    const eValue = addPopupESelect.value === 'custom' ? addPopupEInput.value : addPopupESelect.value;
                    const newDensity = MATERIAL_DENSITY_DATA[eValue] || MATERIAL_DENSITY_DATA['custom'];
                    
                    // Êñ∞Ë¶èÈÉ®ÊùêËøΩÂä†„Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó„ÅÆÂØÜÂ∫¶Ê¨Ñ„ÇíÊõ¥Êñ∞
                    const densityContainer = document.getElementById('add-popup-density-container');
                    if (densityContainer) {
                        densityContainer.innerHTML = createDensityInputHTML('add-popup-density', newDensity);
                        
                        // ÂØÜÂ∫¶Ê¨ÑÊõ¥Êñ∞Âæå„Å´„Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó‰ΩçÁΩÆ„ÇíÂÜçË™øÊï¥
                        setTimeout(() => adjustPopupPosition(elements.addMemberPopup), 0);
                    }
                }
            });
        }
        
        // „Åù„ÅÆ‰ªñ„ÅÆ„Éó„É≠„Éë„ÉÜ„Ç£„ÇíË®≠ÂÆö
        document.getElementById('add-popup-i').value = newMemberDefaults.I;
        document.getElementById('add-popup-a').value = newMemberDefaults.A;
        document.getElementById('add-popup-z').value = newMemberDefaults.Z;
        // Êñ≠Èù¢2Ê¨°ÂçäÂæÑ i (cm) „ÅÆÂàùÊúüÂÄ§„ÇíË®≠ÂÆöÔºànewMemberDefaults „Å´ i / i_radius / ix / iy „ÅÆ„ÅÑ„Åö„Çå„Åã„Åå„ÅÇ„Çå„Å∞‰ΩøÁî®Ôºâ
        try {
            const iVal = newMemberDefaults.i || newMemberDefaults.i_radius || newMemberDefaults.ix || newMemberDefaults.iy || '';
            document.getElementById('add-popup-radius-i').value = iVal;
        } catch(_){}
        // Â∫ßÂ±à‰øÇÊï∞„ÅÆÂàùÊúüÂÄ§„ÇíË®≠ÂÆö
        try { document.getElementById('add-popup-buckling-k').value = newMemberDefaults.bucklingK || ''; } catch(_){}
        document.getElementById('add-popup-i-conn').value = newMemberDefaults.i_conn;
        document.getElementById('add-popup-j-conn').value = newMemberDefaults.j_conn;
        
        // „Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó„ÇíÁîªÈù¢‰∏≠Â§Æ„Å´Ë°®Á§∫
        const popup = elements.addMemberPopup;
        if (!popup) {
            console.error('‚ùå addMemberPopupË¶ÅÁ¥†„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì');
            return;
        }
        console.log('‚úÖ „Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó„ÇíË°®Á§∫„Åó„Åæ„Åô');
        popup.style.display = 'block';
        
        // „Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó„Çí‰∏ÄÂ∫¶Ë°®Á§∫„Åó„Å¶„Çµ„Ç§„Ç∫„ÇíÂèñÂæó
        popup.style.display = 'block';
        popup.style.visibility = 'hidden'; // ‰∏ÄÊôÇÁöÑ„Å´ÈùûË°®Á§∫„Å´„Åó„Å¶„Çµ„Ç§„Ç∫ÂèñÂæó
        
        // „Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó„ÅÆ„Çµ„Ç§„Ç∫„ÇíÂèñÂæó
        const popupRect = popup.getBoundingClientRect();
        const popupWidth = popupRect.width || 380;  // „Éá„Éï„Ç©„É´„ÉàÂπÖ
        const popupHeight = popupRect.height || 400; // „Éá„Éï„Ç©„É´„ÉàÈ´ò„Åï
        
        console.log('üîç „Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó„Çµ„Ç§„Ç∫:', { width: popupWidth, height: popupHeight });
        
        const windowWidth = window.innerWidth;
        const windowHeight = window.innerHeight;
        const minMargin = 20;
        
        // ÁîªÈù¢‰∏≠Â§Æ„Å´ÈÖçÁΩÆ
        const left = Math.max(minMargin, (windowWidth - popupWidth) / 2);
        const top = Math.max(minMargin, (windowHeight - popupHeight) / 2);
        
        console.log('üîç „Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó‰ΩçÁΩÆ:', { left, top, windowWidth, windowHeight });
        
        popup.style.left = `${left}px`;
        popup.style.top = `${top}px`;
        popup.style.position = 'fixed';
        popup.style.visibility = 'visible'; // Ë°®Á§∫„Å´Êàª„Åô
        popup.style.display = 'block';
        
        // „Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó„ÅåÂÆüÈöõ„Å´Ë°®Á§∫„Åï„Çå„Å¶„ÅÑ„Çã„Åã„ÉÅ„Çß„ÉÉ„ÇØ
        setTimeout(() => {
            const finalRect = popup.getBoundingClientRect();
            console.log('üîç „Éù„ÉÉ„Éó„Ç¢„ÉÉ„ÉóÊúÄÁµÇÁä∂ÊÖã:', {
                display: popup.style.display,
                visibility: popup.style.visibility,
                position: popup.style.position,
                left: popup.style.left,
                top: popup.style.top,
                zIndex: popup.style.zIndex,
                rect: finalRect
            });
            
            if (finalRect.width === 0 || finalRect.height === 0) {
                console.error('‚ùå „Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó„ÅÆ„Çµ„Ç§„Ç∫„Åå0„Åß„Åô');
            }
            
            if (finalRect.left < 0 || finalRect.top < 0 || 
                finalRect.right > window.innerWidth || finalRect.bottom > window.innerHeight) {
                console.warn('‚ö†Ô∏è „Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó„ÅåÁîªÈù¢Â§ñ„Å´Ë°®Á§∫„Åï„Çå„Å¶„ÅÑ„Åæ„Åô');
            }
        }, 100);
    };
    // ÈÉ®ÊùêËøΩÂä†Ë®≠ÂÆö„ÅÆÊñ≠Èù¢ÈÅ∏Êäû„Éú„Çø„É≥
    document.getElementById('add-popup-select-section').onclick = () => {
        const url = `steel_selector.html?targetMember=addDefaults`;
        console.log('üöÄ Êñ≠Èù¢ÈÅ∏Êäû„Ç¶„Ç£„É≥„Éâ„Ç¶„ÇíÈñã„Åç„Åæ„Åô:', url);
        const popup = window.open(url, 'SteelSelector', 'width=1200,height=800,scrollbars=yes,resizable=yes');

        if (!popup) {
            alert('„Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó„Éñ„É≠„ÉÉ„Ç´„Éº„Å´„Çà„ÇäÊñ≠Èù¢ÈÅ∏Êäû„ÉÑ„Éº„É´„ÇíÈñã„Åë„Åæ„Åõ„Çì„Åß„Åó„Åü„ÄÇ„Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó„ÇíË®±ÂèØ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ');
            console.error('‚ùå „Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó„Éñ„É≠„ÉÉ„ÇØ: Êñ≠Èù¢ÈÅ∏Êäû„Ç¶„Ç£„É≥„Éâ„Ç¶„ÅåÈñã„Åë„Åæ„Åõ„Çì„Åß„Åó„Åü');
        } else {
            console.log('‚úÖ Êñ≠Èù¢ÈÅ∏Êäû„Ç¶„Ç£„É≥„Éâ„Ç¶„ÅåÈñã„Åç„Åæ„Åó„Åü„ÄÇstorage„Ç§„Éô„É≥„Éà„Åß„Éá„Éº„ÇøÂèó‰ø°„ÇíÂæÖÊ©ü„Åó„Åæ„Åô„ÄÇ');
        }
    };

    document.getElementById('add-popup-ok').onclick = () => {
        const e_select = document.getElementById('add-popup-e-select'), e_input = document.getElementById('add-popup-e-input');
        if (e_select && e_input) {
            newMemberDefaults.E = e_select.value === 'custom' ? e_input.value : e_select.value;
        }

        // FÂÄ§„ÅÆÂèñÂæó - Âº∑Â∫¶„Ç≥„É≥„ÉÜ„Éä„Åã„ÇâÁèæÂú®„ÅÆUI„Å´Âøú„Åò„Å¶ÂÄ§„ÇíÂèñÂæó
        const fContainer = document.getElementById('add-popup-f-container');
        if (fContainer && fContainer.firstElementChild) {
            const strengthContainer = fContainer.firstElementChild;
            const strengthType = strengthContainer.dataset?.strengthType;

            if (strengthType === 'wood-type') {
                // Êú®Êùê„ÅÆÂ†¥Âêà - „Éó„É™„Çª„ÉÉ„ÉàÂÄ§„Åæ„Åü„ÅØ „Ç´„Çπ„Çø„É†ÂÄ§„ÇíÂèñÂæó
                const presetSelect = strengthContainer.querySelector('select');
                if (presetSelect) {
                    newMemberDefaults.F = presetSelect.value;
                    // „Ç´„Çπ„Çø„É†ÂÄ§„ÅÆÂ†¥Âêà„ÅØÂü∫Ê∫ñÂº∑Â∫¶„Éá„Éº„Çø„Çí‰øùÂ≠ò
                    if (presetSelect.value === 'custom') {
                        const ftInput = strengthContainer.querySelector('input[id*="-ft"]');
                        const fcInput = strengthContainer.querySelector('input[id*="-fc"]');
                        const fbInput = strengthContainer.querySelector('input[id*="-fb"]');
                        const fsInput = strengthContainer.querySelector('input[id*="-fs"]');

                        if (ftInput && fcInput && fbInput && fsInput) {
                            newMemberDefaults.F = {
                                baseStrengths: {
                                    ft: parseFloat(ftInput.value),
                                    fc: parseFloat(fcInput.value),
                                    fb: parseFloat(fbInput.value),
                                    fs: parseFloat(fsInput.value)
                                }
                            };
                        }
                    }
                }
            } else {
                // ÂæìÊù•„ÅÆÈáëÂ±ûÊùêÊñô„ÅÆÂ†¥Âêà
                const f_select = document.getElementById('add-popup-f-select');
                const f_input = document.getElementById('add-popup-f-input');
                if (f_select && f_input) {
                    newMemberDefaults.F = f_select.value === 'custom' ? f_input.value : f_select.value;
                } else {
                    // „Çª„É¨„ÇØ„Éà„Éú„ÉÉ„ÇØ„Çπ„Åå„Å™„ÅÑÂ†¥Âêà„ÅØÁõ¥Êé•ÂÖ•ÂäõÂÄ§„ÇíÂèñÂæó
                    const strengthInput = strengthContainer.querySelector('input');
                    if (strengthInput) {
                        newMemberDefaults.F = strengthInput.value;
                    }
                }
            }
        }

        const iInput = document.getElementById('add-popup-i');
        const aInput = document.getElementById('add-popup-a');
        const zInput = document.getElementById('add-popup-z');
        const radiusInput = document.getElementById('add-popup-radius-i');
        const kInput = document.getElementById('add-popup-buckling-k');
        const iConnSelect = document.getElementById('add-popup-i-conn');
        const jConnSelect = document.getElementById('add-popup-j-conn');

        if (iInput) newMemberDefaults.I = iInput.value;
        if (aInput) newMemberDefaults.A = aInput.value;
        if (zInput) newMemberDefaults.Z = zInput.value;
        if (radiusInput) newMemberDefaults.i = radiusInput.value;
        if (kInput) newMemberDefaults.bucklingK = kInput.value;
        if (iConnSelect) newMemberDefaults.i_conn = iConnSelect.value;
        if (jConnSelect) newMemberDefaults.j_conn = jConnSelect.value;

        elements.addMemberPopup.style.display = 'none';
        setCanvasMode('addMember');
    };
    document.getElementById('add-popup-cancel').onclick = () => { elements.addMemberPopup.style.display = 'none'; };

    elements.modelCanvas.addEventListener('mousedown', (e) => {
        if (e.button !== 0) return;
        const rect = elements.modelCanvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        
        selectedNodeIndex = getNodeAt(mouseX, mouseY);
        selectedMemberIndex = getMemberAt(mouseX, mouseY);
        
        // windowÂ§âÊï∞„ÇÇÂêåÊúü
        window.selectedNodeIndex = selectedNodeIndex;
        window.selectedMemberIndex = selectedMemberIndex;
        
        console.log('„Éû„Ç¶„Çπ„ÇØ„É™„ÉÉ„ÇØ:', { mouseX, mouseY, selectedNodeIndex, selectedMemberIndex, isShiftPressed });
        
        if (canvasMode === 'select') {
            if (isShiftPressed && (selectedNodeIndex !== -1 || selectedMemberIndex !== -1)) {
                // Shift„Ç≠„Éº„ÅåÊäº„Åï„Çå„Å¶„ÅÑ„ÇãÂ†¥Âêà„ÅÆË§áÊï∞ÈÅ∏Êäû
                if (selectedNodeIndex !== -1) {
                    // ÁØÄÁÇπ„ÇíÈÅ∏Êäû„Åô„ÇãÂ†¥Âêà„ÄÅÊó¢„Å´ÈÉ®Êùê„ÅåÈÅ∏Êäû„Åï„Çå„Å¶„ÅÑ„Åü„Çâ„ÇØ„É™„Ç¢
                    if (selectedMembers.size > 0) {
                        console.log('ÈÉ®ÊùêÈÅ∏Êäû„Çí„ÇØ„É™„Ç¢„Åó„Å¶ÁØÄÁÇπÈÅ∏Êäû„É¢„Éº„Éâ„Å´Âàá„ÇäÊõø„Åà');
                        selectedMembers.clear();
                    }
                    
                    if (selectedNodes.has(selectedNodeIndex)) {
                        selectedNodes.delete(selectedNodeIndex);
                        console.log('ÁØÄÁÇπ„ÅÆÈÅ∏ÊäûËß£Èô§:', selectedNodeIndex);
                    } else {
                        selectedNodes.add(selectedNodeIndex);
                        console.log('ÁØÄÁÇπ„ÇíÈÅ∏Êäû:', selectedNodeIndex);
                    }
                } else if (selectedMemberIndex !== -1) {
                    // ÈÉ®Êùê„ÇíÈÅ∏Êäû„Åô„ÇãÂ†¥Âêà„ÄÅÊó¢„Å´ÁØÄÁÇπ„ÅåÈÅ∏Êäû„Åï„Çå„Å¶„ÅÑ„Åü„Çâ„ÇØ„É™„Ç¢
                    if (selectedNodes.size > 0) {
                        console.log('ÁØÄÁÇπÈÅ∏Êäû„Çí„ÇØ„É™„Ç¢„Åó„Å¶ÈÉ®ÊùêÈÅ∏Êäû„É¢„Éº„Éâ„Å´Âàá„ÇäÊõø„Åà');
                        selectedNodes.clear();
                    }
                    
                    if (selectedMembers.has(selectedMemberIndex)) {
                        selectedMembers.delete(selectedMemberIndex);
                        console.log('ÈÉ®Êùê„ÅÆÈÅ∏ÊäûËß£Èô§:', selectedMemberIndex);
                    } else {
                        selectedMembers.add(selectedMemberIndex);
                        console.log('ÈÉ®Êùê„ÇíÈÅ∏Êäû:', selectedMemberIndex);
                    }
                }
                console.log('ÁèæÂú®„ÅÆÈÅ∏ÊäûÁä∂ÊÖã:', { 
                    selectedNodes: Array.from(selectedNodes), 
                    selectedMembers: Array.from(selectedMembers) 
                });
                if (typeof drawOnCanvas === 'function') {
                    drawOnCanvas();
                }
                return;
            }
            
            if (selectedNodeIndex !== -1) {
                // Âçò‰∏ÄÈÅ∏ÊäûÔºöÊó¢Â≠ò„ÅÆÂãï‰Ωú
                if (!isShiftPressed) {
                    clearMultiSelection();
                    // ÈÉ®Êùê„ÅÆÈÅ∏Êäû„Çí„ÇØ„É™„Ç¢ÔºàÁØÄÁÇπ„ÇíÈÅ∏Êäû„Åô„ÇãÂ†¥ÂêàÔºâ
                    selectedMemberIndex = null;
                    window.selectedMemberIndex = null;
                }
                isDragging = true;
                pushState();
                // Âçò‰∏ÄÈÅ∏Êäû„Éè„Ç§„É©„Ç§„ÉàË°®Á§∫
                if (typeof drawOnCanvas === 'function') {
                    drawOnCanvas(); // „Éè„Ç§„É©„Ç§„ÉàË°®Á§∫„ÅÆ„Åü„ÇÅÂÜçÊèèÁîª
                }
            } else if (selectedMemberIndex !== -1) {
                // ÈÉ®Êùê„ÅÆÂçò‰∏ÄÈÅ∏Êäû
                if (!isShiftPressed) {
                    clearMultiSelection();
                    // ÁØÄÁÇπ„ÅÆÈÅ∏Êäû„Çí„ÇØ„É™„Ç¢ÔºàÈÉ®Êùê„ÇíÈÅ∏Êäû„Åô„ÇãÂ†¥ÂêàÔºâ
                    selectedNodeIndex = null;
                }
                // ÈÉ®ÊùêÈÅ∏Êäû„Éè„Ç§„É©„Ç§„ÉàË°®Á§∫
                if (typeof drawOnCanvas === 'function') {
                    drawOnCanvas(); // „Éè„Ç§„É©„Ç§„ÉàË°®Á§∫„ÅÆ„Åü„ÇÅÂÜçÊèèÁîª
                }
            } else {
                // Á©∫„ÅÆÂ†¥ÊâÄ„Çí„ÇØ„É™„ÉÉ„ÇØ„Åó„ÅüÂ†¥Âêà„ÅÆÂá¶ÁêÜ
                if (isShiftPressed) {
                    // Shift„Ç≠„Éº„ÅåÊäº„Åï„Çå„Å¶„ÅÑ„ÇãÂ†¥Âêà„ÅØÁØÑÂõ≤ÈÅ∏Êäû„ÇíÈñãÂßã
                    console.log('ÁØÑÂõ≤ÈÅ∏Êäû„ÇíÈñãÂßã„Åó„Åæ„Åô');
                    hideSelectionChoiceMenu();
                    isRangeSelecting = true;
                    isMultiSelecting = true;
                    rangeSelectionAdditive = isShiftPressed;
                    multiSelectStart = { x: mouseX, y: mouseY };
                    multiSelectEnd = { x: mouseX, y: mouseY };
                    drawOnCanvas();
                } else {
                    // ÈÄöÂ∏∏„ÅÆ„ÇØ„É™„ÉÉ„ÇØÔºö„Éë„É≥„Éâ„É©„ÉÉ„Ç∞„ÇíÈñãÂßã
                    console.log('„Ç≠„É£„É≥„Éê„Çπ„Éë„É≥„ÇíÈñãÂßã„Åó„Åæ„Åô');
                    clearMultiSelection();
                    clearSingleSelection(); // Âçò‰∏ÄÈÅ∏Êäû„ÇÇ„ÇØ„É™„Ç¢
                    isDraggingCanvas = true;
                    lastMouseX = mouseX;
                    lastMouseY = mouseY;
                }
            }
        }
    });
    elements.modelCanvas.addEventListener('mousemove', (e) => {
        const rect = elements.modelCanvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        
        // „Éû„Ç¶„Çπ‰ΩçÁΩÆ„Çí‰øùÂ≠òÔºàË¶ñË¶öÁöÑ„Éï„Ç£„Éº„Éâ„Éê„ÉÉ„ÇØÁî®Ôºâ
        currentMouseX = mouseX;
        currentMouseY = mouseY;
        
        // ÈÉ®ÊùêËøΩÂä†„É¢„Éº„Éâ„ÅÆÂ†¥Âêà„ÅØ„É™„Ç¢„É´„Çø„Ç§„É†„ÅßË¶ñË¶öÁöÑ„Éï„Ç£„Éº„Éâ„Éê„ÉÉ„ÇØ„ÇíÊõ¥Êñ∞
        if (canvasMode === 'addMember') {
            drawOnCanvas();
        }
        
        // „Éá„Éê„ÉÉ„Ç∞Ôºö1%„ÅÆÁ¢∫Áéá„Åß„Éû„Ç¶„ÇπÁßªÂãï„ÅÆË©≥Á¥∞„ÇíÂá∫Âäõ
        if (Math.random() < 0.01) {
            console.log('üñ±Ô∏è „Éû„Ç¶„ÇπÁßªÂãï„Éá„Éê„ÉÉ„Ç∞:', {
                canvasMode,
                isRangeSelecting,
                isDragging, 
                isDraggingCanvas,
                Êù°‰ª∂OK: canvasMode === 'select' && !isRangeSelecting && !isDragging && !isDraggingCanvas,
                lastDrawingContext: !!window.lastDrawingContext
            });
        }
        
        // ÈÉ®Êùê„Éõ„Éê„ÉºÊ§úÂá∫„Å®„ÉÑ„Éº„É´„ÉÅ„ÉÉ„ÉóË°®Á§∫
        if (canvasMode === 'select' && !isRangeSelecting && !isDragging && !isDraggingCanvas) {
            // lastDrawingContext„ÅåÂàùÊúüÂåñ„Åï„Çå„Å¶„ÅÑ„Çã„Åã„ÉÅ„Çß„ÉÉ„ÇØ
            if (!window.lastDrawingContext) {
                // ÂàùÂõû„ÅÆÂ†¥Âêà„ÅØÁÑ°Ë¶ñÔºà„Åæ„Å†ÊèèÁîª„ÅåÂÆå‰∫Ü„Åó„Å¶„ÅÑ„Å™„ÅÑÔºâ
                return;
            }
            
            // ÈÉ®ÊùêÊÉÖÂ†±Ë°®Á§∫„ÉÅ„Çß„ÉÉ„ÇØ„Éú„ÉÉ„ÇØ„Çπ„ÅÆÁä∂ÊÖã„ÇíÁ¢∫Ë™ç
            const memberInfoToggle = document.getElementById('member-info-toggle');
            if (!memberInfoToggle || !memberInfoToggle.checked) {
                // „ÉÅ„Çß„ÉÉ„ÇØ„Éú„ÉÉ„ÇØ„Çπ„ÅåÊú™„ÉÅ„Çß„ÉÉ„ÇØ„ÅÆÂ†¥Âêà„ÅØ„ÉÑ„Éº„É´„ÉÅ„ÉÉ„Éó„ÇíÈùûË°®Á§∫
                hideMemberTooltip();
                return;
            }
            
            try {
                const hoveredMember = detectMemberAtPosition(e.clientX, e.clientY);
                if (hoveredMember !== null) {
                    console.log('‚úÖ ÈÉ®ÊùêÊ§úÂá∫ÊàêÂäü:', hoveredMember.number);
                    showMemberTooltip(hoveredMember, e.clientX, e.clientY);
                } else {
                    hideMemberTooltip();
                }
            } catch (error) {
                console.error('‚ùå „ÉÑ„Éº„É´„ÉÅ„ÉÉ„Éó„Ç®„É©„Éº:', error);
            }
        } else {
            // „ÉÑ„Éº„É´„ÉÅ„ÉÉ„ÉóÊù°‰ª∂„ÇíÊ∫Ä„Åü„Åï„Å™„ÅÑÂ†¥Âêà„ÅØÈùûË°®Á§∫
            hideMemberTooltip();
        }
        
        if (isRangeSelecting && canvasMode === 'select') {
            multiSelectEnd = { x: mouseX, y: mouseY };
            drawOnCanvas();
        } else if (isDragging && canvasMode === 'select' && selectedNodeIndex !== null) {
            let modelCoords = inverseTransform(mouseX, mouseY);
            if (modelCoords) {
                if (elements.gridToggle.checked) {
                    const spacing = parseFloat(elements.gridSpacing.value);
                    modelCoords.x = Math.round(modelCoords.x / spacing) * spacing;
                    modelCoords.y = Math.round(modelCoords.y / spacing) * spacing;
                }
                const nodeRow = elements.nodesTable.rows[selectedNodeIndex];
                nodeRow.cells[1].querySelector('input').value = modelCoords.x.toFixed(2);
                nodeRow.cells[2].querySelector('input').value = modelCoords.y.toFixed(2);
                drawOnCanvas();
            }
        } else if (isDraggingCanvas && canvasMode === 'select') {
            const deltaX = mouseX - lastMouseX;
            const deltaY = mouseY - lastMouseY;
            panZoomState.offsetX += deltaX;
            panZoomState.offsetY += deltaY;
            lastMouseX = mouseX;
            lastMouseY = mouseY;
            drawOnCanvas();
        }
    });
    window.addEventListener('mouseup', (e) => {
        if (e.button === 0) {
            if (isRangeSelecting) {
                console.log('ÁØÑÂõ≤ÈÅ∏ÊäûÂÆå‰∫Ü - finalizeRangeSelection„ÇíÂëº„Å≥Âá∫„Åó„Åæ„Åô');
                finalizeRangeSelection(e);
                isRangeSelecting = false;
                rangeSelectionAdditive = false;
                multiSelectStart = { x: 0, y: 0 };
                multiSelectEnd = { x: 0, y: 0 };
                drawOnCanvas();
            }
            if (isDragging) {
                elements.nodesTable.rows[selectedNodeIndex]?.cells[1].querySelector('input').dispatchEvent(new Event('change'));
                isDragging = false;
            }
            if (isDraggingCanvas) {
                isDraggingCanvas = false;
            }
        }
    });
    elements.modelCanvas.addEventListener('click', (e) => { 
        const rect = elements.modelCanvas.getBoundingClientRect(); let mouseX = e.clientX - rect.left, mouseY = e.clientY - rect.top; const clickedNodeIndex = getNodeAt(mouseX, mouseY); 
        if (canvasMode === 'addNode') {
            const targetMemberIndex = getMemberAt(mouseX, mouseY);
            let modelCoords = inverseTransform(mouseX, mouseY); if (!modelCoords) return;
            // ÁØÄÁÇπ„Çí„ÇØ„É™„ÉÉ„ÇØ„Åó„ÅüÂ†¥Âêà„ÅØ„ÄÅÈÉ®ÊùêÂàÜÂâ≤„Åß„ÅØ„Å™„ÅèÈÄöÂ∏∏„ÅÆÁØÄÁÇπËøΩÂä†Âá¶ÁêÜ„ÇíÂÆüË°å
            // (Êó¢Â≠òÁØÄÁÇπ„Å®Âêå„Åò‰ΩçÁΩÆ„Å™„ÅÆ„ÅßÈáçË§á„ÉÅ„Çß„ÉÉ„ÇØ„ÅßÂºæ„Åã„Çå„Çã)
            if (targetMemberIndex !== -1 && clickedNodeIndex === -1) {
                pushState();
                const { nodes } = parseInputs(), memberRow = elements.membersTable.rows[targetMemberIndex];
                const startNodeId = parseInt(memberRow.cells[1].querySelector('input').value), endNodeId = parseInt(memberRow.cells[2].querySelector('input').value);
                const p1 = nodes[startNodeId - 1], p2 = nodes[endNodeId - 1];
                let finalCoords;
                if (elements.gridToggle.checked) {
                    const spacing = parseFloat(elements.gridSpacing.value), snapTolerance = spacing / 2.5;
                    const nearestGridX = Math.round(modelCoords.x / spacing) * spacing, nearestGridY = Math.round(modelCoords.y / spacing) * spacing;
                    const distToGrid = Math.sqrt((modelCoords.x - nearestGridX)**2 + (modelCoords.y - nearestGridY)**2);
                    if (distToGrid < snapTolerance) {
                        const isCollinear = Math.abs((nearestGridY - p1.y)*(p2.x - p1.x) - (nearestGridX - p1.x)*(p2.y - p1.y)) < 1e-6;
                        const isWithinBounds = (nearestGridX >= Math.min(p1.x,p2.x)-1e-6 && nearestGridX <= Math.max(p1.x,p2.x)+1e-6 && nearestGridY >= Math.min(p1.y,p2.y)-1e-6 && nearestGridY <= Math.max(p1.y,p2.y)+1e-6);
                        if (isCollinear && isWithinBounds) finalCoords = { x: nearestGridX, y: nearestGridY };
                    }
                }
                if (!finalCoords) { const dx = p2.x-p1.x, dy = p2.y-p1.y, lenSq = dx*dx+dy*dy, t = lenSq===0 ? 0 : ((modelCoords.x-p1.x)*dx + (modelCoords.y-p1.y)*dy)/lenSq; const clampedT=Math.max(0,Math.min(1,t)); finalCoords={x:p1.x+clampedT*dx,y:p1.y+clampedT*dy}; }
                const e_select=memberRow.cells[3].querySelector('select'), e_input=memberRow.cells[3].querySelector('input[type="number"]'); const E_val = e_select.value==='custom'?e_input.value:e_select.value;
                const f_select=memberRow.cells[4].querySelector('select'), f_input=memberRow.cells[4].querySelector('input[type="number"]'); const F_val = f_select ? (f_select.value==='custom'?f_input.value:f_select.value) : '235';
                const Ibase = parseFloat(memberRow.cells[5].querySelector('.section-I-input')?.value);
                const IfRaw = parseFloat(memberRow.cells[5].querySelector('.section-I-factor')?.value);
                const Abase = parseFloat(memberRow.cells[6].querySelector('.section-A-input')?.value);
                const AfRaw = parseFloat(memberRow.cells[6].querySelector('.section-A-factor')?.value);
                const Zbase = parseFloat(memberRow.cells[7].querySelector('.section-Z-input')?.value);
                const ZfRaw = parseFloat(memberRow.cells[7].querySelector('.section-Z-factor')?.value);

                const If = Number.isFinite(IfRaw) ? IfRaw : 1.0;
                const Af = Number.isFinite(AfRaw) ? AfRaw : 1.0;
                const Zf = Number.isFinite(ZfRaw) ? ZfRaw : 1.0;

                const I_m4 = (Number.isFinite(Ibase) ? Ibase : 0) * If * 1e-8;
                const A_m2 = (Number.isFinite(Abase) ? Abase : 0) * Af * 1e-4;
                const Z_m3 = (Number.isFinite(Zbase) ? Zbase : 0) * Zf * 1e-6;
                
                // Êé•ÂêàÊù°‰ª∂: „ÉÜ„Éº„Éñ„É´Ë°åÂÜÖ„ÅÆ .conn-select „Çí‰Ωø„Å£„Å¶ÂÆâÂÖ®„Å´ÂèñÂæó
                const hasDensityColumn = document.querySelector('.density-column') && document.querySelector('.density-column').style.display !== 'none';
                const connSelectsRow = Array.from(memberRow.querySelectorAll('.conn-select'));
                const iConnVal = connSelectsRow[0]?.value || 'rigid';
                const jConnVal = connSelectsRow[1]?.value || 'rigid';
                const props = {E:E_val, F:F_val, I:I_m4, A:A_m2, Z:Z_m3, i_conn:iConnVal, j_conn:jConnVal};
                // ËøΩÂä†Ââç„Å´Êó¢Â≠òÁØÄÁÇπ„Å®„ÅÆÈáçË§á„ÉÅ„Çß„ÉÉ„ÇØ„ÇíË°å„ÅÜÔºà„Ç∞„É™„ÉÉ„Éâ„Çπ„Éä„ÉÉ„ÉóÂæå„ÅÆÂ∫ßÊ®ô„ÅßÂà§ÂÆöÔºâ
                try {
                    const { nodes } = parseInputs();
                    const dupTolerance = 0.01; // 10mmÊú™Ê∫Ä„ÇíÂêå‰∏Ä„Å®„Åø„Å™„Åô
                    const dupIndex = nodes.findIndex(node => Math.abs(node.x - finalCoords.x) < dupTolerance && Math.abs(node.y - finalCoords.y) < dupTolerance);
                    if (dupIndex !== -1) {
                        // Êó¢Â≠òÁØÄÁÇπ„Å®Âêå‰∏Ä‰ΩçÁΩÆ„ÅÆ„Åü„ÇÅËøΩÂä†„Çí‰∏≠Ê≠¢„Åó„ÄÅ„ÉØ„Éº„Éã„É≥„Ç∞„ÇíË°®Á§∫
                        console.log('‚ö†Ô∏è ÈÉ®ÊùêÂàÜÂâ≤„ÅßÊó¢Â≠òÁØÄÁÇπ„Å®Âêå‰∏Ä‰ΩçÁΩÆ„ÅåÊ§úÂá∫„Åï„Çå„Åæ„Åó„Åü„ÄÇÊñ∞Ë¶èÁØÄÁÇπ„ÅØËøΩÂä†„Åï„Çå„Åæ„Åõ„Çì:', { existingIndex: dupIndex + 1, x: finalCoords.x, y: finalCoords.y });
                        utils.showMessage(`Êó¢Â≠ò„ÅÆÁØÄÁÇπ${dupIndex + 1}„Å®Âêå„Åò‰ΩçÁΩÆ„Åß„Åô„ÄÇÊñ∞Ë¶èÁØÄÁÇπ„ÅØËøΩÂä†„Åï„Çå„Åæ„Åõ„Çì„ÄÇ`, 'warning', 2000);
                    } else {
                        memberRow.querySelector('.delete-row-btn').onclick.apply(memberRow.querySelector('.delete-row-btn'));
                        addRow(elements.nodesTable, [`#`,`<input type="number" value="${finalCoords.x.toFixed(2)}">`,`<input type="number" value="${finalCoords.y.toFixed(2)}">`,`<select><option value="free" selected>Ëá™Áî±</option><option value="pinned">„Éî„É≥</option><option value="fixed">Âõ∫ÂÆö</option><option value="roller_x_fixed">„É≠„Éº„É©„Éº(ÂûÇÁõ¥Ëá™Áî±)</option><option value="roller_y_fixed">„É≠„Éº„É©„Éº(Ê∞¥Âπ≥Ëá™Áî±)</option></select>`, `<input type="number" value="0" step="0.1">`, `<input type="number" value="0" step="0.1">`, `<input type="number" value="0" step="0.001">`], false);
                    }
                } catch (err) {
                    console.error('‚ùå ÈÉ®ÊùêÂàÜÂâ≤Ââç„ÅÆÈáçË§á„ÉÅ„Çß„ÉÉ„ÇØ‰∏≠„Å´„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü:', err);
                    // „Ç®„É©„ÉºÊôÇ„ÅØÂÆâÂÖ®„ÅÆ„Åü„ÇÅËøΩÂä†„Çí‰∏≠Ê≠¢
                    utils.showMessage('„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åü„Åü„ÇÅÁØÄÁÇπ„ÇíËøΩÂä†„Åß„Åç„Åæ„Åõ„Çì„Åß„Åó„Åü„ÄÇ', 'error', 3000);
                }
                const newNodeId = elements.nodesTable.rows.length;
                const newRow1 = addRow(elements.membersTable, [`#`, ...memberRowHTML(startNodeId, newNodeId, props.E, props.F, props.I, props.A, props.Z, '', props.i_conn, 'rigid', '', '', '')], false);
                const newRow2 = addRow(elements.membersTable, [`#`, ...memberRowHTML(newNodeId, endNodeId, props.E, props.F, props.I, props.A, props.Z, '', 'rigid', props.j_conn, '', '', '')], false);
                
                // ÊâãÂãïËøΩÂä†ÈÉ®Êùê„Å´Êñ≠Èù¢ÊÉÖÂ†±„ÇíË®≠ÂÆö
                if (newRow1 && typeof window.setRowSectionInfo === 'function') {
                    const defaultSectionInfo1 = {
                        typeKey: 'estimated',
                        label: 'Êé®ÂÆöÊñ≠Èù¢ÔºàÂÜÜÂΩ¢Ôºâ',
                        rawDims: {
                            D: Math.sqrt(props.A * 1e4 / Math.PI) * 2 * 10,
                            D_scaled: Math.sqrt(props.A * 1e4 / Math.PI) * 2 * 10
                        },
                        source: 'ÊâãÂãïËøΩÂä†'
                    };
                    window.setRowSectionInfo(newRow1, defaultSectionInfo1);
                }
                
                if (newRow2 && typeof window.setRowSectionInfo === 'function') {
                    const defaultSectionInfo2 = {
                        typeKey: 'estimated',
                        label: 'Êé®ÂÆöÊñ≠Èù¢ÔºàÂÜÜÂΩ¢Ôºâ',
                        rawDims: {
                            D: Math.sqrt(props.A * 1e4 / Math.PI) * 2 * 10,
                            D_scaled: Math.sqrt(props.A * 1e4 / Math.PI) * 2 * 10
                        },
                        source: 'ÊâãÂãïËøΩÂä†'
                    };
                    window.setRowSectionInfo(newRow2, defaultSectionInfo2);
                }
                renumberTables(); drawOnCanvas();
            } else { 
                const spacing=parseFloat(elements.gridSpacing.value), snapTolerance=spacing/2.5;
                const snappedX=Math.round(modelCoords.x/spacing)*spacing, snappedY=Math.round(modelCoords.y/spacing)*spacing;
                const dist=Math.sqrt((modelCoords.x-snappedX)**2+(modelCoords.y-snappedY)**2);
                if (elements.gridToggle.checked && dist < snapTolerance) { modelCoords.x=snappedX; modelCoords.y=snappedY; }
                
                // Êó¢Â≠òÁØÄÁÇπ„Å®„ÅÆÈáçË§á„ÉÅ„Çß„ÉÉ„ÇØÔºà„Ç∞„É™„ÉÉ„Éâ„Çπ„Éä„ÉÉ„ÉóÂæå„ÅÆÂ∫ßÊ®ô„ÅßÁ¢∫Ë™çÔºâ
                const tolerance = 0.01; // 10mmÊú™Ê∫Ä„ÅÆÂ∑Æ„ÅØÂêå‰∏Ä„Å®„Åø„Å™„ÅôÔºàÂ∞èÊï∞ÁÇπ‰ª•‰∏ã2Ê°Å„ÅÆË°®Á§∫Á≤æÂ∫¶„Å´ÂØæÂøúÔºâ
                let isDuplicate = false;
                let duplicateNodeIndex = -1;
                
                console.log('üîç ÁØÄÁÇπËøΩÂä†„É¢„Éº„Éâ: ÈáçË§á„ÉÅ„Çß„ÉÉ„ÇØÈñãÂßã', { x: modelCoords.x, y: modelCoords.y });
                
                try {
                    const { nodes } = parseInputs();
                    console.log('üîç ÁØÄÁÇπËøΩÂä†„ÉÅ„Çß„ÉÉ„ÇØ: ËøΩÂä†‰∫àÂÆöÂ∫ßÊ®ô', { x: modelCoords.x, y: modelCoords.y });
                    console.log('üîç Êó¢Â≠òÁØÄÁÇπÊï∞:', nodes.length);
                    
                    for (let i = 0; i < nodes.length; i++) {
                        const node = nodes[i];
                        const dx = Math.abs(node.x - modelCoords.x);
                        const dy = Math.abs(node.y - modelCoords.y);
                        
                        if (dx < tolerance && dy < tolerance) {
                            isDuplicate = true;
                            duplicateNodeIndex = i + 1;
                            console.log('‚ö†Ô∏è ÈáçË§áÊ§úÂá∫:', { 
                                existingNode: { index: i + 1, x: node.x, y: node.y },
                                newCoords: { x: modelCoords.x, y: modelCoords.y },
                                diff: { dx, dy }
                            });
                            break;
                        }
                    }
                    
                    if (!isDuplicate) {
                        console.log('‚úÖ ÈáçË§á„Å™„Åó: ÁØÄÁÇπËøΩÂä†ÂèØËÉΩ');
                    }
                } catch (error) {
                    console.error('‚ùå ÈáçË§á„ÉÅ„Çß„ÉÉ„ÇØÊôÇ„Å´parseInputs„Ç®„É©„Éº:', error);
                    console.error('„Ç®„É©„ÉºË©≥Á¥∞:', error.message);
                    if (error.stack) console.error('„Çπ„Çø„ÉÉ„ÇØ„Éà„É¨„Éº„Çπ:', error.stack);
                    // parseInputs„Ç®„É©„ÉºÊôÇ„ÅØÂÆâÂÖ®„ÅÆ„Åü„ÇÅ„ÄÅÁØÄÁÇπËøΩÂä†„Çí„Çπ„Ç≠„ÉÉ„Éó
                    utils.showMessage('„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åü„Åü„ÇÅÁØÄÁÇπ„ÇíËøΩÂä†„Åß„Åç„Åæ„Åõ„Çì„ÄÇÈÉ®Êùê„Éá„Éº„Çø„ÇíÁ¢∫Ë™ç„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ', 'error', 3000);
                    return; // ÁØÄÁÇπËøΩÂä†„Çí‰∏≠Ê≠¢
                }
                
                if (isDuplicate) {
                    console.log('‚ö†Ô∏è Êó¢Â≠òÁØÄÁÇπ„Å®Âêå‰∏ÄÂ∫ßÊ®ô„ÅÆ„Åü„ÇÅ„ÄÅÊñ∞Ë¶èÁØÄÁÇπ„ÅÆËøΩÂä†„Çí„Çπ„Ç≠„ÉÉ„Éó„Åó„Åæ„Åó„Åü');
                    utils.showMessage(`Êó¢Â≠ò„ÅÆÁØÄÁÇπ${duplicateNodeIndex}„Å®Âêå„Åò‰ΩçÁΩÆ„Åß„Åô„ÄÇÊñ∞Ë¶èÁØÄÁÇπ„ÅØËøΩÂä†„Åï„Çå„Åæ„Åõ„Çì„ÄÇ`, 'warning', 2000);
                } else {
                    console.log('‚úÖ Êñ∞Ë¶èÁØÄÁÇπ„ÇíËøΩÂä†„Åó„Åæ„Åô:', { x: modelCoords.x, y: modelCoords.y });
                    addRow(elements.nodesTable, [`#`,`<input type="number" value="${modelCoords.x.toFixed(2)}">`,`<input type="number" value="${modelCoords.y.toFixed(2)}">`,`<select><option value="free" selected>Ëá™Áî±</option><option value="pinned">„Éî„É≥</option><option value="fixed">Âõ∫ÂÆö</option><option value="roller_x_fixed">„É≠„Éº„É©„Éº(ÂûÇÁõ¥Ëá™Áî±)</option><option value="roller_y_fixed">„É≠„Éº„É©„Éº(Ê∞¥Âπ≥Ëá™Áî±)</option></select>`, `<input type="number" value="0" step="0.1">`, `<input type="number" value="0" step="0.1">`, `<input type="number" value="0" step="0.001">`]); 
                }
            }
        } else if (canvasMode === 'addMember') {
            let targetNodeIndex = clickedNodeIndex;
            
            // ÁØÄÁÇπ„ÅåÂ≠òÂú®„Åó„Å™„ÅÑÂ†¥Âêà„ÅØÊñ∞Ë¶èÁØÄÁÇπ„Çí‰ΩúÊàê
            if (clickedNodeIndex === -1) {
                console.log('üîç ÁØÄÁÇπ„ÅåÂ≠òÂú®„Åó„Å™„ÅÑ‰ΩçÁΩÆ„Çí„ÇØ„É™„ÉÉ„ÇØ - Êñ∞Ë¶èÁØÄÁÇπ„Çí‰ΩúÊàê„Åó„Åæ„Åô');
                
                // „Éû„Ç¶„Çπ‰ΩçÁΩÆ„Çí„É¢„Éá„É´Â∫ßÊ®ô„Å´Â§âÊèõ
                let modelCoords = inverseTransform(mouseX, mouseY);
                if (!modelCoords) {
                    console.error('‚ùå Â∫ßÊ®ôÂ§âÊèõ„Å´Â§±Êïó„Åó„Åæ„Åó„Åü');
                    return;
                }
                
                // „Ç∞„É™„ÉÉ„Éâ„Çπ„Éä„ÉÉ„ÉóÂá¶ÁêÜ
                const spacing = parseFloat(elements.gridSpacing.value);
                const snapTolerance = spacing * 0.3;
                let snappedX = modelCoords.x;
                let snappedY = modelCoords.y;
                
                if (elements.gridToggle.checked) {
                    const gridX = Math.round(modelCoords.x / spacing) * spacing;
                    const gridY = Math.round(modelCoords.y / spacing) * spacing;
                    const dist = Math.sqrt((modelCoords.x - gridX) ** 2 + (modelCoords.y - gridY) ** 2);
                    if (dist < snapTolerance) {
                        // „Ç∞„É™„ÉÉ„Éâ„Å´Ëøë„ÅÑÂ†¥Âêà„ÅØ„Ç∞„É™„ÉÉ„ÉâÂ∫ßÊ®ô„Å´ÈÖçÁΩÆ
                        snappedX = gridX;
                        snappedY = gridY;
                        console.log('üîç „Ç∞„É™„ÉÉ„Éâ„Çπ„Éä„ÉÉ„ÉóÈÅ©Áî®:', { original: { x: modelCoords.x, y: modelCoords.y }, snapped: { x: snappedX, y: snappedY }, distance: dist });
                    } else {
                        // „Ç∞„É™„ÉÉ„Éâ„Åã„ÇâÈÅ†„ÅÑÂ†¥Âêà„ÅØÂÖÉ„ÅÆÂ∫ßÊ®ô„ÇíÁ∂≠ÊåÅ
                        snappedX = modelCoords.x;
                        snappedY = modelCoords.y;
                        console.log('üîç „Ç∞„É™„ÉÉ„Éâ„Çπ„Éä„ÉÉ„ÉóÁÑ°„Åó:', { original: { x: modelCoords.x, y: modelCoords.y }, distance: dist });
                    }
                }
                
                // Êó¢Â≠òÁØÄÁÇπ„Å®„ÅÆÈáçË§á„ÉÅ„Çß„ÉÉ„ÇØ
                const tolerance = 0.01; // 10mmÊú™Ê∫Ä„ÅÆÂ∑Æ„ÅØÂêå‰∏Ä„Å®„Åø„Å™„ÅôÔºàÂ∞èÊï∞ÁÇπ‰ª•‰∏ã2Ê°Å„ÅÆË°®Á§∫Á≤æÂ∫¶„Å´ÂØæÂøúÔºâ
                let existingNodeIndex = -1;
                try {
                    const { nodes } = parseInputs();
                    console.log('üîç ÈÉ®ÊùêËøΩÂä†„É¢„Éº„Éâ: ÁØÄÁÇπ„ÉÅ„Çß„ÉÉ„ÇØ‰∏≠', { x: snappedX, y: snappedY });
                    existingNodeIndex = nodes.findIndex(node => 
                        Math.abs(node.x - snappedX) < tolerance && 
                        Math.abs(node.y - snappedY) < tolerance
                    );
                    if (existingNodeIndex !== -1) {
                        console.log('üîç Êó¢Â≠òÁØÄÁÇπ„ÇíÁô∫Ë¶ã:', { index: existingNodeIndex, node: nodes[existingNodeIndex] });
                    }
                } catch (error) {
                    console.error('‚ùå parseInputs„Ç®„É©„Éº:', error);
                    // parseInputs„Ç®„É©„ÉºÊôÇ„ÅØÈáçË§á„ÉÅ„Çß„ÉÉ„ÇØ„Çí„Çπ„Ç≠„ÉÉ„Éó
                }
                
                if (existingNodeIndex !== -1) {
                    // Êó¢Â≠òÁØÄÁÇπ„ÅåË¶ã„Å§„Åã„Å£„ÅüÂ†¥Âêà„ÄÅ„Åù„ÅÆÁØÄÁÇπ„Çí‰ΩøÁî®
                    targetNodeIndex = existingNodeIndex;
                    console.log('‚úÖ Êó¢Â≠òÁØÄÁÇπ„Çí‰ΩøÁî®„Åó„Åæ„Åô:', { index: targetNodeIndex, x: snappedX, y: snappedY });
                } else {
                    // Êñ∞Ë¶èÁØÄÁÇπ„Çí„ÉÜ„Éº„Éñ„É´„Å´ËøΩÂä†
                    addRow(elements.nodesTable, [`#`, `<input type="number" value="${snappedX.toFixed(2)}">`, `<input type="number" value="${snappedY.toFixed(2)}">`, `<select><option value="free" selected>Ëá™Áî±</option><option value="pinned">„Éî„É≥</option><option value="fixed">Âõ∫ÂÆö</option><option value="roller_x_fixed">„É≠„Éº„É©„Éº(ÂûÇÁõ¥Ëá™Áî±)</option><option value="roller_y_fixed">„É≠„Éº„É©„Éº(Ê∞¥Âπ≥Ëá™Áî±)</option></select>`, `<input type="number" value="0" step="0.1">`, `<input type="number" value="0" step="0.1">`, `<input type="number" value="0" step="0.001">`]);
                    
                    // Êñ∞Ë¶è‰ΩúÊàê„Åï„Çå„ÅüÁØÄÁÇπ„ÅÆ„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ„ÇíÂèñÂæóÔºà„ÉÜ„Éº„Éñ„É´„ÅÆÊúÄÂæå„ÅÆË°åÔºâ
                    const nodeRows = elements.nodesTable.getElementsByTagName('tr');
                    targetNodeIndex = nodeRows.length - 1;
                    
                    console.log('‚úÖ Êñ∞Ë¶èÁØÄÁÇπ„Çí‰ΩúÊàê„Åó„Åæ„Åó„Åü:', { index: targetNodeIndex, x: snappedX, y: snappedY });
                }
            }
            
            if (targetNodeIndex !== -1) {
                if (firstMemberNode === null) { 
                    firstMemberNode = targetNodeIndex;
                    console.log('üîç ÈÉ®Êùê„ÅÆÂßãÁÇπ„ÇíË®≠ÂÆö:', firstMemberNode);
                } else {
                    if (firstMemberNode !== targetNodeIndex) {
                        // ÈÉ®Êùê„ÅÆÈï∑„Åï„Åå0„Å´„Å™„Çâ„Å™„ÅÑ„Åã‰∫ãÂâç„ÉÅ„Çß„ÉÉ„ÇØ
                        let canAddMember = true;
                        try {
                            const { nodes } = parseInputs();
                            const node1 = nodes[firstMemberNode];
                            const node2 = nodes[targetNodeIndex];
                            const length = Math.sqrt((node2.x - node1.x) ** 2 + (node2.y - node1.y) ** 2);
                            const minLength = 0.01; // ÊúÄÂ∞èÈÉ®ÊùêÈï∑ 10mmÔºàÁØÄÁÇπ„ÅÆÈáçË§áÂà§ÂÆö„Å®Âêå„ÅòÔºâ
                            
                            if (length < minLength) {
                                console.log('‚ö†Ô∏è ÈÉ®Êùê„ÅÆÈï∑„Åï„Åå0„Åæ„Åü„ÅØÈùûÂ∏∏„Å´Áü≠„ÅÑ„Åü„ÇÅ„ÄÅËøΩÂä†„Çí„Çπ„Ç≠„ÉÉ„Éó„Åó„Åæ„Åó„Åü:', { from: firstMemberNode, to: targetNodeIndex, length });
                                utils.showMessage('ÈÉ®Êùê„ÅÆÈï∑„Åï„ÅåÁü≠„Åô„Åé„Åæ„Åô„ÄÇÂßãÁÇπ„Å®ÁµÇÁÇπ„ÅåÂêå„Åò‰ΩçÁΩÆ„Å´„ÅÇ„Çä„Åæ„Åô„ÄÇ', 'warning', 2000);
                                canAddMember = false;
                            }
                        } catch (error) {
                            console.error('‚ùå ÈÉ®ÊùêÈï∑„ÉÅ„Çß„ÉÉ„ÇØÊôÇ„Å´„Ç®„É©„Éº:', error);
                            canAddMember = false;
                        }
                        
                        if (canAddMember) {
                            const I_m4 = parseFloat(newMemberDefaults.I)*1e-8, A_m2 = parseFloat(newMemberDefaults.A)*1e-4, Z_m3 = parseFloat(newMemberDefaults.Z)*1e-6;
                            const sectionName = newMemberDefaults.sectionName || '';
                            const sectionAxis = newMemberDefaults.sectionAxis || '';
                            console.log('üîç ÈÉ®ÊùêËøΩÂä†: newMemberDefaults:', { sectionName, sectionAxis, I: newMemberDefaults.I, A: newMemberDefaults.A, Z: newMemberDefaults.Z });
                            const iArgForNew = (newMemberDefaults && (newMemberDefaults.i || newMemberDefaults.i_radius || newMemberDefaults.ix || newMemberDefaults.iy)) ? (newMemberDefaults.i || newMemberDefaults.i_radius || newMemberDefaults.ix || newMemberDefaults.iy) : '';
                            const newRow = addRow(elements.membersTable, [`#`, ...memberRowHTML(firstMemberNode+1, targetNodeIndex+1, newMemberDefaults.E, newMemberDefaults.F, I_m4, A_m2, Z_m3, iArgForNew, newMemberDefaults.i_conn, newMemberDefaults.j_conn, sectionName, sectionAxis, newMemberDefaults.bucklingK || '')]);
                            console.log('‚úÖ ÈÉ®Êùê„Çí‰ΩúÊàê„Åó„Åæ„Åó„Åü:', { from: firstMemberNode, to: targetNodeIndex });

                            // ‚òÖ ËøΩÂä†: Êñ∞Ë¶èË°å„Å´ÂØæ„Åó„Å¶‰øùÂ≠òÊ∏à„Åø„ÅÆ sectionInfo „ÇíÈÅ©Áî®
                            try {
                                if (newRow) {
                                    if (newMemberDefaults && newMemberDefaults.sectionInfo && typeof window.setRowSectionInfo === 'function') {
                                        try { window.setRowSectionInfo(newRow, newMemberDefaults.sectionInfo); } catch (_e) { console.warn('setRowSectionInfo failed on newRow', _e); }
                                    } else if (newRow) {
                                        // Êó¢Â≠ò„ÅÆ setRowSectionInfo „ÅåÁÑ°„Åë„Çå„Å∞„ÄÅdataset „Å´Áõ¥Êé•‰øùÂ≠ò
                                        try {
                                            if (newMemberDefaults && newMemberDefaults.sectionInfo) {
                                                newRow.dataset.sectionInfo = encodeURIComponent(JSON.stringify(newMemberDefaults.sectionInfo));
                                            } else {
                                                // „Å™„Åë„Çå„Å∞ÂæìÊù•„ÅÆÊé®ÂÆöÊñ≠Èù¢ÔºàÂÜÜÂΩ¢Ôºâ„ÇíË®≠ÂÆö
                                                if (typeof window.setRowSectionInfo === 'function') {
                                                    const defaultSectionInfo = {
                                                        typeKey: 'estimated',
                                                        label: 'Êé®ÂÆöÊñ≠Èù¢ÔºàÂÜÜÂΩ¢Ôºâ',
                                                        rawDims: {
                                                            D: Math.sqrt(A_m2 * 1e4 / Math.PI) * 2 * 10
                                                        },
                                                        source: 'ÊâãÂãïËøΩÂä†'
                                                    };
                                                    try { window.setRowSectionInfo(newRow, defaultSectionInfo); } catch (_) { newRow.dataset.sectionInfo = encodeURIComponent(JSON.stringify(defaultSectionInfo)); }
                                                } else {
                                                    const defaultSectionInfo = {
                                                        typeKey: 'estimated',
                                                        label: 'Êé®ÂÆöÊñ≠Èù¢ÔºàÂÜÜÂΩ¢Ôºâ',
                                                        rawDims: { D: Math.sqrt(A_m2 * 1e4 / Math.PI) * 2 * 10 },
                                                        source: 'ÊâãÂãïËøΩÂä†'
                                                    };
                                                    newRow.dataset.sectionInfo = encodeURIComponent(JSON.stringify(defaultSectionInfo));
                                                }
                                            }
                                        } catch (_e) { console.warn('failed to apply sectionInfo to newRow via dataset', _e); }
                                    }

                                    // 3D „Éì„É•„Éº„Ç¢Êõ¥Êñ∞ÈÄöÁü•ÔºàÁü≠ÈÅÖÂª∂Ôºâ
                                    if (typeof sendModelToViewer === 'function') {
                                        setTimeout(() => { try { sendModelToViewer(); } catch (e) { console.warn('sendModelToViewer failed', e); } }, 100);
                                    }
                                }
                            } catch (applyErr) {
                                console.warn('apply sectionInfo to newRow failed', applyErr);
                            }
                        }
                    }
                    firstMemberNode = null;
                }
                drawOnCanvas();
            }
        } 
    });

    const getNodeLoadAt = (canvasX, canvasY) => { if (!lastDrawingContext) return -1; try { const { nodes, nodeLoads } = parseInputs(); const arrowSize = 10, loadScale = 3, tolerance = 5; for (const load of nodeLoads) { if (load.px===0&&load.py===0&&load.mz===0) continue; const node=nodes[load.nodeIndex], pos=lastDrawingContext.transform(node.x, node.y); if (load.px!==0) { const dir=Math.sign(load.px), x1=pos.x, x2=pos.x-arrowSize*loadScale*dir; const rect={left:Math.min(x1,x2)-tolerance,right:Math.max(x1,x2)+tolerance,top:pos.y-(arrowSize/2)-tolerance,bottom:pos.y+(arrowSize/2)+tolerance}; if (canvasX>=rect.left&&canvasX<=rect.right&&canvasY>=rect.top&&canvasY<=rect.bottom) return load.nodeIndex; } if (load.py!==0) { const dir=Math.sign(load.py), y1=pos.y, y2=pos.y+arrowSize*loadScale*dir; const rect={top:Math.min(y1,y2)-tolerance,bottom:Math.max(y1,y2)+tolerance,left:pos.x-(arrowSize/2)-tolerance,right:pos.x+(arrowSize/2)+tolerance}; if (canvasX>=rect.left&&canvasX<=rect.right&&canvasY>=rect.top&&canvasY<=rect.bottom) return load.nodeIndex; } if (load.mz!==0) { const radius=arrowSize*1.5, dist=Math.sqrt((canvasX-pos.x)**2+(canvasY-pos.y)**2); if (dist>=radius-tolerance&&dist<=radius+tolerance) return load.nodeIndex; } } } catch (e) {} return -1; };

    elements.modelCanvas.addEventListener('contextmenu', (e) => {
        e.preventDefault();
        const rect = elements.modelCanvas.getBoundingClientRect(), mouseX = e.clientX-rect.left, mouseY = e.clientY-rect.top;
        
        // ÂÖ®„Å¶„ÅÆ„Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó„Å®„É°„Éã„É•„Éº„ÇíÁ¢∫ÂÆü„Å´ÈùûË°®Á§∫Ôºànull „ÉÅ„Çß„ÉÉ„ÇØ‰ªò„ÅçÔºâ
        if (elements.nodeContextMenu) elements.nodeContextMenu.style.display='none';
        if (elements.memberPropsPopup) {
            elements.memberPropsPopup.style.display='none';
            elements.memberPropsPopup.style.visibility='hidden';
        }
        if (elements.nodePropsPopup) {
            elements.nodePropsPopup.style.display='none';
            elements.nodePropsPopup.style.visibility='hidden';
        }
        if (elements.nodeLoadPopup) {
            elements.nodeLoadPopup.style.display='none';
            elements.nodeLoadPopup.style.visibility='hidden';
        }
        if (elements.nodeCoordsPopup) {
            elements.nodeCoordsPopup.style.display='none';
            elements.nodeCoordsPopup.style.visibility='hidden';
        }
        
        // „Éá„Éê„ÉÉ„Ç∞„É≠„Ç∞„ÇíËøΩÂä†
        console.log('üñ±Ô∏è Âè≥„ÇØ„É™„ÉÉ„ÇØ„Ç§„Éô„É≥„ÉàÁô∫Áîü - „Éû„Ç¶„Çπ‰ΩçÁΩÆ:', { mouseX, mouseY });
        console.log('ÁèæÂú®„ÅÆË§áÊï∞ÈÅ∏ÊäûÁä∂ÊÖã:', {
            selectedMembers: Array.from(selectedMembers),
            selectedNodes: Array.from(selectedNodes),
            selectedMembersSize: selectedMembers.size,
            selectedNodesSize: selectedNodes.size
        });
        
        // Ë§áÊï∞ÈÅ∏ÊäûÁä∂ÊÖã„Çí„ÉÅ„Çß„ÉÉ„ÇØ
        if (selectedMembers.size > 1) {
            console.log('‚úÖ Ë§áÊï∞ÈÉ®ÊùêÈÅ∏ÊäûÊôÇ„ÅÆÂè≥„ÇØ„É™„ÉÉ„ÇØ - ‰∏ÄÊã¨Á∑®ÈõÜ„É°„Éã„É•„ÉºË°®Á§∫:', Array.from(selectedMembers));
            showBulkEditMenu(e.pageX, e.pageY);
            return;
        } else if (selectedNodes.size > 1) {
            console.log('‚úÖ Ë§áÊï∞ÁØÄÁÇπÈÅ∏ÊäûÊôÇ„ÅÆÂè≥„ÇØ„É™„ÉÉ„ÇØ - ‰∏ÄÊã¨Á∑®ÈõÜ„É°„Éã„É•„ÉºË°®Á§∫:', Array.from(selectedNodes));
            showBulkNodeEditMenu(e.pageX, e.pageY);
            return;
        }
        
        console.log('üìç Âçò‰∏ÄÈÅ∏ÊäûÂà§ÂÆöÈñãÂßã');
        selectedNodeIndex = getNodeAt(mouseX, mouseY);
        let loadedNodeIndex = -1; 
        if (selectedNodeIndex === -1) { 
            loadedNodeIndex = getNodeLoadAt(mouseX, mouseY); 
        }
        selectedMemberIndex = getMemberAt(mouseX, mouseY);

        // windowÂ§âÊï∞„ÇÇÂêåÊúü
        window.selectedNodeIndex = selectedNodeIndex;
        window.selectedMemberIndex = selectedMemberIndex;

        console.log('‚úÖ Âè≥„ÇØ„É™„ÉÉ„ÇØÂæå„ÅÆÈÅ∏ÊäûÁä∂ÊÖã:', {
            selectedNodeIndex,
            selectedMemberIndex,
            loadedNodeIndex,
            windowSelectedNodeIndex: window.selectedNodeIndex,
            windowSelectedMemberIndex: window.selectedMemberIndex
        });

        if (loadedNodeIndex !== -1) {
            selectedNodeIndex = loadedNodeIndex;
            console.log('üí° Ëç∑ÈáçÁ∑®ÈõÜ„Éù„ÉÉ„Éó„Ç¢„ÉÉ„ÉóË°®Á§∫ÈñãÂßã - ÁØÄÁÇπ:', selectedNodeIndex + 1);
            const currentLoads = Array.from(elements.nodeLoadsTable.rows).find(row => parseInt(row.cells[0].querySelector('input').value)-1 === selectedNodeIndex);
            document.getElementById('popup-px').value=currentLoads?currentLoads.cells[1].querySelector('input').value:'0';
            document.getElementById('popup-py').value=currentLoads?currentLoads.cells[2].querySelector('input').value:'0';
            document.getElementById('popup-mz').value=currentLoads?currentLoads.cells[3].querySelector('input').value:'0';
            
            // „Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó„ÇíÁîªÈù¢‰∏≠Â§Æ„Å´Ë°®Á§∫Ôºànull „ÉÅ„Çß„ÉÉ„ÇØ‰ªò„ÅçÔºâ
            const popup = elements.nodeLoadPopup;
            if (popup) {
                popup.style.display = 'block';
                popup.style.visibility = 'visible';
                console.log('‚úÖ Ëç∑ÈáçÁ∑®ÈõÜ„Éù„ÉÉ„Éó„Ç¢„ÉÉ„ÉóË°®Á§∫Ë®≠ÂÆöÂÆå‰∫Ü');
                
                // „Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó„ÅÆ„Çµ„Ç§„Ç∫„ÇíÂèñÂæóÔºà„Éá„Éï„Ç©„É´„ÉàÂÄ§„ÇíË®≠ÂÆöÔºâ
                const popupRect = popup.getBoundingClientRect();
                const popupWidth = popupRect.width || 300;  // „Éá„Éï„Ç©„É´„ÉàÂπÖ
                const popupHeight = popupRect.height || 250; // „Éá„Éï„Ç©„É´„ÉàÈ´ò„Åï
                const windowWidth = window.innerWidth;
                const windowHeight = window.innerHeight;
                const availableHeight = Math.min(windowHeight, document.documentElement.clientHeight);
                const minMargin = 10;
                const bottomMargin = 20; // „Çø„Çπ„ÇØ„Éê„ÉºÂØæÁ≠ñ
                
                // ÁîªÈù¢ÂÜÖ„Å´Âèé„Åæ„Çã„Çà„ÅÜ„Å´ÈÖçÁΩÆ
                const left = Math.max(minMargin, Math.min((windowWidth - popupWidth) / 2, windowWidth - popupWidth - minMargin));
                const top = Math.max(minMargin, Math.min((availableHeight - popupHeight) / 2, availableHeight - popupHeight - bottomMargin));
                
                popup.style.left = `${left}px`;
                popup.style.top = `${top}px`;
                popup.style.position = 'fixed';
            } else {
                console.error('‚ùå nodeLoadPopup Ë¶ÅÁ¥†„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì');
            }
        } else if (selectedNodeIndex !== -1) {
            console.log('üí° ÁØÄÁÇπ„Éó„É≠„Éë„ÉÜ„Ç£Á∑®ÈõÜË°®Á§∫ - ÁØÄÁÇπ:', selectedNodeIndex + 1);
            // Áõ¥Êé•ÁØÄÁÇπ„Éó„É≠„Éë„ÉÜ„Ç£Á∑®ÈõÜ„ÇíÈñã„Åè
            openNodeEditor(selectedNodeIndex);
        } else if (selectedMemberIndex !== -1) {
            console.log('üí° ÈÉ®Êùê„Éó„É≠„Éë„ÉÜ„Ç£„Éù„ÉÉ„Éó„Ç¢„ÉÉ„ÉóË°®Á§∫ÈñãÂßã - ÈÉ®Êùê:', selectedMemberIndex + 1);
            const memberRow = elements.membersTable.rows[selectedMemberIndex];
            const e_select = memberRow.cells[3].querySelector('select'), e_input = memberRow.cells[3].querySelector('input[type="number"]');
            const currentE = (e_select.value === 'custom') ? e_input.value : e_select.value;
            
            // „Éù„ÉÉ„Éó„Ç¢„ÉÉ„ÉóÂÜÖ„ÅÆEÂÖ•ÂäõÊ¨Ñ„ÇíÁîüÊàê
            const eContainer = document.getElementById('popup-e-container');
            eContainer.innerHTML = createEInputHTML('popup-e', currentE);
            
            // ÁèæÂú®„ÅÆÊùêÊñô„Çø„Ç§„Éó„Å®Âü∫Ê∫ñÂº∑Â∫¶„ÇíÂèñÂæó
            const strengthContainer = memberRow.cells[4].firstElementChild;
            if (!strengthContainer) {
                console.error('Âº∑Â∫¶ÂÖ•Âäõ„Ç≥„É≥„ÉÜ„Éä„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì');
                return;
            }
            const strengthType = strengthContainer.dataset.strengthType;
            let currentStrength;
            if (strengthType === 'wood-type') {
                const presetSelect = strengthContainer.querySelector('select');
                if (presetSelect.value === 'custom') {
                    currentStrength = { baseStrengths: {} };
                    ['ft', 'fc', 'fb', 'fs'].forEach(key => {
                        currentStrength.baseStrengths[key] = parseFloat(strengthContainer.querySelector(`input[id*="-${key}"]`).value);
                    });
                } else {
                    currentStrength = presetSelect.value;
                }
            } else {
                currentStrength = strengthContainer.querySelector('input').value;
            }

            const popupFContainer = document.getElementById('popup-f-container');
            const selectedOption = e_select.options[e_select.selectedIndex];
            let materialType = 'steel';
            if (selectedOption.textContent.includes('Êú®Êùê')) materialType = 'wood';
            else if (selectedOption.textContent.includes('„Çπ„ÉÜ„É≥„É¨„Çπ')) materialType = 'stainless';
            else if (selectedOption.textContent.includes('„Ç¢„É´„Éü„Éã„Ç¶„É†')) materialType = 'aluminum';
            
            // „Éù„ÉÉ„Éó„Ç¢„ÉÉ„ÉóÂÜÖ„ÅÆFÂÖ•ÂäõÊ¨Ñ„ÇíÁîüÊàê
            popupFContainer.innerHTML = '';
            popupFContainer.appendChild(createStrengthInputHTML(materialType, 'popup-f', currentStrength));

            // „Éù„ÉÉ„Éó„Ç¢„ÉÉ„ÉóÂÜÖ„ÅÆEÈÅ∏Êäû„Å´Âøú„Åò„Å¶FÂÖ•ÂäõÊ¨Ñ„ÇíÊõ¥Êñ∞„Åô„Çã„Ç§„Éô„É≥„Éà„É™„Çπ„Éä„Éº„ÇíËøΩÂä†
            const popupESelect = document.getElementById('popup-e-select');
            if (popupESelect) {
                popupESelect.addEventListener('change', () => {
                    const selectedOpt = popupESelect.options[popupESelect.selectedIndex];
                    let newMaterialType = 'steel';
                    if (selectedOpt.textContent.includes('Êú®Êùê')) newMaterialType = 'wood';
                    else if (selectedOpt.textContent.includes('„Çπ„ÉÜ„É≥„É¨„Çπ')) newMaterialType = 'stainless';
                    else if (selectedOpt.textContent.includes('„Ç¢„É´„Éü„Éã„Ç¶„É†')) newMaterialType = 'aluminum';
                    
                    popupFContainer.innerHTML = '';
                    popupFContainer.appendChild(createStrengthInputHTML(newMaterialType, 'popup-f'));
                    
                    // ÂØÜÂ∫¶„ÇÇÊõ¥Êñ∞ÔºàËá™ÈáçËÄÉÊÖÆ„Åå„Ç™„É≥„ÅÆÂ†¥ÂêàÔºâ
                    const hasDensityColumn = document.querySelector('.density-column') && document.querySelector('.density-column').style.display !== 'none';
                    if (hasDensityColumn) {
                        const popupEInput = document.getElementById('popup-e-input');
                        const eValue = popupESelect.value === 'custom' ? popupEInput.value : popupESelect.value;
                        const newDensity = MATERIAL_DENSITY_DATA[eValue] || MATERIAL_DENSITY_DATA['custom'];
                        
                        // „Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó„ÅÆÂØÜÂ∫¶Ê¨Ñ„ÇíÊõ¥Êñ∞
                        const densityContainer = document.getElementById('popup-density-container');
                        if (densityContainer) {
                            densityContainer.innerHTML = createDensityInputHTML('popup-density', newDensity);
                        }
                    }
                });
            }

            // „Åù„ÅÆ‰ªñ„ÅÆ„Éó„É≠„Éë„ÉÜ„Ç£„ÇíË®≠ÂÆö
            // „ÉÜ„Éº„Éñ„É´„ÅÆÂàóÈÖçÁΩÆ: 0:'#',1:i,2:j,3:E,4:strength,5:I,6:A,7:Z,...
            const tableIcell = memberRow.cells[5];
            const tableAcell = memberRow.cells[6];
            const tableZcell = memberRow.cells[7];
            // „ÉÜ„Éº„Éñ„É´Ë°®Á§∫„ÅØ I „Çí cm^4 Âçò‰Ωç„ÅßË°®Á§∫„Åó„Å¶„ÅÑ„Çã„Åü„ÇÅ„ÄÅ„Åù„ÅÆ„Åæ„Åæ„Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó„Å∏Ê∏°„Åô
            document.getElementById('popup-i').value = tableIcell ? (tableIcell.querySelector('input') ? tableIcell.querySelector('input').value : '') : '';
            document.getElementById('popup-a').value = tableAcell ? tableAcell.querySelector('input').value : '';
            document.getElementById('popup-z').value = tableZcell ? tableZcell.querySelector('input').value : '';
            // ‚ñº‚ñº‚ñº Â§âÊõ¥: popup „Å´Ë°®Á§∫„Åô„ÇãÂ∫ßÂ±àÂçäÂæÑ i „Çí1„Å§„Å†„ÅëÊâ±„ÅÜ
            const popupRadiusEl = document.getElementById('popup-radius-i');
            if (popupRadiusEl) {
                // dataset „Å´ ix/iy „Åå„ÅÇ„Çå„Å∞Â∞è„Åï„ÅÑÊñπÔºà„Åæ„Åü„ÅØÁâáÊñπÔºâ„ÇíÂÑ™ÂÖà„Åó„Å¶Ë°®Á§∫Ôºàdataset ÂÄ§„ÅØ cm Âçò‰ΩçÔºâ
                try {
                    const rawIx = memberRow.dataset.ix;
                    const rawIy = memberRow.dataset.iy;
                    const nIx = (rawIx !== undefined && rawIx !== '') ? parseFloat(rawIx) : NaN;
                    const nIy = (rawIy !== undefined && rawIy !== '') ? parseFloat(rawIy) : NaN;
                    if (!isNaN(nIx) && !isNaN(nIy)) {
                        popupRadiusEl.value = Math.min(nIx, nIy).toFixed(2);
                    } else if (!isNaN(nIx)) {
                        popupRadiusEl.value = nIx.toFixed(2);
                    } else if (!isNaN(nIy)) {
                        popupRadiusEl.value = nIy.toFixed(2);
                    } else {
                        popupRadiusEl.value = '';
                    }
                } catch (e) {
                    popupRadiusEl.value = '';
                }
            }
            // „Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó„Å´Êñ≠Èù¢Âêç„ÇíË°®Á§∫
            try {
                const popupSectionLabelEl = document.getElementById('popup-section-label');
                if (popupSectionLabelEl) {
                    let labelText = '';
                    // ÂÑ™ÂÖà: row.dataset.sectionInfo („Ç®„É≥„Ç≥„Éº„ÉâÊ∏à„Åø„ÅÆÂèØËÉΩÊÄß„ÅÇ„Çä)
                    try {
                        const raw = memberRow.dataset.sectionInfo;
                        if (raw) {
                            let si = null;
                            try {
                                // „Åæ„Åö„Éá„Ç≥„Éº„Éâ + JSON.parse „ÇíË©¶„Åô
                                const dec = decodeURIComponent(raw);
                                si = JSON.parse(dec);
                            } catch (_) {
                                try { si = JSON.parse(raw); } catch (__){ si = null; }
                            }
                            if (si) labelText = si.label || si.sectionLabel || si.name || '';
                        }
                    } catch (err) {
                        labelText = '';
                    }

                    // ÂèñÂæó„Åß„Åç„Å™„Åë„Çå„Å∞„ÉÜ„Éº„Éñ„É´„ÅÆÊñ≠Èù¢ÂêçÁß∞„Çª„É´„Åã„ÇâË™≠„ÇÄÔºà.section-name-cell span ÂÑ™ÂÖàÔºâ
                    if (!labelText) {
                        const nameSpan = memberRow.querySelector('.section-name-cell');
                        if (nameSpan) labelText = nameSpan.textContent.trim();
                        else {
                            // „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ: Êñ≠Èù¢ÂêçÁß∞„ÅåÂÖ•„Çã„Åß„ÅÇ„Çç„ÅÜ„Çª„É´„Çí„Çπ„Ç≠„É£„É≥
                            const cells = memberRow.cells || [];
                            const tryCols = [10,9,11,8,7];
                            for (let ci of tryCols) {
                                if (cells[ci]) {
                                    const t = (cells[ci].textContent || '').trim();
                                    if (t) { labelText = t; break; }
                                }
                            }
                        }
                    }

                    // Ëª∏ÊñπÂêë„ÅÆÂèñÂæó„Å®Ë°®Á§∫ (Á∏¶‰∏¶„Å≥)
                    let axialText = '';
                    try {
                        // „ÇØ„É©„ÇπÂêç„Åã„ÇâËª∏ÊñπÂêë„Çª„É´„ÇíÂèñÂæóÔºàÂàó„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ„ÅÆ„Ç∫„É¨„Å´ÂØæÂøúÔºâ
                        const axisCell = memberRow.querySelector('.section-axis-cell');
                        if (axisCell) {
                            axialText = axisCell.textContent.trim();
                        } else {
                            // „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ: ÂØÜÂ∫¶Âàó„ÅÆÊúâÁÑ°„ÇíÁ¢∫Ë™ç„Åó„Å¶„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ„ÇíË™øÊï¥
                            // ÂØÜÂ∫¶Âàó„Åå„ÅÇ„ÇãÂ†¥Âêà: 12, „Å™„ÅÑÂ†¥Âêà: 11
                            const hasDensity = memberRow.querySelector('.density-cell') || (memberRow.cells[10] && memberRow.cells[10].classList.contains('density-column'));
                            const axisIndex = hasDensity ? 12 : 11;
                            if (memberRow.cells[axisIndex]) {
                                axialText = memberRow.cells[axisIndex].textContent.trim();
                            }
                        }
                        
                        // "ÈÅ∏Êäû" „Å®„ÅÑ„ÅÜÊñáÂ≠óÂàóÔºà„Éú„Çø„É≥„ÅÆ„ÉÜ„Ç≠„Çπ„ÉàÔºâ„ÇíÊãæ„Å£„Å¶„Åó„Åæ„Å£„ÅüÂ†¥Âêà„ÅÆÈô§Â§ñÂá¶ÁêÜ
                        if (axialText === 'ÈÅ∏Êäû') axialText = '';
                    } catch (e) {}

                    popupSectionLabelEl.innerHTML = `Êñ≠Èù¢: ${labelText || '-'}${axialText ? `<br><span style="font-weight:normal; font-size:0.9em;">Ëª∏ÊñπÂêë: ${axialText}</span>` : ''}`;
                }
            } catch (err) {
                console.warn('popup section label set failed', err);
            }
            // ‚ñ≤‚ñ≤‚ñ≤ ËøΩÂä†ÁµÇ‰∫Ü
            
            // ÂØÜÂ∫¶Ê¨Ñ„ÅÆË°®Á§∫/ÈùûË°®Á§∫„Å®ÂÄ§Ë®≠ÂÆö
            const hasDensityColumn = document.querySelector('.density-column') && document.querySelector('.density-column').style.display !== 'none';
            let existingDensityLabel = document.getElementById('popup-density-label');
            let existingDensityContainer = document.getElementById('popup-density-container');
            
            if (hasDensityColumn) {
                // ÂØÜÂ∫¶Ê¨Ñ„ÅåÂøÖË¶Å„Å™Â†¥Âêà
                if (!existingDensityLabel || !existingDensityContainer) {
                    // ÂØÜÂ∫¶Ê¨Ñ„ÇíÂãïÁöÑ„Å´‰ΩúÊàê
                    const propsGrid = document.querySelector('#member-props-popup .props-grid');
                    const zInput = document.getElementById('popup-z');
                    
                    // ÂØÜÂ∫¶„É©„Éô„É´„Çí‰ΩúÊàê
                    const densityLabel = document.createElement('label');
                    densityLabel.setAttribute('for', 'popup-density');
                    densityLabel.textContent = 'ÂØÜÂ∫¶ œÅ (kg/m¬≥)';
                    densityLabel.id = 'popup-density-label';
                    
                    // ÂØÜÂ∫¶ÂÖ•ÂäõÊ¨Ñ„Çí‰ΩúÊàê
                    const densityContainer = document.createElement('div');
                    densityContainer.id = 'popup-density-container';
                    
                    // ZÂÖ•ÂäõÊ¨Ñ„ÅÆÁõ¥Âæå„Å´ÂØÜÂ∫¶Ê¨Ñ„ÇíÊåøÂÖ•
                    // ZÂÖ•ÂäõÊ¨Ñ„ÅÆÊ¨°„Å´ÊåøÂÖ•Ôºà„Çà„ÇäÂÆâÂÖ®„Å™ÊñπÊ≥ïÔºâ
                    const iConnLabel = document.querySelector('label[for="popup-i-conn"]');
                    if (iConnLabel) {
                        propsGrid.insertBefore(densityLabel, iConnLabel);
                        propsGrid.insertBefore(densityContainer, iConnLabel);
                    } else {
                        // ÊåøÂÖ•‰ΩçÁΩÆ„ÅåË¶ã„Å§„Åã„Çâ„Å™„ÅÑÂ†¥Âêà„ÅØÊú´Â∞æ„Å´ËøΩÂä†
                        propsGrid.appendChild(densityLabel);
                        propsGrid.appendChild(densityContainer);
                    }
                    
                    // ‰ΩúÊàê„Åó„ÅüË¶ÅÁ¥†„ÇíÂ§âÊï∞„Å´‰øùÂ≠ò
                    existingDensityLabel = densityLabel;
                    existingDensityContainer = densityContainer;
                }
                
                // ÂØÜÂ∫¶ÂÄ§„ÇíÂèñÂæó„Åó„Å¶„Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó„Å´Ë®≠ÂÆö
                const densityCell = memberRow.cells[8]; // ÂØÜÂ∫¶„ÅØ8Áï™ÁõÆ„ÅÆ„Çª„É´
                if (densityCell && densityCell.classList.contains('density-cell')) {
                    const densitySelect = densityCell.querySelector('select');
                    const densityInput = densityCell.querySelector('input[type="number"]');
                    const currentDensity = (densitySelect && densitySelect.value === 'custom') ? densityInput.value : (densitySelect ? densitySelect.value : '7850');
                    
                    // ÂØÜÂ∫¶ÂÖ•ÂäõÊ¨Ñ„Å´HTML„ÇíË®≠ÂÆö
                    if (existingDensityContainer) {
                        existingDensityContainer.innerHTML = createDensityInputHTML('popup-density', currentDensity);
                    }
                }
                
                // ÂØÜÂ∫¶Ê¨Ñ„ÇíË°®Á§∫
                if (existingDensityLabel) existingDensityLabel.style.display = '';
                if (existingDensityContainer) existingDensityContainer.style.display = '';
                
                // ÂØÜÂ∫¶„Éï„Ç£„Éº„É´„ÉâË°®Á§∫Âæå„Å´„Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó‰ΩçÁΩÆ„ÇíÂÜçË™øÊï¥
                setTimeout(() => adjustPopupPosition(elements.memberPropsPopup), 0);
            } else {
                // ÂØÜÂ∫¶Ê¨Ñ„ÇíÈùûË°®Á§∫
                if (existingDensityLabel) existingDensityLabel.style.display = 'none';
                if (existingDensityContainer) existingDensityContainer.style.display = 'none';
                
                // ÂØÜÂ∫¶„Éï„Ç£„Éº„É´„ÉâÈùûË°®Á§∫Âæå„Å´„Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó‰ΩçÁΩÆ„ÇíÂÜçË™øÊï¥
                setTimeout(() => adjustPopupPosition(elements.memberPropsPopup), 0);
            }
            
            // Êé•ÂêàÊù°‰ª∂: row ÂÜÖ„ÅÆ .conn-select „Åã„ÇâÂÆâÂÖ®„Å´ÂèñÂæó„Åó„Å¶„Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó„Å´ÂèçÊò†
            const popupIConn = document.getElementById('popup-i-conn');
            const popupJConn = document.getElementById('popup-j-conn');
            const connSelectsRow = Array.from(memberRow.querySelectorAll('.conn-select'));
            const iConnSel = connSelectsRow[0] || null;
            const jConnSel = connSelectsRow[1] || null;
            if (popupIConn) {
                if (iConnSel) {
                    popupIConn.value = iConnSel.value;
                    popupIConn.dispatchEvent(new Event('change'));
                }
                else console.warn('popup sync: i_conn select not found on row', { selectedMemberIndex, memberRow });
            }
            if (popupJConn) {
                if (jConnSel) {
                    popupJConn.value = jConnSel.value;
                    popupJConn.dispatchEvent(new Event('change'));
                }
                else console.warn('popup sync: j_conn select not found on row', { selectedMemberIndex, memberRow });
            }

            const memberLoadRow = Array.from(elements.memberLoadsTable.rows).find(row => parseInt(row.cells[0].querySelector('input').value)-1 === selectedMemberIndex);
            const popupW = document.getElementById('popup-w');
            if (popupW) {
                if (memberLoadRow) {
                    const wInput = memberLoadRow.cells[1].querySelector('input');
                    popupW.value = wInput ? wInput.value : '0';
                } else {
                    popupW.value = '0';
                }
            } else {
                console.warn('popup-w Ë¶ÅÁ¥†„Åå DOM ‰∏ä„Å´Â≠òÂú®„Åó„Åæ„Åõ„Çì');
            }
            // Â∫ßÂ±àÈï∑„Åï‰øÇÊï∞ K „ÅÆË™≠„ÅøËæº„ÅøÔºàË°å„ÅÆ dataset „Åã„ÇâÂèçÊò†Ôºâ
            try {
                const popupBucklingK = document.getElementById('popup-buckling-k');
                if (popupBucklingK && row) {
                    // Á©∫Ê¨ÑÊôÇ„ÅØ„Éó„É¨„Éº„Çπ„Éõ„É´„ÉÄ„Åß„ÄåËá™Âãï„Äç„Å®Ë°®Á§∫„Åô„Çã
                    popupBucklingK.placeholder = 'Ëá™Âãï';
                    popupBucklingK.title = 'Á©∫Ê¨Ñ„ÅÆÂ†¥Âêà„ÅØÊé•ÂêàÊù°‰ª∂„Åã„ÇâËá™ÂãïÂà§ÂÆö';
                    popupBucklingK.value = row.dataset.bucklingK !== undefined ? row.dataset.bucklingK : '';
                }
            } catch (e) {
                console.warn('popup init: buckling K load error', e);
            }
            
            // „Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó„ÇíÈÉ®Êùê„Å´Èáç„Å™„Çâ„Å™„ÅÑ‰ΩçÁΩÆ„Å´Ë°®Á§∫Ôºànull „ÉÅ„Çß„ÉÉ„ÇØ‰ªò„ÅçÔºâ
            const popup = elements.memberPropsPopup;
            if (!popup) {
                console.error('‚ùå memberPropsPopup Ë¶ÅÁ¥†„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì');
                return;
            }
            
            let titleEl = document.getElementById('member-props-popup-title');
            if (!titleEl) {
                titleEl = document.createElement('h2');
                titleEl.id = 'member-props-popup-title';
                titleEl.style.textAlign = 'center';
                titleEl.style.marginTop = '0';
                popup.prepend(titleEl);
            }
            // ‰∏äÈÉ®„ÅÆÂ§ß„Åç„Å™„Çø„Ç§„Éà„É´„ÅØ‰∏çË¶Å„Å®„ÅÆ„Åì„Å®„Å™„ÅÆ„ÅßÈùûË°®Á§∫„Å´„Åô„Çã
            titleEl.style.display = 'none';

            // ÈÉ®ÊùêÁï™Âè∑Ë°®Á§∫Ôºà„Éù„ÉÉ„Éó„Ç¢„ÉÉ„ÉóÂÜÖÁõÆÁ´ã„Å§‰ΩçÁΩÆ„Å´Ë°®Á§∫Ôºâ
            let memberIndexEl = document.getElementById('member-props-popup-index');
            if (!memberIndexEl) {
                memberIndexEl = document.createElement('div');
                memberIndexEl.id = 'member-props-popup-index';
                memberIndexEl.style.textAlign = 'center';
                memberIndexEl.style.fontWeight = '600';
                memberIndexEl.style.marginBottom = '8px';
                // title „ÅÆÁõ¥Âæå„Å´ÊåøÂÖ•
                if (titleEl.nextSibling) titleEl.parentNode.insertBefore(memberIndexEl, titleEl.nextSibling);
                else titleEl.parentNode.appendChild(memberIndexEl);
            }
            memberIndexEl.textContent = `ÈÉ®ÊùêÁï™Âè∑: ${selectedMemberIndex + 1}`;

            popup.style.display = 'block';
            popup.style.visibility = 'visible';
            // „Éù„ÉÉ„Éó„Ç¢„ÉÉ„ÉóË°®Á§∫ÊôÇ„Å´„ÄÅÊó¢„Å´„ÄåÂâõ„ÄçË®≠ÂÆö„Åï„Çå„Å¶„ÅÑ„Çã„ÇÇ„ÅÆ„ÅØÂÖ•Âäõ„ÇíÁÑ°ÂäπÂåñ„Åó„Å¶„Åä„Åè
            try {
                const piKx = document.getElementById('popup-i-spring-kx');
                const piKy = document.getElementById('popup-i-spring-ky');
                const piKr = document.getElementById('popup-i-spring-kr');
                const pjKx = document.getElementById('popup-j-spring-kx');
                const pjKy = document.getElementById('popup-j-spring-ky');
                const pjKr = document.getElementById('popup-j-spring-kr');
                const piRKx = document.getElementById('popup-i-spring-rigid-kx');
                const piRKy = document.getElementById('popup-i-spring-rigid-ky');
                const piRKr = document.getElementById('popup-i-spring-rigid-kr');
                const pjRKx = document.getElementById('popup-j-spring-rigid-kx');
                const pjRKy = document.getElementById('popup-j-spring-rigid-ky');
                const pjRKr = document.getElementById('popup-j-spring-rigid-kr');
                if (piKx && piRKx) piKx.disabled = !!piRKx.checked;
                if (piKy && piRKy) piKy.disabled = !!piRKy.checked;
                if (piKr && piRKr) piKr.disabled = !!piRKr.checked;
                if (pjKx && pjRKx) pjKx.disabled = !!pjRKx.checked;
                if (pjKy && pjRKy) pjKy.disabled = !!pjRKy.checked;
                if (pjKr && pjRKr) pjKr.disabled = !!pjRKr.checked;
            } catch (e) {
                console.warn('popup init disable error', e);
            }
            console.log('üì¶ ÈÉ®Êùê„Éó„É≠„Éë„ÉÜ„Ç£„Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó - Ë°®Á§∫Ë®≠ÂÆö:', {
                display: popup.style.display,
                visibility: popup.style.visibility,
                position: popup.style.position
            });
            
            // „Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó„ÅÆ„Çµ„Ç§„Ç∫„ÇíÂèñÂæóÔºà„Éá„Éï„Ç©„É´„ÉàÂÄ§„ÇíË®≠ÂÆöÔºâ
            const popupRect = popup.getBoundingClientRect();
            const popupWidth = popupRect.width || 400;  // „Éá„Éï„Ç©„É´„ÉàÂπÖ
            const popupHeight = popupRect.height || 350; // „Éá„Éï„Ç©„É´„ÉàÈ´ò„Åï
            const windowWidth = window.innerWidth;
            const windowHeight = window.innerHeight;
            const availableHeight = Math.min(windowHeight, document.documentElement.clientHeight);
            const canvasRect = elements.modelCanvas.getBoundingClientRect();
            
            // „Çπ„ÇØ„É≠„Éº„É´‰ΩçÁΩÆ„ÇíËÄÉÊÖÆ
            const scrollX = window.pageXOffset || document.documentElement.scrollLeft;
            const scrollY = window.pageYOffset || document.documentElement.scrollTop;
            
            // ÈÅ∏Êäû„Åï„Çå„ÅüÈÉ®Êùê„ÅÆ‰ΩçÁΩÆ„ÇíÂèñÂæó
            let memberBounds = null;
            if (window.selectedMemberIndex !== null && window.selectedMemberIndex >= 0) {
                try {
                    const { nodes, members } = window.parseInputs();
                    const member = members[window.selectedMemberIndex];
                    if (member && window.lastDrawingContext) {
                        const node1 = nodes[member.i];
                        const node2 = nodes[member.j];
                        if (node1 && node2) {
                            const pos1 = window.lastDrawingContext.transform(node1.x, node1.y);
                            const pos2 = window.lastDrawingContext.transform(node2.x, node2.y);
                            
                            // ÈÉ®Êùê„ÅÆÂ¢ÉÁïå„Éú„ÉÉ„ÇØ„Çπ„ÇíË®àÁÆóÔºà„Ç≠„É£„É≥„Éê„ÇπÂ∫ßÊ®ôÁ≥ªÔºâ
                            const minX = Math.min(pos1.x, pos2.x);
                            const maxX = Math.max(pos1.x, pos2.x);
                            const minY = Math.min(pos1.y, pos2.y);
                            const maxY = Math.max(pos1.y, pos2.y);
                            
                            // „Éö„Éº„Ç∏Â∫ßÊ®ôÁ≥ª„Å´Â§âÊèõ
                            memberBounds = {
                                left: canvasRect.left + minX - 50,   // „Éû„Éº„Ç∏„É≥„ÇíËøΩÂä†
                                right: canvasRect.left + maxX + 50,
                                top: canvasRect.top + minY - 50,
                                bottom: canvasRect.top + maxY + 50
                            };
                        }
                    }
                } catch (error) {
                    console.warn('ÈÉ®Êùê‰ΩçÁΩÆ„ÅÆÂèñÂæó„Å´Â§±Êïó:', error);
                }
            }
            
            let left, top;
            
            if (memberBounds) {
                // ÈÉ®Êùê„ÅÆ‰ΩçÁΩÆ„ÇíÈÅø„Åë„Å¶„Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó„ÇíÈÖçÁΩÆ
                const margin = 20;
                const minMargin = 10;
                const bottomMargin = 20; // „Çø„Çπ„ÇØ„Éê„ÉºÂØæÁ≠ñ
                
                // Âè≥ÂÅ¥„Å´ÈÖçÁΩÆ„ÇíË©¶Ë°å
                left = memberBounds.right + margin;
                if (left + popupWidth > windowWidth - minMargin) {
                    // Âè≥ÂÅ¥„Å´Âèé„Åæ„Çâ„Å™„ÅÑÂ†¥Âêà„ÅØÂ∑¶ÂÅ¥„Å´ÈÖçÁΩÆ
                    left = memberBounds.left - popupWidth - margin;
                    if (left < minMargin) {
                        // Â∑¶ÂÅ¥„Å´„ÇÇÂèé„Åæ„Çâ„Å™„ÅÑÂ†¥Âêà„ÅØ‰∏ä‰∏ã„Å´ÈÖçÁΩÆ
                        left = Math.max(minMargin, Math.min((windowWidth - popupWidth) / 2, windowWidth - popupWidth - minMargin));
                        top = memberBounds.bottom + margin;
                        if (top + popupHeight > availableHeight - bottomMargin) {
                            // ‰∏ãÂÅ¥„Å´Âèé„Åæ„Çâ„Å™„ÅÑÂ†¥Âêà„ÅØ‰∏äÂÅ¥„Å´ÈÖçÁΩÆ
                            top = memberBounds.top - popupHeight - margin;
                            if (top < minMargin) {
                                // „Å©„Åì„Å´„ÇÇÂèé„Åæ„Çâ„Å™„ÅÑÂ†¥Âêà„ÅØÁîªÈù¢‰∏≠Â§ÆÔºàÂº∑Âà∂ÁöÑ„Å´Âèé„ÇÅ„ÇãÔºâ
                                left = Math.max(minMargin, (windowWidth - popupWidth) / 2);
                                top = Math.max(minMargin, (availableHeight - popupHeight) / 2);
                                // „Ç¶„Ç£„É≥„Éâ„Ç¶„Çà„ÇäÂ§ß„Åç„ÅÑÂ†¥Âêà„ÅØË™øÊï¥
                                if (left + popupWidth > windowWidth - minMargin) {
                                    left = minMargin;
                                }
                                if (top + popupHeight > availableHeight - bottomMargin) {
                                    top = minMargin;
                                }
                            }
                        }
                    } else {
                        // Â∑¶ÂÅ¥„Å´ÈÖçÁΩÆ„Åß„Åç„ÇãÂ†¥Âêà„ÅÆÁ∏¶‰ΩçÁΩÆ
                        top = Math.max(minMargin, Math.min(memberBounds.top, availableHeight - popupHeight - bottomMargin));
                    }
                } else {
                    // Âè≥ÂÅ¥„Å´ÈÖçÁΩÆ„Åß„Åç„ÇãÂ†¥Âêà„ÅÆÁ∏¶‰ΩçÁΩÆ
                    top = Math.max(minMargin, Math.min(memberBounds.top, availableHeight - popupHeight - bottomMargin));
                }
            } else {
                // ÈÉ®Êùê„ÅÆ‰ΩçÁΩÆ„ÅåÂèñÂæó„Åß„Åç„Å™„ÅÑÂ†¥Âêà„ÅØÁîªÈù¢‰∏≠Â§Æ„Å´ÈÖçÁΩÆ
                left = Math.max(10, Math.min((windowWidth - popupWidth) / 2, windowWidth - popupWidth - 10));
                top = Math.max(10, Math.min((availableHeight - popupHeight) / 2, availableHeight - popupHeight - 20));
            }
            
            popup.style.left = `${left}px`;
            popup.style.top = `${top}px`;
            popup.style.position = 'fixed';
            popup.style.zIndex = '10000';
            
            console.log('‚úÖ ÈÉ®Êùê„Éó„É≠„Éë„ÉÜ„Ç£„Éù„ÉÉ„Éó„Ç¢„ÉÉ„ÉóË°®Á§∫ÂÆå‰∫Ü:', {
                left: popup.style.left,
                top: popup.style.top,
                display: popup.style.display,
                visibility: popup.style.visibility,
                position: popup.style.position,
                zIndex: popup.style.zIndex
            });
        } else {
            console.log('‚ùå „ÇØ„É™„ÉÉ„ÇØ‰ΩçÁΩÆ„Å´ÁØÄÁÇπ„ÉªÈÉ®Êùê„ÉªËç∑Èáç„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„Åß„Åó„Åü');
        }

        // ÈÅ∏ÊäûÁä∂ÊÖã„Çí„Éè„Ç§„É©„Ç§„ÉàË°®Á§∫„Åô„Çã„Åü„ÇÅÂÜçÊèèÁîª
        drawOnCanvas();
    });
    
    // „Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó„ÅÆ‰ΩçÁΩÆ„ÇíÂãïÁöÑ„Å´ÂÜçË™øÊï¥„Åô„ÇãÈñ¢Êï∞
    function adjustPopupPosition(popup, targetBounds = null) {
        console.log('üìê adjustPopupPositionÂëº„Å≥Âá∫„Åó:', {
            popup: popup?.id,
            display: popup?.style.display,
            targetBounds: targetBounds
        });
        
        if (!popup || popup.style.display === 'none') {
            console.log('‚ùå „Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó„ÅåÈùûË°®Á§∫„Åæ„Åü„ÅØÂ≠òÂú®„Åó„Åæ„Åõ„Çì');
            return;
        }
        
        // ÁèæÂú®„ÅÆ„Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó„Çµ„Ç§„Ç∫„ÇíÂèñÂæó
        const popupRect = popup.getBoundingClientRect();
        const popupWidth = popupRect.width;
        const popupHeight = popupRect.height;
        
        console.log('üìè „Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó„Çµ„Ç§„Ç∫:', {
            width: popupWidth,
            height: popupHeight,
            currentRect: popupRect
        });
        const windowWidth = window.innerWidth;
        
        // ÂÆüÈöõ„Å´Âà©Áî®ÂèØËÉΩ„Å™ÁîªÈù¢È´ò„Åï„ÇíÂèñÂæóÔºà„Çø„Çπ„ÇØ„Éê„Éº„Å™„Å©„ÇíÈô§„ÅèÔºâ
        const windowHeight = window.innerHeight;
        const documentHeight = document.documentElement.clientHeight;
        const availableHeight = Math.min(windowHeight, documentHeight);
        
        const minMargin = 10;
        const bottomMargin = 20; // „Çø„Çπ„ÇØ„Éê„ÉºÂØæÁ≠ñ„Åß„Çà„ÇäÂ§ß„Åç„Å™„Éû„Éº„Ç∏„É≥
        
        let left = parseInt(popup.style.left) || 0;
        let top = parseInt(popup.style.top) || 0;
        
        if (targetBounds) {
            // ÈÉ®Êùê‰ΩçÁΩÆ„ÇíÈÅø„Åë„Å¶ÂÜçÈÖçÁΩÆ
            const margin = 20;
            
            // Âè≥ÂÅ¥„Å´ÈÖçÁΩÆ„ÇíË©¶Ë°å
            left = targetBounds.right + margin;
            if (left + popupWidth > windowWidth - minMargin) {
                // Âè≥ÂÅ¥„Å´Âèé„Åæ„Çâ„Å™„ÅÑÂ†¥Âêà„ÅØÂ∑¶ÂÅ¥„Å´ÈÖçÁΩÆ
                left = targetBounds.left - popupWidth - margin;
                if (left < minMargin) {
                    // Â∑¶ÂÅ¥„Å´„ÇÇÂèé„Åæ„Çâ„Å™„ÅÑÂ†¥Âêà„ÅØ‰∏ä‰∏ã„Å´ÈÖçÁΩÆ
                    left = Math.max(minMargin, Math.min((windowWidth - popupWidth) / 2, windowWidth - popupWidth - minMargin));
                    top = targetBounds.bottom + margin;
                    if (top + popupHeight > availableHeight - bottomMargin) {
                        // ‰∏ãÂÅ¥„Å´Âèé„Åæ„Çâ„Å™„ÅÑÂ†¥Âêà„ÅØ‰∏äÂÅ¥„Å´ÈÖçÁΩÆ
                        top = targetBounds.top - popupHeight - margin;
                        if (top < minMargin) {
                            // „Å©„Åì„Å´„ÇÇÂèé„Åæ„Çâ„Å™„ÅÑÂ†¥Âêà„ÅØÁîªÈù¢‰∏≠Â§ÆÔºàÂº∑Âà∂ÁöÑ„Å´Âèé„ÇÅ„ÇãÔºâ
                            left = Math.max(minMargin, (windowWidth - popupWidth) / 2);
                            top = Math.max(minMargin, (availableHeight - popupHeight) / 2);
                        }
                    }
                } else {
                    // Â∑¶ÂÅ¥„Å´ÈÖçÁΩÆ„Åß„Åç„ÇãÂ†¥Âêà„ÅÆÁ∏¶‰ΩçÁΩÆ
                    top = Math.max(minMargin, Math.min(targetBounds.top, availableHeight - popupHeight - bottomMargin));
                }
            } else {
                // Âè≥ÂÅ¥„Å´ÈÖçÁΩÆ„Åß„Åç„ÇãÂ†¥Âêà„ÅÆÁ∏¶‰ΩçÁΩÆ
                top = Math.max(minMargin, Math.min(targetBounds.top, availableHeight - popupHeight - bottomMargin));
            }
        } else {
            // ÁîªÈù¢Â¢ÉÁïå„ÉÅ„Çß„ÉÉ„ÇØ„ÅÆ„Åø
            // Âè≥Á´Ø„ÉÅ„Çß„ÉÉ„ÇØ
            if (left + popupWidth > windowWidth - minMargin) {
                left = windowWidth - popupWidth - minMargin;
            }
            // Â∑¶Á´Ø„ÉÅ„Çß„ÉÉ„ÇØ
            if (left < minMargin) {
                left = minMargin;
            }
            // ‰∏ãÁ´Ø„ÉÅ„Çß„ÉÉ„ÇØÔºà„Çø„Çπ„ÇØ„Éê„ÉºÂØæÂøúÔºâ
            if (top + popupHeight > availableHeight - bottomMargin) {
                top = availableHeight - popupHeight - bottomMargin;
            }
            // ‰∏äÁ´Ø„ÉÅ„Çß„ÉÉ„ÇØ
            if (top < minMargin) {
                top = minMargin;
            }
        }
        
        // ÊúÄÁµÇÁöÑ„Å´ÁîªÈù¢ÂÜÖ„Å´Âº∑Âà∂ÁöÑ„Å´Âèé„ÇÅ„Çã
        left = Math.max(minMargin, Math.min(left, windowWidth - popupWidth - minMargin));
        top = Math.max(minMargin, Math.min(top, availableHeight - popupHeight - bottomMargin));
        
        console.log('‚úÖ „Éù„ÉÉ„Éó„Ç¢„ÉÉ„ÉóÊúÄÁµÇ‰ΩçÁΩÆ:', {
            left: left,
            top: top,
            windowWidth: windowWidth,
            availableHeight: availableHeight,
            popupDisplay: popup.style.display
        });
        
        // position: fixed„ÇíÊòéÁ§∫ÁöÑ„Å´Ë®≠ÂÆö
        popup.style.position = 'fixed';
        popup.style.left = `${left}px`;
        popup.style.top = `${top}px`;
        popup.style.zIndex = '10000'; // ÈùûÂ∏∏„Å´È´ò„ÅÑz-index„ÇíË®≠ÂÆö
        
        console.log('üéØ „Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó‰ΩçÁΩÆË®≠ÂÆöÂÆå‰∫Ü:', {
            styleLeft: popup.style.left,
            styleTop: popup.style.top,
            styleDisplay: popup.style.display,
            stylePosition: popup.style.position,
            styleZIndex: popup.style.zIndex,
            boundingRect: popup.getBoundingClientRect()
        });
    }
    
    // „Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó„ÅÆ„Éâ„É©„ÉÉ„Ç∞Ê©üËÉΩ„ÇíËøΩÂä†„Åô„ÇãÈñ¢Êï∞
    function makePopupDraggable(popup) {
        if (!popup) return;
        
        let isDragging = false;
        let dragOffset = { x: 0, y: 0 };
        
        // „Éò„ÉÉ„ÉÄ„ÉºÈÉ®ÂàÜ„ÇíÂèñÂæóÔºàh4„Çø„Ç∞„Åæ„Åü„ÅØ„Éù„ÉÉ„Éó„Ç¢„ÉÉ„ÉóÂÖ®‰ΩìÔºâ
        const header = popup.querySelector('h4') || popup;
        if (!header) return;
        
        // „Éò„ÉÉ„ÉÄ„Éº„Å´„Éâ„É©„ÉÉ„Ç∞ÂèØËÉΩ„Åß„ÅÇ„Çã„Åì„Å®„ÇíÁ§∫„Åô„Çπ„Çø„Ç§„É´„ÇíÈÅ©Áî®
        header.style.cursor = 'move';
        header.style.userSelect = 'none';
        
        function startDrag(e) {
            isDragging = true;
            const popupRect = popup.getBoundingClientRect();
            dragOffset.x = e.clientX - popupRect.left;
            dragOffset.y = e.clientY - popupRect.top;
            
            // „Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó„ÇíÊúÄÂâçÈù¢„Å´ÁßªÂãï„Å®„Éâ„É©„ÉÉ„Ç∞„Çπ„Çø„Ç§„É´ÈÅ©Áî®
            popup.style.zIndex = '1002';
            popup.classList.add('popup-dragging');
            
            document.addEventListener('mousemove', doDrag);
            document.addEventListener('mouseup', stopDrag);
            e.preventDefault();
        }
        
        function doDrag(e) {
            if (!isDragging) return;
            
            const windowWidth = window.innerWidth;
            const windowHeight = window.innerHeight;
            const availableHeight = Math.min(windowHeight, document.documentElement.clientHeight);
            const popupRect = popup.getBoundingClientRect();
            const minMargin = 5;
            const bottomMargin = 20;
            
            // Êñ∞„Åó„ÅÑ‰ΩçÁΩÆ„ÇíË®àÁÆó
            let newLeft = e.clientX - dragOffset.x;
            let newTop = e.clientY - dragOffset.y;
            
            // ÁîªÈù¢Â¢ÉÁïåÂÜÖ„Å´Âà∂Èôê
            newLeft = Math.max(minMargin, Math.min(newLeft, windowWidth - popupRect.width - minMargin));
            newTop = Math.max(minMargin, Math.min(newTop, availableHeight - popupRect.height - bottomMargin));
            
            popup.style.left = `${newLeft}px`;
            popup.style.top = `${newTop}px`;
        }
        
        function stopDrag() {
            if (isDragging) {
                isDragging = false;
                // z-index„ÇíÂÖÉ„Å´Êàª„Åó„Å¶„Éâ„É©„ÉÉ„Ç∞„Çπ„Çø„Ç§„É´„ÇíÂâäÈô§
                popup.style.zIndex = '1001';
                popup.classList.remove('popup-dragging');
                document.removeEventListener('mousemove', doDrag);
                document.removeEventListener('mouseup', stopDrag);
            }
        }
        
        header.addEventListener('mousedown', startDrag);
        
        // „Çø„ÉÉ„ÉÅ„Éá„Éê„Ç§„ÇπÂØæÂøú
        function startTouchDrag(e) {
            if (e.touches.length === 1) {
                const touch = e.touches[0];
                const mouseEvent = new MouseEvent('mousedown', {
                    clientX: touch.clientX,
                    clientY: touch.clientY
                });
                startDrag(mouseEvent);
            }
        }
        
        function handleTouchMove(e) {
            if (isDragging && e.touches.length === 1) {
                const touch = e.touches[0];
                const mouseEvent = new MouseEvent('mousemove', {
                    clientX: touch.clientX,
                    clientY: touch.clientY
                });
                doDrag(mouseEvent);
                e.preventDefault();
            }
        }
        
        function handleTouchEnd(e) {
            if (isDragging) {
                stopDrag();
                e.preventDefault();
            }
        }
        
        header.addEventListener('touchstart', startTouchDrag, { passive: false });
        document.addEventListener('touchmove', handleTouchMove, { passive: false });
        document.addEventListener('touchend', handleTouchEnd);
    }
    
    // ÂÖ®„Å¶„ÅÆ„Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó„Å´„Éâ„É©„ÉÉ„Ç∞Ê©üËÉΩ„ÇíÈÅ©Áî®
    if(elements.memberPropsPopup) makePopupDraggable(elements.memberPropsPopup);
    if(elements.addMemberPopup) makePopupDraggable(elements.addMemberPopup);
    if(elements.nodeLoadPopup) makePopupDraggable(elements.nodeLoadPopup);

    // ÁµêÊûúÂõ≥„ÅÆ„Ç≠„É£„É≥„Éê„Çπ„Å´„Éû„Ç¶„ÇπÊìç‰ΩúÊ©üËÉΩ„ÇíËøΩÂä†
    addResultCanvasMouseControls('displacement-canvas');
    addResultCanvasMouseControls('moment-canvas');
    addResultCanvasMouseControls('axial-canvas');
    addResultCanvasMouseControls('shear-canvas');
    addResultCanvasMouseControls('ratio-canvas');

    document.addEventListener('click', (e) => { 
        if (elements.modeAddMemberBtn && elements.modeAddMemberBtn.contains(e.target)) return;
        if(elements.memberPropsPopup && elements.addMemberPopup && !elements.memberPropsPopup.contains(e.target) && !elements.addMemberPopup.contains(e.target)) { 
            if(elements.memberPropsPopup) elements.memberPropsPopup.style.display='none'; 
            if(elements.addMemberPopup) elements.addMemberPopup.style.display='none'; 
        }
        if(elements.nodeLoadPopup && !elements.nodeLoadPopup.contains(e.target)) elements.nodeLoadPopup.style.display='none';
        if(elements.nodeCoordsPopup && !elements.nodeCoordsPopup.contains(e.target)) elements.nodeCoordsPopup.style.display='none';
        if(elements.nodeContextMenu && !elements.nodeContextMenu.contains(e.target)) elements.nodeContextMenu.style.display='none';
    });

    elements.nodeContextMenu.addEventListener('click', (e) => {
        e.stopPropagation();
        const target = e.target;
        if (selectedNodeIndex === null) return;

        if (target.id === 'menu-edit-node-props') {
            openNodeEditor(selectedNodeIndex);
        } else if (target.id === 'menu-delete-node') {
            elements.nodesTable.rows[selectedNodeIndex].querySelector('.delete-row-btn').click();
        }
        elements.nodeContextMenu.style.display = 'none';
    });

    document.getElementById('popup-select-section').onclick = () => {
    if (selectedMemberIndex !== null && selectedMemberIndex >= 0) {
        // „Éù„ÉÉ„Éó„Ç¢„ÉÉ„ÉóÂÜÖ„ÅÆÊÉÖÂ†±„Åã„ÇâÊùêÊñôÊÉÖÂ†±„ÇíÂèñÂæó
        const popup_e_select = document.getElementById('popup-e-select');
        const selectedOption = popup_e_select.options[popup_e_select.selectedIndex];
        let materialType = 'steel';
        if (selectedOption.textContent.includes('Êú®Êùê')) materialType = 'wood';
        else if (selectedOption.textContent.includes('„Ç≥„É≥„ÇØ„É™„Éº„Éà')) materialType = 'concrete';
        else if (selectedOption.textContent.includes('„Çπ„ÉÜ„É≥„É¨„Çπ')) materialType = 'stainless';
        else if (selectedOption.textContent.includes('„Ç¢„É´„Éü„Éã„Ç¶„É†')) materialType = 'aluminum';
        
        const strengthContainer = document.getElementById('popup-f-container').firstElementChild;
        let strengthValue = '';
        if (strengthContainer.querySelector('input')) strengthValue = strengthContainer.querySelector('input').value;
        if (strengthContainer.querySelector('select')) strengthValue = strengthContainer.querySelector('select').value;

        openSteelSelector(selectedMemberIndex, {
            material: materialType,
            E: popup_e_select.value === 'custom' ? document.getElementById('popup-e-input').value : popup_e_select.value,
            strengthValue: strengthValue
        });
        // „Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó„ÅØÈñâ„Åò„Åö„Å´„Åù„ÅÆ„Åæ„ÅæÈñã„ÅÑ„Å¶„Åä„Åè
        // elements.memberPropsPopup.style.display = 'none';
    }
};

    document.getElementById('popup-save').onclick = () => {
        if (selectedMemberIndex === null) return;
        pushState();
        const memberRow = elements.membersTable.rows[selectedMemberIndex];

        // 1. „Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó„Åã„ÇâE‰øÇÊï∞„ÅÆÂÄ§„ÇíÂèñÂæó„Åó„ÄÅ„ÉÜ„Éº„Éñ„É´„Å´ÂèçÊò†
        const popup_e_select = document.getElementById('popup-e-select');
        const popup_e_input = document.getElementById('popup-e-input');
        const newEValue = popup_e_select.value === 'custom' ? popup_e_input.value : popup_e_select.value;
        
        const table_e_select = memberRow.cells[3].querySelector('select');
        const table_e_input = memberRow.cells[3].querySelector('input[type="number"]');
        
        const matching_option = Array.from(table_e_select.options).find(opt => opt.value === newEValue);
        if (matching_option) {
            table_e_select.value = newEValue;
        } else {
            table_e_select.value = 'custom';
        }
        table_e_input.value = newEValue;
        table_e_input.readOnly = (table_e_select.value !== 'custom');
        
        // 2. E‰øÇÊï∞„ÅÆÂ§âÊõ¥„Ç§„Éô„É≥„Éà„ÇíÁô∫ÁÅ´„Åï„Åõ„ÄÅÂü∫Ê∫ñÂº∑Â∫¶UI„ÇíÊ≠£„Åó„ÅèÂÜçÁîüÊàê„Åï„Åõ„Çã
        table_e_select.dispatchEvent(new Event('change'));

        // 3. „Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó„ÅÆÂü∫Ê∫ñÂº∑Â∫¶UI„ÅÆÁä∂ÊÖã„Çí„ÄÅ„ÉÜ„Éº„Éñ„É´„Å´„Ç≥„Éî„Éº„Åô„Çã
        const popupStrengthContainer = document.getElementById('popup-f-container').firstElementChild;
        const tableStrengthContainer = memberRow.cells[4].firstElementChild; // ÂÜçÁîüÊàê„Åï„Çå„ÅüÊúÄÊñ∞„ÅÆUI
        if (!popupStrengthContainer) {
            console.error('„Éù„ÉÉ„Éó„Ç¢„ÉÉ„ÉóÂº∑Â∫¶„Ç≥„É≥„ÉÜ„Éä„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì');
            return;
        }
        const strengthType = popupStrengthContainer.dataset.strengthType;

        if (strengthType === 'wood-type') {
            const popupPresetSelect = popupStrengthContainer.querySelector('select');
            const tablePresetSelect = tableStrengthContainer.querySelector('select');
            tablePresetSelect.value = popupPresetSelect.value;
            tablePresetSelect.dispatchEvent(new Event('change')); // UI„ÅÆÁä∂ÊÖãÔºàreadonly„Å™„Å©Ôºâ„ÇíÊõ¥Êñ∞
            
            if (popupPresetSelect.value === 'custom') {
                ['ft', 'fc', 'fb', 'fs'].forEach(key => {
                    const popupInput = popupStrengthContainer.querySelector(`input[id*="-${key}"]`);
                    const tableInput = tableStrengthContainer.querySelector(`input[id*="-${key}"]`);
                    if(popupInput && tableInput) tableInput.value = popupInput.value;
                });
            }
        } else { // ÈãºÊùê„Å™„Å©„ÅÆÂ†¥Âêà
            const popupSelect = popupStrengthContainer.querySelector('select');
            const popupInput = popupStrengthContainer.querySelector('input');
            const tableSelect = tableStrengthContainer.querySelector('select');
            const tableInput = tableStrengthContainer.querySelector('input');
            if(popupSelect && tableSelect) tableSelect.value = popupSelect.value;
            if(popupInput && tableInput) {
                tableInput.value = popupInput.value;
                tableInput.readOnly = popupInput.readOnly;
            }
        }

        // 4. „Åù„ÅÆ‰ªñ„ÅÆ„Éó„É≠„Éë„ÉÜ„Ç£„ÇíÊõ¥Êñ∞
        // „ÉÜ„Éº„Éñ„É´Âàó: 0:'#',1:i(ÂßãÁÇπ),2:j(ÁµÇÁÇπ),3:E,4:strength,5:I,6:A,7:Z
        // „Äê‰øÆÊ≠£„ÄëI „ÅØÂßãÁÇπ„Çª„É´(cells[1])„Åß„ÅØ„Å™„Åè cells[5] „Å´‰øùÂ≠ò„Åô„Çã
        if (memberRow.cells[5]) memberRow.cells[5].querySelector('.section-I-input').value = document.getElementById('popup-i').value;
        if (memberRow.cells[6]) memberRow.cells[6].querySelector('.section-A-input').value = document.getElementById('popup-a').value;
        if (memberRow.cells[7]) memberRow.cells[7].querySelector('.section-Z-input').value = document.getElementById('popup-z').value;

        // ‚ñº‚ñº‚ñº Â§âÊõ¥: popup „ÅÆÂçò‰∏Ä i ÂÖ•Âäõ„Çí dataset „ÅÆ ix/iy „Å´Ê†ºÁ¥çÔºàÁ©∫Ê¨Ñ„Å™„ÇâÂâäÈô§Ôºâ
        try {
            const newI = document.getElementById('popup-radius-i')?.value;
            if (newI && !isNaN(parseFloat(newI))) {
                // dataset „ÅØ cm Âçò‰Ωç„Åß‰øùÊåÅÔºàÊó¢Â≠ò„Ç≥„Éº„Éâ„Å®„ÅÆ‰∫íÊèõÊÄß„ÅÆ„Åü„ÇÅÔºâ
                memberRow.dataset.ix = newI;
                memberRow.dataset.iy = newI;
            } else {
                delete memberRow.dataset.ix;
                delete memberRow.dataset.iy;
            }
        } catch (e) {
            console.warn('popup i save error', e);
        }
        // ‚ñ≤‚ñ≤‚ñ≤ ËøΩÂä†ÁµÇ‰∫Ü

        // ‚ñº‚ñº‚ñº ËøΩÂä†: „Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó„ÅÆÂ∫ßÂ±à‰øÇÊï∞„Çí„ÉÜ„Éº„Éñ„É´„ÅÆ K Âàó„Å´‰øùÂ≠ò ‚ñº‚ñº‚ñº
        try {
            const popupK = document.getElementById('popup-buckling-k')?.value || '';
            const kInputEl = memberRow.querySelector('.buckling-k-input');
            if (kInputEl) {
                kInputEl.value = popupK;
            }
            // dataset„Å´„ÇÇ‰øùÊåÅ
            if (popupK !== '') memberRow.dataset.bucklingK = popupK; else delete memberRow.dataset.bucklingK;
        } catch (e) {
            console.warn('„Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó„Åã„Çâ„ÉÜ„Éº„Éñ„É´„Å∏Â∫ßÂ±à‰øÇÊï∞K„Çí‰øùÂ≠ò‰∏≠„Å´„Ç®„É©„Éº', e);
        }
        // ‚ñ≤‚ñ≤‚ñ≤ ËøΩÂä†ÁµÇ‰∫Ü ‚ñ≤‚ñ≤‚ñ≤

        // ÂØÜÂ∫¶„ÅÆ‰øùÂ≠òÂá¶ÁêÜ
        const hasDensityColumn = document.querySelector('.density-column') && document.querySelector('.density-column').style.display !== 'none';
        if (hasDensityColumn) {
            const popupDensitySelect = document.getElementById('popup-density-select');
            const popupDensityInput = document.getElementById('popup-density-input');
            
            if (popupDensitySelect && popupDensityInput) {
                const densityCell = memberRow.cells[8]; // ÂØÜÂ∫¶„ÅØ8Áï™ÁõÆ„ÅÆ„Çª„É´
                if (densityCell && densityCell.classList.contains('density-cell')) {
                    const tableDensitySelect = densityCell.querySelector('select');
                    const tableDensityInput = densityCell.querySelector('input[type="number"]');
                    
                    if (tableDensitySelect && tableDensityInput) {
                        tableDensitySelect.value = popupDensitySelect.value;
                        tableDensityInput.value = popupDensityInput.value;
                        tableDensityInput.readOnly = (popupDensitySelect.value !== 'custom');
                    }
                }
            }
        }
        
        // Êé•Âêà„Çª„É¨„ÇØ„Éà„ÅØ„ÉÜ„Éº„Éñ„É´Ë°åÂÜÖ„ÅÆ class="conn-select" „ÅßÁâπÂÆö„Åô„ÇãÔºà„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ„Å´‰æùÂ≠ò„Åó„Å™„ÅÑÔºâ
        const connSelects = Array.from(memberRow.querySelectorAll('.conn-select'));
        const tableIConnSelect = connSelects[0] || null;
        const tableJConnSelect = connSelects[1] || null;

        if (tableIConnSelect) {
            const popupIVal = document.getElementById('popup-i-conn')?.value;
            if (popupIVal !== undefined) {
                tableIConnSelect.value = popupIVal;
                tableIConnSelect.dispatchEvent(new Event('change'));
            }
        }
        if (tableJConnSelect) {
            const popupJVal = document.getElementById('popup-j-conn')?.value;
            if (popupJVal !== undefined) {
                tableJConnSelect.value = popupJVal;
                tableJConnSelect.dispatchEvent(new Event('change'));
            }
        }

        // „Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó„ÅÆ„Éê„ÉçÂÖ•Âäõ„Çí„ÉÜ„Éº„Éñ„É´Ë°å„ÅÆspring-inputs„Å∏ÂèçÊò†Ôºàconn „Çª„É´Âçò‰Ωç„ÅßÊé¢„ÅôÔºâ
        try {
            const applyPopupToConnCell = (connSelectEl, prefix) => {
                if (!connSelectEl) return;
                // conn-select „ÅÆÁõ¥Ëøë„ÅÆ .conn-cell „ÇíÊé¢„ÅôÔºà„ÉÜ„É≥„Éó„É¨„Éº„Éà„Å´„Çà„Å£„Å¶ÊßãÈÄ†„ÅåÁï∞„Å™„ÇãÂèØËÉΩÊÄß„Å´ÂØæÂøúÔºâ
                const connCell = connSelectEl.closest('.conn-cell') || connSelectEl.parentElement;
                const rowSpringBox = connCell ? connCell.querySelector('.spring-inputs') : null;
                if (!rowSpringBox) return;
                const rowKx = rowSpringBox.querySelector('.spring-kx');
                const rowKy = rowSpringBox.querySelector('.spring-ky');
                const rowKr = rowSpringBox.querySelector('.spring-kr');
                const popupKx = document.getElementById(`${prefix}-spring-kx`);
                const popupKy = document.getElementById(`${prefix}-spring-ky`);
                const popupKr = document.getElementById(`${prefix}-spring-kr`);
                // „Ç≥„Éî„ÉºÂâç„Å´Ë°®Á§∫Áä∂ÊÖã„ÇíÊòéÁ§∫ÁöÑ„Å´Êõ¥Êñ∞Ôºà„Éù„ÉÉ„Éó„Ç¢„ÉÉ„ÉóÂÅ¥„ÅÆ select „Åå 'spring' „ÅÆ„Å®„ÅçÔºâ
                const popupConnSelect = document.getElementById(prefix === 'popup-i' ? 'popup-i-conn' : 'popup-j-conn');
                if (popupConnSelect) {
                    if (popupConnSelect.value === 'spring') {
                        rowSpringBox.style.display = '';
                    } else {
                        rowSpringBox.style.display = 'none';
                    }
                }
                if (popupKx && rowKx) rowKx.value = popupKx.value || '0';
                if (popupKy && rowKy) rowKy.value = popupKy.value || '0';
                if (popupKr && rowKr) rowKr.value = popupKr.value || '0';
                // Ââõ„Éï„É©„Ç∞„ÇíÂèçÊò†
                const popupRKx = document.getElementById(`${prefix}-spring-rigid-kx`);
                const popupRKy = document.getElementById(`${prefix}-spring-rigid-ky`);
                const popupRKr = document.getElementById(`${prefix}-spring-rigid-kr`);
                const rowRKx = rowSpringBox ? rowSpringBox.querySelector('.spring-rigid-kx') : null;
                const rowRKy = rowSpringBox ? rowSpringBox.querySelector('.spring-rigid-ky') : null;
                const rowRKr = rowSpringBox ? rowSpringBox.querySelector('.spring-rigid-kr') : null;
                if (popupRKx && rowRKx) {
                    rowRKx.checked = !!popupRKx.checked;
                    // disable input if checked
                    if (rowKx) rowKx.disabled = rowRKx.checked;
                    rowRKx.dispatchEvent(new Event('change'));
                }
                if (popupRKy && rowRKy) {
                    rowRKy.checked = !!popupRKy.checked;
                    if (rowKy) rowKy.disabled = rowRKy.checked;
                    rowRKy.dispatchEvent(new Event('change'));
                }
                if (popupRKr && rowRKr) {
                    rowRKr.checked = !!popupRKr.checked;
                    if (rowKr) rowKr.disabled = rowRKr.checked;
                    rowRKr.dispatchEvent(new Event('change'));
                }
                // ÂÖ•ÂäõÂÄ§„ÇíÊõ∏„ÅçÊèõ„Åà„Åü„Åì„Å®„ÇíÂÖ•Âäõ„Ç§„Éô„É≥„Éà„Åß‰ºù„Åà„Å¶„Åä„ÅèÔºàUI„ÇÑparseÊôÇ„ÅÆË¶≥Ê∏¨„ÅÆ„Åü„ÇÅÔºâ
                if (rowKx) rowKx.dispatchEvent(new Event('input'));
                if (rowKy) rowKy.dispatchEvent(new Event('input'));
                if (rowKr) rowKr.dispatchEvent(new Event('input'));
            };

            applyPopupToConnCell(tableIConnSelect, 'popup-i');
            applyPopupToConnCell(tableJConnSelect, 'popup-j');
        } catch (e) {
            console.warn('popup->row spring apply error', e);
        }
        const wValue = parseFloat(document.getElementById('popup-w').value) || 0;
        const memberLoadRow = Array.from(elements.memberLoadsTable.rows).find(row => parseInt(row.cells[0].querySelector('input').value) - 1 === selectedMemberIndex);
        if (wValue !== 0) {
            if (memberLoadRow) {
                memberLoadRow.cells[1].querySelector('input').value = wValue;
            } else {
                addRow(elements.memberLoadsTable, [`<input type="number" value="${selectedMemberIndex + 1}">`, `<input type="number" value="${wValue}">`]);
            }
        } else if (memberLoadRow) {
            memberLoadRow.querySelector('.delete-row-btn').click();
        }
        // Â∫ßÂ±àÈï∑„Åï‰øÇÊï∞ K „ÅÆ‰øùÂ≠òÔºàÁ©∫Ê¨Ñ„Å™„Çâ dataset „Åã„ÇâÂâäÈô§Ôºâ
        try {
            const popupBucklingK = document.getElementById('popup-buckling-k');
            if (popupBucklingK) {
                const kVal = popupBucklingK.value;
                if (kVal !== '' && !isNaN(parseFloat(kVal))) {
                    memberRow.dataset.bucklingK = kVal;
                } else {
                    delete memberRow.dataset.bucklingK;
                }
            }
        } catch (e) {
            console.warn('popup save: buckling K save error', e);
        }
        elements.memberPropsPopup.style.display = 'none';
        runFullAnalysis();
        drawOnCanvas();
    };
    document.getElementById('popup-cancel').onclick = () => { elements.memberPropsPopup.style.display = 'none'; };
    document.getElementById('popup-delete-member').onclick = () => { if(selectedMemberIndex !== null) { elements.membersTable.rows[selectedMemberIndex].querySelector('.delete-row-btn').click(); elements.memberPropsPopup.style.display='none'; } };

    // ÁØÄÁÇπ„Éó„É≠„Éë„ÉÜ„Ç£Á∑®ÈõÜ„Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó„ÇíÈñã„Åç„ÄÅ„Éá„Éº„Çø„ÇíË®≠ÂÆö„Åô„ÇãÈñ¢Êï∞
    const openNodeEditor = (nodeIndex) => {
        selectedNodeIndex = nodeIndex;
        window.selectedNodeIndex = nodeIndex;

        const nodeRow = elements.nodesTable.rows[nodeIndex];
        
        // ÁØÄÁÇπ„ÉÜ„Éº„Éñ„É´„ÅÆË°å„ÅåÂ≠òÂú®„Åó„Å™„ÅÑÂ†¥Âêà„ÅÆ„Ç®„É©„Éº„Éè„É≥„Éâ„É™„É≥„Ç∞
        if (!nodeRow) {
            console.error('‚ùå ÁØÄÁÇπ„ÉÜ„Éº„Éñ„É´„ÅÆË°å„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì:', nodeIndex);
            alert(`ÁØÄÁÇπ ${nodeIndex + 1} „ÅÆ„ÉÜ„Éº„Éñ„É´Ë°å„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„ÄÇ`);
            return;
        }

        const loadRow = Array.from(elements.nodeLoadsTable.rows).find(row => {
            const input = row.cells[0]?.querySelector('input');
            return input && parseInt(input.value) - 1 === nodeIndex;
        });

        // ÂêÑÂÖ•Âäõ„Éï„Ç£„Éº„É´„Éâ„Å´ÁèæÂú®„ÅÆÂÄ§„ÇíË®≠ÂÆöÔºànull„ÉÅ„Çß„ÉÉ„ÇØ‰ªò„ÅçÔºâ
        const xInput = nodeRow.cells[1]?.querySelector('input');
        const yInput = nodeRow.cells[2]?.querySelector('input');
        const supportSelect = nodeRow.cells[3]?.querySelector('select');
        const dxInput = nodeRow.cells[4]?.querySelector('input');
        const dyInput = nodeRow.cells[5]?.querySelector('input');
        const drInput = nodeRow.cells[6]?.querySelector('input');

        document.getElementById('popup-x').value = xInput ? xInput.value : '0';
        document.getElementById('popup-y').value = yInput ? yInput.value : '0';
        document.getElementById('popup-support').value = supportSelect ? supportSelect.value : 'free';
        document.getElementById('popup-dx').value = dxInput ? dxInput.value : '0';
        document.getElementById('popup-dy').value = dyInput ? dyInput.value : '0';
        document.getElementById('popup-dr').value = drInput ? drInput.value : '0';

        // Ëç∑Èáç„Éá„Éº„Çø„ÅÆË®≠ÂÆöÔºànull„ÉÅ„Çß„ÉÉ„ÇØ‰ªò„ÅçÔºâ
        const pxInput = loadRow?.cells[1]?.querySelector('input');
        const pyInput = loadRow?.cells[2]?.querySelector('input');
        const mzInput = loadRow?.cells[3]?.querySelector('input');
        
        document.getElementById('popup-px').value = pxInput ? pxInput.value : '0';
        document.getElementById('popup-py').value = pyInput ? pyInput.value : '0';
        document.getElementById('popup-mz').value = mzInput ? mzInput.value : '0';
        
        const popup = elements.nodePropsPopup;
        if (!popup) {
            console.error('‚ùå nodePropsPopup Ë¶ÅÁ¥†„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì');
            return;
        }
        
        let titleEl = document.getElementById('node-props-popup-title');
        if (!titleEl) {
            titleEl = document.createElement('h2');
            titleEl.id = 'node-props-popup-title';
            titleEl.style.textAlign = 'center';
            titleEl.style.marginTop = '0';
            popup.prepend(titleEl);
        }
        // ‰∏äÈÉ®„ÅÆÂ§ß„Åç„Å™„Çø„Ç§„Éà„É´„ÅØ‰∏çË¶Å„Å®„ÅÆ„Åì„Å®„Å™„ÅÆ„ÅßÈùûË°®Á§∫„Å´„Åô„Çã
        titleEl.style.display = 'none';

        // ÁØÄÁÇπÁï™Âè∑Ë°®Á§∫Ôºà„Éù„ÉÉ„Éó„Ç¢„ÉÉ„ÉóÂÜÖÁõÆÁ´ã„Å§‰ΩçÁΩÆ„Å´Ë°®Á§∫Ôºâ
        let nodeIndexEl = document.getElementById('node-props-popup-index');
        if (!nodeIndexEl) {
            nodeIndexEl = document.createElement('div');
            nodeIndexEl.id = 'node-props-popup-index';
            nodeIndexEl.style.textAlign = 'center';
            nodeIndexEl.style.fontWeight = '600';
            nodeIndexEl.style.marginBottom = '8px';
            if (titleEl.nextSibling) titleEl.parentNode.insertBefore(nodeIndexEl, titleEl.nextSibling);
            else titleEl.parentNode.appendChild(nodeIndexEl);
        }
        nodeIndexEl.textContent = `ÁØÄÁÇπÁï™Âè∑: ${nodeIndex + 1}`;

        popup.style.display = 'block';
        popup.style.visibility = 'visible';

        // „Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó„ÇíÁîªÈù¢‰∏≠Â§Æ„Å´ÈÖçÁΩÆ
        const popupRect = popup.getBoundingClientRect();
        popup.style.left = `${(window.innerWidth - popupRect.width) / 2}px`;
        popup.style.top = `${(window.innerHeight - popupRect.height) / 2}px`;
        popup.style.position = 'fixed';
        popup.style.zIndex = '10000';
        
        console.log('‚úÖ ÁØÄÁÇπ„Éó„É≠„Éë„ÉÜ„Ç£„Éù„ÉÉ„Éó„Ç¢„ÉÉ„ÉóË°®Á§∫ÂÆå‰∫Ü:', {
            nodeIndex: selectedNodeIndex + 1,
            display: popup.style.display,
            visibility: popup.style.visibility
        });
    };

    // Êñ∞„Åó„ÅÑÁØÄÁÇπ„Éó„É≠„Éë„ÉÜ„Ç£„Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó„ÅÆ‰øùÂ≠ò„Éú„Çø„É≥„ÅÆÂá¶ÁêÜ
    document.getElementById('popup-node-props-save').onclick = () => {
        if (selectedNodeIndex === null) return;
        pushState();
        
        // ÁØÄÁÇπ„ÉÜ„Éº„Éñ„É´„ÅÆÂÄ§„ÇíÊõ¥Êñ∞
        const nodeRow = elements.nodesTable.rows[selectedNodeIndex];
        nodeRow.cells[1].querySelector('input').value = document.getElementById('popup-x').value;
        nodeRow.cells[2].querySelector('input').value = document.getElementById('popup-y').value;
        nodeRow.cells[3].querySelector('select').value = document.getElementById('popup-support').value;
        nodeRow.cells[4].querySelector('input').value = document.getElementById('popup-dx').value;
        nodeRow.cells[5].querySelector('input').value = document.getElementById('popup-dy').value;
        nodeRow.cells[6].querySelector('input').value = document.getElementById('popup-dr').value;

        // ÁØÄÁÇπËç∑Èáç„ÉÜ„Éº„Éñ„É´„ÅÆÂÄ§„ÇíÊõ¥Êñ∞„Åæ„Åü„ÅØ‰ΩúÊàê/ÂâäÈô§
        const px = document.getElementById('popup-px').value || 0;
        const py = document.getElementById('popup-py').value || 0;
        const mz = document.getElementById('popup-mz').value || 0;

        let loadRow = Array.from(elements.nodeLoadsTable.rows).find(row => parseInt(row.cells[0].querySelector('input').value) - 1 === selectedNodeIndex);

        if (parseFloat(px) === 0 && parseFloat(py) === 0 && parseFloat(mz) === 0) {
            if (loadRow) loadRow.remove(); // ÂÖ®„Å¶„ÅÆËç∑Èáç„Åå0„Å™„ÇâË°å„ÇíÂâäÈô§
        } else {
            if (loadRow) { // Êó¢Â≠ò„ÅÆË°å„Åå„ÅÇ„Çå„Å∞Êõ¥Êñ∞
                loadRow.cells[1].querySelector('input').value = px;
                loadRow.cells[2].querySelector('input').value = py;
                loadRow.cells[3].querySelector('input').value = mz;
            } else { // „Å™„Åë„Çå„Å∞Êñ∞Ë¶è‰ΩúÊàê
                addRow(elements.nodeLoadsTable, [`<input type="number" value="${selectedNodeIndex + 1}">`, `<input type="number" value="${px}">`, `<input type="number" value="${py}">`, `<input type="number" value="${mz}">`]);
            }
        }
        
        elements.nodePropsPopup.style.display = 'none';
        runFullAnalysis();
        drawOnCanvas();
    };

    // Êñ∞„Åó„ÅÑÁØÄÁÇπ„Éó„É≠„Éë„ÉÜ„Ç£„Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó„ÅÆ„Ç≠„É£„É≥„Çª„É´„Éú„Çø„É≥„ÅÆÂá¶ÁêÜ
    document.getElementById('popup-node-props-cancel').onclick = () => {
        elements.nodePropsPopup.style.display = 'none';
    };

    // ÁØÄÁÇπÂâäÈô§„Éú„Çø„É≥„ÅÆÂá¶ÁêÜ
    document.getElementById('popup-delete-node').onclick = () => {
        if (selectedNodeIndex === null) return;
        
        // Á¢∫Ë™ç„ÉÄ„Ç§„Ç¢„É≠„Ç∞„ÇíË°®Á§∫
        if (confirm(`ÁØÄÁÇπ ${selectedNodeIndex + 1} „ÇíÂâäÈô§„Åó„Åæ„Åô„ÅãÔºü\n„Åì„ÅÆÁØÄÁÇπ„Å´Êé•Á∂ö„Åï„Çå„Å¶„ÅÑ„ÇãÈÉ®Êùê„ÇÇÂâäÈô§„Åï„Çå„Åæ„Åô„ÄÇ`)) {
            // ÁØÄÁÇπ„ÉÜ„Éº„Éñ„É´„ÅÆË°å„Å®ÂâäÈô§„Éú„Çø„É≥„ÅÆÂ≠òÂú®Á¢∫Ë™ç
            const nodeRow = elements.nodesTable.rows[selectedNodeIndex];
            const deleteBtn = nodeRow?.querySelector('.delete-row-btn');
            
            if (deleteBtn) {
                // ÁØÄÁÇπ„ÉÜ„Éº„Éñ„É´„ÅÆÂâäÈô§„Éú„Çø„É≥„Çí„ÇØ„É™„ÉÉ„ÇØÔºàÊó¢Â≠ò„ÅÆÂâäÈô§Âá¶ÁêÜ„ÇíÂà©Áî®Ôºâ
                deleteBtn.click();
            } else {
                console.error('‚ùå ÂâäÈô§„Éú„Çø„É≥„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì:', selectedNodeIndex);
                alert('ÂâäÈô§„Éú„Çø„É≥„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„ÄÇ„ÉÜ„Éº„Éñ„É´„Åã„ÇâÁõ¥Êé•ÂâäÈô§„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ');
            }
            
            // „Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó„ÇíÈñâ„Åò„Çã
            elements.nodePropsPopup.style.display = 'none';
            
            // ÈÅ∏ÊäûÁä∂ÊÖã„Çí„É™„Çª„ÉÉ„Éà
            selectedNodeIndex = null;
            window.selectedNodeIndex = null;
        }
    };

    document.getElementById('help-select').onclick = () => alert('„ÄêÈÅ∏Êäû/ÁßªÂãï„É¢„Éº„Éâ„Äë\n„ÉªÁØÄÁÇπ„Çí„ÇØ„É™„ÉÉ„ÇØÔºÜ„Éâ„É©„ÉÉ„Ç∞„Åó„Å¶ÁßªÂãï„Åó„Åæ„Åô„ÄÇ\n„ÉªÁØÄÁÇπ„ÄÅÈÉ®Êùê„ÄÅËç∑Èáç„ÇíÂè≥„ÇØ„É™„ÉÉ„ÇØ„Åô„Çã„Å®„ÄÅÁ∑®ÈõÜ„É°„Éã„É•„Éº„ÅåË°®Á§∫„Åï„Çå„Åæ„Åô„ÄÇ\n„ÉªShift„Ç≠„Éº„ÇíÊäº„Åó„Å™„Åå„ÇâÁ©∫ÁôΩÈÉ®ÂàÜ„Çí„Éâ„É©„ÉÉ„Ç∞„Åô„Çã„Å®Áü©ÂΩ¢ÁØÑÂõ≤„ÅßÁØÄÁÇπ„Åæ„Åü„ÅØÈÉ®Êùê„ÇíËøΩÂä†/Ëß£Èô§ÈÅ∏Êäû„Åß„Åç„Åæ„Åô„ÄÇ\n„ÉªCtrlÔºà‚åòÔºâ„Ç≠„Éº„ÇíÊäº„Åó„Å™„Åå„ÇâÁ©∫ÁôΩÈÉ®ÂàÜ„Çí„Éâ„É©„ÉÉ„Ç∞„Åô„Çã„Å®ÁØÑÂõ≤ÈÅ∏Êäû„Çí„ÇÑ„ÇäÁõ¥„Åõ„Åæ„Åô„ÄÇ\n„ÉªÁü©ÂΩ¢ÂÜÖ„Å´ÁØÄÁÇπ„Å®ÈÉ®Êùê„ÅåÊ∑∑Âú®„Åô„ÇãÂ†¥Âêà„ÅØ„ÄÅËß£Èô§Âæå„Å´„Å©„Å°„Çâ„ÇíÈÅ∏Êäû„Åô„Çã„Åã„ÅÆ„É°„Éã„É•„Éº„ÅåË°®Á§∫„Åï„Çå„Åæ„Åô„ÄÇ\n\n‚ñ†Ë§áÊï∞ÈÅ∏ÊäûÊ©üËÉΩÔºö\n„ÉªShift„Ç≠„Éº„ÇíÊäº„Åó„Å™„Åå„ÇâÁØÄÁÇπ„ÇÑÈÉ®Êùê„Çí„ÇØ„É™„ÉÉ„ÇØ„Åô„Çã„Å®Ë§áÊï∞ÈÅ∏Êäû„Åß„Åç„Åæ„Åô„ÄÇ\n„ÉªÈÅ∏Êäû„Åï„Çå„ÅüË¶ÅÁ¥†„ÅØËµ§Ëâ≤„ÅßÂº∑Ë™øË°®Á§∫„Åï„Çå„Åæ„Åô„ÄÇ\n„ÉªEscape„Ç≠„Éº„ÅßÈÅ∏Êäû„Çí„ÇØ„É™„Ç¢„Åß„Åç„Åæ„Åô„ÄÇ\n„ÉªÈÅ∏Êäû‰∏≠„ÅÆË¶ÅÁ¥†„ÅØ‰∏ÄÊã¨Á∑®ÈõÜ„ÅåÂèØËÉΩ„Åß„Åô„ÄÇ');
    document.getElementById('help-add-node').onclick = () => alert('„ÄêÁØÄÁÇπËøΩÂä†„É¢„Éº„Éâ„Äë\n„Éª„Ç≠„É£„É≥„Éê„Çπ‰∏ä„ÅÆÂ•Ω„Åç„Å™‰ΩçÁΩÆ„Çí„ÇØ„É™„ÉÉ„ÇØ„Åô„Çã„Å®„ÄÅÊñ∞„Åó„ÅÑÁØÄÁÇπ„ÅåËøΩÂä†„Åï„Çå„Åæ„Åô„ÄÇ\n„Éª„Ç∞„É™„ÉÉ„ÉâË°®Á§∫ÊôÇ„ÄÅ‰∫§ÁÇπËøë„Åè„Çí„ÇØ„É™„ÉÉ„ÇØ„Åô„Çã„Å®Ëá™Âãï„Åß‰∫§ÁÇπ‰∏ä„Å´ÈÖçÁΩÆ„Åï„Çå„Åæ„Åô„ÄÇ\n„ÉªÊó¢Â≠ò„ÅÆÈÉ®Êùê‰∏ä„Çí„ÇØ„É™„ÉÉ„ÇØ„Åô„Çã„Å®„ÄÅ„Åù„ÅÆÈÉ®Êùê„Çí2„Å§„Å´ÂàÜÂâ≤„Åô„ÇãÂΩ¢„ÅßÁØÄÁÇπ„ÅåËøΩÂä†„Åï„Çå„Åæ„Åô„ÄÇ');
    document.getElementById('help-add-member').onclick = () => alert('„ÄêÈÉ®ÊùêËøΩÂä†„É¢„Éº„Éâ„Äë\nÂßãÁÇπ„Å®„Å™„ÇãÁØÄÁÇπ„Çí„ÇØ„É™„ÉÉ„ÇØ„Åó„ÄÅÊ¨°„Å´ÁµÇÁÇπ„Å®„Å™„ÇãÁØÄÁÇπ„Çí„ÇØ„É™„ÉÉ„ÇØ„Åô„Çã„Å®„ÄÅ2„Å§„ÅÆÁØÄÁÇπ„ÇíÁµê„Å∂ÈÉ®Êùê„ÅåËøΩÂä†„Åï„Çå„Åæ„Åô„ÄÇ');

    // „Ç≠„Éº„Éú„Éº„Éâ„Ç∑„Éß„Éº„Éà„Ç´„ÉÉ„ÉàÊ©üËÉΩ„Å®„Ç§„Éô„É≥„Éà„É™„Çπ„Éä„ÉºÔºàË§áÊï∞ÈÅ∏ÊäûÊ©üËÉΩÔºâ
    document.addEventListener('keydown', (e) => {
        // ÂÖ•Âäõ„Éï„Ç£„Éº„É´„Éâ„Åå„Ç¢„ÇØ„ÉÜ„Ç£„Éñ„Å™Â†¥Âêà„ÅØ„Ç∑„Éß„Éº„Éà„Ç´„ÉÉ„Éà„Çí„Çπ„Ç≠„ÉÉ„ÉóÔºàDelete/Backspace„Å®Ctrl+Z‰ª•Â§ñÔºâ
        const isInputActive = document.activeElement && 
            (document.activeElement.tagName === 'INPUT' || 
             document.activeElement.tagName === 'TEXTAREA' || 
             document.activeElement.tagName === 'SELECT' ||
             document.activeElement.isContentEditable);

        // Shift„Ç≠„ÉºÂá¶ÁêÜÔºàË§áÊï∞ÈÅ∏ÊäûÁî®Ôºâ
        if (e.key === 'Shift') {
            isShiftPressed = true;
            console.log('Shift„Ç≠„ÉºÊäº‰∏ã:', isShiftPressed);
        }
        
        // Escape„Ç≠„Éº - ÈÅ∏Êäû„Çí„ÇØ„É™„Ç¢
        if (e.key === 'Escape') {
            console.log('Escape„Ç≠„ÉºÊäº‰∏ã - Ë§áÊï∞ÈÅ∏Êäû„Çí„ÇØ„É™„Ç¢');
            clearMultiSelection();
            e.preventDefault();
        }
        
        // Delete/Backspace„Ç≠„Éº - ÈÅ∏Êäû„Åï„Çå„ÅüË¶ÅÁ¥†„ÇíÂâäÈô§
        if (e.key === 'Delete' || e.key === 'Backspace') {
            if (isInputActive) return; // ÂÖ•Âäõ„Éï„Ç£„Éº„É´„Éâ„Åß„ÅØÂâäÈô§Âá¶ÁêÜ„Çí„Çπ„Ç≠„ÉÉ„Éó
            
            console.log('Delete„Ç≠„ÉºÊäº‰∏ã - ÈÅ∏Êäû„Åï„Çå„ÅüË¶ÅÁ¥†„ÇíÂâäÈô§');
            e.preventDefault();
            deleteSelectedElements();
        }

        // ÂÖ•Âäõ„Éï„Ç£„Éº„É´„Éâ„Åå„Ç¢„ÇØ„ÉÜ„Ç£„Éñ„Å™Â†¥Âêà„ÄÅ‰ª•‰∏ã„ÅÆ„Ç∑„Éß„Éº„Éà„Ç´„ÉÉ„Éà„Çí„Çπ„Ç≠„ÉÉ„Éó
        if (isInputActive && !(e.ctrlKey && e.key === 'z')) return;

        // „Ç≠„Éº„Éú„Éº„Éâ„Ç∑„Éß„Éº„Éà„Ç´„ÉÉ„Éà
        if (!e.ctrlKey && !e.shiftKey && !e.altKey) {
            switch(e.key.toLowerCase()) {
                case 's':
                    // ÈÅ∏Êäû/ÁßªÂãï„É¢„Éº„Éâ
                    console.log('„Ç∑„Éß„Éº„Éà„Ç´„ÉÉ„Éà: ÈÅ∏Êäû/ÁßªÂãï„É¢„Éº„Éâ (S)');
                    setCanvasMode('select');
                    e.preventDefault();
                    break;
                case 'n':
                    // ÁØÄÁÇπËøΩÂä†„É¢„Éº„Éâ
                    console.log('„Ç∑„Éß„Éº„Éà„Ç´„ÉÉ„Éà: ÁØÄÁÇπËøΩÂä†„É¢„Éº„Éâ (N)');
                    setCanvasMode('addNode');
                    e.preventDefault();
                    break;
                case 'm':
                    // ÈÉ®ÊùêËøΩÂä†„É¢„Éº„Éâ
                    console.log('„Ç∑„Éß„Éº„Éà„Ç´„ÉÉ„Éà: ÈÉ®ÊùêËøΩÂä†„É¢„Éº„Éâ (M)');
                    setCanvasMode('addMember');
                    e.preventDefault();
                    break;
                case 'c':
                    // Ë®àÁÆóÂÆüË°å
                    console.log('„Ç∑„Éß„Éº„Éà„Ç´„ÉÉ„Éà: Ë®àÁÆóÂÆüË°å (C)');
                    if (elements.calculateBtn && !elements.calculateBtn.disabled) {
                        elements.calculateBtn.click();
                    }
                    e.preventDefault();
                    break;
                case 'r':
                    // „É¨„Éù„Éº„ÉàÂá∫Âäõ
                    console.log('„Ç∑„Éß„Éº„Éà„Ç´„ÉÉ„Éà: „É¨„Éù„Éº„ÉàÂá∫Âäõ (R)');
                    if (elements.reportBtn && !elements.reportBtn.disabled) {
                        elements.reportBtn.click();
                    }
                    e.preventDefault();
                    break;
                case 'a':
                    // Ëá™Âãï„Çπ„Ç±„Éº„É™„É≥„Ç∞
                    console.log('„Ç∑„Éß„Éº„Éà„Ç´„ÉÉ„Éà: Ëá™Âãï„Çπ„Ç±„Éº„É™„É≥„Ç∞ (A)');
                    if (elements.autoScaleBtn) {
                        elements.autoScaleBtn.click();
                    }
                    e.preventDefault();
                    break;
                case 'g':
                    // „Ç∞„É™„ÉÉ„ÉâË°®Á§∫ÂàáÊõø
                    console.log('„Ç∑„Éß„Éº„Éà„Ç´„ÉÉ„Éà: „Ç∞„É™„ÉÉ„ÉâË°®Á§∫ÂàáÊõø (G)');
                    if (elements.gridToggle) {
                        elements.gridToggle.checked = !elements.gridToggle.checked;
                        drawOnCanvas();
                    }
                    e.preventDefault();
                    break;
            }
        }
        
        // Ctrl+„Ç≠„Éº „ÅÆÁµÑ„ÅøÂêà„Çè„Åõ
        if (e.ctrlKey) {
            switch(e.key.toLowerCase()) {
                case 'z':
                    // ÂÖÉ„Å´Êàª„Åô
                    console.log('„Ç∑„Éß„Éº„Éà„Ç´„ÉÉ„Éà: ÂÖÉ„Å´Êàª„Åô (Ctrl+Z)');
                    if (elements.undoBtn && !elements.undoBtn.disabled) {
                        elements.undoBtn.click();
                    }
                    e.preventDefault();
                    break;
                case 's':
                    // ÂÖ•Âäõ‰øùÂ≠ò
                    console.log('„Ç∑„Éß„Éº„Éà„Ç´„ÉÉ„Éà: ÂÖ•Âäõ‰øùÂ≠ò (Ctrl+S)');
                    if (elements.saveBtn) {
                        elements.saveBtn.click();
                    }
                    e.preventDefault();
                    break;
                case 'o':
                    // ÂÖ•ÂäõË™≠Ëæº
                    console.log('„Ç∑„Éß„Éº„Éà„Ç´„ÉÉ„Éà: ÂÖ•ÂäõË™≠Ëæº (Ctrl+O)');
                    if (elements.loadBtn) {
                        elements.loadBtn.click();
                    }
                    e.preventDefault();
                    break;
            }
        }
    });
    
    document.addEventListener('keyup', (e) => {
        if (e.key === 'Shift') {
            isShiftPressed = false;
            console.log('Shift„Ç≠„ÉºËß£Êîæ:', isShiftPressed);
        }
    });

// --- Table Row Templates & Presets ---
// ==========================================================
// ‚ñº‚ñº‚ñº ËøΩÂä†: Êñ≠Èù¢Âõ≥ÊèèÁîª„É≠„Ç∏„ÉÉ„ÇØ (steel_selector.js „Åã„ÇâÁßªÊ§ç) ‚ñº‚ñº‚ñº
// ==========================================================

// „É©„Éô„É´„Ç™„Éó„Ç∑„Éß„É≥„ÅÆË®àÁÆó
const calculateLabelOptions = (maxDim, scale = 1) => {
    const fontSize = 24; 
    const labelStrokeWidth = 0.6;
    const safeScale = Number.isFinite(scale) && scale > 0 ? scale : 1;
    const baseFontSize = fontSize;
    return { fontSize, baseFontSize, scale: safeScale, labelStrokeWidth };
};

// „Éû„Éº„Ç∏„É≥„ÅÆË®àÁÆó
const calculateDiagramMargin = (maxDim, labelOptions = {}) => {
    let options = labelOptions;
    if (typeof labelOptions === 'number') options = { fontSize: labelOptions };
    else if (!labelOptions || typeof labelOptions !== 'object') options = {};
    const { fontSize } = options;
    const safeFont = Number.isFinite(fontSize) && fontSize > 0 ? fontSize : 32;
    const fontBasedMargin = safeFont * 4.5;
    return Math.max(80, fontBasedMargin);
};

// SVGÊèèÁîª„Éá„Éº„Çø„ÅÆÁîüÊàê„É°„Ç§„É≥Èñ¢Êï∞
window.buildSectionDiagramData = function(typeKey, rawDims = {}, options = {}) {
    const { labelScaleMultiplier = 1, showDimensions = true } = options || {};

    const sanitize = (value) => (Number.isFinite(value) && value > 0 ? value : null);
    
    // Êï∞ÂÄ§„ÅÆÊï¥ÂΩ¢Áî®„Éò„É´„Éë„Éº
    const formatPrimaryDimension = (value) => (!Number.isFinite(value) ? '' : Math.round(value).toString());
    const formatThicknessDimension = (value) => (!Number.isFinite(value) ? '' : (Math.round(value * 10) / 10).toFixed(1));
    
    const buildLabelLines = (lines) => {
        if (!Array.isArray(lines)) return [];
        return lines.map(line => (line === null || line === undefined ? '' : String(line).trim())).filter(line => line.length > 0);
    };

    // „É©„Éô„É´ÁîüÊàê„Éò„É´„Éë„Éº
    const mmLabel = (symbol, value) => {
        const formatted = formatPrimaryDimension(value);
        if (symbol === 'B') {
            const singleLine = formatted ? `${symbol} = ${formatted} mm` : `${symbol} = ‚Äï`;
            return buildLabelLines([singleLine]);
        }
        return buildLabelLines([`${symbol} =`, formatted ? `${formatted} mm` : '‚Äï']);
    };
    const thicknessLabel = (symbol, value) => {
        const formatted = formatThicknessDimension(value);
        return buildLabelLines([`${symbol} =`, formatted ? `${formatted} mm` : '‚Äï']);
    };
    const phiLabel = (value) => {
        const formatted = formatPrimaryDimension(value);
        return buildLabelLines([formatted ? `œÜ ${formatted} mm` : 'œÜ ‚Äï']);
    };

    // ÂØ∏Ê≥ïÁ∑öÁîüÊàê„Éò„É´„Éë„Éº
    const createHelpers = (maxDim, fontSize) => {
        const baseGap = Math.max(maxDim * 0.02, fontSize * 0.5, 10);
        const smallGap = Math.max(maxDim * 0.01, fontSize * 0.4, 8);
        const lineHeight = fontSize * 1.2;

        const normalizeLabelLines = (label) => {
            if (Array.isArray(label)) return label.map(String).filter(s => s.trim().length > 0);
            if (label === null || label === undefined) return ['‚Äï'];
            const value = String(label).trim();
            return value.length > 0 ? [value] : ['‚Äï'];
        };

        const buildLabelMarkup = (lines, x) => {
            if (!Array.isArray(lines) || lines.length === 0) return '';
            const totalHeight = lineHeight * Math.max(0, lines.length - 1);
            const firstDy = lines.length === 1 ? 0 : -(totalHeight / 2);
            return lines.map((line, index) => {
                const dyValue = index === 0 ? firstDy : lineHeight;
                const dyAttr = index === 0 && lines.length === 1 ? '' : ` dy="${dyValue.toFixed(2)}px"`;
                return `<tspan x="${x}"${dyAttr}>${line}</tspan>`;
            }).join('');
        };

        const adjustGapForLines = (gap, lineCount) => (lineCount <= 1 ? gap : gap + lineHeight * (lineCount - 1) * 0.65);

        const horizontalDim = (x1, x2, y, label, { position = 'below', gap = baseGap, anchor = 'middle', extraClass = '' } = {}) => {
            const textX = anchor === 'start' ? x1 : anchor === 'end' ? x2 : (x1 + x2) / 2;
            const lines = normalizeLabelLines(label);
            const adjustedGap = adjustGapForLines(gap, lines.length);
            const textY = position === 'below' ? y + adjustedGap : y - adjustedGap;
            return `<g class="dimension horizontal ${extraClass}"><text class="dim-label" x="${textX}" y="${textY}" text-anchor="${anchor}" dominant-baseline="middle" font-size="${fontSize.toFixed(2)}px">${buildLabelMarkup(lines, textX)}</text></g>`;
        };

        const verticalDim = (x, y1, y2, label, { side = 'left', gap = baseGap, extraClass = '' } = {}) => {
            const textAnchor = side === 'right' ? 'start' : 'end';
            const textY = (y1 + y2) / 2;
            const lines = normalizeLabelLines(label);
            const adjustedGap = adjustGapForLines(gap, lines.length);
            const finalX = side === 'right' ? x + adjustedGap : x - adjustedGap;
            return `<g class="dimension vertical ${extraClass}"><text class="dim-label" x="${finalX}" y="${textY}" text-anchor="${textAnchor}" dominant-baseline="middle" font-size="${fontSize.toFixed(2)}px">${buildLabelMarkup(lines, finalX)}</text></g>`;
        };

        return { horizontalDim, verticalDim, baseGap, smallGap };
    };

    const wrapSvg = (viewBox, bodyMarkup, dimensionMarkup = '', thicknessMarkup = '', { fontSize = 18, labelStrokeWidth = 0.6 } = {}) => {
        const style = `.section-body { fill: #3b82f6; stroke: #1d4ed8; stroke-width: 1.4; stroke-linejoin: round; } .section-body .void { fill: #ffffff; } .dimension .dim-line { stroke: #0f172a; stroke-width: 1.2; fill: none; } .dimension .dim-label { font-family: sans-serif; font-weight: 600; fill: #0f172a; stroke: #ffffff; stroke-width: ${labelStrokeWidth}; paint-order: stroke fill; } .dimension.thickness .dim-label { fill: #1e3a8a; }`;
        const finalDim = showDimensions ? dimensionMarkup : '';
        const finalThick = showDimensions ? thicknessMarkup : '';
        return { viewBox, markup: `<defs><style>${style}</style></defs><g class="section-body">${bodyMarkup}</g><g class="dim-layer">${finalDim}</g><g class="dim-layer thickness">${finalThick}</g>` };
    };

    // ÂêÑÊñ≠Èù¢„ÅÆ„É¨„É≥„ÉÄ„É©„Éº
    const renderHSection = (dims, { includeLip = false } = {}) => {
        const H = sanitize(dims.H), B = sanitize(dims.B), web = sanitize(dims.t1), flange = sanitize(dims.t2), lip = includeLip ? sanitize(dims.C) : null;
        if (!H || !B || !web || !flange) return null;
        const width = B, height = H, maxDim = Math.max(width, height);
        const labelOptions = calculateLabelOptions(maxDim, labelScaleMultiplier);
        const margin = calculateDiagramMargin(maxDim, labelOptions.fontSize);
        const viewBox = `${-width/2 - margin} ${-height/2 - margin} ${width + margin*2} ${height + margin*2}`;
        const { horizontalDim, verticalDim, baseGap, smallGap } = createHelpers(maxDim, labelOptions.fontSize);

        let shapes = [`<rect x="${-web/2}" y="${-height/2}" width="${web}" height="${height}" />`, `<rect x="${-width/2}" y="${-height/2}" width="${width}" height="${flange}" />`, `<rect x="${-width/2}" y="${height/2 - flange}" width="${width}" height="${flange}" />`];
        if (includeLip && lip && lip > flange/1.5) {
            const lh = Math.min(lip, height/2);
            shapes.push(`<rect x="${-width/2}" y="${-height/2}" width="${flange}" height="${lh}" />`, `<rect x="${width/2-flange}" y="${-height/2}" width="${flange}" height="${lh}" />`, `<rect x="${-width/2}" y="${height/2-lh}" width="${flange}" height="${lh}" />`, `<rect x="${width/2-flange}" y="${height/2-lh}" width="${flange}" height="${lh}" />`);
        }
        const dimensions = [verticalDim(-width/2 - margin*0.55, -height/2, height/2, mmLabel('H', H), {side:'left', gap:baseGap}), horizontalDim(-width/2, width/2, height/2 + margin*0.55, mmLabel('B', B), {position:'below', gap:baseGap})].join('');
        const thickness = [horizontalDim(-web/2, web/2, -height/2 - margin*0.35, thicknessLabel('t‚ÇÅ', web), {position:'above', gap:smallGap}), verticalDim(width/2 + margin*0.45, -height/2, -height/2+flange, thicknessLabel('t‚ÇÇ', flange), {side:'right', gap:baseGap})];
        if (includeLip && lip) thickness.push(verticalDim(width/2 + margin*0.7, -height/2, -height/2+lip, thicknessLabel('C', lip), {side:'right', gap:baseGap*0.8}));
        
        return wrapSvg(viewBox, shapes.join(''), dimensions, thickness.join(''), labelOptions);
    };

    const renderChannelSection = (dims) => {
        const H = sanitize(dims.H), W = sanitize(dims.B)||sanitize(dims.A), tw = sanitize(dims.t1)||sanitize(dims.t), tf = sanitize(dims.t2)||sanitize(dims.t), lip = sanitize(dims.C);
        if (!H || !W || !tw) return null;
        const maxDim = Math.max(W, H);
        const labelOptions = calculateLabelOptions(maxDim, labelScaleMultiplier);
        const margin = calculateDiagramMargin(maxDim, labelOptions.fontSize);
        const viewBox = `${-W/2 - margin} ${-H/2 - margin} ${W + margin*2} ${H + margin*2}`;
        const { horizontalDim, verticalDim, baseGap, smallGap } = createHelpers(maxDim, labelOptions.fontSize);
        const webX = -W/2;
        let shapes = [`<rect x="${webX}" y="${-H/2}" width="${tw}" height="${H}" />`, `<rect x="${webX}" y="${-H/2}" width="${W}" height="${tf}" />`, `<rect x="${webX}" y="${H/2-tf}" width="${W}" height="${tf}" />`];
        if (lip && lip > tf) { const lh = Math.min(lip, H/2); shapes.push(`<rect x="${W/2-tf}" y="${-H/2}" width="${tf}" height="${lh}" />`, `<rect x="${W/2-tf}" y="${H/2-lh}" width="${tf}" height="${lh}" />`); }
        const dimensions = [verticalDim(-W/2 - margin*0.55, -H/2, H/2, mmLabel('H', H), {side:'left', gap:baseGap}), horizontalDim(-W/2, W/2, H/2 + margin*0.55, mmLabel('B', W), {position:'below', gap:baseGap})].join('');
        const thickness = [horizontalDim(-tw/2, tw/2, -H/2 - margin*0.3, thicknessLabel('t‚ÇÅ', tw), {position:'above', gap:smallGap}), verticalDim(W/2 + margin*0.45, -H/2, -H/2+tf, thicknessLabel('t‚ÇÇ', tf), {side:'right', gap:baseGap})];
        if (lip && lip > tf) thickness.push(verticalDim(W/2 + margin*0.7, -H/2, -H/2+lip, thicknessLabel('C', lip), {side:'right', gap:baseGap*0.8}));
        return wrapSvg(viewBox, shapes.join(''), dimensions, thickness.join(''), labelOptions);
    };

    const renderRectTube = (dims) => {
        const H = sanitize(dims.A)||sanitize(dims.H), B = sanitize(dims.B)||sanitize(dims.A), t = sanitize(dims.t);
        if (!H || !B || !t) return null;
        const maxDim = Math.max(H, B);
        const labelOptions = calculateLabelOptions(maxDim, labelScaleMultiplier);
        const margin = calculateDiagramMargin(maxDim, labelOptions.fontSize);
        const viewBox = `${-B/2 - margin} ${-H/2 - margin} ${B + margin*2} ${H + margin*2}`;
        const { horizontalDim, verticalDim, baseGap, smallGap } = createHelpers(maxDim, labelOptions.fontSize);
        const body = `<g><rect x="${-B/2}" y="${-H/2}" width="${B}" height="${H}" /><rect class="void" x="${-B/2+t}" y="${-H/2+t}" width="${B-2*t}" height="${H-2*t}" /></g>`;
        const dimensions = [verticalDim(-B/2 - margin*0.45, -H/2, H/2, mmLabel('H', H), {side:'left', gap:baseGap}), horizontalDim(-B/2, B/2, H/2 + margin*0.5, mmLabel('B', B), {position:'below', gap:baseGap})].join('');
        const thickness = verticalDim(B/2 + margin*0.45, -H/2, -H/2+t, thicknessLabel('t', t), {side:'right', gap:smallGap});
        return wrapSvg(viewBox, body, dimensions, thickness, labelOptions);
    };

    const renderPipe = (dims) => {
        const D = sanitize(dims.D), t = sanitize(dims.t);
        if (!D) return null;
        const labelOptions = calculateLabelOptions(D, labelScaleMultiplier);
        const margin = calculateDiagramMargin(D, labelOptions.fontSize);
        const viewBox = `${-D/2 - margin} ${-D/2 - margin} ${D + margin*2} ${D + margin*2}`;
        const { horizontalDim, verticalDim, baseGap, smallGap } = createHelpers(D, labelOptions.fontSize);
        const body = `<g><circle cx="0" cy="0" r="${D/2}" />${t && t < D/2 ? `<circle class="void" cx="0" cy="0" r="${D/2-t}" />` : ''}</g>`;
        const dimensions = horizontalDim(-D/2, D/2, D/2 + margin*0.55, phiLabel(D), {position:'below', gap:baseGap});
        const thickness = t ? verticalDim(D/2 + margin*0.45, -D/2, -D/2+t, thicknessLabel('t', t), {side:'right', gap:smallGap}) : '';
        return wrapSvg(viewBox, body, dimensions, thickness, labelOptions);
    };

    // „Éì„É´„ÉÄ„Éº„ÅÆÂëº„Å≥Âá∫„Åó
    const numericDims = Object.fromEntries(Object.entries(rawDims || {}).map(([k, v]) => [k, Number(v)]));
    if (['hkatakou_hiro','hkatakou_naka','hkatakou_hoso','ikatakou','keiryouhkatakou'].includes(typeKey)) return renderHSection(numericDims);
    if (['keiryourippuhkatakou'].includes(typeKey)) return renderHSection(numericDims, {includeLip:true});
    if (['mizogatakou','keimizogatakou','rippumizokatakou'].includes(typeKey)) return renderChannelSection(numericDims);
    if (['seihoukei','tyouhoukei','Áü©ÂΩ¢'].includes(typeKey)) return renderRectTube(numericDims);
    if (['koukan','ÂÜÜÂΩ¢'].includes(typeKey)) return renderPipe(numericDims);
    
    // „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ
    return { viewBox: '-120 -80 240 160', markup: `<defs><style>.section-body * { fill: #ccc; }</style></defs><g class="section-body"><rect x="-40" y="-40" width="80" height="80" /></g>` };
};
// ==========================================================
// ‚ñ≤‚ñ≤‚ñ≤ ËøΩÂä†ÁµÇ‰∫Ü ‚ñ≤‚ñ≤‚ñ≤
// ==========================================================

const createEInputHTML = (idPrefix, currentE = '205000') => {

        const materials = { "205000": "„Çπ„ÉÅ„Éº„É´", "193000": "„Çπ„ÉÜ„É≥„É¨„Çπ", "70000": "„Ç¢„É´„Éü„Éã„Ç¶„É†", "8000": "Êú®Êùê" };
        const e_val_str = parseFloat(currentE).toString();
        let isPresetMaterial = materials.hasOwnProperty(e_val_str);
        let options_html = '';
        for (const [value, name] of Object.entries(materials)) { options_html += `<option value="${value}" ${e_val_str === value ? 'selected' : ''}>${name}</option>`; }
        options_html += `<option value="custom" ${!isPresetMaterial ? 'selected' : ''}>‰ªªÊÑèÂÖ•Âäõ</option>`;
        const selectId = `${idPrefix}-select`, inputId = `${idPrefix}-input`;
        
        // HTML„ÇíÁîüÊàê
        const html = `<div style="display: flex; flex-direction: column; gap: 2px;">
            <select id="${selectId}">
                ${options_html}
            </select>
            <input id="${inputId}" type="number" value="${currentE}" title="ÂºæÊÄß‰øÇÊï∞ E (N/mm¬≤)" style="display: inline-block;" ${!isPresetMaterial ? '' : 'readonly'}>
        </div>`;
        
        // „Ç§„Éô„É≥„Éà„É™„Çπ„Éä„Éº„ÇíÂæå„ÅßË®≠ÂÆö„Åô„Çã„Åü„ÇÅ„Å´„ÄÅsetTimeout „Çí‰ΩøÁî®
        setTimeout(() => {
            const select = document.getElementById(selectId);
            const input = document.getElementById(inputId);
            if (select && input) {
                select.addEventListener('change', function() {
                    if (this.value !== 'custom') {
                        input.value = this.value;
                    }
                    input.readOnly = (this.value !== 'custom');
                    input.dispatchEvent(new Event('change'));
                    
                    // Êú®Êùê„ÅåÈÅ∏Êäû„Åï„Çå„ÅüÂ†¥Âêà„ÄÅÂü∫Ê∫ñÂº∑Â∫¶Â§âÊõ¥ÊôÇ„Å´ÂºæÊÄß‰øÇÊï∞„ÇíÊõ¥Êñ∞„Åô„Çã„Ç§„Éô„É≥„Éà„É™„Çπ„Éä„Éº„ÇíË®≠ÂÆö
                    if (this.value === '8000') {
                        setTimeout(() => {
                            const strengthContainer = this.closest('tr')?.cells[4]?.firstElementChild || 
                                                   document.querySelector('[data-strength-type="wood-type"]');
                            if (strengthContainer) {
                                const strengthSelect = strengthContainer.querySelector('select');
                                if (strengthSelect) {
                                    const updateElasticModulus = () => {
                                        const woodType = strengthSelect.value;
                                        const woodElasticModuli = {
                                            'Akamatsu_Group': 8000, 'Kuromatsu_Group': 8000, 'Beimatsu_Group': 8000,
                                            'Karamatsu_Group': 9000, 'Hiba_Group': 9000, 'Hinoki_Group': 9000, 'Beihi_Group': 9000,
                                            'Tuga_Group': 8000, 'Beituga_Group': 8000,
                                            'Momi_Group': 7000, 'Ezomatsu_Group': 7000, 'Todomatsu_Group': 7000, 'Benimatsu_Group': 7000, 
                                            'Sugi_Group': 7000, 'Beisugi_Group': 7000, 'Spruce_Group': 7000,
                                            'Kashi_Group': 10000,
                                            'Kuri_Group': 8000, 'Nara_Group': 8000, 'Buna_Group': 8000, 'Keyaki_Group': 8000
                                        };
                                        if (woodElasticModuli[woodType]) {
                                            input.value = woodElasticModuli[woodType];
                                            input.dispatchEvent(new Event('change'));
                                        }
                                    };
                                    
                                    strengthSelect.removeEventListener('change', updateElasticModulus);
                                    strengthSelect.addEventListener('change', updateElasticModulus);
                                    updateElasticModulus(); // ÂàùÊúüÂÄ§„ÇíË®≠ÂÆö
                                }
                            }
                        }, 100);
                    }
                });
            }
        }, 10);
        
        return html;
    };
   
    const createStrengthInputHTML = (materialType, idPrefix, currentValue, forceCustom = false) => {
        // Debug log
        if (materialType === 'steel') {
            console.log(`createStrengthInputHTML: val=${currentValue}, forceCustom=${forceCustom}`);
        }
        const wrapper = document.createElement('div');
        let htmlContent = '';
        const selectId = `${idPrefix}-select`;
        const inputId = `${idPrefix}-input`;

        switch(materialType) {
            case 'steel': {
                const materials = { "235": "SS400, SN400B", "295": "SM490", "325": "SN490B", "355": "SM520" };
                const f_val_str = currentValue || '235';
                // forceCustom„Ååtrue„ÅÆÂ†¥Âêà„ÅØÂ∏∏„Å´‰ªªÊÑèÂÖ•Âäõ„É¢„Éº„Éâ„Å´„Åô„Çã
                let isPreset = !forceCustom && materials.hasOwnProperty(f_val_str);
                let options_html = '';
                for (const [value, name] of Object.entries(materials)) { 
                    options_html += `<option value="${value}" ${isPreset && f_val_str === value ? 'selected' : ''}>${name} (F=${value})</option>`; 
                }
                options_html += `<option value="custom" ${!isPreset ? 'selected' : ''}>‰ªªÊÑèÂÖ•Âäõ</option>`;
                
                const select = document.createElement('select');
                select.id = selectId;
                select.innerHTML = options_html;
                
                const input = document.createElement('input');
                input.id = inputId;
                input.type = 'number';
                input.value = f_val_str;
                // Â∞èÊï∞ÁÇπÂÖ•Âäõ„ÇíË®±ÂÆπÔºà„Éñ„É©„Ç¶„Ç∂Ê®ôÊ∫ñ„Éê„É™„Éá„Éº„Ç∑„Éß„É≥„ÅÆstep‰∏ç‰∏ÄËá¥„ÇíÂõûÈÅøÔºâ
                input.step = 'any';
                input.min = '0';
                // forceCustom„ÅÆÂ†¥Âêà„ÅØÁ∑®ÈõÜÂèØËÉΩ„Å´„Åô„Çã
                input.readOnly = isPreset;
                
                const div = document.createElement('div');
                div.setAttribute('data-strength-type', 'F-value');
                div.appendChild(select);
                div.appendChild(input);
                
                select.addEventListener('change', function() {
                    input.value = this.value !== 'custom' ? this.value : input.value;
                    input.readOnly = this.value !== 'custom';
                });
                
                return div;
            }
            case 'wood': {
                const wood_val_str = currentValue ? (typeof currentValue === 'object' ? 'custom' : currentValue) : 'Sugi_Group';
                const isCustom = wood_val_str === 'custom';

                const baseStresses = isCustom
                    ? (currentValue.baseStrengths || WOOD_BASE_STRENGTH_DATA['Sugi_Group'])
                    : WOOD_BASE_STRENGTH_DATA[wood_val_str];

                const container = document.createElement('div');
                container.dataset.strengthType = 'wood-type';
                container.style.display = 'flex';
                container.style.flexDirection = 'column';
                container.style.gap = '4px';

                const select = document.createElement('select');
                select.id = `${idPrefix}-preset`;

                for (const [key, value] of Object.entries(WOOD_BASE_STRENGTH_DATA)) {
                    const option = new Option(value.name, key);
                    if (wood_val_str === key) option.selected = true;
                    select.add(option);
                }
                const customOption = new Option('‰ªªÊÑèÂÖ•Âäõ (Âü∫Ê∫ñÂº∑Â∫¶)', 'custom');
                if (isCustom) customOption.selected = true;
                select.add(customOption);
                
                const inputsContainer = document.createElement('div');
                inputsContainer.style.display = 'grid';
                inputsContainer.style.gridTemplateColumns = 'auto 1fr';
                inputsContainer.style.gap = '2px 5px';
                inputsContainer.style.alignItems = 'center';
                inputsContainer.style.fontSize = '0.9em';

                const inputs = {};
                const stressLabels = {ft: "Âü∫Ê∫ñÂºïÂºµÂº∑Â∫¶ Ft", fc: "Âü∫Ê∫ñÂúßÁ∏ÆÂº∑Â∫¶ Fc", fb: "Âü∫Ê∫ñÊõ≤„ÅíÂº∑Â∫¶ Fb", fs: "Âü∫Ê∫ñ„Åõ„ÇìÊñ≠Âº∑Â∫¶ Fs"};

                for (const key of ['ft', 'fc', 'fb', 'fs']) {
                    const label = document.createElement('label');
                    label.htmlFor = `${idPrefix}-${key}`;
                    label.title = stressLabels[key];
                    label.textContent = `${key} :`;
                    
                    const input = document.createElement('input');
                    input.type = 'number';
                    input.id = `${idPrefix}-${key}`;
                    input.value = baseStresses[key].toFixed(2);
                    // Â∞èÊï∞ÁÇπÂÖ•Âäõ„ÇíË®±ÂÆπÔºàtoFixed(2)„ÅÆÂÄ§„Ååstep=1„Å†„Å®ÁÑ°Âäπ„Å´„Å™„Çä„ÅÜ„ÇãÔºâ
                    input.step = 'any';
                    input.min = '0';
                    input.readOnly = !isCustom;
                    
                    inputs[key] = input;
                    inputsContainer.appendChild(label);
                    inputsContainer.appendChild(input);
                }

                select.onchange = () => {
                    const isCustomSelection = select.value === 'custom';
                    if (isCustomSelection) {
                        Object.values(inputs).forEach(input => { input.readOnly = false; });
                    } else {
                        const selectedBaseStresses = WOOD_BASE_STRENGTH_DATA[select.value];
                        inputs.ft.value = selectedBaseStresses.ft.toFixed(2);
                        inputs.fc.value = selectedBaseStresses.fc.toFixed(2);
                        inputs.fb.value = selectedBaseStresses.fb.toFixed(2);
                        inputs.fs.value = selectedBaseStresses.fs.toFixed(2);
                        Object.values(inputs).forEach(input => { input.readOnly = true; });
                    }
                };

                container.appendChild(select);
                container.appendChild(inputsContainer);
                return container;
            }
            case 'stainless': {
                const stainValue = currentValue || '205';
                const isPreset = ['205', '235'].includes(stainValue);
                htmlContent = `<div data-strength-type="F-stainless"><select id="${selectId}" onchange="const input = document.getElementById('${inputId}'); input.value = this.value; input.readOnly = (this.value !== 'custom');"><option value="205" ${stainValue === '205' ? 'selected' : ''}>SUS304</option><option value="235" ${stainValue === '235' ? 'selected' : ''}>SUS316</option><option value="custom" ${!isPreset ? 'selected' : ''}>‰ªªÊÑèÂÖ•Âäõ</option></select><input id="${inputId}" type="number" step="any" min="0" value="${stainValue}" ${isPreset ? 'readonly' : ''}></div>`;
                wrapper.innerHTML = htmlContent;
                return wrapper.firstElementChild;
            }
            case 'aluminum': {
                const alumValue = currentValue || '150';
                const isPreset = ['150', '185'].includes(alumValue);
                htmlContent = `<div data-strength-type="F-aluminum"><select id="${selectId}" onchange="const input = document.getElementById('${inputId}'); input.value = this.value; input.readOnly = (this.value !== 'custom');"><option value="150" ${alumValue === '150' ? 'selected' : ''}>A5052</option><option value="185" ${alumValue === '185' ? 'selected' : ''}>A6061-T6</option><option value="custom" ${!isPreset ? 'selected' : ''}>‰ªªÊÑèÂÖ•Âäõ</option></select><input id="${inputId}" type="number" step="any" min="0" value="${alumValue}" ${isPreset ? 'readonly' : ''}></div>`;
                wrapper.innerHTML = htmlContent;
                return wrapper.firstElementChild;
            }
            default: 
                htmlContent = '<div>-</div>';
                wrapper.innerHTML = htmlContent;
                return wrapper.firstElementChild;
        }
    };

    // ÂØÜÂ∫¶ÂÖ•ÂäõHTML‰ΩúÊàêÈñ¢Êï∞
    const createDensityInputHTML = (idPrefix, currentDensity = 7850) => {
        const inputId = `${idPrefix}-input`;
        const selectId = `${idPrefix}-select`;
        
        // ÊùêÊñôÂà•„ÅÆÊ®ôÊ∫ñÂØÜÂ∫¶„Ç™„Éó„Ç∑„Éß„É≥
        const densityOptions = {
            "7850": "„Çπ„ÉÅ„Éº„É´",
            "7900": "„Çπ„ÉÜ„É≥„É¨„Çπ",
            "2700": "„Ç¢„É´„Éü„Éã„Ç¶„É†",
            "400": "ËªüÊùêÔºàÊùâÁ≠âÔºâ",
            "500": "‰∏≠Á°¨ÊùêÔºàÊùæÁ≠âÔºâ",
            "550": "„ÇÑ„ÇÑÁ°¨ÊùêÔºàÊ™úÁ≠âÔºâ",
            "800": "Á°¨ÊùêÔºàÊ®´Ôºâ"
        };
        
        const density_val_str = currentDensity.toString();
        const isPreset = densityOptions.hasOwnProperty(density_val_str);
        
        let options_html = '';
        for (const [value, name] of Object.entries(densityOptions)) {
            options_html += `<option value="${value}" ${density_val_str === value ? 'selected' : ''}>${name} (${value})</option>`;
        }
        options_html += `<option value="custom" ${!isPreset ? 'selected' : ''}>‰ªªÊÑèÂÖ•Âäõ</option>`;
        
        const html = `<div style="display: flex; flex-direction: column; gap: 2px;">
            <select id="${selectId}">
                ${options_html}
            </select>
            <input id="${inputId}" type="number" value="${currentDensity}" title="ÂØÜÂ∫¶ œÅ (kg/m¬≥)" min="0" ${isPreset ? 'readonly' : ''}>
        </div>`;
        
        // „Ç§„Éô„É≥„Éà„É™„Çπ„Éä„Éº„ÇíÂæå„ÅßË®≠ÂÆö
        setTimeout(() => {
            const select = document.getElementById(selectId);
            const input = document.getElementById(inputId);
            if (select && input) {
                select.addEventListener('change', function() {
                    if (this.value !== 'custom') {
                        input.value = this.value;
                        input.readOnly = true;
                    } else {
                        input.readOnly = false;
                    }
                });
            }
        }, 10);
        
        return html;
    };

    const memberRowHTML = (i, j, E = '205000', F='235', I = 1.84e-5, A = 2.34e-3, Z = 1.23e-3, i_rad = '', i_conn = 'rigid', j_conn = 'rigid', sectionName = '', sectionAxis = '', bucklingK = '', forceCustomF = false, J_cm4 = '', Iw_cm6 = '') => {
        console.log(`memberRowHTML: F=${F}, forceCustomF=${forceCustomF}`);
        // ÂºïÊï∞„Å´ bucklingK „ÇíËøΩÂä†Ôºà„Éá„Éï„Ç©„É´„Éà„ÅØÁ©∫Ôºâ
        const baseColumns = [
            `<input type="number" value="${i}">`,
            `<input type="number" value="${j}">`,
            createEInputHTML(`member-e-${i}-${j}`, E),
            createStrengthInputHTML('steel', `member-strength-${i}-${j}`, F, forceCustomF),
            `<div class="cell-input-wrapper reduction-wrapper" data-reduction-decimals="2">
                <input type="number" class="reduction-base-input section-I-input" value="${(I * 1e8).toFixed(2)}" title="Êñ≠Èù¢‰∫åÊ¨°„É¢„Éº„É°„É≥„Éà I (cm‚Å¥)">
                <div><span>‰ΩéÊ∏õ‰øÇÊï∞Ôºö</span><input type="number" class="reduction-factor-input section-I-factor" value="1.0" step="0.01" title="‰ΩéÊ∏õ‰øÇÊï∞" placeholder="‰ΩéÊ∏õ‰øÇÊï∞"></div>
                <div class="reduced-label" style="display:none;">‰ΩéÊ∏õÂæåÔºö<span class="reduced-value"></span></div>
            </div>`,
            `<div class="cell-input-wrapper reduction-wrapper" data-reduction-decimals="2">
                <input type="number" class="reduction-base-input section-A-input" value="${(A * 1e4).toFixed(2)}" title="Êñ≠Èù¢Á©ç A (cm¬≤)">
                <div><span>‰ΩéÊ∏õ‰øÇÊï∞Ôºö</span><input type="number" class="reduction-factor-input section-A-factor" value="1.0" step="0.01" title="‰ΩéÊ∏õ‰øÇÊï∞" placeholder="‰ΩéÊ∏õ‰øÇÊï∞"></div>
                <div class="reduced-label" style="display:none;">‰ΩéÊ∏õÂæåÔºö<span class="reduced-value"></span></div>
            </div>`,
            `<div class="cell-input-wrapper reduction-wrapper" data-reduction-decimals="2">
                <input type="number" class="reduction-base-input section-Z-input" value="${(Z * 1e6).toFixed(2)}" title="Êñ≠Èù¢‰øÇÊï∞ Z (cm¬≥)">
                <div><span>‰ΩéÊ∏õ‰øÇÊï∞Ôºö</span><input type="number" class="reduction-factor-input section-Z-factor" value="1.0" step="0.01" title="‰ΩéÊ∏õ‰øÇÊï∞" placeholder="‰ΩéÊ∏õ‰øÇÊï∞"></div>
                <div class="reduced-label" style="display:none;">‰ΩéÊ∏õÂæåÔºö<span class="reduced-value"></span></div>
            </div>`,
            // ËøΩÂä†: Êñ≠Èù¢2Ê¨°ÂçäÂæÑ i (cm) ÂÖ•ÂäõÔºàÁ∑®ÈõÜÂèØËÉΩÔºâ
            `<div class="cell-input-wrapper reduction-wrapper" data-reduction-decimals="2">
                <input type="number" class="radius-i-input col-buckling reduction-base-input section-i-input" value="${i_rad !== '' ? Number(i_rad).toFixed(2) : ''}" title="Êñ≠Èù¢2Ê¨°ÂçäÂæÑ i (cm)">
                <div><span>‰ΩéÊ∏õ‰øÇÊï∞Ôºö</span><input type="number" class="reduction-factor-input section-i-factor" value="1.0" step="0.01" title="‰ΩéÊ∏õ‰øÇÊï∞" placeholder="‰ΩéÊ∏õ‰øÇÊï∞"></div>
                <div class="reduced-label" style="display:none;">‰ΩéÊ∏õÂæåÔºö<span class="reduced-value"></span></div>
                <span class="auto-label" style="display:none;">(Ëá™Âãï)</span>
            </div>`,
            `<div class="cell-input-wrapper">
                <input type="number" class="section-J-input col-section" value="${(J_cm4 !== undefined && J_cm4 !== null && String(J_cm4).trim() !== '') ? J_cm4 : ''}" step="any" title="„Å≠„Åò„ÇäÂÆöÊï∞ J (cm‚Å¥)">
            </div>`,
            `<div class="cell-input-wrapper">
                <input type="number" class="section-Iw-input col-section" value="${(Iw_cm6 !== undefined && Iw_cm6 !== null && String(Iw_cm6).trim() !== '') ? Iw_cm6 : ''}" step="any" title="Êõ≤„Åí„Å≠„Åò„ÇäÂÆöÊï∞ Iw (cm‚Å∂)">
            </div>`
        ];

        // „Éê„ÉçÂÖ•ÂäõÈÉ®ÂàÜ„ÅÆHTML„ÉÜ„É≥„Éó„É¨„Éº„ÉàÁîüÊàêÈñ¢Êï∞ÔºàÂçò‰ΩçË°®Á§∫„Éª„É¨„Ç§„Ç¢„Ç¶„ÉàË™øÊï¥ÁâàÔºâ
        const createSpringInputs = (prefix) => `
        <div class="spring-inputs" style="display:none; margin-top:4px; padding:6px 4px; background-color:#f8f9fa; border:1px solid #e9ecef; border-radius:4px; text-align:left; width: 100%; box-sizing: border-box;">
            
            <div style="display:flex; align-items:center; justify-content:space-between; margin-bottom:4px;">
                <div style="display:flex; flex-direction:column; line-height:1;">
                    <span style="font-size:10px; font-weight:bold; color:#555;">Kx</span>
                    <span style="font-size:9px; color:#888; transform:scale(0.9); transform-origin:left top;">(kN/mm)</span>
                </div>
                <div style="display:flex; flex-direction:column; align-items:flex-end; gap:4px;">
                    <input class="spring-kx" type="number" min="0" step="0.01" value="0" style="width:45px; padding:1px; font-size:10px; border:1px solid #ccc; border-radius:2px;">
                    <label style="font-size:10px; display:flex; align-items:center; cursor:pointer; margin:0;">
                        <input type="checkbox" class="spring-rigid-kx" style="margin:0 4px 0 0; vertical-align:middle;" 
                               onchange="this.closest('.spring-inputs').querySelector('.spring-kx').disabled = this.checked">Ââõ
                    </label>
                </div>
            </div>

            <div style="display:flex; align-items:center; justify-content:space-between; margin-bottom:4px;">
                <div style="display:flex; flex-direction:column; line-height:1;">
                    <span style="font-size:10px; font-weight:bold; color:#555;">Ky</span>
                    <span style="font-size:9px; color:#888; transform:scale(0.9); transform-origin:left top;">(kN/mm)</span>
                </div>
                <div style="display:flex; flex-direction:column; align-items:flex-end; gap:4px;">
                    <input class="spring-ky" type="number" min="0" step="0.01" value="0" style="width:45px; padding:1px; font-size:10px; border:1px solid #ccc; border-radius:2px;">
                    <label style="font-size:10px; display:flex; align-items:center; cursor:pointer; margin:0;">
                        <input type="checkbox" class="spring-rigid-ky" style="margin:0 4px 0 0; vertical-align:middle;" 
                               onchange="this.closest('.spring-inputs').querySelector('.spring-ky').disabled = this.checked">Ââõ
                    </label>
                </div>
            </div>

            <div style="display:flex; align-items:center; justify-content:space-between;">
                <div style="display:flex; flex-direction:column; line-height:1;">
                    <span style="font-size:10px; font-weight:bold; color:#555;">Kr</span>
                    <span style="font-size:8px; color:#888; transform:scale(0.85); transform-origin:left top;">(kN¬∑mm/rad)</span>
                </div>
                <div style="display:flex; flex-direction:column; align-items:flex-end; gap:4px;">
                    <input class="spring-kr" type="number" min="0" step="0.01" value="0" style="width:45px; padding:1px; font-size:10px; border:1px solid #ccc; border-radius:2px;">
                    <label style="font-size:10px; display:flex; align-items:center; cursor:pointer; margin:0;">
                        <input type="checkbox" class="spring-rigid-kr" style="margin:0 4px 0 0; vertical-align:middle;" 
                               onchange="this.closest('.spring-inputs').querySelector('.spring-kr').disabled = this.checked">Ââõ
                    </label>
                </div>
            </div>
            
        </div>
    `;

        // Ëá™ÈáçËÄÉÊÖÆ„ÉÅ„Çß„ÉÉ„ÇØ„Éú„ÉÉ„ÇØ„Çπ„Åå„Ç™„É≥„ÅÆÂ†¥Âêà„ÄÅÂØÜÂ∫¶Âàó„ÇíËøΩÂä†
        // „Éó„É™„Çª„ÉÉ„ÉàË™≠„ÅøËæº„Åø‰∏≠„ÅØÂØÜÂ∫¶Âàó„ÅÆË°®Á§∫Áä∂ÊÖã„Å´Èñ¢‰øÇ„Å™„ÅèËøΩÂä†„Åó„Å™„ÅÑ
        const shouldAddDensity = !window.isLoadingPreset &&
                                elements.considerSelfWeightCheckbox &&
                                elements.considerSelfWeightCheckbox.checked;

        if (shouldAddDensity) {
            const density = MATERIAL_DENSITY_DATA[E] || MATERIAL_DENSITY_DATA['custom'];
            baseColumns.push(createDensityInputHTML(`member-density-${i}-${j}`, density));
        }

        // Â∫ßÂ±à‰øÇÊï∞ÂÖ•Âäõ„Çª„É´ (ÂØÜÂ∫¶„ÅÆÂæå„Å´ËøΩÂä†)
        baseColumns.push(`
            <div class="cell-input-wrapper">
                <input type=\"number\" class=\"buckling-k-input col-buckling\" value=\"${bucklingK}\" step=\"0.1\" min=\"0.1\" max=\"10.0\" placeholder=\"Ëá™Âãï\" style=\"width:50px;\" title=\"Á©∫Ê¨Ñ„ÅÆÂ†¥Âêà„ÅØÊé•ÂêàÊù°‰ª∂„Åã„ÇâËá™ÂãïÂà§ÂÆö\">
                <span class="auto-label" style="display:none;">(Ëá™Âãï)</span>
            </div>
        `);

        // Êñ≠Èù¢ÂêçÁß∞„Å®Ëª∏ÊñπÂêë„ÅÆÂàó„ÇíËøΩÂä†
        baseColumns.push(`<span class="section-name-cell">${sectionName || '-'}</span>`);
        baseColumns.push(`<span class="section-axis-cell">${sectionAxis || '-'}</span>`);

        // Êé•Á∂öÊù°‰ª∂Âàó„ÇíËøΩÂä†
        // ÂêÑÊé•Á∂ö„Çª„É´ÂÜÖ„Å´„Éê„ÉçÈÅ∏ÊäûÊôÇ„ÅÆ„ÅøË°®Á§∫„Åô„Çã„Éê„ÉçÂâõÊÄßÂÖ•Âäõ„Éñ„É≠„ÉÉ„ÇØ„ÇíÂê´„ÇÅ„Çã
        baseColumns.push(`
            <div class="conn-cell">
                <select class="conn-select"><option value="rigid" ${i_conn === 'rigid' ? 'selected' : ''}>Ââõ</option><option value="pinned" ${i_conn === 'pinned' || i_conn === 'pin' || i_conn === 'p' ? 'selected' : ''}>„Éî„É≥</option><option value="spring" ${i_conn === 'spring' ? 'selected' : ''}>„Éê„Éç</option></select>
                ${createSpringInputs(`i`)}
            </div>
        `);
        baseColumns.push(`
            <div class="conn-cell">
                <select class="conn-select"><option value="rigid" ${j_conn === 'rigid' ? 'selected' : ''}>Ââõ</option><option value="pinned" ${j_conn === 'pinned' || j_conn === 'pin' || j_conn === 'p' ? 'selected' : ''}>„Éî„É≥</option><option value="spring" ${j_conn === 'spring' ? 'selected' : ''}>„Éê„Éç</option></select>
                ${createSpringInputs(`j`)}
            </div>
        `);

        return baseColumns;
    };
    window.memberRowHTML = memberRowHTML;
    
const p_truss = {
    ic: 'p',
    jc: 'p',
    E: UNIT_CONVERSION.E_STEEL,
    I: 1e-7, // Ë°®Á§∫ÊôÇ„Å´0„Å´„Å™„Çâ„Å™„ÅÑ„ÉÄ„Éü„ÉºÂÄ§
    Z: 1e-6, // Ë°®Á§∫ÊôÇ„Å´0„Å´„Å™„Çâ„Å™„ÅÑ„ÉÄ„Éü„ÉºÂÄ§
};

const STRONG_AXIS_INFO = Object.freeze({ key: 'x', mode: 'strong', label: 'Âº∑Ëª∏ (XËª∏)' });

const PRESET_SECTION_IMAGE_URLS = {
    hkatakou_hoso: 'https://arkhitek.co.jp/wp-content/uploads/2025/09/HÂΩ¢Èãº.png',
    hkatakou_hiro: 'https://arkhitek.co.jp/wp-content/uploads/2025/09/HÂΩ¢Èãº.png'
};

const cloneDeep = (value) => (value === undefined || value === null) ? value : JSON.parse(JSON.stringify(value));

const approxEqual = (a, b) => {
    if (typeof a !== 'number' || typeof b !== 'number') return false;
    const tolerance = Math.max(1e-9, Math.abs(a) * 1e-4);
    return Math.abs(a - b) <= tolerance;
};

const formatDimensionValue = (value) => {
    if (typeof value !== 'number' || !isFinite(value)) return value;
    return Math.abs(value - Math.round(value)) < 1e-6 ? Math.round(value) : Number(value.toFixed(2));
};

const buildSectionDiagramData = (typeKey, rawDims = {}, options = {}) => {
    const {
        labelScaleMultiplier = 1,
        showDimensions = true  // ÂØ∏Ê≥ïÁ∑ö„Å®ÂØ∏Ê≥ïÂÄ§„ÅÆË°®Á§∫/ÈùûË°®Á§∫„ÇíÂà∂Âæ°
    } = options || {};

    const numericDims = Object.fromEntries(
        Object.entries(rawDims).map(([key, value]) => {
            const num = Number(value);
            return [key, Number.isFinite(num) ? num : null];
        })
    );

    const sanitize = (value) => (Number.isFinite(value) && value > 0 ? value : null);

    const formatPrimaryDimension = (value) => {
        if (!Number.isFinite(value)) return '';
        return Math.round(value).toString();
    };

    const formatThicknessDimension = (value) => {
        if (!Number.isFinite(value)) return '';
        return (Math.round(value * 10) / 10).toFixed(1);
    };

    const buildLabelLines = (lines) => {
        if (!Array.isArray(lines)) return [];
        return lines
            .map((line) => (line === null || line === undefined ? '' : String(line).trim()))
            .filter((line) => line.length > 0);
    };

    const mmLabel = (symbol, value) => {
        const formatted = formatPrimaryDimension(value);
        if (symbol === 'B') {
            const singleLine = formatted ? `${symbol} = ${formatted} mm` : `${symbol} = ‚Äï`;
            return buildLabelLines([singleLine]);
        }
        return buildLabelLines([`${symbol} =`, formatted ? `${formatted} mm` : '‚Äï']);
    };

    const thicknessLabel = (symbol, value) => {
        const formatted = formatThicknessDimension(value);
        return buildLabelLines([`${symbol} =`, formatted ? `${formatted} mm` : '‚Äï']);
    };

    const phiLabel = (value) => {
        const formatted = formatPrimaryDimension(value);
        return buildLabelLines([formatted ? `œÜ ${formatted} mm` : 'œÜ ‚Äï']);
    };

    const createHelpers = (maxDim, fontSize) => {
        const baseGap = Math.max(maxDim * 0.12, fontSize * 0.85, 18);
        const smallGap = Math.max(maxDim * 0.08, fontSize * 0.7, 14);
        const lineHeight = fontSize * 1.2;

        const normalizeLabelLines = (label) => {
            if (Array.isArray(label)) {
                const cleaned = label.filter((line) => line !== null && line !== undefined && String(line).trim().length > 0).map(String);
                return cleaned.length > 0 ? cleaned : ['‚Äï'];
            }
            if (label && typeof label === 'object' && Array.isArray(label.lines)) {
                const cleaned = label.lines.filter((line) => line !== null && line !== undefined && String(line).trim().length > 0).map(String);
                return cleaned.length > 0 ? cleaned : ['‚Äï'];
            }
            if (label === null || label === undefined) return ['‚Äï'];
            const value = String(label).trim();
            return value.length > 0 ? [value] : ['‚Äï'];
        };

        const buildLabelMarkup = (lines, x) => {
            if (!Array.isArray(lines) || lines.length === 0) return '';
            const totalHeight = lineHeight * Math.max(0, lines.length - 1);
            const firstDy = lines.length === 1 ? 0 : -(totalHeight / 2);

            return lines
                .map((line, index) => {
                    const dyValue = index === 0 ? firstDy : lineHeight;
                    const dyAttr = index === 0 && lines.length === 1 ? '' : ` dy="${dyValue.toFixed(2)}px"`;
                    return `<tspan x="${x}"${dyAttr}>${line}</tspan>`;
                })
                .join('');
        };

        const adjustGapForLines = (gap, lineCount) => {
            if (!Number.isFinite(gap) || lineCount <= 1) return gap;
            const extra = lineHeight * (lineCount - 1) * 0.65;
            return gap + extra;
        };

        const horizontalDim = (x1, x2, y, label, { position = 'below', gap = baseGap, anchor = 'middle', extraClass = '' } = {}) => {
            const textX = anchor === 'start' ? x1 : anchor === 'end' ? x2 : (x1 + x2) / 2;
            const lines = normalizeLabelLines(label);
            const lineCount = lines.length;
            const adjustedGap = adjustGapForLines(gap, lineCount);
            const textY = position === 'below' ? y + adjustedGap : y - adjustedGap;
            const markup = buildLabelMarkup(lines, textX);
            return `
                <g class="dimension horizontal ${extraClass}">
                    <line class="dim-line" x1="${x1}" y1="${y}" x2="${x2}" y2="${y}" />
                    <text class="dim-label" x="${textX}" y="${textY}" text-anchor="${anchor}" dominant-baseline="middle">${markup}</text>
                </g>
            `;
        };

        const verticalDim = (x, y1, y2, label, { side = 'left', gap = baseGap, extraClass = '' } = {}) => {
            const textAnchor = side === 'right' ? 'start' : 'end';
            const textY = (y1 + y2) / 2;
            const lines = normalizeLabelLines(label);
            const lineCount = lines.length;
            const adjustedGap = adjustGapForLines(gap, lineCount);
            const finalX = side === 'right' ? x + adjustedGap : x - adjustedGap;
            const markup = buildLabelMarkup(lines, finalX);
            return `
                <g class="dimension vertical ${extraClass}">
                    <line class="dim-line" x1="${x}" y1="${y1}" x2="${x}" y2="${y2}" />
                    <text class="dim-label" x="${finalX}" y="${textY}" text-anchor="${textAnchor}" dominant-baseline="middle">${markup}</text>
                </g>
            `;
        };

        return { horizontalDim, verticalDim, baseGap, smallGap };
    };

    const calculateLabelOptions = (maxDim, scale = 1) => {
        const safeScale = Number.isFinite(scale) && scale > 0 ? scale : 1;

        if (!Number.isFinite(maxDim) || maxDim <= 0) {
            const baseFontSize = 28;
            const fontSize = baseFontSize * safeScale;
            return {
                fontSize,
                baseFontSize,
                scale: safeScale,
                labelStrokeWidth: 0.6 * Math.max(1, safeScale)
            };
        }

        const baseFontSize = Math.max(24, Math.min(56, maxDim * 0.18));
        const fontSize = baseFontSize * safeScale;
        const labelStrokeWidth = (fontSize >= 42 ? 0.8 : 0.6) * Math.max(1, safeScale * 0.9);
        return { fontSize, baseFontSize, scale: safeScale, labelStrokeWidth };
    };

    const calculateDiagramMargin = (maxDim, labelOptions = {}) => {
        let options = labelOptions;
        if (typeof labelOptions === 'number') {
            options = { fontSize: labelOptions, baseFontSize: labelOptions, scale: 1 };
        } else if (!labelOptions || typeof labelOptions !== 'object') {
            options = {};
        }

        const { fontSize, baseFontSize, scale = 1 } = options;
        const safeFont = Number.isFinite(fontSize) && fontSize > 0 ? fontSize : 32;
        const safeBase = Number.isFinite(baseFontSize) && baseFontSize > 0 ? baseFontSize : safeFont;
        const safeScale = Number.isFinite(scale) && scale > 0 ? scale : 1;
        const scaleFactor = Math.pow(safeScale, 0.65);

        if (!Number.isFinite(maxDim) || maxDim <= 0) {
            const fallbackGap = Math.max(safeBase * 0.9, 24);
            const baseMargin = Math.max(72, safeBase * 3.2, fallbackGap * 2.8);
            return baseMargin / scaleFactor;
        }

        const gapEstimate = Math.max(maxDim * 0.12, safeBase * 0.9, 20);
        const sideGapEstimate = Math.max(maxDim * 0.16, safeBase * 1.1, 24);
        const baseMargin = Math.max(maxDim * 0.52, 60);
        const fontMargin = safeFont * 3.2;
        const rawMargin = Math.max(baseMargin, fontMargin, gapEstimate * 3, sideGapEstimate * 2.4);
        return rawMargin / scaleFactor;
    };

    const wrapSvg = (viewBox, bodyMarkup, dimensionMarkup = '', thicknessMarkup = '', { fontSize = 18, labelStrokeWidth = 0.6 } = {}) => {
        const style = `
            .section-body {
                fill: #3b82f6;
                stroke: #1d4ed8;
                stroke-width: 1.4;
                stroke-linejoin: round;
            }
            .section-body * {
                fill: inherit;
                stroke: inherit;
            }
            .section-body .void {
                fill: #ffffff;
            }
            .dimension .dim-line {
                stroke: #0f172a;
                stroke-width: 1.2;
                fill: none;
                vector-effect: non-scaling-stroke;
            }
            .dimension .dim-label {
                font-family: 'Segoe UI', 'Hiragino Sans', sans-serif;
                font-weight: 600;
                font-size: ${fontSize}px;
                fill: #0f172a;
                stroke: #ffffff;
                stroke-width: ${labelStrokeWidth};
                paint-order: stroke fill;
            }
            .dimension.thickness .dim-line {
                stroke: #1e3a8a;
            }
            .dimension.thickness .dim-label {
                fill: #1e3a8a;
            }
        `;

        const defs = `
            <defs>
                <style>${style}</style>
            </defs>
        `;

        // showDimensions„Ååfalse„ÅÆÂ†¥Âêà„ÅØÂØ∏Ê≥ïÁ∑ö„ÇíÈùûË°®Á§∫
        const finalDimensionMarkup = showDimensions ? dimensionMarkup : '';
        const finalThicknessMarkup = showDimensions ? thicknessMarkup : '';

        return {
            viewBox,
            markup: `${defs}<g class="section-body">${bodyMarkup}</g><g class="dim-layer">${finalDimensionMarkup}</g><g class="dim-layer thickness">${finalThicknessMarkup}</g>`
        };
    };

    const renderHSection = (dims, { includeLip = false } = {}) => {
        const H = sanitize(dims.H);
        const B = sanitize(dims.B);
        const web = sanitize(dims.t1);
        const flange = sanitize(dims.t2);
        const lip = includeLip ? sanitize(dims.C) : null;

        if (!H || !B || !web || !flange) return null;

        const width = B;
        const height = H;
        const maxDim = Math.max(width, height);
        const labelOptions = calculateLabelOptions(maxDim, labelScaleMultiplier);
        const margin = calculateDiagramMargin(maxDim, labelOptions);
        const viewBox = `${-width / 2 - margin} ${-height / 2 - margin} ${width + margin * 2} ${height + margin * 2}`;
        const { horizontalDim, verticalDim, baseGap, smallGap } = createHelpers(maxDim, labelOptions.fontSize);

        const shapes = [
            `<rect x="${-web / 2}" y="${-height / 2}" width="${web}" height="${height}" />`,
            `<rect x="${-width / 2}" y="${-height / 2}" width="${width}" height="${flange}" />`,
            `<rect x="${-width / 2}" y="${height / 2 - flange}" width="${width}" height="${flange}" />`
        ];

        if (includeLip && lip && lip > flange / 1.5) {
            const lipHeight = Math.min(lip, height / 2);
            shapes.push(`<rect x="${-width / 2}" y="${-height / 2}" width="${flange}" height="${lipHeight}" />`);
            shapes.push(`<rect x="${width / 2 - flange}" y="${-height / 2}" width="${flange}" height="${lipHeight}" />`);
            shapes.push(`<rect x="${-width / 2}" y="${height / 2 - lipHeight}" width="${flange}" height="${lipHeight}" />`);
            shapes.push(`<rect x="${width / 2 - flange}" y="${height / 2 - lipHeight}" width="${flange}" height="${lipHeight}" />`);
        }

        const dimensions = [
            verticalDim(-width / 2 - margin * 0.55, -height / 2, height / 2, mmLabel('H', H), { side: 'left', gap: baseGap }),
            horizontalDim(-width / 2, width / 2, height / 2 + margin * 0.55, mmLabel('B', B), { position: 'below', gap: baseGap })
        ].join('');

        const thickness = [
            horizontalDim(-web / 2, web / 2, -height / 2 - margin * 0.35, thicknessLabel('t‚ÇÅ', web), { position: 'above', gap: smallGap }),
            verticalDim(width / 2 + margin * 0.45, -height / 2, -height / 2 + flange, thicknessLabel('t‚ÇÇ', flange), { side: 'right', gap: baseGap })
        ];

        if (includeLip && lip) {
            thickness.push(
                verticalDim(width / 2 + margin * 0.7, -height / 2, -height / 2 + lip, thicknessLabel('C', lip), { side: 'right', gap: baseGap * 0.8 })
            );
        }

        return wrapSvg(viewBox, shapes.join(''), dimensions, thickness.join(''), labelOptions);
    };

    const renderChannelSection = (dims) => {
        const H = sanitize(dims.H);
        const flangeWidth = sanitize(dims.B) || sanitize(dims.A);
        const webThickness = sanitize(dims.t1) || sanitize(dims.t);
        const flangeThickness = sanitize(dims.t2) || sanitize(dims.t);
        const lip = sanitize(dims.C);

        if (!H || !flangeWidth || !webThickness || !flangeThickness) return null;

        const width = flangeWidth;
        const height = H;
        const maxDim = Math.max(width, height);
        const labelOptions = calculateLabelOptions(maxDim, labelScaleMultiplier);
        const margin = calculateDiagramMargin(maxDim, labelOptions.fontSize);
        const viewBox = `${-width / 2 - margin} ${-height / 2 - margin} ${width + margin * 2} ${height + margin * 2}`;
        const { horizontalDim, verticalDim, baseGap, smallGap } = createHelpers(maxDim, labelOptions.fontSize);

        const webX = -width / 2;
        const shapes = [
            `<rect x="${webX}" y="${-height / 2}" width="${webThickness}" height="${height}" />`,
            `<rect x="${webX}" y="${-height / 2}" width="${width}" height="${flangeThickness}" />`,
            `<rect x="${webX}" y="${height / 2 - flangeThickness}" width="${width}" height="${flangeThickness}" />`
        ];

        if (lip && lip > flangeThickness) {
            const lipHeight = Math.min(lip, height / 2);
            shapes.push(`<rect x="${width / 2 - flangeThickness}" y="${-height / 2}" width="${flangeThickness}" height="${lipHeight}" />`);
            shapes.push(`<rect x="${width / 2 - flangeThickness}" y="${height / 2 - lipHeight}" width="${flangeThickness}" height="${lipHeight}" />`);
        }

        const dimensions = [
            verticalDim(-width / 2 - margin * 0.55, -height / 2, height / 2, mmLabel('H', H), { side: 'left', gap: baseGap }),
            horizontalDim(-width / 2, width / 2, height / 2 + margin * 0.55, mmLabel('B', flangeWidth), { position: 'below', gap: baseGap })
        ].join('');

        const thickness = [
            horizontalDim(-webThickness / 2, webThickness / 2, -height / 2 - margin * 0.3, thicknessLabel('t‚ÇÅ', webThickness), { position: 'above', gap: smallGap }),
            verticalDim(width / 2 + margin * 0.45, -height / 2, -height / 2 + flangeThickness, thicknessLabel('t‚ÇÇ', flangeThickness), { side: 'right', gap: baseGap })
        ];

        if (lip && lip > flangeThickness) {
            thickness.push(
                verticalDim(width / 2 + margin * 0.7, -height / 2, -height / 2 + lip, thicknessLabel('C', lip), { side: 'right', gap: baseGap * 0.8 })
            );
        }

        return wrapSvg(viewBox, shapes.join(''), dimensions, thickness.join(''), labelOptions);
    };

    // ËªΩ„Åø„ÅûÂΩ¢Èãº„Å®„É™„ÉÉ„ÉóÊ∫ùÂΩ¢ÈãºÁî®„ÅÆÂ∞ÇÁî®ÊèèÁîªÈñ¢Êï∞ÔºàÊùøÂéö t „ÅÆ„ÅøË°®Á§∫Ôºâ
    const renderLightChannelSection = (dims) => {
        const H = sanitize(dims.H);
        const flangeWidth = sanitize(dims.B) || sanitize(dims.A);
        const t = sanitize(dims.t) || sanitize(dims.t1) || sanitize(dims.t2); // Áµ±‰∏Ä„Åï„Çå„ÅüÊùøÂéö 't' „Çí‰ΩøÁî®
        const lip = sanitize(dims.C);

        if (!H || !flangeWidth || !t) return null;

        const width = flangeWidth;
        const height = H;
        const maxDim = Math.max(width, height);
        const labelOptions = calculateLabelOptions(maxDim, labelScaleMultiplier);
        const margin = calculateDiagramMargin(maxDim, labelOptions);
        const viewBox = `${-width / 2 - margin} ${-height / 2 - margin} ${width + margin * 2} ${height + margin * 2}`;
        const { horizontalDim, verticalDim, baseGap, smallGap } = createHelpers(maxDim, labelOptions.fontSize);

        const webX = -width / 2;
        const shapes = [
            `<rect x="${webX}" y="${-height / 2}" width="${t}" height="${height}" />`, // webThickness -> t
            `<rect x="${webX}" y="${-height / 2}" width="${width}" height="${t}" />`, // flangeThickness -> t
            `<rect x="${webX}" y="${height / 2 - t}" width="${width}" height="${t}" />`  // flangeThickness -> t
        ];

        if (lip && lip > t) { // flangeThickness -> t
            const lipHeight = Math.min(lip, height / 2);
            shapes.push(`<rect x="${width / 2 - t}" y="${-height / 2}" width="${t}" height="${lipHeight}" />`); // flangeThickness -> t
            shapes.push(`<rect x="${width / 2 - t}" y="${height / 2 - lipHeight}" width="${t}" height="${lipHeight}" />`); // flangeThickness -> t
        }

        const dimensions = [
            verticalDim(-width / 2 - margin * 0.55, -height / 2, height / 2, mmLabel('H', H), { side: 'left', gap: baseGap }),
            horizontalDim(-width / 2, width / 2, height / 2 + margin * 0.55, mmLabel('B', flangeWidth), { position: 'below', gap: baseGap })
        ].join('');

        const thickness = [
            // Áµ±‰∏Ä„Åï„Çå„ÅüÊùøÂéö 't' „ÅÆ„É©„Éô„É´„Çí1„Å§„Å†„ÅëË°®Á§∫
            verticalDim(width / 2 + margin * 0.45, height / 2 - t, height / 2, thicknessLabel('t', t), { side: 'right', gap: baseGap })
        ];

        if (lip && lip > t) {
            thickness.push(
                // CÔºà„É™„ÉÉ„ÉóÔºâ„ÅÆÂØ∏Ê≥ïË°®Á§∫„ÅØÁ∂≠ÊåÅ
                verticalDim(width / 2 + margin * 0.7, -height / 2, -height / 2 + lip, thicknessLabel('C', lip), { side: 'right', gap: baseGap * 0.8 })
            );
        }

        return wrapSvg(viewBox, shapes.join(''), dimensions, thickness.join(''), labelOptions);
    };

    const renderAngleSection = (dims) => {
        const A = sanitize(dims.A);
        const B = sanitize(dims.B) || A;
        const t = sanitize(dims.t);

        if (!A || !B || !t) return null;

        const width = B;
        const height = A;
        const maxDim = Math.max(width, height);
        const labelOptions = calculateLabelOptions(maxDim, labelScaleMultiplier);
        const margin = calculateDiagramMargin(maxDim, labelOptions);
        const viewBox = `${-width / 2 - margin} ${-height / 2 - margin} ${width + margin * 2} ${height + margin * 2}`;
        const { horizontalDim, verticalDim, baseGap, smallGap } = createHelpers(maxDim, labelOptions.fontSize);

        const leftX = -width / 2;
        const rightX = width / 2;
        const topY = -height / 2;
        const bottomY = height / 2;

        const verticalLeg = `<rect x="${leftX}" y="${topY}" width="${t}" height="${height}" />`;
        const horizontalLeg = `<rect x="${leftX}" y="${bottomY - t}" width="${width}" height="${t}" />`;
        const body = `<g>${verticalLeg}${horizontalLeg}</g>`;

        const dimensions = [
            verticalDim(leftX - margin * 0.45, topY, bottomY, mmLabel('A', A), { side: 'left', gap: baseGap }),
            horizontalDim(leftX, rightX, bottomY + margin * 0.55, mmLabel('B', B), { position: 'below', gap: baseGap })
        ].join('');

        const thickness = [
            horizontalDim(leftX, leftX + t, topY - margin * 0.3, thicknessLabel('t', t), { position: 'above', gap: smallGap, anchor: 'start' })
        ];

        return wrapSvg(viewBox, body, dimensions, thickness.join(''), labelOptions);
    };

    const renderRectTube = (dims) => {
        const outerH = sanitize(dims.A) || sanitize(dims.H);
        const outerB = sanitize(dims.B) || sanitize(dims.A);
        const t = sanitize(dims.t);

        if (!outerH || !outerB || !t) return null;

        const width = outerB;
        const height = outerH;
        const maxDim = Math.max(width, height);
        const labelOptions = calculateLabelOptions(maxDim, labelScaleMultiplier);
        const margin = calculateDiagramMargin(maxDim, labelOptions);
        const viewBox = `${-width / 2 - margin} ${-height / 2 - margin} ${width + margin * 2} ${height + margin * 2}`;
        const { horizontalDim, verticalDim, baseGap, smallGap } = createHelpers(maxDim, labelOptions.fontSize);

        const outerRect = `<rect x="${-width / 2}" y="${-height / 2}" width="${width}" height="${height}" />`;
        const innerRect = `<rect class="void" x="${-width / 2 + t}" y="${-height / 2 + t}" width="${width - 2 * t}" height="${height - 2 * t}" />`;
        const body = `<g>${outerRect}${innerRect}</g>`;

        const dimensions = [
            verticalDim(-width / 2 - margin * 0.45, -height / 2, height / 2, mmLabel('H', outerH), { side: 'left', gap: baseGap }),
            horizontalDim(-width / 2, width / 2, height / 2 + margin * 0.5, mmLabel('B', outerB), { position: 'below', gap: baseGap })
        ].join('');

        const thickness = [
            verticalDim(width / 2 + margin * 0.45, -height / 2, -height / 2 + t, thicknessLabel('t', t), { side: 'right', gap: smallGap })
        ].join('');

        return wrapSvg(viewBox, body, dimensions, thickness, labelOptions);
    };

    const renderPipe = (dims) => {
        const D = sanitize(dims.D);
        const t = sanitize(dims.t);

        if (!D) return null;

        const width = D;
        const height = D;
        const maxDim = D;
        const labelOptions = calculateLabelOptions(maxDim, labelScaleMultiplier);
        const margin = calculateDiagramMargin(maxDim, labelOptions);
        const viewBox = `${-width / 2 - margin} ${-height / 2 - margin} ${width + margin * 2} ${height + margin * 2}`;
        const { horizontalDim, verticalDim, baseGap, smallGap } = createHelpers(maxDim, labelOptions.fontSize);

        const outerCircle = `<circle cx="0" cy="0" r="${D / 2}" />`;
        const innerCircle = t && t < D / 2 ? `<circle class="void" cx="0" cy="0" r="${D / 2 - t}" />` : '';
        const body = `<g>${outerCircle}${innerCircle}</g>`;

        const dimensions = horizontalDim(-D / 2, D / 2, D / 2 + margin * 0.55, phiLabel(D), { position: 'below', gap: baseGap });

        const thickness = t
            ? verticalDim(D / 2 + margin * 0.45, -D / 2, -D / 2 + t, thicknessLabel('t', t), { side: 'right', gap: smallGap })
            : '';

        return wrapSvg(viewBox, body, dimensions, thickness, labelOptions);
    };

    const renderSolidRect = (dims) => {
        const H = sanitize(dims.H);
        const B = sanitize(dims.B);

        if (!H || !B) return null;

        const width = B;
        const height = H;
        const maxDim = Math.max(width, height);
        const labelOptions = calculateLabelOptions(maxDim, labelScaleMultiplier);
        const margin = calculateDiagramMargin(maxDim, labelOptions);
        const viewBox = `${-width / 2 - margin} ${-height / 2 - margin} ${width + margin * 2} ${height + margin * 2}`;
        const { horizontalDim, verticalDim, baseGap } = createHelpers(maxDim, labelOptions.fontSize);

        const body = `<rect x="${-width / 2}" y="${-height / 2}" width="${width}" height="${height}" />`;

        const dimensions = [
            verticalDim(-width / 2 - margin * 0.5, -height / 2, height / 2, mmLabel('H', H), { side: 'left', gap: baseGap }),
            horizontalDim(-width / 2, width / 2, height / 2 + margin * 0.5, mmLabel('B', B), { position: 'below', gap: baseGap })
        ].join('');

        return wrapSvg(viewBox, body, dimensions, '', labelOptions);
    };

    const renderSolidCircle = (dims) => {
        const D = sanitize(dims.D);

        if (!D) return null;

        const width = D;
        const maxDim = D;
    const labelOptions = calculateLabelOptions(maxDim, labelScaleMultiplier);
    const margin = calculateDiagramMargin(maxDim, labelOptions);
        const viewBox = `${-width / 2 - margin} ${-width / 2 - margin} ${width + margin * 2} ${width + margin * 2}`;
        const { horizontalDim, baseGap } = createHelpers(maxDim, labelOptions.fontSize);

        const body = `<circle cx="0" cy="0" r="${D / 2}" />`;
        const dimensions = horizontalDim(-D / 2, D / 2, D / 2 + margin * 0.5, phiLabel(D), { position: 'below', gap: baseGap });

        return wrapSvg(viewBox, body, dimensions, '', labelOptions);
    };

    const sectionBuilders = {
        hkatakou_hiro: (dims) => renderHSection(dims),
        hkatakou_naka: (dims) => renderHSection(dims),
        hkatakou_hoso: (dims) => renderHSection(dims),
        ikatakou: (dims) => renderHSection(dims),
        keiryouhkatakou: (dims) => renderHSection(dims),
        keiryourippuhkatakou: (dims) => renderHSection(dims, { includeLip: true }),
        mizogatakou: (dims) => renderChannelSection(dims), // „Åø„ÅûÂΩ¢Èãº„ÅØÊó¢Â≠ò„ÅÆÈñ¢Êï∞„ÇíÁ∂ôÁ∂ö‰ΩøÁî®
        keimizogatakou: (dims) => renderLightChannelSection(dims), // ËªΩ„Åø„ÅûÂΩ¢Èãº„ÅØÂ∞ÇÁî®Èñ¢Êï∞‰ΩøÁî®
        rippumizokatakou: (dims) => renderLightChannelSection(dims), // „É™„ÉÉ„ÉóÊ∫ùÂΩ¢Èãº„ÅØÂ∞ÇÁî®Èñ¢Êï∞‰ΩøÁî®
        touhenyamakatakou: (dims) => renderAngleSection(dims),
        futouhenyamagata: (dims) => renderAngleSection(dims),
        seihoukei: (dims) => renderRectTube({ ...dims, A: sanitize(dims.A), B: sanitize(dims.A), t: sanitize(dims.t) }),
        tyouhoukei: (dims) => renderRectTube(dims),
        koukan: (dims) => renderPipe(dims),
        'Áü©ÂΩ¢': (dims) => renderSolidRect(dims),
        'ÂÜÜÂΩ¢': (dims) => renderSolidCircle(dims)
    };

    const builder = sectionBuilders[typeKey];
    const result = builder ? builder(numericDims) : null;

    if (result) {
        return result;
    }

    const fallbackViewBox = '-120 -80 240 160';
    const fallbackMarkup = `<g class="section-body"><rect x="-40" y="-40" width="80" height="80" /></g>`;
    return {
        viewBox: fallbackViewBox,
        markup: `
            <defs>
                <style>
                    .section-body * { fill: #94a3b8; stroke: #475569; stroke-width: 1.2; }
                </style>
            </defs>
            ${fallbackMarkup}
        `
    };
};

const generateSectionSvgMarkup = (typeKey, dims) => {
    if (!typeKey || !dims) return '';
    const diagram = buildSectionDiagramData(typeKey, dims, { labelScaleMultiplier: 0.5, showDimensions: false });
    if (!diagram || !diagram.markup) return '';
    return `<svg xmlns="http://www.w3.org/2000/svg" viewBox="${diagram.viewBox}" width="240" height="180" role="img" aria-label="Êñ≠Èù¢Âõ≥">${diagram.markup}</svg>`;
};

const deriveSectionTypeKey = (sectionInfo) => {
    if (!sectionInfo || typeof sectionInfo !== 'object') return null;

    // Êó¢„Å´ÊòéÁ§∫„Åï„Çå„Å¶„ÅÑ„ÇãÂÄôË£ú„ÇíÂÑ™ÂÖà„ÄÇ„Åü„Å†„Åó„Éó„É¨„Éº„Çπ„Éõ„É´„ÉÄÔºà'unknown' Á≠âÔºâ„ÅØÁÑ°Ë¶ñ„Åô„Çã„ÄÇ
    const candidates = [
        sectionInfo.typeKey,
        sectionInfo.sectionType,
        sectionInfo.type,
        sectionInfo.profileKey,
        sectionInfo.profileType,
        sectionInfo.categoryKey
    ];
    const isPlaceholder = (v) => {
        if (typeof v !== 'string') return false;
        const t = v.trim().toLowerCase();
        return t === '' || /^(unknown|‰∏çÊòé|„Åù„ÅÆ‰ªñ|n\/a|na|none|unk)$/i.test(t);
    };
    const explicit = candidates.find(value => typeof value === 'string' && value.trim().length > 0 && !isPlaceholder(value));
    if (explicit) return explicit;

    // „É©„Éô„É´„ÇÑ typeLabel „Åã„Çâ„ÅÆÊé®ÂÆöÔºàÊâãÂãïÁ∑®ÈõÜ„Å´„Çà„Å£„Å¶ typeKey „ÅåÊ¨†ËêΩ„Åó„Å¶„ÅÑ„Çã„Ç±„Éº„Çπ„Å´ÂÇô„Åà„ÇãÔºâ
    const textSources = [sectionInfo.typeLabel, sectionInfo.label, sectionInfo.designation, sectionInfo.sectionLabel, sectionInfo.name]
        .filter(Boolean)
        .map(s => String(s).toLowerCase());

    const combined = textSources.join(' ');
    try {
        // „Åæ„Åö I ÂΩ¢Èãº„ÇíÂà§ÂÆöÔºà"IÂΩ¢" „ÇÑ "IÂΩ¢Èãº"„ÄÅËã±Ë™û„ÅÆ i-beam „Å™„Å©Ôºâ
        if (combined.includes('iÂΩ¢') || combined.includes('iÂΩ¢Èãº') || combined.includes('i-beam') || combined.includes('i beam') || combined.match(/\bi\b/) && combined.includes('ÂΩ¢')) {
            console.log('deriveSectionTypeKey: „É©„Éô„É´„Åã„Çâ IÂΩ¢Èãº „ÇíÊé®ÂÆö„Åó„Åæ„Åó„Åü', sectionInfo.label);
            return 'ikatakou';
        }

        if (combined.includes('hÂΩ¢Èãº') || combined.includes('hÂΩ¢')) {
            if (combined.includes('Â∫ÉÂπÖ') || combined.includes('„Å≤„Çç') || combined.includes('wide') || combined.match(/\bwide\b/)) {
                console.log('deriveSectionTypeKey: „É©„Éô„É´„Åã„Çâ HÂΩ¢ÈãºÔºàÂ∫ÉÂπÖÔºâ „ÇíÊé®ÂÆö„Åó„Åæ„Åó„Åü', sectionInfo.label);
                return 'hkatakou_hiro';
            }
            if (combined.includes('Á¥∞ÂπÖ') || combined.includes('„Åª„Åù') || combined.includes('narrow') || combined.match(/\bnarrow\b/)) {
                console.log('deriveSectionTypeKey: „É©„Éô„É´„Åã„Çâ HÂΩ¢ÈãºÔºàÁ¥∞ÂπÖÔºâ „ÇíÊé®ÂÆö„Åó„Åæ„Åó„Åü', sectionInfo.label);
                return 'hkatakou_hoso';
            }
            // „Éá„Éï„Ç©„É´„Éà„Åß H ÂΩ¢ÈãºÔºàÁ¥∞ÂπÖÔºâ„Çí„Åæ„ÅöËøî„Åô
            console.log('deriveSectionTypeKey: „É©„Éô„É´„Å´ HÂΩ¢Èãº „ÇíÂê´„ÇÄ„ÅåÂπÖÂà§ÂÆö„Åå„Åß„Åç„Å™„Åã„Å£„Åü„Åü„ÇÅÁ¥∞ÂπÖ„Çí‰ªÆÂÆö„Åó„Åæ„Åô', sectionInfo.label);
            return 'hkatakou_hoso';
        }

        // ‰ªñ„ÅÆ„Ç≠„Éº„ÉØ„Éº„Éâ„Éô„Éº„Çπ„ÅÆÊé®ÂÆöÔºàÂÜÜÂΩ¢„ÄÅÁü©ÂΩ¢„Å™„Å©Ôºâ
        if (combined.includes('ÂÜÜÂΩ¢') || combined.includes('œÜ') || combined.includes('ÂÜÜ')) {
            return 'circle';
        }
        if (combined.includes('Áü©ÂΩ¢') || combined.includes('Ëßí') || combined.includes('Èï∑Êñπ')) {
            return 'rectangle';
        }
    } catch (e) {
        console.warn('deriveSectionTypeKey: „É©„Éô„É´Ëß£Êûê‰∏≠„Å´„Ç®„É©„Éº', e, sectionInfo);
    }

    return null;
};

const parseDimensionValue = (value) => {
    if (value === null || value === undefined) return null;
    if (typeof value === 'number') return Number.isFinite(value) ? value : null;
    const numeric = Number.parseFloat(String(value).replace(/[^0-9.+-]/g, ''));
    return Number.isFinite(numeric) ? numeric : null;
};

const deriveSectionDimensions = (sectionInfo) => {
    if (!sectionInfo || typeof sectionInfo !== 'object') return null;

    const sourceCandidates = [sectionInfo.rawDims, sectionInfo.dims, sectionInfo.dimensionsMap];
    for (const candidate of sourceCandidates) {
        if (candidate && typeof candidate === 'object' && !Array.isArray(candidate)) {
            return Object.fromEntries(
                Object.entries(candidate)
                    .map(([key, value]) => [key, parseDimensionValue(value)])
                    .filter(([, value]) => Number.isFinite(value) && value > 0)
            );
        }
    }

    if (Array.isArray(sectionInfo.dimensions)) {
        const fromArray = Object.fromEntries(
            sectionInfo.dimensions
                .map((dim) => {
                    if (!dim || typeof dim !== 'object') return null;
                    const key = dim.key || dim.name || dim.label;
                    const value = parseDimensionValue(dim.value);
                    if (!key || !Number.isFinite(value) || value <= 0) return null;
                    return [key, value];
                })
                .filter(Boolean)
        );
        if (Object.keys(fromArray).length > 0) return fromArray;
    }

    return null;
};

window.ensureSectionSvgMarkup = (sectionInfo) => {
    if (!sectionInfo || typeof sectionInfo !== 'object') return sectionInfo;
    if (sectionInfo.svgMarkup && sectionInfo.svgMarkup.includes('<svg')) return sectionInfo;

    const typeKey = deriveSectionTypeKey(sectionInfo);
    const dims = deriveSectionDimensions(sectionInfo);

    if (!typeKey || !dims) return sectionInfo;

    // Ë£úÂÆå: Êé®ÂÆö„Åß„Åç„Åü typeKey „ÅØÊòéÁ§∫ÁöÑ„Å´‰øùÂ≠ò„Åó„Å¶„Åä„Åè
    try {
        if (!sectionInfo.typeKey || /^(unknown|‰∏çÊòé|„Åù„ÅÆ‰ªñ|n\/a|na|none|unk)$/i.test(String(sectionInfo.typeKey))) {
            sectionInfo.typeKey = typeKey;
        }
    } catch (e) {
        console.warn('ensureSectionSvgMarkup: typeKey Ë£úÂÆå„Å´Â§±Êïó„Åó„Åæ„Åó„Åü', e, sectionInfo);
    }

    const diagram = buildSectionDiagramData(typeKey, dims, { labelScaleMultiplier: 0.5, showDimensions: false });
    if (diagram && diagram.markup) {
        sectionInfo.svgMarkup = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="${diagram.viewBox}" width="240" height="180" role="img" aria-label="Êñ≠Èù¢Âõ≥">${diagram.markup}</svg>`;
        if (!sectionInfo.rawDims) {
            sectionInfo.rawDims = { ...dims };
        }
    }

    return sectionInfo;
};

const buildPresetSectionInfo = ({ typeKey, typeLabel, designation, dims }) => {
    const axis = { ...STRONG_AXIS_INFO };
    const dimensionEntries = [
        { key: 'H', label: 'H', value: formatDimensionValue(dims.H) },
        { key: 'B', label: 'B', value: formatDimensionValue(dims.B) },
        { key: 't1', label: 't‚ÇÅ', value: formatDimensionValue(dims.t1) },
        { key: 't2', label: 't‚ÇÇ', value: formatDimensionValue(dims.t2) }
    ];

    if (dims.r !== undefined) {
        dimensionEntries.push({ key: 'r', label: 'r', value: formatDimensionValue(dims.r) });
    }

    const dimensionSummary = dimensionEntries.map(d => `${d.label}=${d.value}`).join(', ');

    // ÊùøÂéö„Åæ„ÅßÂê´„Çì„Å†Ë©≥Á¥∞„Å™ÂêçÁß∞„ÇíÁîüÊàê
    let detailedLabel = typeLabel;
    if (designation) {
        // Âü∫Êú¨ÂØ∏Ê≥ïÔºàÈ´ò„Åï√óÂπÖÔºâ„Å´Âä†„Åà„Å¶ÊùøÂéöÊÉÖÂ†±„ÇíËøΩÂä†
        if (dims.t1 !== undefined && dims.t2 !== undefined) {
            detailedLabel = `${typeLabel} ${designation}√ó${dims.t1}√ó${dims.t2}`;
        } else if (dims.t !== undefined) {
            detailedLabel = `${typeLabel} ${designation}√ó${dims.t}`;
        } else {
            detailedLabel = `${typeLabel} ${designation}`;
        }
    }

    const sectionInfo = {
        typeKey,
        typeLabel,
        designation,
        label: detailedLabel.trim(),
        dimensions: dimensionEntries,
        dimensionSummary,
    svgMarkup: generateSectionSvgMarkup(typeKey, dims),
        imageUrl: PRESET_SECTION_IMAGE_URLS[typeKey] || '',
        rawDims: { ...dims },
        source: 'library',
        axis
    };

    return ensureSectionSvgMarkup(sectionInfo);
};

const PRESET_SECTION_PROFILES = [
    {
        target: { I: 7.21e-5, A: 4.678e-3, Z: 4.81e-4 },
        sectionInfo: buildPresetSectionInfo({
            typeKey: 'hkatakou_hoso',
            typeLabel: 'HÂΩ¢ÈãºÔºàÁ¥∞ÂπÖÔºâ',
            designation: '300√ó150',
            dims: { H: 300, B: 150, t1: 6.5, t2: 9, r: 13 }
        }),
        properties: { Zx: 481, Zy: 67.7, ix: 12.4, iy: 3.29 }
    },
    {
        target: { I: 1.10e-4, A: 5.245e-3, Z: 6.38e-4 },
        sectionInfo: buildPresetSectionInfo({
            typeKey: 'hkatakou_hoso',
            typeLabel: 'HÂΩ¢ÈãºÔºàÁ¥∞ÂπÖÔºâ',
            designation: '346√ó174',
            dims: { H: 346, B: 174, t1: 6, t2: 9, r: 13 }
        }),
        properties: { Zx: 638, Zy: 91, ix: 14.5, iy: 3.88 }
    },
    {
        target: { I: 1.81e-5, A: 2.667e-3, Z: 1.81e-4 },
        sectionInfo: buildPresetSectionInfo({
            typeKey: 'hkatakou_hoso',
            typeLabel: 'HÂΩ¢ÈãºÔºàÁ¥∞ÂπÖÔºâ',
            designation: '200√ó100',
            dims: { H: 200, B: 100, t1: 5.5, t2: 8, r: 8 }
        }),
        properties: { Zx: 181, Zy: 26.7, ix: 8.23, iy: 2.24 }
    },
    {
        target: { I: 3.96e-5, A: 3.697e-3, Z: 3.17e-4 },
        sectionInfo: buildPresetSectionInfo({
            typeKey: 'hkatakou_hoso',
            typeLabel: 'HÂΩ¢ÈãºÔºàÁ¥∞ÂπÖÔºâ',
            designation: '250√ó125',
            dims: { H: 250, B: 125, t1: 6, t2: 9, r: 8 }
        }),
        properties: { Zx: 317, Zy: 47, ix: 10.4, iy: 2.82 }
    },
    {
        target: { I: 1.35e-4, A: 6.291e-3, Z: 7.71e-4 },
        sectionInfo: buildPresetSectionInfo({
            typeKey: 'hkatakou_hoso',
            typeLabel: 'HÂΩ¢ÈãºÔºàÁ¥∞ÂπÖÔºâ',
            designation: '350√ó175',
            dims: { H: 350, B: 175, t1: 7, t2: 11, r: 13 }
        }),
        properties: { Zx: 771, Zy: 112, ix: 14.6, iy: 3.96 }
    },
    {
        target: { I: 2.35e-4, A: 8.337e-3, Z: 1.17e-3 },
        sectionInfo: buildPresetSectionInfo({
            typeKey: 'hkatakou_hoso',
            typeLabel: 'HÂΩ¢ÈãºÔºàÁ¥∞ÂπÖÔºâ',
            designation: '400√ó200',
            dims: { H: 400, B: 200, t1: 8, t2: 13, r: 13 }
        }),
        properties: { Zx: 1170, Zy: 174, ix: 16.8, iy: 4.56 }
    },
    {
        target: { I: 3.98e-4, A: 1.719e-2, Z: 2.28e-3 },
        sectionInfo: buildPresetSectionInfo({
            typeKey: 'hkatakou_hiro',
            typeLabel: 'HÂΩ¢ÈãºÔºàÂ∫ÉÂπÖÔºâ',
            designation: '350√ó350',
            dims: { H: 350, B: 350, t1: 12, t2: 19, r: 13 }
        }),
        properties: { Zx: 2280, Zy: 776, ix: 15.2, iy: 8.89 }
    },
    {
        target: { I: 5.61e-4, A: 1.868e-2, Z: 2.85e-3 },
        sectionInfo: buildPresetSectionInfo({
            typeKey: 'hkatakou_hiro',
            typeLabel: 'HÂΩ¢ÈãºÔºàÂ∫ÉÂπÖÔºâ',
            designation: '394√ó398',
            dims: { H: 394, B: 398, t1: 11, t2: 18, r: 22 }
        }),
        properties: { Zx: 2850, Zy: 951, ix: 17.3, iy: 10.1 }
    },
    {
        target: { I: 6.66e-4, A: 2.187e-2, Z: 3.33e-3 },
        sectionInfo: buildPresetSectionInfo({
            typeKey: 'hkatakou_hiro',
            typeLabel: 'HÂΩ¢ÈãºÔºàÂ∫ÉÂπÖÔºâ',
            designation: '400√ó400',
            dims: { H: 400, B: 400, t1: 13, t2: 21, r: 22 }
        }),
        properties: { Zx: 3330, Zy: 1120, ix: 17.5, iy: 10.1 }
    }
];

const findPresetSectionProfile = (member) => {
    if (!member || typeof member !== 'object') return null;
    return PRESET_SECTION_PROFILES.find(({ target }) =>
        approxEqual(member.I, target.I) &&
        approxEqual(member.A, target.A) &&
        approxEqual(member.Z, target.Z)
    ) || null;
};

// steel_data.js „ÅÆ window.steelData „Åã„Çâ„ÄÅÊñ≠Èù¢ÊÉÖÂ†±ÔºàtypeKey + ÂØ∏Ê≥ïÔºâ„Å´‰∏ÄËá¥„Åô„ÇãÊñ≠Èù¢ÂÆöÊï∞„ÇíÂèñÂæó
// ‚ÄªË®àÁÆó‰æã„Éó„É™„Çª„ÉÉ„Éà„Åß„ÇÇÊ®™Â∫ßÂ±àÊ§úÂÆö„Å´ÂøÖË¶Å„Å™ Iy/J/Iw „ÇíÊèÉ„Åà„Çã„Åü„ÇÅ
const lookupSteelDataPropertiesForSectionInfo = (sectionInfo) => {
    try {
        const typeKey = sectionInfo?.typeKey;
        const dims = sectionInfo?.rawDims;
        const steelData = window.steelData;
        if (!typeKey || !dims || !steelData || !steelData[typeKey]) return null;

        const category = steelData[typeKey];
        const headers = category?.headers;
        const data = category?.data;
        if (!Array.isArray(headers) || !Array.isArray(data) || data.length === 0) return null;

        const idx = (headerName) => headers.findIndex(h => String(h).trim() === headerName);
        const idxHB = idx('H√óB');
        const idxA = idx('Êñ≠Èù¢Á©ç(cm¬≤)');
        const idxIx = idx('Ix(cm‚Å¥)');
        const idxIy = idx('Iy(cm‚Å¥)');
        const idxZx = idx('Zx(cm¬≥)');
        const idxZy = idx('Zy(cm¬≥)');
        const idxix = idx('ix(cm)');
        const idxiy = idx('iy(cm)');
        const idxJ = idx('J(cm‚Å¥)');
        const idxIw = idx('Iw(cm‚Å∂)');

        const idxT1 = idx('t1');
        const idxT2 = idx('t2');
        const idxR = idx('r');

        const H = Number(dims.H);
        const B = Number(dims.B);
        if (!isFinite(H) || !isFinite(B)) return null;
        const hbKey = `${H}√ó${B}`;

        const t1 = dims.t1 !== undefined ? Number(dims.t1) : null;
        const t2 = dims.t2 !== undefined ? Number(dims.t2) : null;
        const r = dims.r !== undefined ? Number(dims.r) : null;

        const approxNum = (a, b, tol = 1e-6) => {
            if (!isFinite(a) || !isFinite(b)) return false;
            return Math.abs(a - b) <= tol;
        };

        const row = data.find((row) => {
            if (!Array.isArray(row)) return false;
            if (idxHB >= 0 && String(row[idxHB]).trim() !== hbKey) return false;
            if (idxT1 >= 0 && t1 !== null && !approxNum(Number(row[idxT1]), t1, 1e-3)) return false;
            if (idxT2 >= 0 && t2 !== null && !approxNum(Number(row[idxT2]), t2, 1e-3)) return false;
            if (idxR >= 0 && r !== null && !approxNum(Number(row[idxR]), r, 1e-3)) return false;
            return true;
        });

        if (!row) return null;

        const pick = (i) => (i >= 0 ? Number(row[i]) : null);

        return {
            // Âçò‰Ωç„ÅØ steelData „ÅÆ„Åæ„ÅæÔºàcmÁ≥ªÔºâ„ÅßËøî„Åô
            A: pick(idxA),
            Ix: pick(idxIx),
            Iy: pick(idxIy),
            Zx: pick(idxZx),
            Zy: pick(idxZy),
            ix: pick(idxix),
            iy: pick(idxiy),
            J: pick(idxJ),
            Iw: pick(idxIw)
        };
    } catch (e) {
        console.warn('lookupSteelDataPropertiesForSectionInfo failed', e);
        return null;
    }
};

const parseSectionInfoFromMember = (member) => {
    if (!member || typeof member !== 'object') return null;

    if (member.sectionInfo && typeof member.sectionInfo === 'object' && !Array.isArray(member.sectionInfo)) {
        const info = cloneDeep(member.sectionInfo);
        return ensureSectionSvgMarkup(info);
    }

    const resolveCandidate = (raw) => {
        if (typeof raw !== 'string') return null;
        const trimmed = raw.trim();
        if (!trimmed) return null;
        let decoded = trimmed;
        try {
            decoded = decodeURIComponent(trimmed);
        } catch (error) {
            // „Éá„Ç≥„Éº„Éâ„Å´Â§±Êïó„Åó„ÅüÂ†¥Âêà„ÅØÂÖÉ„ÅÆÊñáÂ≠óÂàó„Çí‰ΩøÁî®
        }
        try {
            const parsed = JSON.parse(decoded);
            return parsed && typeof parsed === 'object' ? ensureSectionSvgMarkup(parsed) : null;
        } catch (error) {
            console.warn('Failed to parse sectionInfo from preset member definition:', error, member);
            return null;
        }
    };

    return resolveCandidate(member.sectionInfo) || resolveCandidate(member.sectionInfoEncoded) || null;
};

const safeDecodeString = (value) => {
    if (typeof value !== 'string') return value;
    if (value.length === 0) return '';
    try {
        return decodeURIComponent(value);
    } catch (error) {
        return value;
    }
};

const buildAxisInfo = (member, existingSectionInfo) => {
    if (!member || typeof member !== 'object') return null;

    const axisFromSection = existingSectionInfo && typeof existingSectionInfo === 'object'
        ? existingSectionInfo.axis
        : null;

    const rawKey = member.sectionAxisKey || axisFromSection?.key;
    const rawMode = member.sectionAxisMode || axisFromSection?.mode;
    const rawLabelValue = typeof member.sectionAxisLabel === 'string'
        ? safeDecodeString(member.sectionAxisLabel)
        : axisFromSection?.label;

    if (!(rawKey || rawMode || rawLabelValue)) return null;

    return normalizeAxisInfo({
        key: rawKey,
        mode: rawMode,
        label: rawLabelValue
    });
};

const presets = [
    { name: '--- 1. Âü∫Êú¨„É¢„Éá„É´ (Basic Models) ---', disabled: true },
    // 1A-1: ÂçòÁ¥îÊ¢Å(‰∏≠Â§ÆÈõÜ‰∏≠Ëç∑Èáç) / Zreq‚âà425cm¬≥ -> H-300x150x6.5x9 (Zx=481cm¬≥) „ÇíÈÅ∏Êäû
    { name: '1A-1: ÂçòÁ¥îÊ¢Å (‰∏≠Â§ÆÈõÜ‰∏≠Ëç∑Èáç)', data: { nodes: [{x:0,y:0,s:'p'},{x:8,y:0,s:'r'},{x:4,y:0,s:'f'}], members: [{i:1,j:3, E:UNIT_CONVERSION.E_STEEL, I:7.21e-5, A:4.678e-3, Z:4.81e-4},{i:3,j:2, E:UNIT_CONVERSION.E_STEEL, I:7.21e-5, A:4.678e-3, Z:4.81e-4}], nl: [{n:3, py:-50}], ml: []} },
    // 1A-2: ÂçòÁ¥îÊ¢Å(Á≠âÂàÜÂ∏ÉËç∑Èáç) / Zreq‚âà531cm¬≥ -> H-346x174x6x9 (Zx=638cm¬≥) „ÇíÈÅ∏Êäû
    { name: '1A-2: ÂçòÁ¥îÊ¢Å (Á≠âÂàÜÂ∏ÉËç∑Èáç)', data: { nodes: [{x:0,y:0,s:'p'},{x:10,y:0,s:'r'}], members: [{i:1,j:2, E:UNIT_CONVERSION.E_STEEL, I:1.10e-4, A:5.245e-3, Z:6.38e-4}], nl: [], ml: [{m:1,w:10}]} },
    // 1A-3: ÁâáÊåÅ„Å°Ê¢Å(ÂÖàÁ´ØÈõÜ‰∏≠Ëç∑Èáç) / Zreq‚âà510cm¬≥ -> H-346x174x6x9 (Zx=638cm¬≥) „ÇíÈÅ∏Êäû
    { name: '1A-3: ÁâáÊåÅ„Å°Ê¢Å (ÂÖàÁ´ØÈõÜ‰∏≠Ëç∑Èáç)', data: { nodes: [{x:0,y:0,s:'x'},{x:6,y:0,s:'f'}], members: [{i:1,j:2, E:UNIT_CONVERSION.E_STEEL, I:1.10e-4, A:5.245e-3, Z:6.38e-4}], nl: [{n:2,py:-20}], ml: []} },
    // 1A-4: ÁâáÊåÅ„Å°Ê¢Å(Á≠âÂàÜÂ∏ÉËç∑Èáç) / Zreq‚âà425cm¬≥ -> H-300x150x6.5x9 (Zx=481cm¬≥) „ÇíÈÅ∏Êäû
    { name: '1A-4: ÁâáÊåÅ„Å°Ê¢Å (Á≠âÂàÜÂ∏ÉËç∑Èáç)', data: { nodes: [{x:0,y:0,s:'x'},{x:5,y:0,s:'f'}], members: [{i:1,j:2, E:UNIT_CONVERSION.E_STEEL, I:7.21e-5, A:4.678e-3, Z:4.81e-4}], nl: [], ml: [{m:1,w:8}]} },
    // 1A-5: ‰∏°Á´ØÂõ∫ÂÆöÊ¢Å(Á≠âÂàÜÂ∏ÉËç∑Èáç) / Zreq‚âà510cm¬≥ -> H-346x174x6x9 (Zx=638cm¬≥) „ÇíÈÅ∏Êäû
    { name: '1A-5: ‰∏°Á´ØÂõ∫ÂÆöÊ¢Å (Á≠âÂàÜÂ∏ÉËç∑Èáç)', data: { nodes: [{x:0,y:0,s:'x'},{x:12,y:0,s:'x'}], members: [{i:1,j:2, E:UNIT_CONVERSION.E_STEEL, I:1.10e-4, A:5.245e-3, Z:6.38e-4}], nl:[], ml:[{m:1,w:10}]} },
    // 1A-6: ÊåÅ„Å°Âá∫„ÅóÊ¢Å / Zreq‚âà191cm¬≥ -> H-200x100x5.5x8 (Zx=181cm¬≥) „ÇíÈÅ∏Êäû
    { name: '1A-6: ÊåÅ„Å°Âá∫„ÅóÊ¢Å', data: { nodes: [{x:0,y:0,s:'p'},{x:6,y:0,s:'r'},{x:9,y:0,s:'f'}], members: [{i:1,j:2, E:UNIT_CONVERSION.E_STEEL, I:1.81e-5, A:2.667e-3, Z:1.81e-4},{i:2,j:3, E:UNIT_CONVERSION.E_STEEL, I:1.81e-5, A:2.667e-3, Z:1.81e-4}], nl: [{n:3,py:-15}], ml: []} },
    // 1A-7: 2ÂæÑÈñìÈÄ£Á∂öÊ¢Å / Zreq‚âà340cm¬≥ -> H-300x150x6.5x9 (Zx=481cm¬≥) „ÇíÈÅ∏Êäû
    { name: '1A-7: 2ÂæÑÈñìÈÄ£Á∂öÊ¢Å', data: { nodes: [{x:0,y:0,s:'p'},{x:8,y:0,s:'r'},{x:16,y:0,s:'r'}], members:[{i:1,j:2, E:UNIT_CONVERSION.E_STEEL, I:7.21e-5, A:4.678e-3, Z:4.81e-4},{i:2,j:3, E:UNIT_CONVERSION.E_STEEL, I:7.21e-5, A:4.678e-3, Z:4.81e-4}], nl:[], ml:[{m:1,w:10},{m:2,w:10}]} },
    // 1A-8: LÂΩ¢„É©„Éº„É°„É≥ / Zreq‚âà255cm¬≥ -> H-250x125x6x9 (Zx=317cm¬≥) „ÇíÈÅ∏Êäû
    { name: '1A-8: LÂΩ¢„É©„Éº„É°„É≥ (Ë§áÂêàËç∑Èáç)', data: { nodes: [{x:0,y:0,s:'x'},{x:0,y:4,s:'f'},{x:6,y:4,s:'f'}], members:[{i:1,j:2, E:UNIT_CONVERSION.E_STEEL, I:3.96e-5, A:3.697e-3, Z:3.17e-4},{i:2,j:3, E:UNIT_CONVERSION.E_STEEL, I:3.96e-5, A:3.697e-3, Z:3.17e-4}], nl:[{n:3, py:-20},{n:2, px:15}], ml:[] } },
    // 1A-9: ÈñÄÂΩ¢„É©„Éº„É°„É≥ / Zreq‚âà255cm¬≥ -> H-250x125x6x9 (Zx=317cm¬≥) „ÇíÈÅ∏Êäû
    { name: '1A-9: ÈñÄÂΩ¢„É©„Éº„É°„É≥ (Ê∞¥Âπ≥Ëç∑Èáç)', data: { nodes: [{x:0, y:0, s:'x'},{x:0, y:4, s:'f'},{x:6, y:4, s:'f'},{x:6, y:0, s:'x'}], members: [{i:1, j:2, E:UNIT_CONVERSION.E_STEEL, I:3.96e-5, A:3.697e-3, Z:3.17e-4},{i:2, j:3, E:UNIT_CONVERSION.E_STEEL, I:3.96e-5, A:3.697e-3, Z:3.17e-4},{i:3, j:4, E:UNIT_CONVERSION.E_STEEL, I:3.96e-5, A:3.697e-3, Z:3.17e-4}], nl: [{n:2, px:30}], ml: [] } },
    { name: '--- 2. Âª∫ÁØâ„Éª„Éà„É©„ÇπÊßãÈÄ† (Buildings & Trusses) ---', disabled: true },
    // 2A-1: 2Â±§„É©„Éº„É°„É≥ / Ê¢Å:H-200x100 (Zx=181), Êü±:H-250x125 (Zx=317) „ÇíÈÅ∏Êäû
    { name: '2A-1: 2Â±§„É©„Éº„É°„É≥', data: { nodes: [{x:0,y:0,s:'x'},{x:6,y:0,s:'x'},{x:12,y:0,s:'x'},{x:0,y:3.5,s:'f'},{x:6,y:3.5,s:'f'},{x:12,y:3.5,s:'f'},{x:0,y:7,s:'f'},{x:6,y:7,s:'f'},{x:12,y:7,s:'f'}], members: [
        {i:1,j:4, E:UNIT_CONVERSION.E_STEEL, I:3.96e-5, A:3.697e-3, Z:3.17e-4},{i:2,j:5, E:UNIT_CONVERSION.E_STEEL, I:3.96e-5, A:3.697e-3, Z:3.17e-4},{i:3,j:6, E:UNIT_CONVERSION.E_STEEL, I:3.96e-5, A:3.697e-3, Z:3.17e-4},
        {i:4,j:7, E:UNIT_CONVERSION.E_STEEL, I:3.96e-5, A:3.697e-3, Z:3.17e-4},{i:5,j:8, E:UNIT_CONVERSION.E_STEEL, I:3.96e-5, A:3.697e-3, Z:3.17e-4},{i:6,j:9, E:UNIT_CONVERSION.E_STEEL, I:3.96e-5, A:3.697e-3, Z:3.17e-4},
        {i:4,j:5, E:UNIT_CONVERSION.E_STEEL, I:1.81e-5, A:2.667e-3, Z:1.81e-4},{i:5,j:6, E:UNIT_CONVERSION.E_STEEL, I:1.81e-5, A:2.667e-3, Z:1.81e-4},
        {i:7,j:8, E:UNIT_CONVERSION.E_STEEL, I:1.81e-5, A:2.667e-3, Z:1.81e-4},{i:8,j:9, E:UNIT_CONVERSION.E_STEEL, I:1.81e-5, A:2.667e-3, Z:1.81e-4}
    ], nl:[], ml:[{m:7,w:15},{m:8,w:15},{m:9,w:10},{m:10,w:10}]} },
    // 2A-2, 2A-3, 2A-4, 2A-5, 2B-1, 2B-2 ... 4C-4 ÂÖ®„Å¶„Å´ÂêåÊßò„ÅÆË™øÊï¥„ÇíÂÆüÊñΩ
    { name: '2A-2: 3Â±§„É©„Éº„É°„É≥', data: { nodes: [{x:0,y:0,s:'x'},{x:6,y:0,s:'x'},{x:12,y:0,s:'x'},{x:18,y:0,s:'x'},{x:0,y:3.5,s:'f'},{x:6,y:3.5,s:'f'},{x:12,y:3.5,s:'f'},{x:18,y:3.5,s:'f'},{x:0,y:7,s:'f'},{x:6,y:7,s:'f'},{x:12,y:7,s:'f'},{x:18,y:7,s:'f'},{x:0,y:10.5,s:'f'},{x:6,y:10.5,s:'f'},{x:12,y:10.5,s:'f'},{x:18,y:10.5,s:'f'}], members: [
        {i:1,j:5, E:UNIT_CONVERSION.E_STEEL, I:7.21e-5, A:4.678e-3, Z:4.81e-4},{i:2,j:6, E:UNIT_CONVERSION.E_STEEL, I:7.21e-5, A:4.678e-3, Z:4.81e-4},{i:3,j:7, E:UNIT_CONVERSION.E_STEEL, I:7.21e-5, A:4.678e-3, Z:4.81e-4},{i:4,j:8, E:UNIT_CONVERSION.E_STEEL, I:7.21e-5, A:4.678e-3, Z:4.81e-4},
        {i:5,j:9, E:UNIT_CONVERSION.E_STEEL, I:3.96e-5, A:3.697e-3, Z:3.17e-4},{i:6,j:10, E:UNIT_CONVERSION.E_STEEL, I:3.96e-5, A:3.697e-3, Z:3.17e-4},{i:7,j:11, E:UNIT_CONVERSION.E_STEEL, I:3.96e-5, A:3.697e-3, Z:3.17e-4},{i:8,j:12, E:UNIT_CONVERSION.E_STEEL, I:3.96e-5, A:3.697e-3, Z:3.17e-4},
        {i:9,j:13, E:UNIT_CONVERSION.E_STEEL, I:3.96e-5, A:3.697e-3, Z:3.17e-4},{i:10,j:14, E:UNIT_CONVERSION.E_STEEL, I:3.96e-5, A:3.697e-3, Z:3.17e-4},{i:11,j:15, E:UNIT_CONVERSION.E_STEEL, I:3.96e-5, A:3.697e-3, Z:3.17e-4},{i:12,j:16, E:UNIT_CONVERSION.E_STEEL, I:3.96e-5, A:3.697e-3, Z:3.17e-4},
        {i:5,j:6, E:UNIT_CONVERSION.E_STEEL, I:3.96e-5, A:3.697e-3, Z:3.17e-4},{i:6,j:7, E:UNIT_CONVERSION.E_STEEL, I:3.96e-5, A:3.697e-3, Z:3.17e-4},{i:7,j:8, E:UNIT_CONVERSION.E_STEEL, I:3.96e-5, A:3.697e-3, Z:3.17e-4},
        {i:9,j:10, E:UNIT_CONVERSION.E_STEEL, I:3.96e-5, A:3.697e-3, Z:3.17e-4},{i:10,j:11, E:UNIT_CONVERSION.E_STEEL, I:3.96e-5, A:3.697e-3, Z:3.17e-4},{i:11,j:12, E:UNIT_CONVERSION.E_STEEL, I:3.96e-5, A:3.697e-3, Z:3.17e-4},
        {i:13,j:14, E:UNIT_CONVERSION.E_STEEL, I:3.96e-5, A:3.697e-3, Z:3.17e-4},{i:14,j:15, E:UNIT_CONVERSION.E_STEEL, I:3.96e-5, A:3.697e-3, Z:3.17e-4},{i:15,j:16, E:UNIT_CONVERSION.E_STEEL, I:3.96e-5, A:3.697e-3, Z:3.17e-4}
    ], nl:[], ml:[{m:13,w:15},{m:14,w:15},{m:15,w:15},{m:16,w:12},{m:17,w:12},{m:18,w:12},{m:19,w:10},{m:20,w:10},{m:21,w:10}]} },
    { name: '2A-3: 5Â±§„É©„Éº„É°„É≥', data: { nodes: [{x:0,y:0,s:'x'},{x:7,y:0,s:'x'},{x:14,y:0,s:'x'},{x:0,y:3.5,s:'f'},{x:7,y:3.5,s:'f'},{x:14,y:3.5,s:'f'},{x:0,y:7,s:'f'},{x:7,y:7,s:'f'},{x:14,y:7,s:'f'},{x:0,y:10.5,s:'f'},{x:7,y:10.5,s:'f'},{x:14,y:10.5,s:'f'},{x:0,y:14,s:'f'},{x:7,y:14,s:'f'},{x:14,y:14,s:'f'},{x:0,y:17.5,s:'f'},{x:7,y:17.5,s:'f'},{x:14,y:17.5,s:'f'}], members: [
        {i:1,j:4, E:UNIT_CONVERSION.E_STEEL, I:1.35e-4, A:6.291e-3, Z:7.71e-4},{i:2,j:5, E:UNIT_CONVERSION.E_STEEL, I:1.35e-4, A:6.291e-3, Z:7.71e-4},{i:3,j:6, E:UNIT_CONVERSION.E_STEEL, I:1.35e-4, A:6.291e-3, Z:7.71e-4},
        {i:4,j:7, E:UNIT_CONVERSION.E_STEEL, I:1.35e-4, A:6.291e-3, Z:7.71e-4},{i:5,j:8, E:UNIT_CONVERSION.E_STEEL, I:1.35e-4, A:6.291e-3, Z:7.71e-4},{i:6,j:9, E:UNIT_CONVERSION.E_STEEL, I:1.35e-4, A:6.291e-3, Z:7.71e-4},
        {i:7,j:10, E:UNIT_CONVERSION.E_STEEL, I:7.21e-5, A:4.678e-3, Z:4.81e-4},{i:8,j:11, E:UNIT_CONVERSION.E_STEEL, I:7.21e-5, A:4.678e-3, Z:4.81e-4},{i:9,j:12, E:UNIT_CONVERSION.E_STEEL, I:7.21e-5, A:4.678e-3, Z:4.81e-4},
        {i:10,j:13, E:UNIT_CONVERSION.E_STEEL, I:7.21e-5, A:4.678e-3, Z:4.81e-4},{i:11,j:14, E:UNIT_CONVERSION.E_STEEL, I:7.21e-5, A:4.678e-3, Z:4.81e-4},{i:12,j:15, E:UNIT_CONVERSION.E_STEEL, I:7.21e-5, A:4.678e-3, Z:4.81e-4},
        {i:13,j:16, E:UNIT_CONVERSION.E_STEEL, I:3.96e-5, A:3.697e-3, Z:3.17e-4},{i:14,j:17, E:UNIT_CONVERSION.E_STEEL, I:3.96e-5, A:3.697e-3, Z:3.17e-4},{i:15,j:18, E:UNIT_CONVERSION.E_STEEL, I:3.96e-5, A:3.697e-3, Z:3.17e-4},
        {i:4,j:5, E:UNIT_CONVERSION.E_STEEL, I:3.96e-5, A:3.697e-3, Z:3.17e-4},{i:5,j:6, E:UNIT_CONVERSION.E_STEEL, I:3.96e-5, A:3.697e-3, Z:3.17e-4},
        {i:7,j:8, E:UNIT_CONVERSION.E_STEEL, I:3.96e-5, A:3.697e-3, Z:3.17e-4},{i:8,j:9, E:UNIT_CONVERSION.E_STEEL, I:3.96e-5, A:3.697e-3, Z:3.17e-4},
        {i:10,j:11, E:UNIT_CONVERSION.E_STEEL, I:3.96e-5, A:3.697e-3, Z:3.17e-4},{i:11,j:12, E:UNIT_CONVERSION.E_STEEL, I:3.96e-5, A:3.697e-3, Z:3.17e-4},
        {i:13,j:14, E:UNIT_CONVERSION.E_STEEL, I:1.81e-5, A:2.667e-3, Z:1.81e-4},{i:14,j:15, E:UNIT_CONVERSION.E_STEEL, I:1.81e-5, A:2.667e-3, Z:1.81e-4},
        {i:16,j:17, E:UNIT_CONVERSION.E_STEEL, I:1.81e-5, A:2.667e-3, Z:1.81e-4},{i:17,j:18, E:UNIT_CONVERSION.E_STEEL, I:1.81e-5, A:2.667e-3, Z:1.81e-4}
    ], nl:[], ml:[{m:16,w:18},{m:17,w:18},{m:18,w:15},{m:19,w:15},{m:20,w:15},{m:21,w:15},{m:22,w:12},{m:23,w:12},{m:24,w:10},{m:25,w:10}]} },
    { name: '2A-4: „Éñ„É¨„Éº„Çπ‰ªò3Â±§„É©„Éº„É°„É≥', data: { nodes: [{x:0,y:0,s:'x'},{x:6,y:0,s:'x'},{x:12,y:0,s:'x'},{x:0,y:3.5,s:'f'},{x:6,y:3.5,s:'f'},{x:12,y:3.5,s:'f'},{x:0,y:7,s:'f'},{x:6,y:7,s:'f'},{x:12,y:7,s:'f'},{x:0,y:10.5,s:'f'},{x:6,y:10.5,s:'f'},{x:12,y:10.5,s:'f'}], members: [
        {i:1,j:4, E:UNIT_CONVERSION.E_STEEL, I:3.96e-5, A:3.697e-3, Z:3.17e-4},{i:2,j:5, E:UNIT_CONVERSION.E_STEEL, I:3.96e-5, A:3.697e-3, Z:3.17e-4},{i:3,j:6, E:UNIT_CONVERSION.E_STEEL, I:3.96e-5, A:3.697e-3, Z:3.17e-4},
        {i:4,j:7, E:UNIT_CONVERSION.E_STEEL, I:3.96e-5, A:3.697e-3, Z:3.17e-4},{i:5,j:8, E:UNIT_CONVERSION.E_STEEL, I:3.96e-5, A:3.697e-3, Z:3.17e-4},{i:6,j:9, E:UNIT_CONVERSION.E_STEEL, I:3.96e-5, A:3.697e-3, Z:3.17e-4},
        {i:7,j:10, E:UNIT_CONVERSION.E_STEEL, I:1.81e-5, A:2.667e-3, Z:1.81e-4},{i:8,j:11, E:UNIT_CONVERSION.E_STEEL, I:1.81e-5, A:2.667e-3, Z:1.81e-4},{i:9,j:12, E:UNIT_CONVERSION.E_STEEL, I:1.81e-5, A:2.667e-3, Z:1.81e-4},
        {i:4,j:5, E:UNIT_CONVERSION.E_STEEL, I:1.81e-5, A:2.667e-3, Z:1.81e-4},{i:5,j:6, E:UNIT_CONVERSION.E_STEEL, I:1.81e-5, A:2.667e-3, Z:1.81e-4},
        {i:7,j:8, E:UNIT_CONVERSION.E_STEEL, I:1.81e-5, A:2.667e-3, Z:1.81e-4},{i:8,j:9, E:UNIT_CONVERSION.E_STEEL, I:1.81e-5, A:2.667e-3, Z:1.81e-4},
        {i:10,j:11, E:UNIT_CONVERSION.E_STEEL, I:1.81e-5, A:2.667e-3, Z:1.81e-4},{i:11,j:12, E:UNIT_CONVERSION.E_STEEL, I:1.81e-5, A:2.667e-3, Z:1.81e-4},
        {i:1,j:5, ...p_truss, A:1.269e-3},{i:2,j:4, ...p_truss, A:1.269e-3},{i:2,j:6, ...p_truss, A:1.269e-3},{i:3,j:5, ...p_truss, A:1.269e-3},
        {i:4,j:8, ...p_truss, A:1.269e-3},{i:5,j:7, ...p_truss, A:1.269e-3},{i:5,j:9, ...p_truss, A:1.269e-3},{i:6,j:8, ...p_truss, A:1.269e-3}
    ], nl:[{n:4,px:15},{n:5,px:15},{n:6,px:15},{n:7,px:12},{n:8,px:12},{n:9,px:12},{n:10,px:8},{n:11,px:8},{n:12,px:8}], ml:[{m:10,w:15},{m:11,w:15},{m:12,w:12},{m:13,w:12},{m:14,w:10},{m:15,w:10}]} },
    { name: '2A-5: Âú∞ÈúáÂäõ„ÅÆ‰ΩúÁî®„Åô„Çã3Â±§„É©„Éº„É°„É≥', data: { nodes: [{x:0,y:0,s:'x'},{x:8,y:0,s:'x'},{x:16,y:0,s:'x'},{x:0,y:4,s:'f'},{x:8,y:4,s:'f'},{x:16,y:4,s:'f'},{x:0,y:8,s:'f'},{x:8,y:8,s:'f'},{x:16,y:8,s:'f'},{x:0,y:12,s:'f'},{x:8,y:12,s:'f'},{x:16,y:12,s:'f'}], members: [
        {i:1,j:4, E:UNIT_CONVERSION.E_STEEL, I:7.21e-5, A:4.678e-3, Z:4.81e-4},{i:2,j:5, E:UNIT_CONVERSION.E_STEEL, I:7.21e-5, A:4.678e-3, Z:4.81e-4},{i:3,j:6, E:UNIT_CONVERSION.E_STEEL, I:7.21e-5, A:4.678e-3, Z:4.81e-4},
        {i:4,j:7, E:UNIT_CONVERSION.E_STEEL, I:7.21e-5, A:4.678e-3, Z:4.81e-4},{i:5,j:8, E:UNIT_CONVERSION.E_STEEL, I:7.21e-5, A:4.678e-3, Z:4.81e-4},{i:6,j:9, E:UNIT_CONVERSION.E_STEEL, I:7.21e-5, A:4.678e-3, Z:4.81e-4},
        {i:7,j:10, E:UNIT_CONVERSION.E_STEEL, I:3.96e-5, A:3.697e-3, Z:3.17e-4},{i:8,j:11, E:UNIT_CONVERSION.E_STEEL, I:3.96e-5, A:3.697e-3, Z:3.17e-4},{i:9,j:12, E:UNIT_CONVERSION.E_STEEL, I:3.96e-5, A:3.697e-3, Z:3.17e-4},
        {i:4,j:5, E:UNIT_CONVERSION.E_STEEL, I:3.96e-5, A:3.697e-3, Z:3.17e-4},{i:5,j:6, E:UNIT_CONVERSION.E_STEEL, I:3.96e-5, A:3.697e-3, Z:3.17e-4},
        {i:7,j:8, E:UNIT_CONVERSION.E_STEEL, I:3.96e-5, A:3.697e-3, Z:3.17e-4},{i:8,j:9, E:UNIT_CONVERSION.E_STEEL, I:3.96e-5, A:3.697e-3, Z:3.17e-4},
        {i:10,j:11, E:UNIT_CONVERSION.E_STEEL, I:3.96e-5, A:3.697e-3, Z:3.17e-4},{i:11,j:12, E:UNIT_CONVERSION.E_STEEL, I:3.96e-5, A:3.697e-3, Z:3.17e-4}
    ], nl:[{n:4,px:25},{n:5,px:25},{n:6,px:25},{n:7,px:20},{n:8,px:20},{n:9,px:20},{n:10,px:15},{n:11,px:15},{n:12,px:15}], ml:[{m:10,w:20},{m:11,w:20},{m:12,w:15},{m:13,w:15},{m:14,w:12},{m:15,w:12}]} },
    { name: '2B-1: Âª∫ÁØâ„É©„Éº„É°„É≥ (2Â±§2„Çπ„Éë„É≥)', data: { nodes: [{x:0,y:0,s:'x'},{x:6,y:0,s:'x'},{x:12,y:0,s:'x'},{x:0,y:4,s:'f'},{x:6,y:4,s:'f'},{x:12,y:4,s:'f'},{x:0,y:8,s:'f'},{x:6,y:8,s:'f'},{x:12,y:8,s:'f'}], members:[
        {i:1,j:4, E:UNIT_CONVERSION.E_STEEL, I:3.96e-5, A:3.697e-3, Z:3.17e-4},{i:2,j:5, E:UNIT_CONVERSION.E_STEEL, I:3.96e-5, A:3.697e-3, Z:3.17e-4},{i:3,j:6, E:UNIT_CONVERSION.E_STEEL, I:3.96e-5, A:3.697e-3, Z:3.17e-4},
        {i:4,j:5, E:UNIT_CONVERSION.E_STEEL, I:3.96e-5, A:3.697e-3, Z:3.17e-4},{i:5,j:6, E:UNIT_CONVERSION.E_STEEL, I:3.96e-5, A:3.697e-3, Z:3.17e-4},
        {i:4,j:7, E:UNIT_CONVERSION.E_STEEL, I:3.96e-5, A:3.697e-3, Z:3.17e-4},{i:5,j:8, E:UNIT_CONVERSION.E_STEEL, I:3.96e-5, A:3.697e-3, Z:3.17e-4},{i:6,j:9, E:UNIT_CONVERSION.E_STEEL, I:3.96e-5, A:3.697e-3, Z:3.17e-4},
        {i:7,j:8, E:UNIT_CONVERSION.E_STEEL, I:3.96e-5, A:3.697e-3, Z:3.17e-4},{i:8,j:9, E:UNIT_CONVERSION.E_STEEL, I:3.96e-5, A:3.697e-3, Z:3.17e-4}
    ], nl:[{n:4,py:-15},{n:5,py:-15},{n:6,py:-15},{n:7,py:-15},{n:8,py:-15},{n:9,py:-15}], ml:[] } },
    { name: '2B-2: Âª∫ÁØâ„É©„Éº„É°„É≥ (2Â±§2„Çπ„Éë„É≥„Éª„Éñ„É¨„Éº„Çπ‰ªò„Åç)', data: { nodes: [{x:0,y:0,s:'x'},{x:6,y:0,s:'x'},{x:12,y:0,s:'x'},{x:0,y:4,s:'f'},{x:6,y:4,s:'f'},{x:12,y:4,s:'f'},{x:0,y:8,s:'f'},{x:6,y:8,s:'f'},{x:12,y:8,s:'f'}], members:[
        {i:1,j:4, E:UNIT_CONVERSION.E_STEEL, I:1.81e-5, A:2.667e-3, Z:1.81e-4},{i:2,j:5, E:UNIT_CONVERSION.E_STEEL, I:1.81e-5, A:2.667e-3, Z:1.81e-4},{i:3,j:6, E:UNIT_CONVERSION.E_STEEL, I:1.81e-5, A:2.667e-3, Z:1.81e-4},
        {i:4,j:5, E:UNIT_CONVERSION.E_STEEL, I:1.81e-5, A:2.667e-3, Z:1.81e-4},{i:5,j:6, E:UNIT_CONVERSION.E_STEEL, I:1.81e-5, A:2.667e-3, Z:1.81e-4},
        {i:4,j:7, E:UNIT_CONVERSION.E_STEEL, I:1.81e-5, A:2.667e-3, Z:1.81e-4},{i:5,j:8, E:UNIT_CONVERSION.E_STEEL, I:1.81e-5, A:2.667e-3, Z:1.81e-4},{i:6,j:9, E:UNIT_CONVERSION.E_STEEL, I:1.81e-5, A:2.667e-3, Z:1.81e-4},
        {i:7,j:8, E:UNIT_CONVERSION.E_STEEL, I:1.81e-5, A:2.667e-3, Z:1.81e-4},{i:8,j:9, E:UNIT_CONVERSION.E_STEEL, I:1.81e-5, A:2.667e-3, Z:1.81e-4},
        {i:1,j:5, ...p_truss, A:1.269e-3},{i:5,j:9, ...p_truss, A:1.269e-3}
    ], nl:[{n:4,py:-15},{n:5,py:-15},{n:6,py:-15},{n:7,py:-15},{n:8,py:-15},{n:9,py:-15}], ml:[] } },
    { name: '2C-1: „Éà„É©„ÇπÂ±ãÊ†π', data: { nodes: [{x:0,y:0,s:'p'},{x:6,y:0,s:'r'},{x:12,y:0,s:'r'},{x:3,y:2,s:'f'},{x:9,y:2,s:'f'},{x:6,y:4,s:'f'}], members:[
        {i:1,j:4, ...p_truss, A:1.269e-3},{i:4,j:6, ...p_truss, A:1.269e-3},{i:6,j:5, ...p_truss, A:1.269e-3},{i:5,j:3, ...p_truss, A:1.269e-3},
        {i:1,j:2, ...p_truss, A:1.269e-3},{i:2,j:3, ...p_truss, A:1.269e-3},{i:4,j:2, ...p_truss, A:1.269e-3},{i:2,j:5, ...p_truss, A:1.269e-3}
    ], nl:[{n:4,py:-10},{n:5,py:-10},{n:6,py:-10}], ml:[] } },
    { name: '2C-2: Âπ≥Ë°åÂº¶„Éà„É©„Çπ', data: { nodes: [{x:0,y:0,s:'p'},{x:4,y:0,s:'f'},{x:8,y:0,s:'f'},{x:12,y:0,s:'r'},{x:0,y:2,s:'f'},{x:4,y:2,s:'f'},{x:8,y:2,s:'f'},{x:12,y:2,s:'f'}], members:[
        {i:1,j:2, ...p_truss, A:1.7e-3},{i:2,j:3, ...p_truss, A:1.7e-3},{i:3,j:4, ...p_truss, A:1.7e-3},{i:5,j:6, ...p_truss, A:1.7e-3},{i:6,j:7, ...p_truss, A:1.7e-3},
        {i:7,j:8, ...p_truss, A:1.7e-3},{i:1,j:5, ...p_truss, A:1.7e-3},{i:2,j:6, ...p_truss, A:1.7e-3},{i:3,j:7, ...p_truss, A:1.7e-3},{i:4,j:8, ...p_truss, A:1.7e-3},
        {i:1,j:6, ...p_truss, A:1.7e-3},{i:2,j:7, ...p_truss, A:1.7e-3},{i:3,j:8, ...p_truss, A:1.7e-3}
    ], nl:[{n:5,py:-10},{n:6,py:-10},{n:7,py:-10},{n:8,py:-10}], ml:[] } },
    { name: '2C-3: „Éó„É©„ÉÉ„Éà„Éª„Éà„É©„Çπ', data: { nodes: [{x:0,y:0,s:'p'},{x:3,y:0,s:'f'},{x:6,y:0,s:'f'},{x:9,y:0,s:'f'},{x:12,y:0,s:'r'},{x:0,y:2,s:'f'},{x:3,y:2,s:'f'},{x:6,y:2,s:'f'},{x:9,y:2,s:'f'},{x:12,y:2,s:'f'}], members:[
        {i:1,j:2, ...p_truss, A:1.7e-3},{i:2,j:3, ...p_truss, A:1.7e-3},{i:3,j:4, ...p_truss, A:1.7e-3},{i:4,j:5, ...p_truss, A:1.7e-3},
        {i:6,j:7, ...p_truss, A:1.7e-3},{i:7,j:8, ...p_truss, A:1.7e-3},{i:8,j:9, ...p_truss, A:1.7e-3},{i:9,j:10, ...p_truss, A:1.7e-3},
        {i:1,j:6, ...p_truss, A:1.269e-3},{i:2,j:7, ...p_truss, A:1.269e-3},{i:3,j:8, ...p_truss, A:1.269e-3},{i:4,j:9, ...p_truss, A:1.269e-3},{i:5,j:10, ...p_truss, A:1.269e-3},
        {i:1,j:7, ...p_truss, A:1.269e-3},{i:2,j:8, ...p_truss, A:1.269e-3},{i:3,j:9, ...p_truss, A:1.269e-3},{i:4,j:10, ...p_truss, A:1.269e-3}
    ], nl:[{n:6,py:-10},{n:7,py:-10},{n:8,py:-10},{n:9,py:-10},{n:10,py:-10}], ml:[] } },
    { name: '2C-4: „Éè„Ç¶„Éª„Éà„É©„Çπ', data: { nodes: [{x:0,y:0,s:'p'},{x:3,y:0,s:'f'},{x:6,y:0,s:'f'},{x:9,y:0,s:'f'},{x:12,y:0,s:'r'},{x:0,y:2,s:'f'},{x:3,y:2,s:'f'},{x:6,y:2,s:'f'},{x:9,y:2,s:'f'},{x:12,y:2,s:'f'}], members:[
        {i:1,j:2, ...p_truss, A:1.7e-3},{i:2,j:3, ...p_truss, A:1.7e-3},{i:3,j:4, ...p_truss, A:1.7e-3},{i:4,j:5, ...p_truss, A:1.7e-3},
        {i:6,j:7, ...p_truss, A:1.7e-3},{i:7,j:8, ...p_truss, A:1.7e-3},{i:8,j:9, ...p_truss, A:1.7e-3},{i:9,j:10, ...p_truss, A:1.7e-3},
        {i:1,j:6, ...p_truss, A:1.269e-3},{i:2,j:7, ...p_truss, A:1.269e-3},{i:3,j:8, ...p_truss, A:1.269e-3},{i:4,j:9, ...p_truss, A:1.269e-3},{i:5,j:10, ...p_truss, A:1.269e-3},
        {i:6,j:2, ...p_truss, A:1.269e-3},{i:7,j:3, ...p_truss, A:1.269e-3},{i:8,j:4, ...p_truss, A:1.269e-3},{i:9,j:5, ...p_truss, A:1.269e-3}
    ], nl:[{n:6,py:-10},{n:7,py:-10},{n:8,py:-10},{n:9,py:-10},{n:10,py:-10}], ml:[] } },
    { name: '2C-5: „ÉØ„Éº„É¨„É≥„Éª„Éà„É©„Çπ', data: { nodes: [{x:0,y:0,s:'p'},{x:6,y:0,s:'r'},{x:12,y:0,s:'f'},{x:3,y:2,s:'f'},{x:9,y:2,s:'f'}], members:[
        {i:1,j:4, ...p_truss, A:1.7e-3},{i:4,j:2, ...p_truss, A:1.7e-3},{i:2,j:5, ...p_truss, A:1.7e-3},{i:5,j:3, ...p_truss, A:1.7e-3},
        {i:4,j:5, ...p_truss, A:1.7e-3},{i:1,j:2, ...p_truss, A:1.7e-3},{i:2,j:3, ...p_truss, A:1.7e-3}
    ], nl:[{n:4,py:-15},{n:5,py:-15}], ml:[] } },
    { name: '--- 3. Ê©ãÊ¢ÅÊßãÈÄ†Áâ© (Bridge Structures) ---', disabled: true },
    { name: '3A-1: ÂçòÁ¥îÊîØÊåÅÊ°ÅÊ©ã', data: { nodes: [{x:0,y:0,s:'p'},{x:3,y:0,s:'f'},{x:6,y:0,s:'f'},{x:9,y:0,s:'f'},{x:12,y:0,s:'r'}], members:[
        {i:1,j:2, E:UNIT_CONVERSION.E_STEEL, I:2.35e-4, A:8.337e-3, Z:1.17e-3},{i:2,j:3, E:UNIT_CONVERSION.E_STEEL, I:2.35e-4, A:8.337e-3, Z:1.17e-3},
        {i:3,j:4, E:UNIT_CONVERSION.E_STEEL, I:2.35e-4, A:8.337e-3, Z:1.17e-3},{i:4,j:5, E:UNIT_CONVERSION.E_STEEL, I:2.35e-4, A:8.337e-3, Z:1.17e-3}
    ], nl:[], ml:[{m:1,w:20},{m:2,w:20},{m:3,w:20},{m:4,w:20}] } },
    { name: '3A-2: 2ÂæÑÈñìÈÄ£Á∂öÊ°ÅÊ©ã', data: { nodes: [{x:0,y:0,s:'p'},{x:4,y:0,s:'f'},{x:8,y:0,s:'r'},{x:12,y:0,s:'f'},{x:16,y:0,s:'r'}], members:[
        {i:1,j:2, E:UNIT_CONVERSION.E_STEEL, I:1.35e-4, A:6.291e-3, Z:7.71e-4},{i:2,j:3, E:UNIT_CONVERSION.E_STEEL, I:1.35e-4, A:6.291e-3, Z:7.71e-4},
        {i:3,j:4, E:UNIT_CONVERSION.E_STEEL, I:1.35e-4, A:6.291e-3, Z:7.71e-4},{i:4,j:5, E:UNIT_CONVERSION.E_STEEL, I:1.35e-4, A:6.291e-3, Z:7.71e-4}
    ], nl:[], ml:[{m:1,w:20},{m:2,w:20},{m:3,w:20},{m:4,w:20}] } },
    { name: '3A-3: „Ç≤„É´„Éê„ÉºÊ°ÅÊ©ã', data: { nodes: [{x:0, y:0, s:'p'},{x:4, y:0, s:'f'},{x:8, y:0, s:'r'},{x:12, y:0, s:'f'},{x:16, y:0, s:'r'}], members: [
        {i:1, j:2, E:UNIT_CONVERSION.E_STEEL, I:7.21e-5, A:4.678e-3, Z:4.81e-4},{i:2, j:3, E:UNIT_CONVERSION.E_STEEL, I:7.21e-5, A:4.678e-3, Z:4.81e-4, i_conn:'p', j_conn:'rigid'},
        {i:3, j:4, E:UNIT_CONVERSION.E_STEEL, I:7.21e-5, A:4.678e-3, Z:4.81e-4, i_conn:'rigid', j_conn:'p'},{i:4, j:5, E:UNIT_CONVERSION.E_STEEL, I:7.21e-5, A:4.678e-3, Z:4.81e-4}
    ], nl: [], ml: [{m:1, w:20},{m:2, w:20},{m:3, w:20},{m:4, w:20}] } },
    { name: '3B-1: ÂçòÁ¥î„Éà„É©„ÇπÊ©ã', data: { nodes: [{x:0,y:0,s:'p'},{x:6,y:0,s:'f'},{x:12,y:0,s:'r'},{x:0,y:3,s:'f'},{x:6,y:3,s:'f'},{x:12,y:3,s:'f'}], members:[
        {i:1,j:2, ...p_truss, A:3.697e-3},{i:2,j:3, ...p_truss, A:3.697e-3},
        {i:4,j:5, ...p_truss, A:3.697e-3},{i:5,j:6, ...p_truss, A:3.697e-3},
        {i:1,j:4, ...p_truss, A:1.7e-3},{i:2,j:5, ...p_truss, A:1.7e-3},{i:3,j:6, ...p_truss, A:1.7e-3},
        {i:1,j:5, ...p_truss, A:1.7e-3},{i:2,j:6, ...p_truss, A:1.7e-3}
    ], nl:[{n:1,py:-30},{n:2,py:-30},{n:3,py:-30}], ml:[] } },
    { name: '3B-2: 2ÂæÑÈñìÈÄ£Á∂ö„Éà„É©„ÇπÊ©ã', data: { nodes: [{x:0,y:0,s:'p'},{x:6,y:0,s:'f'},{x:12,y:0,s:'r'},{x:18,y:0,s:'f'},{x:24,y:0,s:'r'},{x:0,y:3,s:'f'},{x:6,y:3,s:'f'},{x:12,y:3,s:'f'},{x:18,y:3,s:'f'},{x:24,y:3,s:'f'}], members:[
        {i:1,j:2, ...p_truss, A:4.678e-3},{i:2,j:3, ...p_truss, A:4.678e-3},{i:3,j:4, ...p_truss, A:4.678e-3},{i:4,j:5, ...p_truss, A:4.678e-3},
        {i:6,j:7, ...p_truss, A:4.678e-3},{i:7,j:8, ...p_truss, A:4.678e-3},{i:8,j:9, ...p_truss, A:4.678e-3},{i:9,j:10, ...p_truss, A:4.678e-3},
        {i:1,j:6, ...p_truss, A:1.7e-3},{i:2,j:7, ...p_truss, A:1.7e-3},{i:3,j:8, ...p_truss, A:1.7e-3},{i:4,j:9, ...p_truss, A:1.7e-3},{i:5,j:10, ...p_truss, A:1.7e-3},
        {i:6,j:2, ...p_truss, A:1.7e-3},{i:7,j:3, ...p_truss, A:1.7e-3},{i:8,j:4, ...p_truss, A:1.7e-3},{i:9,j:5, ...p_truss, A:1.7e-3},
        {i:7,j:2, ...p_truss, A:1.7e-3},{i:8,j:3, ...p_truss, A:1.7e-3},{i:9,j:4, ...p_truss, A:1.7e-3}
    ], nl:[{n:1,py:-40},{n:2,py:-40},{n:3,py:-40},{n:4,py:-40},{n:5,py:-40}], ml:[] } },
    { name: '3B-3: „Ç≤„É´„Éê„Éº„Éà„É©„ÇπÊ©ã', data: { nodes: [{x:0,y:0,s:'p'},{x:6,y:0,s:'f'},{x:12,y:0,s:'r'},{x:18,y:0,s:'f'},{x:24,y:0,s:'r'},{x:0,y:3,s:'f'},{x:6,y:3,s:'f'},{x:12,y:3,s:'f'},{x:18,y:3,s:'f'},{x:24,y:3,s:'f'},{x:9,y:0,s:'f'},{x:15,y:0,s:'f'}], members:[
        {i:1,j:2, ...p_truss, A:3.697e-3},{i:2,j:11, ...p_truss, A:3.697e-3},{i:11,j:12, ...p_truss, A:3.697e-3},{i:12,j:4, ...p_truss, A:3.697e-3},{i:4,j:5, ...p_truss, A:3.697e-3},
        {i:6,j:7, ...p_truss, A:3.697e-3},{i:7,j:8, ...p_truss, A:3.697e-3},{i:8,j:9, ...p_truss, A:3.697e-3},{i:9,j:10, ...p_truss, A:3.697e-3},
        {i:1,j:6, ...p_truss, A:1.7e-3},{i:2,j:7, ...p_truss, A:1.7e-3},{i:11,j:8, ...p_truss, A:1.7e-3},{i:12,j:8, ...p_truss, A:1.7e-3},{i:4,j:9, ...p_truss, A:1.7e-3},{i:5,j:10, ...p_truss, A:1.7e-3},
        {i:1,j:7, ...p_truss, A:1.7e-3},{i:2,j:6, ...p_truss, A:1.7e-3},{i:2,j:8, ...p_truss, A:1.7e-3},{i:4,j:8, ...p_truss, A:1.7e-3},{i:4,j:10, ...p_truss, A:1.7e-3},{i:5,j:9, ...p_truss, A:1.7e-3}
    ], nl:[{n:1,py:-40},{n:2,py:-40},{n:11,py:-40},{n:12,py:-40},{n:4,py:-40},{n:5,py:-40}], ml:[] } },
    { name: '3C-1: 2„Éí„É≥„Ç∏„Ç¢„Éº„ÉÅÊ©ã', data: { nodes: [{x:0,y:0,s:'p'},{x:4,y:2,s:'f'},{x:8,y:3,s:'f'},{x:12,y:3.5,s:'f'},{x:16,y:3,s:'f'},{x:20,y:2,s:'f'},{x:24,y:0,s:'r'}], members:[
        {i:1,j:2, E:UNIT_CONVERSION.E_STEEL, I:1.35e-4, A:6.291e-3, Z:7.71e-4},{i:2,j:3, E:UNIT_CONVERSION.E_STEEL, I:1.35e-4, A:6.291e-3, Z:7.71e-4},
        {i:3,j:4, E:UNIT_CONVERSION.E_STEEL, I:1.35e-4, A:6.291e-3, Z:7.71e-4},{i:4,j:5, E:UNIT_CONVERSION.E_STEEL, I:1.35e-4, A:6.291e-3, Z:7.71e-4},
        {i:5,j:6, E:UNIT_CONVERSION.E_STEEL, I:1.35e-4, A:6.291e-3, Z:7.71e-4},{i:6,j:7, E:UNIT_CONVERSION.E_STEEL, I:1.35e-4, A:6.291e-3, Z:7.71e-4}
    ], nl:[{n:2,py:-20},{n:3,py:-20},{n:4,py:-20},{n:5,py:-20},{n:6,py:-20}], ml:[] } },
    { name: '3C-2: 3„Éí„É≥„Ç∏„Ç¢„Éº„ÉÅÊ©ã', data: { nodes: [{x:0,y:0,s:'p'},{x:4,y:2,s:'f'},{x:8,y:3,s:'f'},{x:12,y:3.5,s:'f'},{x:16,y:3,s:'f'},{x:20,y:2,s:'f'},{x:24,y:0,s:'r'}], members:[
        {i:1,j:2, E:UNIT_CONVERSION.E_STEEL, I:1.35e-4, A:6.291e-3, Z:7.71e-4},{i:2,j:3, E:UNIT_CONVERSION.E_STEEL, I:1.35e-4, A:6.291e-3, Z:7.71e-4},{i:3,j:4, E:UNIT_CONVERSION.E_STEEL, I:1.35e-4, A:6.291e-3, Z:7.71e-4, j_conn:'p'},
        {i:4,j:5, E:UNIT_CONVERSION.E_STEEL, I:1.35e-4, A:6.291e-3, Z:7.71e-4, i_conn:'p'},{i:5,j:6, E:UNIT_CONVERSION.E_STEEL, I:1.35e-4, A:6.291e-3, Z:7.71e-4},{i:6,j:7, E:UNIT_CONVERSION.E_STEEL, I:1.35e-4, A:6.291e-3, Z:7.71e-4}
    ], nl:[{n:2,py:-20},{n:3,py:-20},{n:4,py:-20},{n:5,py:-20},{n:6,py:-20}], ml:[] } },
    { name: '3C-3: „Çø„Ç§„Éâ„Ç¢„Éº„ÉÅÊ©ã', data: { nodes: [{x:0,y:0,s:'p'},{x:4,y:2,s:'f'},{x:8,y:3,s:'f'},{x:12,y:3.5,s:'f'},{x:16,y:3,s:'f'},{x:20,y:2,s:'f'},{x:24,y:0,s:'r'}], members:[
        {i:1,j:2, E:UNIT_CONVERSION.E_STEEL, I:1.35e-4, A:6.291e-3, Z:7.71e-4},{i:2,j:3, E:UNIT_CONVERSION.E_STEEL, I:1.35e-4, A:6.291e-3, Z:7.71e-4},{i:3,j:4, E:UNIT_CONVERSION.E_STEEL, I:1.35e-4, A:6.291e-3, Z:7.71e-4},
        {i:4,j:5, E:UNIT_CONVERSION.E_STEEL, I:1.35e-4, A:6.291e-3, Z:7.71e-4},{i:5,j:6, E:UNIT_CONVERSION.E_STEEL, I:1.35e-4, A:6.291e-3, Z:7.71e-4},{i:6,j:7, E:UNIT_CONVERSION.E_STEEL, I:1.35e-4, A:6.291e-3, Z:7.71e-4},
        {i:1,j:7, E:UNIT_CONVERSION.E_STEEL, I:1.35e-4, A:6.291e-3, Z:7.71e-4}
    ], nl:[{n:2,py:-20},{n:3,py:-20},{n:4,py:-20},{n:5,py:-20},{n:6,py:-20}], ml:[] } },
    { name: '3D-1: „É©„É≥„Ç¨„ÉºÊ©ã', data: { nodes: [{x:0,y:0,s:'p'},{x:6,y:0,s:'f'},{x:12,y:0,s:'f'},{x:18,y:0,s:'f'},{x:24,y:0,s:'r'},{x:6,y:4,s:'f'},{x:12,y:5,s:'f'},{x:18,y:4,s:'f'}], members:[
        {i:1,j:2, E:UNIT_CONVERSION.E_STEEL, I:1.35e-4, A:6.291e-3, Z:7.71e-4},{i:2,j:3, E:UNIT_CONVERSION.E_STEEL, I:1.35e-4, A:6.291e-3, Z:7.71e-4},{i:3,j:4, E:UNIT_CONVERSION.E_STEEL, I:1.35e-4, A:6.291e-3, Z:7.71e-4},{i:4,j:5, E:UNIT_CONVERSION.E_STEEL, I:1.35e-4, A:6.291e-3, Z:7.71e-4},
        {i:1,j:6, E:UNIT_CONVERSION.E_STEEL, I:7.21e-5, A:4.678e-3, Z:4.81e-4},{i:6,j:7, E:UNIT_CONVERSION.E_STEEL, I:7.21e-5, A:4.678e-3, Z:4.81e-4},{i:7,j:8, E:UNIT_CONVERSION.E_STEEL, I:7.21e-5, A:4.678e-3, Z:4.81e-4},{i:8,j:5, E:UNIT_CONVERSION.E_STEEL, I:7.21e-5, A:4.678e-3, Z:4.81e-4},
        {i:2,j:6, ...p_truss, A:1.7e-3},{i:3,j:7, ...p_truss, A:1.7e-3},{i:4,j:8, ...p_truss, A:1.7e-3}
    ], nl:[{n:2,py:-20},{n:3,py:-20},{n:4,py:-20}], ml:[] } },
    { name: '3D-2: „É≠„Éº„ÇºÊ©ã', data: { nodes: [{x:0,y:0,s:'p'},{x:6,y:0,s:'f'},{x:12,y:0,s:'f'},{x:18,y:0,s:'f'},{x:24,y:0,s:'r'},{x:0,y:4,s:'f'},{x:6,y:5,s:'f'},{x:12,y:5.5,s:'f'},{x:18,y:5,s:'f'},{x:24,y:4,s:'f'}], members:[
        {i:1,j:2, E:UNIT_CONVERSION.E_STEEL, I:1.35e-4, A:6.291e-3, Z:7.71e-4},{i:2,j:3, E:UNIT_CONVERSION.E_STEEL, I:1.35e-4, A:6.291e-3, Z:7.71e-4},{i:3,j:4, E:UNIT_CONVERSION.E_STEEL, I:1.35e-4, A:6.291e-3, Z:7.71e-4},{i:4,j:5, E:UNIT_CONVERSION.E_STEEL, I:1.35e-4, A:6.291e-3, Z:7.71e-4},
        {i:6,j:7, E:UNIT_CONVERSION.E_STEEL, I:7.21e-5, A:4.678e-3, Z:4.81e-4},{i:7,j:8, E:UNIT_CONVERSION.E_STEEL, I:7.21e-5, A:4.678e-3, Z:4.81e-4},{i:8,j:9, E:UNIT_CONVERSION.E_STEEL, I:7.21e-5, A:4.678e-3, Z:4.81e-4},{i:9,j:10, E:UNIT_CONVERSION.E_STEEL, I:7.21e-5, A:4.678e-3, Z:4.81e-4},
        {i:1,j:6, ...p_truss, A:1.7e-3},{i:2,j:7, ...p_truss, A:1.7e-3},{i:3,j:8, ...p_truss, A:1.7e-3},{i:4,j:9, ...p_truss, A:1.7e-3},{i:5,j:10, ...p_truss, A:1.7e-3},
        {i:2,j:6, ...p_truss, A:1.7e-3},{i:3,j:7, ...p_truss, A:1.7e-3},{i:4,j:8, ...p_truss, A:1.7e-3},{i:5,j:9, ...p_truss, A:1.7e-3}
    ], nl:[{n:2,py:-20},{n:3,py:-20},{n:4,py:-20}], ml:[] } },
    { name: '3D-3: ÊñúÂºµÊ©ã', data: { nodes: [{x:0,y:0,s:'p'},{x:6,y:0,s:'f'},{x:12,y:0,s:'r'},{x:18,y:0,s:'f'},{x:24,y:0,s:'r'},{x:12,y:8,s:'f'}], members:[
        {i:1,j:2, E:UNIT_CONVERSION.E_STEEL, I:7.21e-5, A:4.678e-3, Z:4.81e-4},{i:2,j:3, E:UNIT_CONVERSION.E_STEEL, I:7.21e-5, A:4.678e-3, Z:4.81e-4},
        {i:3,j:4, E:UNIT_CONVERSION.E_STEEL, I:7.21e-5, A:4.678e-3, Z:4.81e-4},{i:4,j:5, E:UNIT_CONVERSION.E_STEEL, I:7.21e-5, A:4.678e-3, Z:4.81e-4},
        {i:3,j:6, E:UNIT_CONVERSION.E_STEEL, I:1.35e-4, A:6.291e-3, Z:7.71e-4},
        {i:1,j:6, ...p_truss, A:2.667e-3},{i:2,j:6, ...p_truss, A:2.667e-3},{i:4,j:6, ...p_truss, A:2.667e-3},{i:5,j:6, ...p_truss, A:2.667e-3}
    ], nl:[{n:2,py:-20},{n:4,py:-20}], ml:[] } },
    { name: '--- 4. „Åù„ÅÆ‰ªñ„ÉªÁâπÊÆäÊßãÈÄ† (Misc. & Special) ---', disabled: true },
    { name: '4A-1: È´òÂ±§„Éì„É´', data: { nodes: [{x:0,y:0,s:'x'},{x:8,y:0,s:'x'},{x:16,y:0,s:'x'},{x:0,y:4,s:'f'},{x:8,y:4,s:'f'},{x:16,y:4,s:'f'},{x:0,y:8,s:'f'},{x:8,y:8,s:'f'},{x:16,y:8,s:'f'},{x:0,y:12,s:'f'},{x:8,y:12,s:'f'},{x:16,y:12,s:'f'},{x:0,y:16,s:'f'},{x:8,y:16,s:'f'},{x:16,y:16,s:'f'}], members:[
        {i:1,j:4, E:UNIT_CONVERSION.E_STEEL, I:1.35e-4, A:6.291e-3, Z:7.71e-4},{i:2,j:5, E:UNIT_CONVERSION.E_STEEL, I:1.35e-4, A:6.291e-3, Z:7.71e-4},{i:3,j:6, E:UNIT_CONVERSION.E_STEEL, I:1.35e-4, A:6.291e-3, Z:7.71e-4},
        {i:4,j:7, E:UNIT_CONVERSION.E_STEEL, I:1.10e-4, A:5.245e-3, Z:6.38e-4},{i:5,j:8, E:UNIT_CONVERSION.E_STEEL, I:1.10e-4, A:5.245e-3, Z:6.38e-4},{i:6,j:9, E:UNIT_CONVERSION.E_STEEL, I:1.10e-4, A:5.245e-3, Z:6.38e-4},
        {i:7,j:10, E:UNIT_CONVERSION.E_STEEL, I:7.21e-5, A:4.678e-3, Z:4.81e-4},{i:8,j:11, E:UNIT_CONVERSION.E_STEEL, I:7.21e-5, A:4.678e-3, Z:4.81e-4},{i:9,j:12, E:UNIT_CONVERSION.E_STEEL, I:7.21e-5, A:4.678e-3, Z:4.81e-4},
        {i:10,j:13, E:UNIT_CONVERSION.E_STEEL, I:3.96e-5, A:3.697e-3, Z:3.17e-4},{i:11,j:14, E:UNIT_CONVERSION.E_STEEL, I:3.96e-5, A:3.697e-3, Z:3.17e-4},{i:12,j:15, E:UNIT_CONVERSION.E_STEEL, I:3.96e-5, A:3.697e-3, Z:3.17e-4},
        {i:4,j:5, E:UNIT_CONVERSION.E_STEEL, I:3.96e-5, A:3.697e-3, Z:3.17e-4},{i:5,j:6, E:UNIT_CONVERSION.E_STEEL, I:3.96e-5, A:3.697e-3, Z:3.17e-4},
        {i:7,j:8, E:UNIT_CONVERSION.E_STEEL, I:3.96e-5, A:3.697e-3, Z:3.17e-4},{i:8,j:9, E:UNIT_CONVERSION.E_STEEL, I:3.96e-5, A:3.697e-3, Z:3.17e-4},
        {i:10,j:11, E:UNIT_CONVERSION.E_STEEL, I:1.81e-5, A:2.667e-3, Z:1.81e-4},{i:11,j:12, E:UNIT_CONVERSION.E_STEEL, I:1.81e-5, A:2.667e-3, Z:1.81e-4},
        {i:13,j:14, E:UNIT_CONVERSION.E_STEEL, I:1.81e-5, A:2.667e-3, Z:1.81e-4},{i:14,j:15, E:UNIT_CONVERSION.E_STEEL, I:1.81e-5, A:2.667e-3, Z:1.81e-4}
    ], nl:[{n:13,px:10},{n:14,px:10},{n:15,px:10},{n:13,py:-30},{n:14,py:-30},{n:15,py:-30}], ml:[] } },
    { name: '4A-2: Â§ß„Çπ„Éë„É≥Â±ãÊ†π', data: { nodes: [{x:0,y:0,s:'p'},{x:8,y:0,s:'r'},{x:16,y:0,s:'r'},{x:24,y:0,s:'p'},{x:4,y:7,s:'f'},{x:12,y:9,s:'f'},{x:20,y:7,s:'f'}], members:[
        {i:1,j:5, ...p_truss, A:3.697e-3},{i:5,j:2, ...p_truss, A:3.697e-3},{i:2,j:6, ...p_truss, A:3.697e-3},{i:6,j:3, ...p_truss, A:3.697e-3},
        {i:3,j:7, ...p_truss, A:3.697e-3},{i:7,j:4, ...p_truss, A:3.697e-3},{i:5,j:6, ...p_truss, A:3.697e-3},{i:6,j:7, ...p_truss, A:3.697e-3},
        {i:1,j:2, ...p_truss, A:2.667e-3},{i:2,j:3, ...p_truss, A:2.667e-3},{i:3,j:4, ...p_truss, A:2.667e-3}
    ], nl:[{n:5,py:-10},{n:6,py:-10},{n:7,py:-10}], ml:[] } },
    { name: '4A-3: Ë§áÂêà„É©„Éº„É°„É≥ÊßãÈÄ†', data: { nodes: [{x:0,y:0,s:'x'},{x:8,y:0,s:'x'},{x:16,y:0,s:'x'},{x:24,y:0,s:'x'},{x:0,y:4,s:'f'},{x:8,y:4,s:'f'},{x:16,y:4,s:'f'},{x:24,y:4,s:'f'},{x:0,y:8,s:'f'},{x:8,y:8,s:'f'},{x:16,y:8,s:'f'},{x:24,y:8,s:'f'}], members:[
        {i:1,j:5, E:UNIT_CONVERSION.E_STEEL, I:7.21e-5, A:4.678e-3, Z:4.81e-4},{i:2,j:6, E:UNIT_CONVERSION.E_STEEL, I:7.21e-5, A:4.678e-3, Z:4.81e-4},{i:3,j:7, E:UNIT_CONVERSION.E_STEEL, I:7.21e-5, A:4.678e-3, Z:4.81e-4},{i:4,j:8, E:UNIT_CONVERSION.E_STEEL, I:7.21e-5, A:4.678e-3, Z:4.81e-4},
        {i:5,j:9, E:UNIT_CONVERSION.E_STEEL, I:3.96e-5, A:3.697e-3, Z:3.17e-4},{i:6,j:10, E:UNIT_CONVERSION.E_STEEL, I:3.96e-5, A:3.697e-3, Z:3.17e-4},{i:7,j:11, E:UNIT_CONVERSION.E_STEEL, I:3.96e-5, A:3.697e-3, Z:3.17e-4},{i:8,j:12, E:UNIT_CONVERSION.E_STEEL, I:3.96e-5, A:3.697e-3, Z:3.17e-4},
        {i:5,j:6, E:UNIT_CONVERSION.E_STEEL, I:3.96e-5, A:3.697e-3, Z:3.17e-4},{i:6,j:7, E:UNIT_CONVERSION.E_STEEL, I:3.96e-5, A:3.697e-3, Z:3.17e-4},{i:7,j:8, E:UNIT_CONVERSION.E_STEEL, I:3.96e-5, A:3.697e-3, Z:3.17e-4},
        {i:9,j:10, E:UNIT_CONVERSION.E_STEEL, I:3.96e-5, A:3.697e-3, Z:3.17e-4},{i:10,j:11, E:UNIT_CONVERSION.E_STEEL, I:3.96e-5, A:3.697e-3, Z:3.17e-4},{i:11,j:12, E:UNIT_CONVERSION.E_STEEL, I:3.96e-5, A:3.697e-3, Z:3.17e-4},
        {i:1,j:6, ...p_truss, A:1.7e-3},{i:2,j:5, ...p_truss, A:1.7e-3},{i:2,j:7, ...p_truss, A:1.7e-3},{i:3,j:6, ...p_truss, A:1.7e-3},
        {i:3,j:8, ...p_truss, A:1.7e-3},{i:4,j:7, ...p_truss, A:1.7e-3},{i:5,j:10, ...p_truss, A:1.7e-3},{i:6,j:9, ...p_truss, A:1.7e-3},
        {i:6,j:11, ...p_truss, A:1.7e-3},{i:7,j:10, ...p_truss, A:1.7e-3},{i:7,j:12, ...p_truss, A:1.7e-3},{i:8,j:11, ...p_truss, A:1.7e-3}
    ], nl:[{n:9,px:20},{n:10,px:20},{n:11,px:20},{n:12,px:20},{n:9,py:-30},{n:10,py:-30},{n:11,py:-30},{n:12,py:-30}], ml:[] } },
    { name: '4B-1: ‰∏ãË∑Ø„Ç¢„Éº„ÉÅÊ©ã', data: { nodes: [{x:0,y:0,s:'p'},{x:6,y:0,s:'f'},{x:12,y:0,s:'f'},{x:18,y:0,s:'f'},{x:24,y:0,s:'r'},{x:6,y:4,s:'f'},{x:12,y:5,s:'f'},{x:18,y:4,s:'f'}], members:[
        {i:1,j:2, E:UNIT_CONVERSION.E_STEEL, I:7.21e-5, A:4.678e-3, Z:4.81e-4},{i:2,j:3, E:UNIT_CONVERSION.E_STEEL, I:7.21e-5, A:4.678e-3, Z:4.81e-4},{i:3,j:4, E:UNIT_CONVERSION.E_STEEL, I:7.21e-5, A:4.678e-3, Z:4.81e-4},{i:4,j:5, E:UNIT_CONVERSION.E_STEEL, I:7.21e-5, A:4.678e-3, Z:4.81e-4},
        {i:1,j:6, E:UNIT_CONVERSION.E_STEEL, I:3.96e-5, A:3.697e-3, Z:3.17e-4},{i:6,j:7, E:UNIT_CONVERSION.E_STEEL, I:3.96e-5, A:3.697e-3, Z:3.17e-4},{i:7,j:8, E:UNIT_CONVERSION.E_STEEL, I:3.96e-5, A:3.697e-3, Z:3.17e-4},{i:8,j:5, E:UNIT_CONVERSION.E_STEEL, I:3.96e-5, A:3.697e-3, Z:3.17e-4},
        {i:2,j:6, E:UNIT_CONVERSION.E_STEEL, I:1.81e-5, A:2.667e-3, Z:1.81e-4},{i:3,j:7, E:UNIT_CONVERSION.E_STEEL, I:1.81e-5, A:2.667e-3, Z:1.81e-4},{i:4,j:8, E:UNIT_CONVERSION.E_STEEL, I:1.81e-5, A:2.667e-3, Z:1.81e-4}
    ], nl:[{n:2,py:-20},{n:3,py:-20},{n:4,py:-20}], ml:[] } },
    { name: '4B-2: Ë§áÂêà„Éà„É©„ÇπÊ©ã', data: { nodes: [{x:0,y:0,s:'p'},{x:6,y:0,s:'f'},{x:12,y:0,s:'f'},{x:18,y:0,s:'f'},{x:24,y:0,s:'r'},{x:0,y:4,s:'f'},{x:6,y:4,s:'f'},{x:12,y:4,s:'f'},{x:18,y:4,s:'f'},{x:24,y:4,s:'f'},{x:6,y:8,s:'f'},{x:12,y:9,s:'f'},{x:18,y:8,s:'f'}], members:[
        {i:1,j:2, ...p_truss, A:3.697e-3},{i:2,j:3, ...p_truss, A:3.697e-3},{i:3,j:4, ...p_truss, A:3.697e-3},{i:4,j:5, ...p_truss, A:3.697e-3},
        {i:6,j:7, ...p_truss, A:3.697e-3},{i:7,j:8, ...p_truss, A:3.697e-3},{i:8,j:9, ...p_truss, A:3.697e-3},{i:9,j:10, ...p_truss, A:3.697e-3},
        {i:7,j:11, ...p_truss, A:2.667e-3},{i:8,j:12, ...p_truss, A:2.667e-3},{i:9,j:13, ...p_truss, A:2.667e-3},{i:11,j:12, ...p_truss, A:2.667e-3},{i:12,j:13, ...p_truss, A:2.667e-3},
        {i:1,j:6, ...p_truss, A:1.7e-3},{i:2,j:7, ...p_truss, A:1.7e-3},{i:3,j:8, ...p_truss, A:1.7e-3},{i:4,j:9, ...p_truss, A:1.7e-3},{i:5,j:10, ...p_truss, A:1.7e-3},
        {i:6,j:2, ...p_truss, A:1.7e-3},{i:7,j:3, ...p_truss, A:1.7e-3},{i:8,j:4, ...p_truss, A:1.7e-3},{i:9,j:5, ...p_truss, A:1.7e-3},
        {i:7,j:12, ...p_truss, A:1.7e-3},{i:8,j:11, ...p_truss, A:1.7e-3},{i:8,j:13, ...p_truss, A:1.7e-3},{i:9,j:12, ...p_truss, A:1.7e-3}
    ], nl:[{n:1,py:-20},{n:2,py:-20},{n:3,py:-20},{n:4,py:-20},{n:5,py:-20}], ml:[] } },
    { name: '4B-3: ÂêäÂ∫äÁâàÊ©ã', data: { nodes: [{x:0,y:0,s:'x'},{x:36,y:0,s:'x'},{x:0,y:12,s:'f'},{x:36,y:12,s:'f'},{x:6,y:0,s:'f'},{x:12,y:0,s:'f'},{x:18,y:0,s:'f'},{x:24,y:0,s:'f'},{x:30,y:0,s:'f'},{x:6,y:9,s:'f'},{x:12,y:8,s:'f'},{x:18,y:7,s:'f'},{x:24,y:8,s:'f'},{x:30,y:9,s:'f'}], members:[
        {i:1,j:3, E:UNIT_CONVERSION.E_STEEL, I:2.35e-4, A:8.337e-3, Z:1.17e-3},{i:2,j:4, E:UNIT_CONVERSION.E_STEEL, I:2.35e-4, A:8.337e-3, Z:1.17e-3},
        {i:3,j:10, ...p_truss, A:4.678e-3},{i:10,j:11, ...p_truss, A:4.678e-3},{i:11,j:12, ...p_truss, A:4.678e-3},{i:12,j:13, ...p_truss, A:4.678e-3},
        {i:13,j:14, ...p_truss, A:4.678e-3},{i:14,j:4, ...p_truss, A:4.678e-3},
        {i:5,j:6, E:UNIT_CONVERSION.E_STEEL, I:7.21e-5, A:4.678e-3, Z:4.81e-4},{i:6,j:7, E:UNIT_CONVERSION.E_STEEL, I:7.21e-5, A:4.678e-3, Z:4.81e-4},{i:7,j:8, E:UNIT_CONVERSION.E_STEEL, I:7.21e-5, A:4.678e-3, Z:4.81e-4},{i:8,j:9, E:UNIT_CONVERSION.E_STEEL, I:7.21e-5, A:4.678e-3, Z:4.81e-4},
        {i:5,j:10, ...p_truss, A:1.7e-3},{i:6,j:11, ...p_truss, A:1.7e-3},{i:7,j:12, ...p_truss, A:1.7e-3},{i:8,j:13, ...p_truss, A:1.7e-3},{i:9,j:14, ...p_truss, A:1.7e-3}
    ], nl:[{n:5,py:-15},{n:6,py:-15},{n:7,py:-15},{n:8,py:-15},{n:9,py:-15}], ml:[] } },
    { name: '4B-4: ÊñúÂºµÊ©ã', data: { nodes: [{x:0,y:0,s:'p'},{x:50,y:0,s:'r'},{x:25,y:0,s:'r'},{x:25,y:20,s:'f'},{x:10,y:0,s:'f'},{x:20,y:0,s:'f'},{x:30,y:0,s:'f'},{x:40,y:0,s:'f'}], members:[
        {i:3,j:4, E:UNIT_CONVERSION.E_STEEL, I:2.35e-4, A:8.337e-3, Z:1.17e-3},
        {i:4,j:5, ...p_truss, A:3.697e-3},{i:4,j:6, ...p_truss, A:3.697e-3},{i:4,j:7, ...p_truss, A:3.697e-3},{i:4,j:8, ...p_truss, A:3.697e-3},
        {i:1,j:5, E:UNIT_CONVERSION.E_STEEL, I:7.21e-5, A:4.678e-3, Z:4.81e-4},{i:5,j:6, E:UNIT_CONVERSION.E_STEEL, I:7.21e-5, A:4.678e-3, Z:4.81e-4},
        {i:6,j:3, E:UNIT_CONVERSION.E_STEEL, I:7.21e-5, A:4.678e-3, Z:4.81e-4},{i:3,j:7, E:UNIT_CONVERSION.E_STEEL, I:7.21e-5, A:4.678e-3, Z:4.81e-4},
        {i:7,j:8, E:UNIT_CONVERSION.E_STEEL, I:7.21e-5, A:4.678e-3, Z:4.81e-4},{i:8,j:2, E:UNIT_CONVERSION.E_STEEL, I:7.21e-5, A:4.678e-3, Z:4.81e-4}
    ], nl:[{n:5,py:-20},{n:6,py:-20},{n:7,py:-20},{n:8,py:-20}], ml:[] } },
    { name: '4B-5: Ë§áÂêà„Ç¢„Éº„ÉÅÊ©ã', data: { nodes: [{x:0,y:0,s:'x'},{x:40,y:0,s:'p'},{x:8,y:0,s:'f'},{x:16,y:0,s:'f'},{x:24,y:0,s:'f'},{x:32,y:0,s:'f'},{x:8,y:6,s:'f'},{x:16,y:8,s:'f'},{x:24,y:8,s:'f'},{x:32,y:6,s:'f'},{x:20,y:10,s:'f'}], members:[
        {i:1,j:3, E:UNIT_CONVERSION.E_STEEL, I:7.21e-5, A:4.678e-3, Z:4.81e-4},{i:3,j:4, E:UNIT_CONVERSION.E_STEEL, I:7.21e-5, A:4.678e-3, Z:4.81e-4},{i:4,j:5, E:UNIT_CONVERSION.E_STEEL, I:7.21e-5, A:4.678e-3, Z:4.81e-4},
        {i:5,j:6, E:UNIT_CONVERSION.E_STEEL, I:7.21e-5, A:4.678e-3, Z:4.81e-4},{i:6,j:2, E:UNIT_CONVERSION.E_STEEL, I:7.21e-5, A:4.678e-3, Z:4.81e-4},
        {i:7,j:8, E:UNIT_CONVERSION.E_STEEL, I:1.10e-4, A:5.245e-3, Z:6.38e-4},{i:8,j:11, E:UNIT_CONVERSION.E_STEEL, I:1.10e-4, A:5.245e-3, Z:6.38e-4},
        {i:11,j:9, E:UNIT_CONVERSION.E_STEEL, I:1.10e-4, A:5.245e-3, Z:6.38e-4},{i:9,j:10, E:UNIT_CONVERSION.E_STEEL, I:1.10e-4, A:5.245e-3, Z:6.38e-4},
        {i:3,j:7, ...p_truss, A:1.7e-3},{i:4,j:8, ...p_truss, A:1.7e-3},{i:5,j:9, ...p_truss, A:1.7e-3},{i:6,j:10, ...p_truss, A:1.7e-3},
        {i:3,j:8, ...p_truss, A:1.7e-3},{i:4,j:7, ...p_truss, A:1.7e-3},{i:4,j:9, ...p_truss, A:1.7e-3},{i:5,j:8, ...p_truss, A:1.7e-3},
        {i:5,j:10, ...p_truss, A:1.7e-3},{i:6,j:9, ...p_truss, A:1.7e-3}
    ], nl:[{n:3,py:-15},{n:4,py:-15},{n:5,py:-15},{n:6,py:-15}], ml:[] } },
    { name: '4C-1: È´òÂ±§Âª∫Áâ©ÔºãÂà∂ÊåØË£ÖÁΩÆ', data: { nodes: [{x:0,y:0,s:'x'},{x:8,y:0,s:'x'},{x:16,y:0,s:'x'},{x:0,y:4,s:'f'},{x:8,y:4,s:'f'},{x:16,y:4,s:'f'},{x:0,y:8,s:'f'},{x:8,y:8,s:'f'},{x:16,y:8,s:'f'},{x:0,y:12,s:'f'},{x:8,y:12,s:'f'},{x:16,y:12,s:'f'},{x:0,y:16,s:'f'},{x:8,y:16,s:'f'},{x:16,y:16,s:'f'},{x:0,y:20,s:'f'},{x:8,y:20,s:'f'},{x:16,y:20,s:'f'},{x:0,y:24,s:'f'},{x:8,y:24,s:'f'},{x:16,y:24,s:'f'},{x:0,y:28,s:'f'},{x:8,y:28,s:'f'},{x:16,y:28,s:'f'},{x:0,y:32,s:'f'},{x:8,y:32,s:'f'},{x:16,y:32,s:'f'},{x:0,y:36,s:'f'},{x:8,y:36,s:'f'},{x:16,y:36,s:'f'}], members:[
        {i:1,j:4,E:205000,I:6.66e-4,A:2.187e-2,Z:3.33e-3},{i:4,j:7,E:205000,I:6.66e-4,A:2.187e-2,Z:3.33e-3},{i:7,j:10,E:205000,I:5.61e-4,A:1.868e-2,Z:2.85e-3},{i:10,j:13,E:205000,I:5.61e-4,A:1.868e-2,Z:2.85e-3},{i:13,j:16,E:205000,I:3.98e-4,A:1.719e-2,Z:2.28e-3},{i:16,j:19,E:205000,I:3.98e-4,A:1.719e-2,Z:2.28e-3},{i:19,j:22,E:205000,I:2.35e-4,A:8.337e-3,Z:1.17e-3},{i:22,j:25,E:205000,I:2.35e-4,A:8.337e-3,Z:1.17e-3},{i:25,j:28,E:205000,I:1.35e-4,A:6.291e-3,Z:7.71e-4},
        {i:2,j:5,E:205000,I:6.66e-4,A:2.187e-2,Z:3.33e-3},{i:5,j:8,E:205000,I:6.66e-4,A:2.187e-2,Z:3.33e-3},{i:8,j:11,E:205000,I:5.61e-4,A:1.868e-2,Z:2.85e-3},{i:11,j:14,E:205000,I:5.61e-4,A:1.868e-2,Z:2.85e-3},{i:14,j:17,E:205000,I:3.98e-4,A:1.719e-2,Z:2.28e-3},{i:17,j:20,E:205000,I:3.98e-4,A:1.719e-2,Z:2.28e-3},{i:20,j:23,E:205000,I:2.35e-4,A:8.337e-3,Z:1.17e-3},{i:23,j:26,E:205000,I:2.35e-4,A:8.337e-3,Z:1.17e-3},{i:26,j:29,E:205000,I:1.35e-4,A:6.291e-3,Z:7.71e-4},
        {i:3,j:6,E:205000,I:6.66e-4,A:2.187e-2,Z:3.33e-3},{i:6,j:9,E:205000,I:6.66e-4,A:2.187e-2,Z:3.33e-3},{i:9,j:12,E:205000,I:5.61e-4,A:1.868e-2,Z:2.85e-3},{i:12,j:15,E:205000,I:5.61e-4,A:1.868e-2,Z:2.85e-3},{i:15,j:18,E:205000,I:3.98e-4,A:1.719e-2,Z:2.28e-3},{i:18,j:21,E:205000,I:3.98e-4,A:1.719e-2,Z:2.28e-3},{i:21,j:24,E:205000,I:2.35e-4,A:8.337e-3,Z:1.17e-3},{i:24,j:27,E:205000,I:2.35e-4,A:8.337e-3,Z:1.17e-3},{i:27,j:30,E:205000,I:1.35e-4,A:6.291e-3,Z:7.71e-4},
        {i:4,j:5,E:205000,I:2.35e-4,A:8.337e-3,Z:1.17e-3},{i:5,j:6,E:205000,I:2.35e-4,A:8.337e-3,Z:1.17e-3},{i:7,j:8,E:205000,I:2.35e-4,A:8.337e-3,Z:1.17e-3},{i:8,j:9,E:205000,I:2.35e-4,A:8.337e-3,Z:1.17e-3},{i:10,j:11,E:205000,I:1.35e-4,A:6.291e-3,Z:7.71e-4},{i:11,j:12,E:205000,I:1.35e-4,A:6.291e-3,Z:7.71e-4},{i:13,j:14,E:205000,I:1.35e-4,A:6.291e-3,Z:7.71e-4},{i:14,j:15,E:205000,I:1.35e-4,A:6.291e-3,Z:7.71e-4},{i:16,j:17,E:205000,I:1.35e-4,A:6.291e-3,Z:7.71e-4},{i:17,j:18,E:205000,I:1.35e-4,A:6.291e-3,Z:7.71e-4},{i:19,j:20,E:205000,I:7.21e-5,A:4.678e-3,Z:4.81e-4},{i:20,j:21,E:205000,I:7.21e-5,A:4.678e-3,Z:4.81e-4},{i:22,j:23,E:205000,I:7.21e-5,A:4.678e-3,Z:4.81e-4},{i:23,j:24,E:205000,I:7.21e-5,A:4.678e-3,Z:4.81e-4},{i:25,j:26,E:205000,I:7.21e-5,A:4.678e-3,Z:4.81e-4},{i:26,j:27,E:205000,I:7.21e-5,A:4.678e-3,Z:4.81e-4},{i:28,j:29,E:205000,I:7.21e-5,A:4.678e-3,Z:4.81e-4},{i:29,j:30,E:205000,I:7.21e-5,A:4.678e-3,Z:4.81e-4},
        {i:4,j:8, ...p_truss, A:1.269e-3},{i:5,j:9, ...p_truss, A:1.269e-3},{i:7,j:11, ...p_truss, A:1.269e-3},{i:8,j:12, ...p_truss, A:1.269e-3},
        {i:13,j:17, ...p_truss, A:1.269e-3},{i:14,j:18, ...p_truss, A:1.269e-3},{i:16,j:20, ...p_truss, A:1.269e-3},{i:17,j:21, ...p_truss, A:1.269e-3},
        {i:22,j:26, ...p_truss, A:1.269e-3},{i:23,j:27, ...p_truss, A:1.269e-3},{i:25,j:29, ...p_truss, A:1.269e-3},{i:26,j:30, ...p_truss, A:1.269e-3}
    ], nl:[{n:4,px:10},{n:7,px:10},{n:10,px:10},{n:13,px:10},{n:16,px:10},{n:19,px:10},{n:22,px:10},{n:25,px:10},{n:28,px:10}], ml:[] } },
    { name: '4C-2: Â§ß„Çπ„Éë„É≥Á´ã‰Ωì„Éà„É©„Çπ', data: { nodes: [{x:0, y:0, s:'p'},{x:6, y:0, s:'f'},{x:12, y:0, s:'f'},{x:18, y:0, s:'f'},{x:24, y:0, s:'f'},{x:30, y:0, s:'f'},{x:36, y:0, s:'r'},{x:0, y:6, s:'f'},{x:6, y:6, s:'f'},{x:12, y:6, s:'f'},{x:18, y:6, s:'f'},{x:24, y:6, s:'f'},{x:30, y:6, s:'f'},{x:36, y:6, s:'f'}], members:[
        {i:1,j:2, ...p_truss, A:2.667e-3},{i:2,j:3, ...p_truss, A:2.667e-3},{i:3,j:4, ...p_truss, A:2.667e-3},{i:4,j:5, ...p_truss, A:2.667e-3},{i:5,j:6, ...p_truss, A:2.667e-3},{i:6,j:7, ...p_truss, A:2.667e-3},
        {i:8,j:9, ...p_truss, A:2.667e-3},{i:9,j:10, ...p_truss, A:2.667e-3},{i:10,j:11, ...p_truss, A:2.667e-3},{i:11,j:12, ...p_truss, A:2.667e-3},{i:12,j:13, ...p_truss, A:2.667e-3},{i:13,j:14, ...p_truss, A:2.667e-3},
        {i:1,j:8, ...p_truss, A:1.7e-3},{i:2,j:9, ...p_truss, A:1.7e-3},{i:3,j:10, ...p_truss, A:1.7e-3},{i:4,j:11, ...p_truss, A:1.7e-3},{i:5,j:12, ...p_truss, A:1.7e-3},{i:6,j:13, ...p_truss, A:1.7e-3},{i:7,j:14, ...p_truss, A:1.7e-3},
        {i:1,j:9, ...p_truss, A:1.7e-3},{i:2,j:10, ...p_truss, A:1.7e-3},{i:3,j:11, ...p_truss, A:1.7e-3},{i:4,j:12, ...p_truss, A:1.7e-3},{i:5,j:13, ...p_truss, A:1.7e-3},{i:6,j:14, ...p_truss, A:1.7e-3},
        {i:8,j:2, ...p_truss, A:1.7e-3},{i:9,j:3, ...p_truss, A:1.7e-3},{i:10,j:4, ...p_truss, A:1.7e-3},{i:11,j:5, ...p_truss, A:1.7e-3},{i:12,j:6, ...p_truss, A:1.7e-3},{i:13,j:7, ...p_truss, A:1.7e-3}
    ], nl:[{n:8,py:-15},{n:9,py:-15},{n:10,py:-15},{n:11,py:-15},{n:12,py:-15},{n:13,py:-15},{n:14,py:-15}], ml:[] } },
    { name: '4C-3: ÁâπÊÆä„Éâ„Éº„É†ÊßãÈÄ†', data: { nodes: [{x:0,y:0,s:'p'},{x:40,y:0,s:'r'},{x:5,y:3,s:'f'},{x:10,y:6,s:'f'},{x:15,y:9,s:'f'},{x:20,y:10,s:'f'},{x:25,y:9,s:'f'},{x:30,y:6,s:'f'},{x:35,y:3,s:'f'},{x:2.5,y:1.5,s:'f'},{x:37.5,y:1.5,s:'f'}], members:[
        {i:1,j:10, E:UNIT_CONVERSION.E_STEEL, I:1.10e-4, A:5.245e-3, Z:6.38e-4},{i:10,j:3, E:UNIT_CONVERSION.E_STEEL, I:1.10e-4, A:5.245e-3, Z:6.38e-4},{i:3,j:4, E:UNIT_CONVERSION.E_STEEL, I:1.10e-4, A:5.245e-3, Z:6.38e-4},{i:4,j:5, E:UNIT_CONVERSION.E_STEEL, I:1.10e-4, A:5.245e-3, Z:6.38e-4},{i:5,j:6, E:UNIT_CONVERSION.E_STEEL, I:1.10e-4, A:5.245e-3, Z:6.38e-4},
        {i:6,j:7, E:UNIT_CONVERSION.E_STEEL, I:1.10e-4, A:5.245e-3, Z:6.38e-4},{i:7,j:8, E:UNIT_CONVERSION.E_STEEL, I:1.10e-4, A:5.245e-3, Z:6.38e-4},{i:8,j:9, E:UNIT_CONVERSION.E_STEEL, I:1.10e-4, A:5.245e-3, Z:6.38e-4},{i:9,j:11, E:UNIT_CONVERSION.E_STEEL, I:1.10e-4, A:5.245e-3, Z:6.38e-4},{i:11,j:2, E:UNIT_CONVERSION.E_STEEL, I:1.10e-4, A:5.245e-3, Z:6.38e-4}
    ], nl:[{n:3,py:-10},{n:4,py:-10},{n:5,py:-10},{n:6,py:-10},{n:7,py:-10},{n:8,py:-10},{n:9,py:-10}], ml:[] } },
    { name: '4C-4: Â§öÂ±§„É°„Ç¨„Çπ„Éà„É©„ÇØ„ÉÅ„É£„Éº', data: { nodes: [{x:0,y:0,s:'x'},{x:12,y:0,s:'x'},{x:24,y:0,s:'x'},{x:36,y:0,s:'x'},{x:48,y:0,s:'x'},{x:0,y:12,s:'f'},{x:12,y:12,s:'f'},{x:24,y:12,s:'f'},{x:36,y:12,s:'f'},{x:48,y:12,s:'f'},{x:0,y:24,s:'f'},{x:12,y:24,s:'f'},{x:24,y:24,s:'f'},{x:36,y:24,s:'f'},{x:48,y:24,s:'f'},{x:0,y:36,s:'f'},{x:12,y:36,s:'f'},{x:24,y:36,s:'f'},{x:36,y:36,s:'f'},{x:48,y:36,s:'f'},{x:0,y:48,s:'f'},{x:12,y:48,s:'f'},{x:24,y:48,s:'f'},{x:36,y:48,s:'f'},{x:48,y:48,s:'f'}], members: [
        {i:1,j:6, E:UNIT_CONVERSION.E_STEEL, I:6.66e-4, A:2.187e-2, Z:3.33e-3},{i:6,j:11, E:UNIT_CONVERSION.E_STEEL, I:6.66e-4, A:2.187e-2, Z:3.33e-3},{i:11,j:16, E:UNIT_CONVERSION.E_STEEL, I:5.61e-4, A:1.868e-2, Z:2.85e-3},{i:16,j:21, E:UNIT_CONVERSION.E_STEEL, I:5.61e-4, A:1.868e-2, Z:2.85e-3},
        {i:2,j:7, E:UNIT_CONVERSION.E_STEEL, I:6.66e-4, A:2.187e-2, Z:3.33e-3},{i:7,j:12, E:UNIT_CONVERSION.E_STEEL, I:6.66e-4, A:2.187e-2, Z:3.33e-3},{i:12,j:17, E:UNIT_CONVERSION.E_STEEL, I:5.61e-4, A:1.868e-2, Z:2.85e-3},{i:17,j:22, E:UNIT_CONVERSION.E_STEEL, I:5.61e-4, A:1.868e-2, Z:2.85e-3},
        {i:3,j:8, E:UNIT_CONVERSION.E_STEEL, I:6.66e-4, A:2.187e-2, Z:3.33e-3},{i:8,j:13, E:UNIT_CONVERSION.E_STEEL, I:6.66e-4, A:2.187e-2, Z:3.33e-3},{i:13,j:18, E:UNIT_CONVERSION.E_STEEL, I:5.61e-4, A:1.868e-2, Z:2.85e-3},{i:18,j:23, E:UNIT_CONVERSION.E_STEEL, I:5.61e-4, A:1.868e-2, Z:2.85e-3},
        {i:4,j:9, E:UNIT_CONVERSION.E_STEEL, I:6.66e-4, A:2.187e-2, Z:3.33e-3},{i:9,j:14, E:UNIT_CONVERSION.E_STEEL, I:6.66e-4, A:2.187e-2, Z:3.33e-3},{i:14,j:19, E:UNIT_CONVERSION.E_STEEL, I:5.61e-4, A:1.868e-2, Z:2.85e-3},{i:19,j:24, E:UNIT_CONVERSION.E_STEEL, I:5.61e-4, A:1.868e-2, Z:2.85e-3},
        {i:5,j:10, E:UNIT_CONVERSION.E_STEEL, I:6.66e-4, A:2.187e-2, Z:3.33e-3},{i:10,j:15, E:UNIT_CONVERSION.E_STEEL, I:6.66e-4, A:2.187e-2, Z:3.33e-3},{i:15,j:20, E:UNIT_CONVERSION.E_STEEL, I:5.61e-4, A:1.868e-2, Z:2.85e-3},{i:20,j:25, E:UNIT_CONVERSION.E_STEEL, I:5.61e-4, A:1.868e-2, Z:2.85e-3},
        {i:6,j:10, ...p_truss, A:6.291e-3},{i:11,j:15, ...p_truss, A:6.291e-3},{i:16,j:20, ...p_truss, A:6.291e-3},{i:21,j:25, ...p_truss, A:6.291e-3},
        {i:1,j:7, ...p_truss, A:6.291e-3},{i:2,j:6, ...p_truss, A:6.291e-3},{i:2,j:8, ...p_truss, A:6.291e-3},{i:3,j:7, ...p_truss, A:6.291e-3},
        {i:3,j:9, ...p_truss, A:6.291e-3},{i:4,j:8, ...p_truss, A:6.291e-3},{i:4,j:10, ...p_truss, A:6.291e-3},{i:5,j:9, ...p_truss, A:6.291e-3},
        {i:6,j:12, ...p_truss, A:6.291e-3},{i:7,j:11, ...p_truss, A:6.291e-3},{i:7,j:13, ...p_truss, A:6.291e-3},{i:8,j:12, ...p_truss, A:6.291e-3},
        {i:8,j:14, ...p_truss, A:6.291e-3},{i:9,j:13, ...p_truss, A:6.291e-3},{i:9,j:15, ...p_truss, A:6.291e-3},{i:10,j:14, ...p_truss, A:6.291e-3},
        {i:11,j:17, ...p_truss, A:4.678e-3},{i:12,j:16, ...p_truss, A:4.678e-3},{i:12,j:18, ...p_truss, A:4.678e-3},{i:13,j:17, ...p_truss, A:4.678e-3},
        {i:13,j:19, ...p_truss, A:4.678e-3},{i:14,j:18, ...p_truss, A:4.678e-3},{i:14,j:20, ...p_truss, A:4.678e-3},{i:15,j:19, ...p_truss, A:4.678e-3},
        {i:16,j:22, ...p_truss, A:4.678e-3},{i:17,j:21, ...p_truss, A:4.678e-3},{i:17,j:23, ...p_truss, A:4.678e-3},{i:18,j:22, ...p_truss, A:4.678e-3},
        {i:18,j:24, ...p_truss, A:4.678e-3},{i:19,j:23, ...p_truss, A:4.678e-3},{i:19,j:25, ...p_truss, A:4.678e-3},{i:20,j:24, ...p_truss, A:4.678e-3}
    ], nl:[{n:6,px:20},{n:7,px:20},{n:8,px:20},{n:9,px:20},{n:10,px:20},{n:11,px:20},{n:12,px:20},{n:13,px:20},{n:14,px:20},{n:15,px:20},{n:16,px:20},{n:17,px:20},{n:18,px:20},{n:19,px:20},{n:20,px:20},{n:21,px:20},{n:22,px:20},{n:23,px:20},{n:24,px:20},{n:25,px:20}], ml:[] } }
];

// Êñ≠Èù¢ÊÉÖÂ†±Ë®≠ÂÆöÈñ¢Êï∞ÔºàloadPresetÈñ¢Êï∞„Çà„ÇäÂâç„Å´ÂÆöÁæ©Ôºâ
window.applySectionAxisDataset = function applySectionAxisDataset(row, axisInfo) {
    if (!row) return;

    const normalizedAxis = normalizeAxisInfo(axisInfo);
    if (normalizedAxis) {
        row.dataset.sectionAxisKey = normalizedAxis.key;
        row.dataset.sectionAxisMode = normalizedAxis.mode;
        row.dataset.sectionAxisLabel = normalizedAxis.label;
    } else {
        delete row.dataset.sectionAxisKey;
        delete row.dataset.sectionAxisMode;
        delete row.dataset.sectionAxisLabel;
    }
};

window.setRowSectionInfo = function setRowSectionInfo(row, sectionInfo) {
    console.log('üîß setRowSectionInfo called', { row, hasSectionInfo: !!sectionInfo });

    if (!(row instanceof HTMLTableRowElement)) {
        console.warn('setRowSectionInfo: invalid `row` argument (expected HTMLTableRowElement).', row);
        return;
    }

    // Show existing encoded value for debugging
    try {
        const prevEncoded = row.dataset.sectionInfo;
        if (prevEncoded) {
            let prevDecoded = null;
            try {
                prevDecoded = JSON.parse(decodeURIComponent(prevEncoded));
            } catch (e) {
                try { prevDecoded = JSON.parse(prevEncoded); } catch (e2) { prevDecoded = null; }
            }
            console.log('setRowSectionInfo: previous sectionInfo (decoded):', prevDecoded);
        } else {
            console.log('setRowSectionInfo: no previous sectionInfo on row.dataset');
        }
    } catch (err) {
        console.warn('setRowSectionInfo: error while reading previous dataset.sectionInfo', err);
    }

    if (!sectionInfo) {
        console.log('setRowSectionInfo: called with null/undefined sectionInfo ‚Äî skipping write (no-op).');
        return;
    }

    // Ensure the object has SVG markup and axis normalized
    let enrichedInfo = ensureSectionSvgMarkup(sectionInfo || {});
    if (!enrichedInfo || typeof enrichedInfo !== 'object') {
        console.error('setRowSectionInfo: enriched sectionInfo is invalid:', enrichedInfo);
        return;
    }

    // Detailed debug: log the enriched info before any guard/fix
    try {
        console.log('setRowSectionInfo: enrichedInfo (pre-guard):', JSON.parse(JSON.stringify(enrichedInfo)));
    } catch (e) {
        console.log('setRowSectionInfo: enrichedInfo (pre-guard) (stringify failed)', enrichedInfo);
    }

    // Guard: if typeKey is missing or unknown, attempt to derive a better typeKey
    try {
        if (!enrichedInfo.typeKey || enrichedInfo.typeKey === 'unknown') {
            const derived = (typeof deriveSectionTypeKey === 'function') ? deriveSectionTypeKey(enrichedInfo) : null;
            if (derived && derived !== 'unknown') {
                enrichedInfo.typeKey = derived;
                console.log('setRowSectionInfo: derived and applied typeKey:', derived);
                // regenerate svg/axis now that typeKey is set
                try {
                    enrichedInfo = ensureSectionSvgMarkup(enrichedInfo || {});
                    console.log('setRowSectionInfo: re-run ensureSectionSvgMarkup after typeKey derivation');
                } catch (e2) {
                    console.warn('setRowSectionInfo: ensureSectionSvgMarkup failed after typeKey derivation', e2);
                }
            } else {
                console.log('setRowSectionInfo: could not derive typeKey (keeps unknown)');
            }
        }
    } catch (err) {
        console.warn('setRowSectionInfo: error during typeKey derivation guard', err);
    }

    // Save to dataset with encoding, but guard against circular structures
    try {
        const json = JSON.stringify(enrichedInfo);
        row.dataset.sectionInfo = encodeURIComponent(json);
        console.log('setRowSectionInfo: wrote encoded sectionInfo to dataset (length=' + row.dataset.sectionInfo.length + ')');
    } catch (err) {
        console.error('setRowSectionInfo: failed to stringify/encode sectionInfo, attempting raw string write.', err);
        try {
            row.dataset.sectionInfo = String(enrichedInfo);
        } catch (err2) {
            console.error('setRowSectionInfo: final fallback write failed.', err2);
        }
    }

    // Supplementary dataset fields for quicker access
    try {
        row.dataset.sectionLabel = enrichedInfo.label || '';
        row.dataset.sectionSummary = enrichedInfo.dimensionSummary || '';
        row.dataset.sectionSource = enrichedInfo.source || '';
    } catch (err) {
        console.warn('setRowSectionInfo: failed to set supplementary dataset fields', err);
    }

    // Apply axis dataset if helper exists
    try {
        if (window.applySectionAxisDataset) {
            window.applySectionAxisDataset(row, enrichedInfo.axis);
            console.log('setRowSectionInfo: applied axis dataset via applySectionAxisDataset', enrichedInfo.axis);
        } else if (enrichedInfo.axis) {
            // fallback: write axis fields directly
            row.dataset.sectionAxisKey = enrichedInfo.axis.key || '';
            row.dataset.sectionAxisMode = enrichedInfo.axis.mode || '';
            row.dataset.sectionAxisLabel = enrichedInfo.axis.label || '';
            console.log('setRowSectionInfo: wrote axis fields directly to dataset', { key: row.dataset.sectionAxisKey, mode: row.dataset.sectionAxisMode });
        }
    } catch (err) {
        console.warn('setRowSectionInfo: error while applying axis dataset', err);
    }

    // Update visible cells (name / axis) using class-based selectors; fall back to position-based.
    try {
        const sectionNameCell = row.querySelector('.section-name-cell');
        if (sectionNameCell) sectionNameCell.textContent = enrichedInfo.label || '-';
        else {
            const cellCount = row.cells.length;
            if (cellCount >= 6) {
                const nameCellIndex = cellCount - 6;
                if (!row.cells[nameCellIndex].querySelector('input, select, button')) {
                    row.cells[nameCellIndex].textContent = enrichedInfo.label || '-';
                }
            }
        }

        const sectionAxisCell = row.querySelector('.section-axis-cell');
        if (sectionAxisCell) sectionAxisCell.textContent = enrichedInfo.axis?.label || '-';
        else {
            const cellCount = row.cells.length;
            if (cellCount >= 5) {
                const axisCellIndex = cellCount - 5;
                if (!row.cells[axisCellIndex].querySelector('input, select, button')) {
                    row.cells[axisCellIndex].textContent = enrichedInfo.axis?.label || '-';
                }
            }
        }
    } catch (err) {
        console.warn('setRowSectionInfo: failed to update visible name/axis cells', err);
    }

    // For debugging: read back the dataset and show decoded value
    try {
        const afterEncoded = row.dataset.sectionInfo;
        let afterDecoded = null;
        try { afterDecoded = JSON.parse(decodeURIComponent(afterEncoded)); } catch (e) { try { afterDecoded = JSON.parse(afterEncoded); } catch (e2) { afterDecoded = afterEncoded; } }
        console.log('setRowSectionInfo: post-write dataset.sectionInfo (decoded):', afterDecoded);
    } catch (err) {
        console.warn('setRowSectionInfo: error while decoding written dataset.sectionInfo', err);
    }
};

const loadPreset = (index) => {
        const preset = presets[index];
        if (!preset || !preset.data) return;
        const p = preset.data;
        
        // „Éó„É™„Çª„ÉÉ„ÉàË™≠„ÅøËæº„Åø‰∏≠„Éï„É©„Ç∞„ÇíË®≠ÂÆöÔºàÊèèÁîªÂá¶ÁêÜ„Çí„Çπ„Ç≠„ÉÉ„Éó„Åô„Çã„Åü„ÇÅÔºâ
        window.isLoadingPreset = true;
        
        HistoryManager.clear();
        elements.nodesTable.innerHTML = '';
        elements.membersTable.innerHTML = '';
        elements.nodeLoadsTable.innerHTML = '';
        elements.memberLoadsTable.innerHTML = '';
        p.nodes.forEach(n => addRow(elements.nodesTable, [`#`, `<input type="number" value="${n.x}">`, `<input type="number" value="${n.y}">`, `<select><option value="free"${n.s==='f'?' selected':''}>Ëá™Áî±</option><option value="pinned"${n.s==='p'?' selected':''}>„Éî„É≥</option><option value="fixed"${n.s==='x'?' selected':''}>Âõ∫ÂÆö</option><option value="roller_x_fixed">„É≠„Éº„É©„Éº(ÂûÇÁõ¥Ëá™Áî±)</option><option value="roller_y_fixed"${n.s==='r'?' selected':''}>„É≠„Éº„É©„Éº(Ê∞¥Âπ≥Ëá™Áî±)</option></select>`, `<input type="number" value="0" step="0.1">`, `<input type="number" value="0" step="0.1">`, `<input type="number" value="0" step="0.001">`], false));
        p.members.forEach(m => {
            const E_N_mm2 = m.E || '205000';
            const F_N_mm2 = m.F || '235';
            const I_m4 = m.I || 1e-9;
            const A_m2 = m.A || 1e-3;
            const Z_m3 = m.Z || 1e-9;

            // „Éó„É™„Çª„ÉÉ„Éà„Åã„ÇâÊñ≠Èù¢ÊÉÖÂ†±„Å®Ëª∏ÊÉÖÂ†±„ÇíÂèñÂæó
            const presetProfile = findPresetSectionProfile(m);
            const sectionInfoFromPreset = presetProfile ? cloneDeep(presetProfile.sectionInfo) : parseSectionInfoFromMember(m);
            const axisInfo = buildAxisInfo(m, sectionInfoFromPreset);

            // Êñ≠Èù¢ÂêçÁß∞„Å®Ëª∏ÊñπÂêë„ÇíÂèñÂæó
            const sectionName = sectionInfoFromPreset?.label || '';
            const sectionAxis = axisInfo?.label || '';
            // „Éó„É™„Çª„ÉÉ„Éà„ÇÑ„É°„É≥„Éê„Éº„Éá„Éº„Çø„Å´ ix/iy „ÅåÂê´„Åæ„Çå„ÇãÂ†¥Âêà„ÄÅÂ∞è„Åï„ÅÑÊñπ„ÇíÊñ≠Èù¢i (cm) „Å®„Åó„Å¶‰ΩøÁî®
            let i_rad_val = '';
            try {
                const p_ix = presetProfile?.properties?.ix ?? m.ix;
                const p_iy = presetProfile?.properties?.iy ?? m.iy;
                if (p_ix !== undefined && p_iy !== undefined) {
                    const npx = parseFloat(p_ix);
                    const npy = parseFloat(p_iy);
                    if (!isNaN(npx) && !isNaN(npy)) i_rad_val = Math.min(npx, npy);
                } else if (m.I && m.A) {
                    // I (m4), A (m2) „Åã„ÇâÊé®ÂÆö„Åó„Å¶ cm Âçò‰Ωç„Å´Â§âÊèõ
                    try { i_rad_val = Math.sqrt((m.I) / (m.A)) * 100; } catch (e) { i_rad_val = ''; }
                }
            } catch (e) { i_rad_val = ''; }
            const rowCells = memberRowHTML(m.i, m.j, E_N_mm2, F_N_mm2, I_m4, A_m2, Z_m3, i_rad_val, m.i_conn || m.ic, m.j_conn || m.jc, sectionName, sectionAxis, (m.bucklingK !== undefined ? m.bucklingK : ''));
            if (!rowCells || !Array.isArray(rowCells)) {
                console.warn('Failed to build member row cells for preset member:', m);
                return;
            }

            let newRow = addRow(elements.membersTable, [`#`, ...rowCells], false);
            if (!(newRow instanceof HTMLTableRowElement)) {
                if (newRow && typeof newRow.then === 'function') {
                    console.warn('addRow returned a Promise; falling back to last table row for preset member handling.', m);
                } else if (newRow !== undefined) {
                    console.warn('addRow returned a non-row value; attempting fallback.', newRow);
                }

                const memberRows = elements.membersTable?.rows;
                if (memberRows && memberRows.length > 0) {
                    newRow = memberRows[memberRows.length - 1];
                } else {
                    newRow = null;
                }
            }

            if (!(newRow instanceof HTMLTableRowElement)) {
                console.warn('Failed to obtain member row element for preset member:', m);
                return;
            }

            const propertySource = presetProfile ? { ...(presetProfile.properties || {}) } : {};

            // steelData „ÅåÂà©Áî®„Åß„Åç„ÇãÂ†¥Âêà„ÅØ„ÄÅ„Éó„É™„Çª„ÉÉ„ÉàÊñ≠Èù¢ÊÉÖÂ†±„Åã„Çâ Ix/Iy/J/Iw Á≠â„ÇíË£úÂÆå
            // ÔºàË®àÁÆó‰æã„Éó„É™„Çª„ÉÉ„Éà„Åß„ÇÇÊ®™Â∫ßÂ±àÊ§úÂÆö„ÅåË°å„Åà„Çã„Çà„ÅÜ„Å´Ôºâ
            const steelProps = lookupSteelDataPropertiesForSectionInfo(sectionInfoFromPreset);
            if (steelProps) {
                Object.keys(steelProps).forEach((k) => {
                    if (propertySource[k] == null && steelProps[k] != null && isFinite(steelProps[k])) {
                        propertySource[k] = steelProps[k];
                    }
                });
            }

            if (sectionInfoFromPreset) {
                if (axisInfo && !sectionInfoFromPreset.axis) {
                    sectionInfoFromPreset.axis = { ...axisInfo };
                }
                if (typeof window.setRowSectionInfo === 'function') {
                    window.setRowSectionInfo(newRow, sectionInfoFromPreset);
                } else {
                    console.warn('setRowSectionInfoÈñ¢Êï∞„ÅåÂÆöÁæ©„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇ„Éó„É™„Çª„ÉÉ„ÉàË™≠„ÅøËæº„Åø„Çí„Çπ„Ç≠„ÉÉ„Éó„Åó„Åæ„Åô„ÄÇ');
                }
            } else if (axisInfo) {
                if (typeof window.applySectionAxisDataset === 'function') {
                    window.applySectionAxisDataset(newRow, axisInfo);
                } else {
                    console.warn('applySectionAxisDatasetÈñ¢Êï∞„ÅåÂÆöÁæ©„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇËª∏ÊÉÖÂ†±Ë®≠ÂÆö„Çí„Çπ„Ç≠„ÉÉ„Éó„Åó„Åæ„Åô„ÄÇ');
                }
            }

            const zxToApply = propertySource?.Zx ?? m.Zx;
            const zyToApply = propertySource?.Zy ?? m.Zy;
            const ixToApply = propertySource?.ix ?? m.ix;
            const iyToApply = propertySource?.iy ?? m.iy;

            // Ê®™Â∫ßÂ±àÁî®ÔºàcmÂçò‰Ωç„ÅÆÂÄ§„Çídataset„Å´‰øùÊåÅ„ÄÇparseInputs„ÅßSI„Å∏Â§âÊèõÔºâ
            const ixMomToApply = propertySource?.Ix ?? m.Ix;
            const iyMomToApply = propertySource?.Iy ?? m.Iy;
            const jToApply = propertySource?.J ?? m.J;
            const iwToApply = propertySource?.Iw ?? m.Iw;

            if (zxToApply != null) newRow.dataset.zx = zxToApply;
            if (zyToApply != null) newRow.dataset.zy = zyToApply;
            if (ixToApply != null) newRow.dataset.ix = ixToApply;
            if (iyToApply != null) newRow.dataset.iy = iyToApply;

            if (ixMomToApply != null) newRow.dataset.ixMom = ixMomToApply;
            if (iyMomToApply != null) newRow.dataset.iyMom = iyMomToApply;
            if (jToApply != null) newRow.dataset.j = jToApply;
            if (iwToApply != null) newRow.dataset.iw = iwToApply;
        });
        p.nl.forEach(l => addRow(elements.nodeLoadsTable, [`<input type="number" value="${l.n || l.node}">`, `<input type="number" value="${l.px||0}">`, `<input type="number" value="${l.py||0}">`, `<input type="number" value="${l.mz||0}">`], false));
        p.ml.forEach(l => addRow(elements.memberLoadsTable, [`<input type="number" value="${l.m || l.member}">`, `<input type="number" value="${l.w||0}">`], false));
        renumberTables();
        
        // „Éó„É™„Çª„ÉÉ„ÉàË™≠„ÅøËæº„ÅøÂÆå‰∫Ü„Éï„É©„Ç∞„Çí„ÇØ„É™„Ç¢
        window.isLoadingPreset = false;
        
        // „Éá„Éï„Ç©„É´„ÉàË°®Á§∫ÊôÇÔºà„Éó„É™„Çª„ÉÉ„Éà15Ôºâ„ÅÆÊñ≠Èù¢ÊÉÖÂ†±„ÇíÂÜçË®≠ÂÆö
        if (index === 15) {
            setTimeout(() => {
                console.log('üîß „Éá„Éï„Ç©„É´„ÉàË°®Á§∫ÊôÇ„ÅÆÊñ≠Èù¢ÊÉÖÂ†±„ÇíÂÜçË®≠ÂÆö‰∏≠...');
                const memberRows = elements.membersTable.querySelectorAll('tbody tr');
                memberRows.forEach((row, memberIndex) => {
                    const cells = row.cells;
                    if (cells && cells.length >= 9) {
                        // Êñ≠Èù¢ÊÄßËÉΩ„Åã„ÇâÊñ≠Èù¢ÊÉÖÂ†±„ÇíÊé®ÂÆö
                        const IInput = cells[5]?.querySelector('input');
                        const AInput = cells[6]?.querySelector('input');
                        const ZInput = cells[7]?.querySelector('input');
                        
                        if (IInput && AInput && ZInput) {
                            const I = parseFloat(IInput.value) || 0;
                            const A = parseFloat(AInput.value) || 0;
                            const Z = parseFloat(ZInput.value) || 0;
                            
                            // Êñ≠Èù¢ÊÄßËÉΩ„Åã„ÇâÊñ≠Èù¢„Éó„É≠„Éï„Ç°„Ç§„É´„ÇíÊ§úÁ¥¢
                            const presetProfile = PRESET_SECTION_PROFILES.find(({ target }) =>
                                approxEqual(I, target.I) &&
                                approxEqual(A, target.A) &&
                                approxEqual(Z, target.Z)
                            );
                            
                            if (presetProfile && presetProfile.sectionInfo) {
                                console.log(`üîß ÈÉ®Êùê${memberIndex + 1}„ÅÆÊñ≠Èù¢ÊÉÖÂ†±„ÇíË®≠ÂÆö:`, presetProfile.sectionInfo.label);
                                
                                // Êñ≠Èù¢ÂêçÁß∞„Çª„É´„Å®Ëª∏ÊñπÂêë„Çª„É´„ÇíÁõ¥Êé•Êõ¥Êñ∞
                                // ÂØÜÂ∫¶Âàó„ÅÆÊúâÁÑ°„ÅØ„Çª„É´Êï∞„ÅßÂà§ÂÆö
                                const hasDensityColumn = (cells && cells.length >= 15);
                                const sectionNameCell = cells[hasDensityColumn ? 10 : 9];
                                const sectionAxisCell = cells[hasDensityColumn ? 11 : 10];
                                
                                if (sectionNameCell) {
                                    const nameSpan = sectionNameCell.querySelector('.section-name-cell');
                                    if (nameSpan) {
                                        nameSpan.textContent = presetProfile.sectionInfo.label || '-';
                                    } else {
                                        sectionNameCell.textContent = presetProfile.sectionInfo.label || '-';
                                    }
                                }
                                
                                if (sectionAxisCell) {
                                    const axisSpan = sectionAxisCell.querySelector('.section-axis-cell');
                                    if (axisSpan) {
                                        axisSpan.textContent = presetProfile.sectionInfo.axis?.label || '-';
                                    } else {
                                        sectionAxisCell.textContent = presetProfile.sectionInfo.axis?.label || '-';
                                    }
                                }
                                
                                // setRowSectionInfo„ÇÇÂëº„Å≥Âá∫„Åó„Å¶„Éá„Éº„Çø„Çª„ÉÉ„ÉàÂ±ûÊÄß„ÇíË®≠ÂÆö
                                window.setRowSectionInfo(row, presetProfile.sectionInfo);
                                
                                // 3D„Éì„É•„Éº„Ç¢„Å®„ÉÑ„Éº„É´„ÉÅ„ÉÉ„ÉóÁî®„Å´ÈÉ®Êùê„Éá„Éº„Çø„ÇíÊõ¥Êñ∞
                                console.log(`üîß ÈÉ®Êùê${memberIndex + 1}„ÅÆÊñ≠Èù¢ÊÉÖÂ†±„Çí„Éá„Éº„Çø„Çª„ÉÉ„ÉàÂ±ûÊÄß„Å´Ë®≠ÂÆöÂÆå‰∫Ü`);
                            }
                        }
                    }
                });
                console.log('‚úÖ „Éá„Éï„Ç©„É´„ÉàË°®Á§∫ÊôÇ„ÅÆÊñ≠Èù¢ÊÉÖÂ†±ÂÜçË®≠ÂÆöÂÆå‰∫Ü');
                
                // 3D„Éì„É•„Éº„Ç¢„ÇíÊõ¥Êñ∞ÔºàÈñã„ÅÑ„Å¶„ÅÑ„ÇãÂ†¥ÂêàÔºâ
                if (viewerWindow && !viewerWindow.closed) {
                    setTimeout(() => {
                        sendModelToViewer();
                        console.log('üîß 3D„Éì„É•„Éº„Ç¢„ÇíÊõ¥Êñ∞„Åó„Åæ„Åó„Åü');
                    }, 200);
                }
            }, 100);
        }
        
        // Ëá™ÈáçËÄÉÊÖÆ„ÉÅ„Çß„ÉÉ„ÇØ„Éú„ÉÉ„ÇØ„Çπ„ÅåON„ÅÆÂ†¥Âêà„ÄÅËá™Èáç„ÇíÂÜçË®àÁÆó„Åó„Å¶Ë°®Á§∫„ÇíÊõ¥Êñ∞
        const considerSelfWeightCheckbox = document.getElementById('consider-self-weight-checkbox');
        if (considerSelfWeightCheckbox && considerSelfWeightCheckbox.checked) {
            // Ëá™ÈáçËÄÉÊÖÆ„ÅÆË°®Á§∫„ÇíÊõ¥Êñ∞ÔºàÂØÜÂ∫¶Âàó„ÅÆËøΩÂä†„Å™„Å©Ôºâ
            updateSelfWeightDisplay();
        }
        
        // ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ ‰øÆÊ≠£ÁÆáÊâÄ ‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ
        // ÊèèÁîªÁØÑÂõ≤„ÅÆËá™ÂãïË™øÊï¥„Éï„É©„Ç∞„Çí„É™„Çª„ÉÉ„Éà
        panZoomState.isInitialized = false; 
        
        // ÁµêÊûúÂõ≥„ÅÆ„Éë„É≥„Éª„Ç∫„Éº„É†Áä∂ÊÖã„ÇÇ„É™„Çª„ÉÉ„Éà
        Object.keys(resultPanZoomStates).forEach(key => {
            resultPanZoomStates[key].isInitialized = false;
        }); 
        
        drawOnCanvas();
        runFullAnalysis();
    };
    presets.forEach((p, i) => {
        const option = document.createElement('option');
        option.value = i;
        option.textContent = p.name;
        if (p.disabled) {
            option.disabled = true;
            option.style.fontWeight = 'bold';
            option.style.backgroundColor = '#eee';
        }
        elements.presetSelector.appendChild(option);
    });
    elements.presetSelector.addEventListener('change', (e) => {
        loadPreset(e.target.value);
    });

    elements.addNodeBtn.onclick = () => {
        const nodes = Array.from(elements.nodesTable.rows).map(row => ({
            x: parseFloat(row.cells[1].querySelector('input').value),
            y: parseFloat(row.cells[2].querySelector('input').value)
        }));
        let newX = 0, newY = 0;
        if(nodes.length > 0) {
            const maxX = Math.max(...nodes.map(n => n.x));
            const nodeAtMaxX = nodes.find(n => n.x === maxX);
            newX = maxX + parseFloat(elements.gridSpacing.value);
            newY = nodeAtMaxX.y;
        }
        addRow(elements.nodesTable, [`#`, `<input type="number" value="${newX.toFixed(2)}">`, `<input type="number" value="${newY.toFixed(2)}">`, `<select><option value="free">Ëá™Áî±</option><option value="pinned">„Éî„É≥</option><option value="fixed">Âõ∫ÂÆö</option><option value="roller_x_fixed">„É≠„Éº„É©„Éº(ÂûÇÁõ¥Ëá™Áî±)</option><option value="roller_y_fixed">„É≠„Éº„É©„Éº(Ê∞¥Âπ≥Ëá™Áî±)</option></select>`, `<input type="number" value="0" step="0.1">`, `<input type="number" value="0" step="0.1">`, `<input type="number" value="0" step="0.001">`]);
    };
    elements.addMemberBtn.onclick = () => {
        const nodeCount = elements.nodesTable.rows.length;
        if (nodeCount < 2) {
            alert('ÈÉ®Êùê„ÇíËøΩÂä†„Åô„Çã„Å´„ÅØÂ∞ë„Å™„Åè„Å®„ÇÇ2„Å§„ÅÆÁØÄÁÇπ„ÅåÂøÖË¶Å„Åß„Åô„ÄÇ');
            return;
        }
        const existingMembers = new Set();
        Array.from(elements.membersTable.rows).forEach(row => {
            const i = parseInt(row.cells[1].querySelector('input').value);
            const j = parseInt(row.cells[2].querySelector('input').value);
            existingMembers.add(`${Math.min(i,j)}-${Math.max(i,j)}`);
        });
        for (let i = 1; i <= nodeCount; i++) {
            for (let j = i + 1; j <= nodeCount; j++) {
                if (!existingMembers.has(`${i}-${j}`)) {
                    const I_m4 = parseFloat(newMemberDefaults.I) * 1e-8;
                    const A_m2 = parseFloat(newMemberDefaults.A) * 1e-4;
                    const Z_m3 = parseFloat(newMemberDefaults.Z) * 1e-6;
                    const iArgForNew = (newMemberDefaults && (newMemberDefaults.i || newMemberDefaults.i_radius || newMemberDefaults.ix || newMemberDefaults.iy)) ? (newMemberDefaults.i || newMemberDefaults.i_radius || newMemberDefaults.ix || newMemberDefaults.iy) : '';
                    const newRow = addRow(elements.membersTable, [`#`, ...memberRowHTML(i,j,newMemberDefaults.E,newMemberDefaults.F,I_m4,A_m2,Z_m3,iArgForNew,newMemberDefaults.i_conn,newMemberDefaults.j_conn, '', '', '')]);
                    
                    // ÊâãÂãïËøΩÂä†ÈÉ®Êùê„Å´Êñ≠Èù¢ÊÉÖÂ†±„ÇíË®≠ÂÆö
                    if (newRow && typeof window.setRowSectionInfo === 'function') {
                        // „Éá„Éï„Ç©„É´„Éà„ÅÆÊñ≠Èù¢ÊÉÖÂ†±„Çí‰ΩúÊàê
                        const defaultSectionInfo = {
                            typeKey: 'estimated',
                            label: 'Êé®ÂÆöÊñ≠Èù¢ÔºàÂÜÜÂΩ¢Ôºâ',
                            rawDims: {
                                D: Math.sqrt(A_m2 * 1e4 / Math.PI) * 2 * 10, // A„Åã„ÇâÁõ¥ÂæÑ„ÇíË®àÁÆóÔºàmmÔºâ
                                D_scaled: Math.sqrt(A_m2 * 1e4 / Math.PI) * 2 * 10
                            },
                            source: 'ÊâãÂãïËøΩÂä†'
                        };
                        window.setRowSectionInfo(newRow, defaultSectionInfo);
                    }
                    return;
                }
            }
        }
        alert('Êé•Á∂öÂèØËÉΩ„Å™„Åô„Åπ„Å¶„ÅÆÁØÄÁÇπ„Éö„Ç¢„ÅØÊó¢„Å´Êé•Á∂ö„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ');
    };
    // members-table ÂÜÖ„ÅÆÊé•Á∂ö„Çª„É¨„ÇØ„Éà„Å´Âøú„Åò„Å¶Ë°åÂÜÖ„ÅÆ„Éê„ÉçÂÖ•Âäõ„ÇíË°®Á§∫/ÈùûË°®Á§∫„Åô„Çã„É¶„Éº„ÉÜ„Ç£„É™„ÉÜ„Ç£
    const updateAllSpringVisibility = () => {
        try {
            const rows = elements.membersTable.rows;
            Array.from(rows).forEach(row => {
                const connCells = row.querySelectorAll('.conn-cell');
                if (!connCells) return;
                connCells.forEach((cell) => {
                    const select = cell.querySelector('.conn-select');
                    const springBox = cell.querySelector('.spring-inputs');
                    if (!select || !springBox) return;
                    if (select.value === 'spring') {
                        springBox.style.display = '';
                    } else {
                        springBox.style.display = 'none';
                    }
                });
            });
        } catch (e) {
            console.warn('updateAllSpringVisibility error', e);
        }
    };

    // „Ç§„Éô„É≥„Éà„Éá„É™„Ç≤„Éº„Ç∑„Éß„É≥„Åßselect„ÅÆÂ§âÊõ¥„ÇíÁõ£Ë¶ñ
    elements.membersTable.addEventListener('change', (e) => {
        const sel = e.target;
        if (!sel || sel.tagName !== 'SELECT') return;
        if (!sel.classList.contains('conn-select')) return;
        const cell = sel.closest('.conn-cell');
        if (!cell) return;
        const springBox = cell.querySelector('.spring-inputs');
        if (!springBox) return;
        if (sel.value === 'spring') springBox.style.display = '';
        else springBox.style.display = 'none';
    });

    // ÂàùÊúüË°®Á§∫„ÅÆË™øÊï¥ÔºàÊó¢Â≠òË°å„Åå„ÅÇ„ÇãÂ†¥ÂêàÔºâ
    setTimeout(updateAllSpringVisibility, 50);

    elements.addNodeLoadBtn.onclick = () => { addRow(elements.nodeLoadsTable, ['<input type="number" value="1">', '<input type="number" value="0">', '<input type="number" value="0">', '<input type="number" value="0">']); };
    elements.addMemberLoadBtn.onclick = () => { addRow(elements.memberLoadsTable, ['<input type="number" value="1">', '<input type="number" value="0">']); };
    
    
    const saveInputData = () => {
        try {
            const state = getCurrentState();
            const csvSections = [];

            // 2D/3D„Å©„Å°„Çâ„ÅÆ‰øùÂ≠ò„Éá„Éº„Çø„Åã„ÇíÂà§Âà•„Åß„Åç„Çã„Çà„ÅÜ„Å´„É°„ÇøÊÉÖÂ†±„Çí‰ªò‰∏é
            csvSections.push('#META\nkey,value\nmode,2d\n');
            if (state.nodes.length > 0) {
                const header = 'x,y,support';
                const rows = state.nodes.map(n => `${n.x},${n.y},${n.support}`);
                csvSections.push('#NODES\n' + header + '\n' + rows.join('\n'));
            }
            if (state.members.length > 0) {
                    const header = 'i,j,E,strengthType,strengthValue,I,I_factor,A,A_factor,Z,Z_factor,i_radius,i_factor,bucklingK,i_conn,j_conn,Kx_i,Ky_i,Kr_i,Kx_j,Ky_j,Kr_j,Zx,Zy,ix,iy,sectionLabel,sectionSummary,sectionSource,sectionInfo,sectionAxisKey,sectionAxisMode,sectionAxisLabel';
                        const rows = state.members.map(m => {
                    const sectionLabel = m.sectionLabel ? encodeURIComponent(m.sectionLabel) : '';
                    const sectionSummary = m.sectionSummary ? encodeURIComponent(m.sectionSummary) : '';
                    const sectionSource = m.sectionSource ? encodeURIComponent(m.sectionSource) : '';
                    const sectionInfoEncoded = m.sectionInfoEncoded || (m.sectionInfo ? encodeURIComponent(JSON.stringify(m.sectionInfo)) : '');
                    const sectionAxisKey = m.sectionAxisKey || (m.sectionAxis && m.sectionAxis.key) || '';
                    const sectionAxisMode = m.sectionAxisMode || (m.sectionAxis && m.sectionAxis.mode) || '';
                    const sectionAxisLabelRaw = m.sectionAxisLabel || (m.sectionAxis && m.sectionAxis.label) || '';
                    const sectionAxisLabel = sectionAxisLabelRaw ? encodeURIComponent(sectionAxisLabelRaw) : '';
                        const kxi = m.spring_i && m.spring_i.Kx ? m.spring_i.Kx : '';
                        const kyi = m.spring_i && m.spring_i.Ky ? m.spring_i.Ky : '';
                        const kri = m.spring_i && m.spring_i.Kr ? m.spring_i.Kr : '';
                        const kxj = m.spring_j && m.spring_j.Kx ? m.spring_j.Kx : '';
                        const kyj = m.spring_j && m.spring_j.Ky ? m.spring_j.Ky : '';
                        const krj = m.spring_j && m.spring_j.Kr ? m.spring_j.Kr : '';
                            const bk = (m.bucklingK !== undefined && m.bucklingK !== null) ? m.bucklingK : '';
                            const I_factor = (m.I_factor !== undefined && m.I_factor !== null && m.I_factor !== '') ? m.I_factor : '1.0';
                            const A_factor = (m.A_factor !== undefined && m.A_factor !== null && m.A_factor !== '') ? m.A_factor : '1.0';
                            const Z_factor = (m.Z_factor !== undefined && m.Z_factor !== null && m.Z_factor !== '') ? m.Z_factor : '1.0';
                            const i_factor = (m.i_factor !== undefined && m.i_factor !== null && m.i_factor !== '') ? m.i_factor : '1.0';
                            const i_radius = (m.i_radius !== undefined && m.i_radius !== null) ? m.i_radius : '';
                            return `${m.i},${m.j},${m.E},${m.strengthType},${m.strengthValue},${m.I},${I_factor},${m.A},${A_factor},${m.Z},${Z_factor},${i_radius},${i_factor},${bk},${m.i_conn},${m.j_conn},${kxi},${kyi},${kri},${kxj},${kyj},${krj},${m.Zx || ''},${m.Zy || ''},${m.ix || ''},${m.iy || ''},${sectionLabel},${sectionSummary},${sectionSource},${sectionInfoEncoded},${sectionAxisKey},${sectionAxisMode},${sectionAxisLabel}`;
                });
                csvSections.push('#MEMBERS\n' + header + '\n' + rows.join('\n'));
            }
            if (state.nodeLoads.length > 0) {
                const header = 'node,px,py,mz';
                const rows = state.nodeLoads.map(l => `${l.node},${l.px},${l.py},${l.mz}`);
                csvSections.push('#NODELOADS\n' + header + '\n' + rows.join('\n'));
            }
            if (state.memberLoads.length > 0) {
                const header = 'member,w';
                const rows = state.memberLoads.map(l => `${l.member},${l.w}`);
                csvSections.push('#MEMBERLOADS\n' + header + '\n' + rows.join('\n'));
            }
            const csvString = csvSections.join('\n\n');
            const blob = new Blob([csvString], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'frame-model.csv';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        } catch (error) {
            alert('CSV„Éá„Éº„Çø„ÅÆ‰øùÂ≠ò„Å´Â§±Êïó„Åó„Åæ„Åó„Åü: ' + error.message);
        }
    };

    const detectCsvSavedMode = (text) => {
        if (typeof text !== 'string' || !text.trim()) return null;

        const metaMatch = text.match(/#META\s*[\r\n]+([^#]*)/i);
        if (metaMatch && metaMatch[1]) {
            const metaLines = metaMatch[1].trim().split(/\r?\n/).filter(Boolean);
            if (metaLines.length >= 2) {
                const metaHeader = metaLines[0].split(',').map(s => s.trim());
                const keyIndex = metaHeader.indexOf('key');
                const valueIndex = metaHeader.indexOf('value');
                for (let i = 1; i < metaLines.length; i++) {
                    const cols = metaLines[i].split(',');
                    const key = (cols[keyIndex] || '').trim().toLowerCase();
                    const value = (cols[valueIndex] || '').trim().toLowerCase();
                    if (key === 'mode' && (value === '2d' || value === '3d')) return value;
                }
            }
        }

        const nodesHeaderMatch = text.match(/#NODES\s*[\r\n]+([^\r\n]+)/i);
        if (nodesHeaderMatch && nodesHeaderMatch[1]) {
            const keys = nodesHeaderMatch[1].split(',').map(s => s.trim().toLowerCase());
            if (keys.includes('z') || keys.includes('dz_forced')) return '3d';
            if (keys.includes('x') && keys.includes('y') && !keys.includes('z')) return '2d';
        }

        const membersHeaderMatch = text.match(/#MEMBERS\s*[\r\n]+([^\r\n]+)/i);
        if (membersHeaderMatch && membersHeaderMatch[1]) {
            const keys = membersHeaderMatch[1].split(',').map(s => s.trim().toLowerCase());
            if (keys.includes('i_factor') || keys.includes('i_radius') || keys.includes('i_factor')) return '2d';
            if (keys.includes('iz') || keys.includes('iy') || keys.includes('zz') || keys.includes('zy') || keys.includes('wz')) return '3d';
        }

        const nodeLoadsHeaderMatch = text.match(/#NODELOADS\s*[\r\n]+([^\r\n]+)/i);
        if (nodeLoadsHeaderMatch && nodeLoadsHeaderMatch[1]) {
            const keys = nodeLoadsHeaderMatch[1].split(',').map(s => s.trim().toLowerCase());
            if (keys.includes('pz')) return '3d';
        }
        return null;
    };

    const parseCsvTextToState = (text) => {
        const state = { meta: {}, nodes: [], members: [], nodeLoads: [], memberLoads: [] };
        const sections = text.split(/#\w+\s*/).filter(s => s.trim() !== '');
        const headers = text.match(/#\w+/g) || [];
        if (headers.length === 0 || sections.length === 0) throw new Error('ÊúâÂäπ„Å™„Çª„ÇØ„Ç∑„Éß„É≥Ôºà#NODES„Å™„Å©Ôºâ„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„Åß„Åó„Åü„ÄÇ');

        headers.forEach((header, index) => {
            const sectionText = sections[index];
            if (!sectionText) return;
            const lines = sectionText.trim().split(/\r?\n/);
            const headerLine = lines.shift();
            const keys = (headerLine || '').split(',').map(s => s.trim()).filter(Boolean);
            lines.forEach(line => {
                if (!line.trim()) return;
                const values = line.split(',');
                const obj = {};
                keys.forEach((key, i) => obj[key] = values[i] ? values[i].trim() : '');

                if (header === '#META') {
                    const k = (obj.key || '').trim();
                    const v = (obj.value || '').trim();
                    if (k) state.meta[k] = v;
                } else if (header === '#NODES') {
                    state.nodes.push(obj);
                } else if (header === '#MEMBERS') {
                    state.members.push(obj);
                } else if (header === '#NODELOADS') {
                    state.nodeLoads.push(obj);
                } else if (header === '#MEMBERLOADS') {
                    state.memberLoads.push(obj);
                }
            });
        });

        return state;
    };

    const loadFromCsvText = (text) => {
        const savedMode = detectCsvSavedMode(text);
        if (savedMode === '3d') {
            // 3D„Éá„Éº„Çø„Çí2DÂÅ¥„ÅßË™≠„Çì„Å†Â†¥Âêà„ÅØ„ÄÅË¶™(Áµ±ÂêàUI)„Å´ÂàáÊõøÔºã3DÂÅ¥„ÅßË™≠Ëæº„ÇíË¶ÅÊ±Ç
            try {
                if (window.parent && window.parent !== window) {
                    window.parent.postMessage({ type: 'statica:requestLoadCsv', mode: '3d', text }, '*');
                    return { redirected: true, mode: '3d' };
                }
            } catch (e) {
                // ignore
            }
            throw new Error('„Åì„ÅÆCSV„ÅØ3D‰øùÂ≠ò„Éá„Éº„Çø„ÅÆ„Åü„ÇÅ„ÄÅ3DÊßãÈÄ†Ëß£Êûê„É¢„Éº„Éâ„ÅßË™≠„ÅøËæº„Çì„Åß„Åè„Å†„Åï„ÅÑ„ÄÇ');
        }

        const state = parseCsvTextToState(text);
        if (state.nodes.length === 0 && state.members.length === 0) throw new Error('„Éï„Ç°„Ç§„É´„Åã„ÇâÊúâÂäπ„Å™„Éá„Éº„Çø„ÇíË™≠„ÅøËæº„ÇÅ„Åæ„Åõ„Çì„Åß„Åó„Åü„ÄÇ');
        historyStack = [];
        pushState();
        restoreState(state);
        runFullAnalysis();
        return { redirected: false, mode: '2d' };
    };

    // Ë¶™(Áµ±ÂêàUI)„Åã„ÇâCSV„ÉÜ„Ç≠„Çπ„Éà„ÇíÊ∏°„Åï„Çå„ÅüÂ†¥Âêà„Å´„ÇÇÂæ©ÂÖÉ„Åß„Åç„Çã„Çà„ÅÜ„Å´ÂÖ¨Èñã
    window.__staticaLoadCsvText2D = (text) => {
        try {
            loadFromCsvText(text);
        } catch (e) {
            alert('CSV„ÉÜ„Ç≠„Çπ„Éà„ÅÆË™≠„ÅøËæº„Åø„Å´Â§±Êïó„Åó„Åæ„Åó„Åü: ' + (e && e.message ? e.message : String(e)));
        }
    };

    // Ë¶™(Áµ±ÂêàUI)„Åã„Çâ„ÅÆCSVË™≠ËæºË¶ÅÊ±Ç„ÇíÂèó‰ø°
    window.addEventListener('message', (event) => {
        const data = event && event.data;
        if (!data || data.type !== 'statica:loadCsv') return;
        if (typeof data.text !== 'string') return;
        window.__staticaLoadCsvText2D(data.text);
    });
    const loadInputData = () => {
        const fileInput = document.createElement('input');
        fileInput.type = 'file';
        fileInput.accept = '.csv,text/csv';
        fileInput.onchange = (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (event) => {
                try {
                    const text = event.target.result;
                    loadFromCsvText(text);
                } catch (error) {
                    alert('CSV„Éï„Ç°„Ç§„É´„ÅÆË™≠„ÅøËæº„Åø„Å´Â§±Êïó„Åó„Åæ„Åó„Åü: ' + error.message);
                }
            };
            reader.readAsText(file);
        };
        fileInput.click();
    };
    // „É¨„Éù„Éº„ÉàÁî®„ÅÆ„ÉÜ„Éº„Éñ„É´ HTML „ÇíÁîüÊàê„Åô„ÇãÈñ¢Êï∞
    const generateReportTableHTML = (tableId) => {
        const table = document.getElementById(tableId);
        if (!table) return '';
        
        let html = '<table style="width:100%;border-collapse:collapse;margin-bottom:2em;">';
        
        // „Éò„ÉÉ„ÉÄ„Éº
        const thead = table.querySelector('thead');
        if (thead) {
            html += '<thead>';
            Array.from(thead.rows).forEach(row => {
                html += '<tr>';
                Array.from(row.cells).forEach(cell => {
                    html += `<th style="border:1px solid #ccc;padding:8px;text-align:center;background-color:#f0f8ff;">${cell.textContent}</th>`;
                });
                html += '</tr>';
            });
            html += '</thead>';
        }
        
        // „Éú„Éá„Ç£
        const tbody = table.querySelector('tbody');
        if (tbody) {
            html += '<tbody>';
            Array.from(tbody.rows).forEach(row => {
                html += '<tr>';
                Array.from(row.cells).forEach((cell, cellIndex) => {
                    let cellContent = '';
                    
                    // ÈÉ®Êùê„ÉÜ„Éº„Éñ„É´„ÅÆÂü∫Ê∫ñÂº∑Â∫¶ÂàóÔºà4Áï™ÁõÆ„ÅÆÂàó„ÄÅ„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ3Ôºâ„ÅÆÁâπÂà•Âá¶ÁêÜ
                    if (tableId === 'members-table' && cellIndex === 4) {
                        const strengthContainer = cell.firstElementChild;
                        if (strengthContainer) {
                            const strengthType = strengthContainer.dataset.strengthType;
                            
                            switch(strengthType) {
                                case 'F-value':
                                case 'F-stainless':
                                case 'F-aluminum':
                                    const select = strengthContainer.querySelector('select');
                                    const input = strengthContainer.querySelector('input');
                                    if (select && input) {
                                        const selectedOption = select.options[select.selectedIndex];
                                        if (select.value === 'custom') {
                                            cellContent = `‰ªªÊÑèÂÖ•Âäõ (F=${input.value})`;
                                        } else {
                                            cellContent = selectedOption.textContent;
                                        }
                                    }
                                    break;
                                case 'wood-type':
                                    const presetSelect = strengthContainer.querySelector('select');
                                    if (presetSelect) {
                                        if (presetSelect.value === 'custom') {
                                            const inputs = strengthContainer.querySelectorAll('input');
                                            const values = Array.from(inputs).map(input => 
                                                `${input.id.split('-').pop()}=${input.value}`
                                            ).join(', ');
                                            cellContent = `‰ªªÊÑèÂÖ•Âäõ (${values})`;
                                        } else {
                                            const selectedOption = presetSelect.options[presetSelect.selectedIndex];
                                            cellContent = selectedOption.textContent;
                                        }
                                    }
                                    break;
                                default:
                                    cellContent = cell.textContent || '-';
                            }
                        } else {
                            cellContent = cell.textContent || '-';
                        }
                    } else if (tableId === 'members-table' && (cellIndex === 5 || cellIndex === 6 || cellIndex === 7 || cellIndex === 8)) {
                        // I/A/Z/iÔºàÊñ≠Èù¢Ë´∏ÈáèÔºâ„ÅÆ‰ΩéÊ∏õ‰øÇÊï∞Ë°®Á§∫
                        const kind = (cellIndex === 5) ? 'I' : (cellIndex === 6) ? 'A' : (cellIndex === 7) ? 'Z' : 'i';
                        const baseSelector = (kind === 'i') ? '.radius-i-input' : `.section-${kind}-input`;
                        const factorSelector = (kind === 'i') ? '.section-i-factor' : `.section-${kind}-factor`;
                        const baseEl = cell.querySelector(baseSelector);
                        const factorEl = cell.querySelector(factorSelector);
                        const baseRaw = baseEl ? baseEl.value : '';
                        const factorRaw = (factorEl && factorEl.value !== '') ? factorEl.value : '1.0';
                        const baseNum = parseFloat(baseRaw);
                        const factorNum = parseFloat(factorRaw);
                        const reducedNum = (Number.isFinite(baseNum) && Number.isFinite(factorNum)) ? (baseNum * factorNum) : NaN;
                        const baseDisp = baseRaw !== '' ? baseRaw : '-';
                        const factorDisp = factorRaw !== '' ? factorRaw : '1.0';
                        const reducedDisp = Number.isFinite(reducedNum) ? String(reducedNum) : '-';
                        cellContent = `ÂÖÉ=${baseDisp}<br>‰øÇÊï∞=${factorDisp}<br>‰ΩéÊ∏õÂæå=${reducedDisp}`;
                    } else {
                        // ÈÄöÂ∏∏„ÅÆ„Çª„É´Âá¶ÁêÜ
                        const input = cell.querySelector('input');
                        const select = cell.querySelector('select');
                        if (input) {
                            cellContent = input.value || '-';
                        } else if (select) {
                            const selectedOption = select.options[select.selectedIndex];
                            cellContent = selectedOption ? selectedOption.textContent : '-';
                        } else {
                            cellContent = cell.textContent || '-';
                        }
                    }
                    
                    html += `<td style="border:1px solid #ccc;padding:8px;text-align:center;">${cellContent}</td>`;
                });
                html += '</tr>';
            });
            html += '</tbody>';
        }
        
        html += '</table>';
        return html;
    };

    const generateReport = () => {
        try {
            const modelCanvasImg=elements.modelCanvas.toDataURL('image/png');
            const displacementCanvasImg=elements.displacementCanvas.toDataURL('image/png');
            const momentCanvasImg=elements.momentCanvas.toDataURL('image/png');
            const axialCanvasImg=elements.axialCanvas.toDataURL('image/png');
            const shearCanvasImg=elements.shearCanvas.toDataURL('image/png');
            const ratioCanvasImg = elements.ratioCanvas.toDataURL('image/png');

            const reportWindow = window.open('', '_blank');
            // Â∫ßÂ±àËß£ÊûêÁµêÊûú„ÅÆ„É¨„Éù„Éº„ÉàÁî®HTMLÁîüÊàê
            let bucklingReportHTML = '';
            if (lastBucklingResults && lastBucklingResults.length > 0) {
                bucklingReportHTML = `<div class="no-break"><h2>Â∫ßÂ±àËß£ÊûêÁµêÊûú</h2>${generateReportTableHTML('buckling-analysis-results')}</div>`;
            }

            reportWindow.document.write(`<html><head><title>ÊßãÈÄ†Ëß£Êûê„É¨„Éù„Éº„Éà</title><style>body{font-family:sans-serif;margin:2em;}h1,h2,h3{color:#005A9C;border-bottom:2px solid #f0f8ff;padding-bottom:5px;}table{width:100%;border-collapse:collapse;margin-bottom:2em;}th,td{border:1px solid #ccc;padding:8px;text-align:center;}th{background-color:#f0f8ff;}img{max-width:100%;height:auto;border:1px solid #ccc;margin:1em 0;}.grid{display:grid;grid-template-columns:1fr;gap:20px;}.no-break{page-break-inside:avoid;}@media print{body{margin:1em;}button{display:none;}}</style></head><body><button onclick="window.print()">„É¨„Éù„Éº„Éà„ÇíÂç∞Âà∑</button><h1>ÊßãÈÄ†Ëß£Êûê„É¨„Éù„Éº„Éà</h1><p>ÁîüÊàêÊó•ÊôÇ: ${new Date().toLocaleString()}</p><div class="no-break"><h2>„É¢„Éá„É´Âõ≥</h2><img src="${modelCanvasImg}"></div><h2>ÂÖ•Âäõ„Éá„Éº„Çø</h2><div class="no-break"><h3>ÁØÄÁÇπÂ∫ßÊ®ô„Å®Â¢ÉÁïåÊù°‰ª∂</h3>${generateReportTableHTML('nodes-table')}</div><div class="no-break"><h3>ÈÉ®Êùê (Áâ©ÊÄßÂÄ§„ÉªÊé•ÂêàÊù°‰ª∂)</h3>${generateReportTableHTML('members-table')}</div><div class="no-break"><h3>ÁØÄÁÇπËç∑Èáç</h3>${generateReportTableHTML('node-loads-table')}</div><div class="no-break"><h3>ÈÉ®ÊùêÁ≠âÂàÜÂ∏ÉËç∑Èáç</h3>${generateReportTableHTML('member-loads-table')}</div><h2>Ë®àÁÆóÁµêÊûú</h2><div class="no-break grid"><div><h3>Â§â‰ΩçÂõ≥</h3><img src="${displacementCanvasImg}"></div><div><h3>Êõ≤„Åí„É¢„Éº„É°„É≥„ÉàÂõ≥</h3><img src="${momentCanvasImg}"></div><div><h3>Ëª∏ÂäõÂõ≥</h3><img src="${axialCanvasImg}"></div><div><h3>„Åõ„ÇìÊñ≠ÂäõÂõ≥</h3><img src="${shearCanvasImg}"></div></div><div class="no-break">${generateReportTableHTML('displacement-results')}</div><div class="no-break">${generateReportTableHTML('reaction-results')}</div><div class="no-break">${generateReportTableHTML('force-results')}</div><div class="no-break"><h2>Êñ≠Èù¢ÁÆóÂÆöÁµêÊûú</h2><h3>Ê§úÂÆöÊØîÂõ≥</h3><img src="${ratioCanvasImg}"><h3>Ê§úÂÆöÊØî Ë©≥Á¥∞</h3>${generateReportTableHTML('section-check-results')}<h3>„Åü„Çè„ÅøÂà∂Èôê</h3>${generateReportTableHTML('deflection-check-results')}<h3>Ê®™Â∫ßÂ±àÔºàÊõ≤„ÅíÊùêÔºâ</h3>${generateReportTableHTML('ltb-check-results')}</div>${bucklingReportHTML}</body></html>`);
            reportWindow.document.close();
        } catch (e) {
            alert('„É¨„Éù„Éº„Éà„ÅÆÁîüÊàê„Å´Â§±Êïó„Åó„Åæ„Åó„Åü: ' + e.message);
            console.error("Report generation failed: ", e);
        }
    };
    
    const runFullAnalysis = () => {
        // „Éó„É™„Çª„ÉÉ„ÉàË™≠„ÅøËæº„Åø‰∏≠„ÅØËß£Êûê„Çí„Çπ„Ç≠„ÉÉ„Éó
        if (window.isLoadingPreset) {
            return;
        }
        calculate();
        runSectionCheck();
    };
    
    // Make runFullAnalysis globally accessible
    window.runFullAnalysis = runFullAnalysis;

    // Á∞°Êòì„ÉÜ„Çπ„Éà„Éó„É™„Çª„ÉÉ„Éà: 2ÁØÄÁÇπ1ÈÉ®Êùê„ÄÅ‰∏°Á´Ø„Å´„Éê„ÉçÊé•Á∂ö„ÇíË®≠ÂÆö„Åó„ÅüÂãï‰ΩúÁ¢∫Ë™çÁî®„Çµ„É≥„Éó„É´
    // Ëß£Êûê„Åß„ÅÆÂÆâÂÆöÊÄß„ÇíÁ¢∫‰øù„Åô„Çã„Åü„ÇÅ„ÄÅÊ∞¥Âπ≥/ÂûÇÁõ¥ÊñπÂêë„ÅÆÂâõÊÄß„ÅØÈùû„Çº„É≠„ÅÆ‰ª£Ë°®ÂÄ§„ÇíË®≠ÂÆö„Åó„Åæ„Åô„ÄÇ
    window.createSimpleSpringPreset = () => {
        try {
            // Âçò‰Ωç„ÅØUI„Å®Âêå‰∏Ä (Kx,Ky: N/mm, Kr: N¬∑mm/rad)
            const state = {
                nodes: [
                    { x: 0, y: 0, support: 'fixed', dx_forced: 0, dy_forced: 0, r_forced: 0 },
                    { x: 1000, y: 0, support: 'free', dx_forced: 0, dy_forced: 0, r_forced: 0 }
                ],
                members: [
                    {
                        i: 1,
                        j: 2,
                        E: '205000',
                        strengthType: '',
                        strengthValue: '',
                        I: '1.84e-5',
                        A: '2.34e-3',
                        Z: '1.23e-3',
                        // ‰∏°Á´Ø„Çí„Éê„ÉçÊé•Á∂ö„Å´Ë®≠ÂÆöÔºàÂÖ∏ÂûãÂÄ§Ôºâ
                        i_conn: 'spring',
                        j_conn: 'spring',
                        // ÂßãÁ´Ø„Éê„Éç: Kx=1.0 kN/mm, Ky=1.0 kN/mm, Kr=10000 kN¬∑mm/rad
                        spring_i: { Kx: 1.0, Ky: 1.0, Kr: 10000 },
                        // ÁµÇÁ´Ø„Éê„Éç: Kx=0.5 kN/mm, Ky=0.5 kN/mm, Kr=5000 kN¬∑mm/rad
                        spring_j: { Kx: 0.5, Ky: 0.5, Kr: 5000 }
                    }
                ],
                nodeLoads: [],
                memberLoads: []
            };
            HistoryManager.clear();
            restoreState(state);
            // „É≠„Ç∞„ÅßË®≠ÂÆöÂÜÖÂÆπ„ÇíË°®Á§∫„Åó„Å¶Á¢∫Ë™ç„Åó„ÇÑ„Åô„Åè„Åô„Çã
            console.log('createSimpleSpringPreset: state restored', JSON.stringify(state, null, 2));
            runFullAnalysis();
            console.log('createSimpleSpringPreset: „Éó„É™„Çª„ÉÉ„Éà„ÇíË™≠„ÅøËæº„Åø„ÄÅËß£Êûê„ÇíÂÆüË°å„Åó„Åæ„Åó„Åü„ÄÇ');
        } catch (e) {
            console.error('createSimpleSpringPreset „Ç®„É©„Éº:', e);
        }
    };
    
    const runSectionCheck = () => {
        if (!lastResults) return;
        const selectedTerm = document.querySelector('input[name="load-term"]:checked').value;
        lastSectionCheckResults = calculateSectionCheck(selectedTerm);
        window.lastSectionCheckResults = lastSectionCheckResults; // „Ç∞„É≠„Éº„Éê„É´„Å´‰øùÂ≠ò

        lastDeflectionCheckResults = calculateDeflectionCheck();
        window.lastDeflectionCheckResults = lastDeflectionCheckResults;

        lastLtbCheckResults = calculateLtbCheck(selectedTerm);
        window.lastLtbCheckResults = lastLtbCheckResults;

        // „Ç®„ÇØ„Çª„É´Âá∫ÂäõÁî®„Å´„ÇÇÊñ≠Èù¢Ê§úÂÆöÁµêÊûú„Çí‰øùÂ≠ò
        if (lastAnalysisResult) {
            lastAnalysisResult.sectionCheckResults = lastSectionCheckResults;
            lastAnalysisResult.deflectionCheckResults = lastDeflectionCheckResults;
            lastAnalysisResult.deflectionCheckSettings = getDeflectionCheckSettings();

            lastAnalysisResult.ltbCheckResults = lastLtbCheckResults;
            lastAnalysisResult.ltbCheckSettings = getLtbCheckSettings();
        }

        displaySectionCheckResults();
        displayDeflectionCheckResults();
        displayLtbCheckResults();
        drawRatioDiagram();
    };
    elements.calculateBtn.addEventListener('click', runFullAnalysis);
    

    elements.calculateAndAnimateBtn.addEventListener('click', () => {
        runFullAnalysis();
        if (lastResults && lastResults.D) {
            animateDisplacement(lastResults.nodes, lastResults.members, lastResults.D, lastResults.memberLoads);
        }
    });
    
    document.body.classList.remove('section-check-disabled');
    elements.loadTermRadios.forEach(radio => radio.addEventListener('change', () => {
        if (lastResults) {
            runSectionCheck();
        }
    }));

    // „Åü„Çè„ÅøÂà∂ÈôêÔºà„Çµ„Éº„Éì„ÇπÊÄßÔºâË®≠ÂÆö„ÅÆÂêåÊúü„Éª„Ç§„Éô„É≥„Éà
    const setupDeflectionCheckControls = () => {
        const ampInput = document.getElementById('defl-amp-factor');
        const allowMmInput = document.getElementById('defl-allow-mm');
        const spanRatioInput = document.getElementById('defl-span-ratio');
        if (!ampInput || !allowMmInput || !spanRatioInput) return;

        const syncToUI = () => {
            const s = window.settings?.deflectionCheck;
            if (!s) return;
            ampInput.value = (s.amplificationFactor ?? 1.0);
            allowMmInput.value = (s.allowableDeflectionMm ?? 10);
            spanRatioInput.value = (s.spanRatio ?? 300);
        };

        const syncFromUI = () => {
            window.settings = window.settings || {};
            window.settings.deflectionCheck = window.settings.deflectionCheck || { amplificationFactor: 1.0, allowableDeflectionMm: 10, spanRatio: 300 };
            window.settings.deflectionCheck.amplificationFactor = Math.max(0, parseFloat(ampInput.value) || 0);
            window.settings.deflectionCheck.allowableDeflectionMm = Math.max(0, parseFloat(allowMmInput.value) || 0);
            window.settings.deflectionCheck.spanRatio = Math.max(1, parseFloat(spanRatioInput.value) || 1);
        };

        syncToUI();
        const onChange = () => {
            syncFromUI();
            if (lastResults) runSectionCheck();
        };
        ampInput.addEventListener('input', onChange);
        allowMmInput.addEventListener('input', onChange);
        spanRatioInput.addEventListener('input', onChange);
    };
    try { setupDeflectionCheckControls(); } catch (e) { console.warn('setupDeflectionCheckControls failed', e); }

    // Ê®™Â∫ßÂ±àÔºàLTBÔºâË®≠ÂÆö„ÅÆÂêåÊúü„Éª„Ç§„Éô„É≥„Éà
    const setupLtbCheckControls = () => {
        const factorInput = document.getElementById('ltb-unbraced-factor');
        const cbInput = document.getElementById('ltb-cb');
        const nuInput = document.getElementById('ltb-nu');
        if (!factorInput || !cbInput || !nuInput) return;

        const syncToUI = () => {
            const s = window.settings?.ltbCheck;
            if (!s) return;
            factorInput.value = (s.unbracedLengthFactor ?? 1.0);
            cbInput.value = (s.cb ?? 1.0);
            nuInput.value = (s.nu ?? 0.30);
        };

        const syncFromUI = () => {
            window.settings = window.settings || {};
            window.settings.ltbCheck = window.settings.ltbCheck || { unbracedLengthFactor: 1.0, cb: 1.0, nu: 0.30 };
            window.settings.ltbCheck.unbracedLengthFactor = Math.max(0, parseFloat(factorInput.value) || 0);
            window.settings.ltbCheck.cb = Math.max(0.01, parseFloat(cbInput.value) || 1.0);
            const nu = parseFloat(nuInput.value);
            window.settings.ltbCheck.nu = (isFinite(nu) && nu >= 0 && nu < 0.5) ? nu : 0.30;
        };

        syncToUI();
        const onChange = () => {
            syncFromUI();
            if (lastResults) runSectionCheck();
        };
        factorInput.addEventListener('input', onChange);
        cbInput.addEventListener('input', onChange);
        nuInput.addEventListener('input', onChange);
    };
    try { setupLtbCheckControls(); } catch (e) { console.warn('setupLtbCheckControls failed', e); }
    
    elements.gridToggle.addEventListener('change', drawOnCanvas);
    elements.gridSpacing.addEventListener('change', drawOnCanvas);
    
    // ÈÉ®ÊùêÊÉÖÂ†±Ë°®Á§∫„ÉÅ„Çß„ÉÉ„ÇØ„Éú„ÉÉ„ÇØ„Çπ„ÅÆ„Ç§„Éô„É≥„Éà„É™„Çπ„Éä„Éº
    if (elements.memberInfoToggle) {
        elements.memberInfoToggle.addEventListener('change', () => {
            // „ÉÅ„Çß„ÉÉ„ÇØ„ÅåÂ§ñ„Åï„Çå„ÅüÂ†¥Âêà„ÅØ„ÉÑ„Éº„É´„ÉÅ„ÉÉ„Éó„ÇíÂç≥Â∫ß„Å´ÈùûË°®Á§∫
            if (!elements.memberInfoToggle.checked) {
                hideMemberTooltip();
            }
        });
    }
    
    // Ëç∑ÈáçË°®Á§∫Âà∂Âæ°„ÉÅ„Çß„ÉÉ„ÇØ„Éú„ÉÉ„ÇØ„Çπ„ÅÆ„Ç§„Éô„É≥„Éà„É™„Çπ„Éä„Éº
    const showExternalLoadsCheckbox = document.getElementById('show-external-loads');
    const showSelfWeightCheckbox = document.getElementById('show-self-weight');
    const showMemberDimensionsCheckbox = document.getElementById('show-member-dimensions');
    const showSpringStiffnessCheckbox = document.getElementById('show-spring-stiffness');
    if (showExternalLoadsCheckbox) {
        showExternalLoadsCheckbox.addEventListener('change', drawOnCanvas);
    }
    if (showSelfWeightCheckbox) {
        showSelfWeightCheckbox.addEventListener('change', drawOnCanvas);
    }
    if (showMemberDimensionsCheckbox) {
        showMemberDimensionsCheckbox.addEventListener('change', drawOnCanvas);
    }
    if (showSpringStiffnessCheckbox) {
        showSpringStiffnessCheckbox.addEventListener('change', drawOnCanvas);
    }
    
    elements.saveBtn.addEventListener('click', saveInputData);
    elements.loadBtn.addEventListener('click', loadInputData);
    
    // ==========================================================================
    // „É¢„Éá„É´ÂÖ±Êúâ„É™„É≥„ÇØÊ©üËÉΩ
    // ==========================================================================
    const createShareLinkBtn = document.getElementById('create-share-link-btn');
    const shareLinkModal = document.getElementById('share-link-modal');
    const shareLinkModalClose = document.getElementById('share-link-modal-close');
    const shareLinkTextarea = document.getElementById('share-link-textarea');
    const copyShareLinkBtn = document.getElementById('copy-share-link-btn');
    let isShareLinkLoaded = false;

    // URL„Çª„Éº„Éï„Å™Base64„Ç®„É≥„Ç≥„Éº„ÉâÈñ¢Êï∞
    function toBase64Url(u8) {
        return btoa(String.fromCharCode.apply(null, u8))
            .replace(/\+/g, '-')
            .replace(/\//g, '_')
            .replace(/=/g, '');
    }

    // URL„Çª„Éº„Éï„Å™Base64„Éá„Ç≥„Éº„ÉâÈñ¢Êï∞
    function fromBase64Url(str) {
        str = str.replace(/-/g, '+').replace(/_/g, '/');
        while (str.length % 4) {
            str += '=';
        }
        const decoded = atob(str);
        const u8 = new Uint8Array(decoded.length);
        for (let i = 0; i < decoded.length; ++i) {
            u8[i] = decoded.charCodeAt(i);
        }
        return u8;
    }

    // ÂÖ±Êúâ„É™„É≥„ÇØ„ÇíÁîüÊàê„Åô„ÇãÈñ¢Êï∞ÔºàÁü≠Á∏ÆURL„ÉªÂÖÉURL‰ΩµË®òÁâàÔºâ
    const generateShareLink = async () => {
        try {
            const state = getCurrentState();
            const jsonString = JSON.stringify(state);
            const compressed = pako.deflate(jsonString);
            const encodedData = toBase64Url(compressed);
            const baseUrl = window.location.href.split('#')[0];
            const longUrl = `${baseUrl}#model=${encodedData}`;

            // „É¢„Éº„ÉÄ„É´Ë¶ÅÁ¥†„ÅÆÂèñÂæó
            const modalBody = shareLinkModal.querySelector('.modal-body');
            const copyBtn = document.getElementById('copy-share-link-btn');
            
            // Êó¢Â≠ò„ÅÆ„Äå„Ç≥„Éî„Éº„Äç„Éú„Çø„É≥„ÅØ‰ªäÂõû„ÅØ‰ΩøÁî®„Åó„Å™„ÅÑ„Åü„ÇÅÈùûË°®Á§∫„Å´„Åô„Çã
            if (copyBtn) copyBtn.style.display = 'none';

            // „É¢„Éº„ÉÄ„É´„ÇíË°®Á§∫„Åó„ÄÅ„É≠„Éº„Éâ‰∏≠„É°„ÉÉ„Çª„Éº„Ç∏„ÇíË®≠ÂÆö
            shareLinkModal.style.display = 'flex';
            modalBody.innerHTML = `
                <div style="text-align:center; padding:20px;">
                    <div style="display:inline-block; width:20px; height:20px; border:3px solid #f3f3f3; border-top:3px solid #005A9C; border-radius:50%; animation:spin 1s linear infinite; margin-bottom:10px;"></div>
                    <p>„É™„É≥„ÇØ„ÇíÁîüÊàê‰∏≠...</p>
                </div>
                <style>@keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }</style>
            `;

            let shortUrl = null;

            // TinyURL API„Çí‰ΩøÁî®„Åó„Å¶Áü≠Á∏Æ„ÇíË©¶„Åø„Çã
            try {
                const response = await fetch(`https://tinyurl.com/api-create.php?url=${encodeURIComponent(longUrl)}`);
                if (response.ok) {
                    shortUrl = await response.text();
                }
            } catch (apiError) {
                console.warn("URLÁü≠Á∏Æ„Å´Â§±Êïó„Åó„Åæ„Åó„Åü:", apiError);
            }

            // HTML„ÅÆÊßãÁØâ
            let htmlContent = '<p style="margin-bottom:15px; font-size:14px;">‰ª•‰∏ã„ÅÆ„É™„É≥„ÇØ„Çí„Ç≥„Éî„Éº„Åó„Å¶ÂÖ±Êúâ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>';

            // 1. Áü≠Á∏ÆURL„Çª„ÇØ„Ç∑„Éß„É≥
            if (shortUrl) {
                htmlContent += `
                    <div style="margin-bottom: 20px; background:#f8f9fa; padding:10px; border-radius:5px; border:1px solid #e9ecef;">
                        <label style="font-weight:bold; display:block; margin-bottom:5px; color:#005A9C;">Áü≠Á∏ÆURL (Êé®Â•®):</label>
                        <div style="display:flex; gap:5px;">
                            <input type="text" value="${shortUrl}" readonly style="flex:1; padding:8px; border:1px solid #ccc; border-radius:4px; font-family:monospace;" id="short-url-input">
                            <button class="generate-btn" style="padding:0 15px; white-space:nowrap;" onclick="
                                document.getElementById('short-url-input').select();
                                document.execCommand('copy');
                                this.textContent = '„Ç≥„Éî„ÉºÂÆå‰∫Ü';
                                this.style.backgroundColor = '#28a745';
                                setTimeout(() => { this.textContent = '„Ç≥„Éî„Éº'; this.style.backgroundColor = ''; }, 2000);
                            ">„Ç≥„Éî„Éº</button>
                        </div>
                    </div>
                `;
            } else {
                htmlContent += `<div style="color:#d9534f; margin-bottom:10px; font-size:13px;">‚ÄªÁü≠Á∏ÆURL„ÅÆÁîüÊàê„Å´Â§±Êïó„Åó„Åæ„Åó„ÅüÔºà„Éç„ÉÉ„Éà„ÉØ„Éº„ÇØ„Ç®„É©„ÉºÁ≠âÔºâ„ÄÇ</div>`;
            }

            // 2. ÂÖÉ„ÅÆURL„Çª„ÇØ„Ç∑„Éß„É≥
            htmlContent += `
                <div>
                    <label style="font-weight:bold; display:block; margin-bottom:5px; color:#555;">ÂÖÉ„ÅÆURL (ÂÆåÂÖ®Áâà):</label>
                    <div style="display:flex; gap:5px;">
                        <textarea readonly style="flex:1; padding:8px; border:1px solid #ccc; border-radius:4px; height:60px; resize:none; font-family:monospace; font-size:12px;" id="long-url-input">${longUrl}</textarea>
                        <button class="generate-btn" style="padding:0 15px; height:60px; white-space:nowrap;" onclick="
                            document.getElementById('long-url-input').select();
                            document.execCommand('copy');
                            this.textContent = '„Ç≥„Éî„ÉºÂÆå‰∫Ü';
                            this.style.backgroundColor = '#28a745';
                            setTimeout(() => { this.textContent = '„Ç≥„Éî„Éº'; this.style.backgroundColor = ''; }, 2000);
                        ">„Ç≥„Éî„Éº</button>
                    </div>
                    <p style="font-size:11px; color:#888; margin-top:5px;">‚ÄªÁü≠Á∏ÆURL„ÅåÊ©üËÉΩ„Åó„Å™„ÅÑÂ†¥Âêà„ÅØ„Åì„Å°„Çâ„Çí‰ΩøÁî®„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
                </div>
            `;

            modalBody.innerHTML = htmlContent;

        } catch (error) {
            console.error("ÂÖ±Êúâ„É™„É≥„ÇØÁîüÊàê„Ç®„É©„Éº:", error);
            alert("ÂÖ±Êúâ„É™„É≥„ÇØ„ÅÆÁîüÊàê„Å´Â§±Êïó„Åó„Åæ„Åó„Åü: " + error.message);
            shareLinkModal.style.display = 'none';
        }
    };

    // ÂÖ±Êúâ„É™„É≥„ÇØ„Åã„Çâ„É¢„Éá„É´„ÇíË™≠„ÅøËæº„ÇÄÈñ¢Êï∞
    const loadFromShareLink = () => {
        try {
            if (window.location.hash && window.location.hash.startsWith('#model=')) {
                console.log("ÂÖ±Êúâ„É™„É≥„ÇØ„Åã„Çâ„É¢„Éá„É´„ÇíË™≠„ÅøËæº„Åø„Åæ„Åô...");
                const encodedData = window.location.hash.substring(7);
                if (!encodedData) return;

                const compressed = fromBase64Url(encodedData);
                const jsonString = pako.inflate(compressed, { to: 'string' });
                const state = JSON.parse(jsonString);
                
                if (state && state.nodes) {
                    HistoryManager.clear();
                    elements.nodesTable.innerHTML = '';
                    elements.membersTable.innerHTML = '';
                    elements.nodeLoadsTable.innerHTML = '';
                    elements.memberLoadsTable.innerHTML = '';
                    clearResults();

                    restoreState(state);
                    runFullAnalysis();
                    console.log("„É¢„Éá„É´„ÅÆË™≠„ÅøËæº„Åø„ÅåÂÆå‰∫Ü„Åó„Åæ„Åó„Åü„ÄÇ");
                    isShareLinkLoaded = true;
                    window.isShareLinkLoaded = true;
                    
                    history.replaceState(null, document.title, window.location.pathname + window.location.search);
                }
            }
        } catch (error) {
            console.error("ÂÖ±Êúâ„É™„É≥„ÇØ„Åã„Çâ„ÅÆ„É¢„Éá„É´Ë™≠„ÅøËæº„Åø„Å´Â§±Êïó„Åó„Åæ„Åó„Åü:", error);
            alert("ÂÖ±Êúâ„É™„É≥„ÇØ„Åã„Çâ„ÅÆ„É¢„Éá„É´Ë™≠„ÅøËæº„Åø„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇ„É™„É≥„ÇØ„ÅåÁ†¥Êêç„Åó„Å¶„ÅÑ„ÇãÂèØËÉΩÊÄß„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ");
        }
    };

    // ÂÖ±Êúâ„É¢„Éº„ÉÄ„É´„ÅÆ„Ç§„Éô„É≥„Éà„É™„Çπ„Éä„Éº
    if (createShareLinkBtn) {
        createShareLinkBtn.addEventListener('click', generateShareLink);
    }
    if (shareLinkModalClose) {
        shareLinkModalClose.addEventListener('click', () => shareLinkModal.style.display = 'none');
    }
    if (shareLinkModal) {
        shareLinkModal.addEventListener('click', (e) => {
            if (e.target === shareLinkModal) {
                shareLinkModal.style.display = 'none';
            }
        });
    }
    if (copyShareLinkBtn) {
        copyShareLinkBtn.addEventListener('click', () => {
            shareLinkTextarea.select();
            document.execCommand('copy');
            copyShareLinkBtn.textContent = '„Ç≥„Éî„Éº„Åó„Åæ„Åó„ÅüÔºÅ';
            setTimeout(() => {
                copyShareLinkBtn.textContent = '„É™„É≥„ÇØ„Çí„Ç≥„Éî„Éº';
            }, 2000);
        });
    }

    // „Éö„Éº„Ç∏Ë™≠„ÅøËæº„ÅøÊôÇ„Å´ÂÖ±Êúâ„É™„É≥„ÇØ„Çí„ÉÅ„Çß„ÉÉ„ÇØ
    loadFromShareLink();
    
    // „Ç®„ÇØ„Çª„É´Âá∫Âäõ„Éú„Çø„É≥„ÅÆ„Ç§„Éô„É≥„Éà„É™„Çπ„Éä„ÉºËøΩÂä†Ôºà„Ç®„É©„Éº„ÉÅ„Çß„ÉÉ„ÇØ‰ªò„ÅçÔºâ
    if (elements.exportExcelBtn) {
        console.log('„Ç®„ÇØ„Çª„É´Âá∫Âäõ„Éú„Çø„É≥„Å´„Ç§„Éô„É≥„Éà„É™„Çπ„Éä„Éº„ÇíËøΩÂä†„Åó„Å¶„ÅÑ„Åæ„Åô...');
        elements.exportExcelBtn.addEventListener('click', exportToExcelHandler);
        console.log('„Ç®„ÇØ„Çª„É´Âá∫Âäõ„Éú„Çø„É≥„ÅÆ„Ç§„Éô„É≥„Éà„É™„Çπ„Éä„Éº„ÅåËøΩÂä†„Åï„Çå„Åæ„Åó„Åü');
    } else {
        console.error('„Ç®„ÇØ„Çª„É´Âá∫Âäõ„Éú„Çø„É≥„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„ÇìÔºÅ');
    }
    
    elements.reportBtn.addEventListener('click', generateReport);
    window.addEventListener('resize', drawOnCanvas);

    elements.autoScaleBtn.addEventListener('click', () => {
        console.log('=== AUTO SCALE BUTTON CLICKED ===');
        console.log('panZoomState before reset:', JSON.stringify(panZoomState));
        panZoomState.isInitialized = false;
        console.log('panZoomState after reset:', JSON.stringify(panZoomState));
        console.log('Calling drawOnCanvas()...');
        drawOnCanvas();
        console.log('drawOnCanvas() completed');
        console.log('panZoomState after drawOnCanvas:', JSON.stringify(panZoomState));
        console.log('=== AUTO SCALE BUTTON PROCESS COMPLETED ===');
    });

    // ÂÖ•ÂäõÊ§úË®º„ÅÆÂàùÊúüÂåñ
    initializeExistingInputValidation();

    // ÈÅ∏Êäû„Åï„Çå„ÅüË¶ÅÁ¥†„ÇíÂâäÈô§„Åô„ÇãÈñ¢Êï∞
    const deleteSelectedElements = () => {
        if (selectedNodes.size === 0 && selectedMembers.size === 0) {
            console.log('ÂâäÈô§ÂØæË±°„ÅÆË¶ÅÁ¥†„ÅåÈÅ∏Êäû„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì');
            return;
        }

        const nodeCount = selectedNodes.size;
        const memberCount = selectedMembers.size;
        
        // Á¢∫Ë™ç„ÉÄ„Ç§„Ç¢„É≠„Ç∞
        let confirmMessage = '';
        if (nodeCount > 0 && memberCount > 0) {
            confirmMessage = `ÈÅ∏Êäû„Åï„Çå„ÅüÁØÄÁÇπ${nodeCount}ÂÄã„Å®ÈÉ®Êùê${memberCount}ÂÄã„ÇíÂâäÈô§„Åó„Åæ„Åô„ÅãÔºü\nÈñ¢ÈÄ£„Åô„ÇãËç∑Èáç„ÇÇÂêåÊôÇ„Å´ÂâäÈô§„Åï„Çå„Åæ„Åô„ÄÇ`;
        } else if (nodeCount > 0) {
            confirmMessage = `ÈÅ∏Êäû„Åï„Çå„ÅüÁØÄÁÇπ${nodeCount}ÂÄã„ÇíÂâäÈô§„Åó„Åæ„Åô„ÅãÔºü\nÈñ¢ÈÄ£„Åô„ÇãÈÉ®Êùê„Å®Ëç∑Èáç„ÇÇÂêåÊôÇ„Å´ÂâäÈô§„Åï„Çå„Åæ„Åô„ÄÇ`;
        } else {
            confirmMessage = `ÈÅ∏Êäû„Åï„Çå„ÅüÈÉ®Êùê${memberCount}ÂÄã„ÇíÂâäÈô§„Åó„Åæ„Åô„ÅãÔºü\nÈñ¢ÈÄ£„Åô„ÇãËç∑Èáç„ÇÇÂêåÊôÇ„Å´ÂâäÈô§„Åï„Çå„Åæ„Åô„ÄÇ`;
        }
        
        if (!confirm(confirmMessage)) {
            return;
        }

        pushState(); // ÂÖÉ„Å´Êàª„ÅôÁî®„ÅÆÁä∂ÊÖã‰øùÂ≠ò

        try {
            // ÁØÄÁÇπ„ÅÆÂâäÈô§Âá¶ÁêÜ
            if (selectedNodes.size > 0) {
                deleteSelectedNodes();
            }

            // ÈÉ®Êùê„ÅÆÂâäÈô§Âá¶ÁêÜ
            if (selectedMembers.size > 0) {
                deleteSelectedMembers();
            }

            // ÈÅ∏Êäû„Çí„ÇØ„É™„Ç¢
            clearMultiSelection();

            // „ÉÜ„Éº„Éñ„É´„ÅÆÁï™Âè∑„ÇíÊåØ„ÇäÁõ¥„Åó
            renumberTables();

            // ÂÜçÊèèÁîª
            drawOnCanvas();

            console.log(`ÂâäÈô§ÂÆå‰∫Ü: ÁØÄÁÇπ${nodeCount}ÂÄã, ÈÉ®Êùê${memberCount}ÂÄã`);
            
        } catch (error) {
            console.error('ÂâäÈô§Âá¶ÁêÜ‰∏≠„Å´„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü:', error);
            alert('ÂâäÈô§Âá¶ÁêÜ‰∏≠„Å´„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü: ' + error.message);
        }
    };

    // ÈÅ∏Êäû„Åï„Çå„ÅüÁØÄÁÇπ„ÇíÂâäÈô§„Åô„ÇãÈñ¢Êï∞
    const deleteSelectedNodes = () => {
        // ÁØÄÁÇπ„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ„ÇíÈôçÈ†Ü„Åß„ÇΩ„Éº„ÉàÔºàÂæå„Çç„Åã„ÇâÂâäÈô§„Åó„Å¶Áï™Âè∑„Åö„Çå„ÇíÈò≤„ÅêÔºâ
        const sortedNodeIndices = Array.from(selectedNodes).sort((a, b) => b - a);
        
        sortedNodeIndices.forEach(nodeIndex => {
            if (nodeIndex < elements.nodesTable.rows.length) {
                const deletedNodeNumber = nodeIndex + 1;
                
                // „Åì„ÅÆÁØÄÁÇπ„Å´Èñ¢ÈÄ£„Åô„ÇãÈÉ®Êùê„ÇíÂâäÈô§
                const membersToDelete = [];
                Array.from(elements.membersTable.rows).forEach((row, idx) => {
                    const startInput = row.cells[1].querySelector('input');
                    const endInput = row.cells[2].querySelector('input');
                    const startNode = parseInt(startInput.value);
                    const endNode = parseInt(endInput.value);
                    
                    if (startNode === deletedNodeNumber || endNode === deletedNodeNumber) {
                        membersToDelete.push(row);
                    }
                });
                
                // ÈÉ®Êùê„ÇíÂâäÈô§
                membersToDelete.forEach(row => row.remove());
                
                // „Åì„ÅÆÁØÄÁÇπ„Å´Èñ¢ÈÄ£„Åô„ÇãËç∑Èáç„ÇíÂâäÈô§
                const nodeLoadsToDelete = [];
                Array.from(elements.nodeLoadsTable.rows).forEach(row => {
                    const nodeInput = row.cells[0].querySelector('input');
                    const nodeNumber = parseInt(nodeInput.value);
                    if (nodeNumber === deletedNodeNumber) {
                        nodeLoadsToDelete.push(row);
                    }
                });
                
                nodeLoadsToDelete.forEach(row => row.remove());
                
                // ÁØÄÁÇπ„ÇíÂâäÈô§
                elements.nodesTable.rows[nodeIndex].remove();
                
                // „Çà„ÇäÂ§ß„Åç„Å™Áï™Âè∑„ÅÆÁØÄÁÇπÁï™Âè∑„ÇíË™øÊï¥
                updateNodeNumbersAfterDeletion(deletedNodeNumber);
            }
        });
    };

    // ÈÅ∏Êäû„Åï„Çå„ÅüÈÉ®Êùê„ÇíÂâäÈô§„Åô„ÇãÈñ¢Êï∞
    const deleteSelectedMembers = () => {
        // ÈÉ®Êùê„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ„ÇíÈôçÈ†Ü„Åß„ÇΩ„Éº„Éà
        const sortedMemberIndices = Array.from(selectedMembers).sort((a, b) => b - a);
        
        sortedMemberIndices.forEach(memberIndex => {
            if (memberIndex < elements.membersTable.rows.length) {
                const deletedMemberNumber = memberIndex + 1;
                
                // „Åì„ÅÆÈÉ®Êùê„Å´Èñ¢ÈÄ£„Åô„ÇãËç∑Èáç„ÇíÂâäÈô§
                const memberLoadsToDelete = [];
                Array.from(elements.memberLoadsTable.rows).forEach(row => {
                    const memberInput = row.cells[0].querySelector('input');
                    const memberNumber = parseInt(memberInput.value);
                    if (memberNumber === deletedMemberNumber) {
                        memberLoadsToDelete.push(row);
                    }
                });
                
                memberLoadsToDelete.forEach(row => row.remove());
                
                // ÈÉ®Êùê„ÇíÂâäÈô§
                elements.membersTable.rows[memberIndex].remove();
                
                // „Çà„ÇäÂ§ß„Åç„Å™Áï™Âè∑„ÅÆÈÉ®ÊùêÁï™Âè∑„ÇíË™øÊï¥
                updateMemberNumbersAfterDeletion(deletedMemberNumber);
            }
        });
    };

    // ÁØÄÁÇπÂâäÈô§Âæå„ÅÆÁï™Âè∑Ë™øÊï¥
    const updateNodeNumbersAfterDeletion = (deletedNodeNumber) => {
        // ÈÉ®ÊùêË°®„ÅÆÁØÄÁÇπÁï™Âè∑„ÇíÊõ¥Êñ∞
        Array.from(elements.membersTable.rows).forEach(row => {
            const startInput = row.cells[1].querySelector('input');
            const endInput = row.cells[2].querySelector('input');
            
            const startNode = parseInt(startInput.value);
            const endNode = parseInt(endInput.value);
            
            if (startNode > deletedNodeNumber) {
                startInput.value = startNode - 1;
            }
            if (endNode > deletedNodeNumber) {
                endInput.value = endNode - 1;
            }
        });
        
        // ÁØÄÁÇπËç∑ÈáçË°®„ÅÆÁØÄÁÇπÁï™Âè∑„ÇíÊõ¥Êñ∞
        Array.from(elements.nodeLoadsTable.rows).forEach(row => {
            const nodeInput = row.cells[0].querySelector('input');
            const nodeNumber = parseInt(nodeInput.value);
            
            if (nodeNumber > deletedNodeNumber) {
                nodeInput.value = nodeNumber - 1;
            }
        });
    };

    // ÈÉ®ÊùêÂâäÈô§Âæå„ÅÆÁï™Âè∑Ë™øÊï¥
    const updateMemberNumbersAfterDeletion = (deletedMemberNumber) => {
        // ÈÉ®ÊùêËç∑ÈáçË°®„ÅÆÈÉ®ÊùêÁï™Âè∑„ÇíÊõ¥Êñ∞
        Array.from(elements.memberLoadsTable.rows).forEach(row => {
            const memberInput = row.cells[0].querySelector('input');
            const memberNumber = parseInt(memberInput.value);
            
            if (memberNumber > deletedMemberNumber) {
                memberInput.value = memberNumber - 1;
            }
        });
    };

    elements.resetModelBtn.addEventListener('click', () => {
        if (confirm('Êú¨ÂΩì„Å´„É¢„Éá„É´ÊÉÖÂ†±„ÇíÂÖ®„Å¶„É™„Çª„ÉÉ„Éà„Åó„Åæ„Åô„ÅãÔºü„Åì„ÅÆÊìç‰Ωú„ÅØÂÖÉ„Å´Êàª„Åõ„Åæ„Åõ„Çì„ÄÇ')) {
            panZoomState.isInitialized = false;
            HistoryManager.clear();
            elements.nodesTable.innerHTML = '';
            elements.membersTable.innerHTML = '';
            elements.nodeLoadsTable.innerHTML = '';
            elements.memberLoadsTable.innerHTML = '';
            clearResults();
            drawOnCanvas();
        }
    });
    
    // ‚ñº‚ñº‚ñº ËøΩÂä†: ÂàóË°®Á§∫„Éà„Ç∞„É´„ÅÆ„Ç§„Éô„É≥„Éà„É™„Çπ„Éä„ÉºË®≠ÂÆö„Å®ÂàùÊúüÂÆüË°å ‚ñº‚ñº‚ñº
    const colToggles = document.querySelectorAll('.column-toggles .col-toggle');
    colToggles.forEach(toggle => {
        toggle.addEventListener('change', updateMemberTableVisibility);
    });
    // „Éö„Éº„Ç∏Ë™≠„ÅøËæº„ÅøÊôÇ„Å´ÁèæÂú®„ÅÆ„ÉÅ„Çß„ÉÉ„ÇØÁä∂ÊÖã„ÇíÈÅ©Áî®
    try { updateMemberTableVisibility(); } catch (e) { console.warn('updateMemberTableVisibility failed', e); }
    // ‚ñ≤‚ñ≤‚ñ≤ ËøΩÂä†ÁµÇ‰∫Ü ‚ñ≤‚ñ≤‚ñ≤

    // Initial Load
    let initializedWithPreset = false;
    if (!isShareLinkLoaded) {
        loadPreset(15);
        if (elements.presetSelector) {
            elements.presetSelector.value = 15;
        }
        initializedWithPreset = true;
    } else {
        console.log('ÂÖ±Êúâ„É™„É≥„ÇØ„Åã„Çâ„É¢„Éá„É´„ÇíË™≠„ÅøËæº„Çì„Å†„Åü„ÇÅ„ÄÅÂàùÊúü„Éó„É™„Çª„ÉÉ„Éà„Çí„Çπ„Ç≠„ÉÉ„Éó„Åó„Åæ„Åô„ÄÇ');
    }
    setCanvasMode('select');
    
    // ÂàùÊúüÂåñÊôÇ„Å´Ëá™ÈáçË°®Á§∫„ÇíÊõ¥Êñ∞
    if (initializedWithPreset) {
        setTimeout(() => {
            updateSelfWeightDisplay();
        }, 100); // „Éó„É™„Çª„ÉÉ„ÉàË™≠„ÅøËæº„ÅøÂæå„Å´ÂÆüË°å
    }



    // Queue for pending section updates when target row is not yet available
    window.pendingSectionUpdates = window.pendingSectionUpdates || new Map();
    function processPendingSectionUpdates() {
        if (!elements || !elements.membersTable) return;
        for (const [idx, pendingProps] of Array.from(window.pendingSectionUpdates.entries())) {
            const i = Number(idx);
            if (!isNaN(i) && i >= 0 && i < elements.membersTable.rows.length) {
                window.pendingSectionUpdates.delete(idx);
                try { updateMemberProperties(i, pendingProps); } catch (e) { console.warn('processPendingSectionUpdates: update failed', e); }
                continue;
            }

            // If index is not available, try to find a matching row by stable identifiers
            try {
                let foundIndex = -1;
                const rows = Array.from(elements.membersTable.rows || []);
                // Prefer exact match on dataset.memberId or dataset.memberIndex if provided
                if (pendingProps && typeof pendingProps === 'object') {
                    const candidateId = pendingProps.memberId || pendingProps.member_index || pendingProps.memberIndex || pendingProps.id;
                    const candidateLabel = pendingProps.sectionLabel || (pendingProps.sectionInfo && pendingProps.sectionInfo.label) || null;
                    if (candidateId != null) {
                        for (let r = 0; r < rows.length; r++) {
                            const ds = rows[r].dataset || {};
                            if (ds.memberId && String(ds.memberId) === String(candidateId)) { foundIndex = r; break; }
                            if (ds.memberIndex && String(ds.memberIndex) === String(candidateId)) { foundIndex = r; break; }
                        }
                    }

                    // If still not found, try matching by sectionLabel
                    if (foundIndex === -1 && candidateLabel) {
                        for (let r = 0; r < rows.length; r++) {
                            const ds = rows[r].dataset || {};
                            if (ds.sectionLabel && ds.sectionLabel === candidateLabel) { foundIndex = r; break; }
                        }
                    }
                }

                if (foundIndex >= 0) {
                    window.pendingSectionUpdates.delete(idx);
                    console.log(`processPendingSectionUpdates: matched pending update ${idx} -> row ${foundIndex} by identifier`);
                    try { updateMemberProperties(foundIndex, pendingProps); } catch (e) { console.warn('processPendingSectionUpdates: update failed after match', e); }
                } else {
                    // keep the pending entry for future attempts
                    // but log that it remains pending
                    console.log(`processPendingSectionUpdates: pending update ${idx} could not be matched yet (rows=${elements.membersTable.rows.length})`);
                }
            } catch (matchErr) {
                console.warn('processPendingSectionUpdates: error while matching pending update', matchErr);
            }
        }
    }
    // Periodically try to apply pending updates (will be no-op when map empty)
    setInterval(() => { if (window.pendingSectionUpdates && window.pendingSectionUpdates.size > 0) processPendingSectionUpdates(); }, 250);

    // Also watch the members table for row additions/removals and process pending updates immediately
    try {
        setTimeout(() => {
            try {
                if (elements && elements.membersTable) {
                    const targetNode = elements.membersTable.tBodies && elements.membersTable.tBodies[0] ? elements.membersTable.tBodies[0] : elements.membersTable;
                    const mo = new MutationObserver((mutationsList) => {
                        if (window.pendingSectionUpdates && window.pendingSectionUpdates.size > 0) {
                            console.log('MutationObserver: membersTable changed ‚Äî processing pendingSectionUpdates');
                            try { processPendingSectionUpdates(); } catch (e) { console.warn('processPendingSectionUpdates failed from MutationObserver', e); }
                        }
                    });
                    mo.observe(targetNode, { childList: true });
                    // Keep a reference so it isn't GC'd and can be used later if needed
                    window._membersTableMutationObserver = mo;
                    console.log('MutationObserver attached to membersTable for pendingSectionUpdates handling');
                }
            } catch (inner) {
                console.warn('Failed to attach MutationObserver to membersTable', inner);
            }
        }, 0);
    } catch (outerErr) {
        console.warn('Error scheduling MutationObserver attachment', outerErr);
    }

    function updateMemberProperties(memberIndex, props) {
        if (memberIndex >= 0 && memberIndex < elements.membersTable.rows.length) {
            const row = elements.membersTable.rows[memberIndex];

            // Âü∫Êú¨ÁöÑ„Å™Ë°®Á§∫Êõ¥Êñ∞: sectionInfo.label „ÇíÊúÄÂÑ™ÂÖà„Å´‰Ωø„ÅÑ„ÄÅprops.sectionName/sectionLabel „ÅØ„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ
            const displaySectionName = (props.sectionInfo && (props.sectionInfo.label || props.sectionInfo.sectionLabel || props.sectionInfo.name)) || props.sectionLabel || props.sectionName || '-';
            const displayAxisLabel = (props.sectionAxis && props.sectionAxis.label) || props.sectionAxisLabel || '-';

            const sectionNameCell = row.querySelector('.section-name-cell');
            if (sectionNameCell) sectionNameCell.textContent = displaySectionName;

            const sectionAxisCell = row.querySelector('.section-axis-cell');
            if (sectionAxisCell) sectionAxisCell.textContent = displayAxisLabel;

            // Êñ≠Èù¢ÊÄßËÉΩ (I, A, Z) „ÇíÈÉ®Êùê„ÉÜ„Éº„Éñ„É´„ÅÆÂÖ•ÂäõÊ¨Ñ„Å´„ÇÇÂèçÊò†ÔºàËß£Êûê„Å´Áõ¥Áµê„Åô„Çã„Åü„ÇÅÂøÖÈ†àÔºâ
            try {
                // „ÉÜ„Éº„Éñ„É´Âàó: 0:'#',1:i(ÂßãÁÇπ),2:j(ÁµÇÁÇπ),3:E,4:strength,5:I,6:A,7:Z
                if (props.I !== undefined && row.cells[5]) {
                    const iEl = row.cells[5].querySelector('.section-I-input');
                    if (iEl) iEl.value = props.I;
                }
                if (props.A !== undefined && row.cells[6]) {
                    const aEl = row.cells[6].querySelector('.section-A-input');
                    if (aEl) aEl.value = props.A;
                }
                if (props.Z !== undefined && row.cells[7]) {
                    const zEl = row.cells[7].querySelector('.section-Z-input');
                    if (zEl) zEl.value = props.Z;
                }
                if (props.J !== undefined) {
                    const jEl = row.querySelector('.section-J-input');
                    if (jEl) jEl.value = props.J;
                }
                if (props.Iw !== undefined) {
                    const iwEl = row.querySelector('.section-Iw-input');
                    if (iwEl) iwEl.value = props.Iw;
                }
                if (typeof window.updateReductionDisplays === 'function') {
                    window.updateReductionDisplays(row);
                }
            } catch (e) {
                console.warn('updateMemberProperties: failed to update I/A/Z inputs', e);
            }

            // dataset „Å´„ÅÑ„Åè„Å§„Åã„ÅÆÊÄßËÉΩÂÄ§„Çí‰øùÂ≠ò
            if (props.Zx) row.dataset.zx = props.Zx;
            if (props.Zy) row.dataset.zy = props.Zy;
            if (props.ix) row.dataset.ix = props.ix;
            if (props.iy) row.dataset.iy = props.iy;

            // Ê®™Â∫ßÂ±àÁ≠â„ÅßÂøÖË¶Å„Å®„Å™„ÇãÊñ≠Èù¢ÁâπÊÄßÔºàcmÁ≥ª„Åß‰øùÊåÅÔºâ
            // data-ix-mom / data-iy-mom / data-j / data-iw
            if (props.Ix) row.dataset.ixMom = props.Ix;
            if (props.Iy) row.dataset.iyMom = props.Iy;
            if (props.J !== undefined && props.J !== null && props.J !== '') row.dataset.j = props.J;
            else delete row.dataset.j;
            if (props.Iw !== undefined && props.Iw !== null && props.Iw !== '') row.dataset.iw = props.Iw;
            else delete row.dataset.iw;

            // sectionInfo „Åå„ÅÇ„ÇãÂ†¥Âêà„ÅØÁ¢∫ÂÆü„Å´ dataset „Å´‰øùÂ≠ò
            if (props.sectionInfo) {
                // ÊúÄÁµÇÈò≤Ë°õ: typeKey „ÅåÁÑ°„Åë„Çå„Å∞„Éà„ÉÉ„Éó„É¨„Éô„É´„ÅÆ typeKey „ÅßË£úÂÆå
                try {
                    if ((!props.sectionInfo.typeKey || String(props.sectionInfo.typeKey).trim() === '') && (props.typeKey || props.selectedTypeKey)) {
                        props.sectionInfo.typeKey = props.typeKey || props.selectedTypeKey;
                    }
                } catch (e) { /* ignore */ }

                // ÊúÄÁµÇÈò≤Ë°õ: rawDims „ÅåÁÑ°„Åë„Çå„Å∞ props.dims „Åã„ÇâÂæ©ÂÖÉ
                try {
                    if ((!props.sectionInfo.rawDims || Object.keys(props.sectionInfo.rawDims).length === 0) && props.dims && typeof props.dims === 'object') {
                        props.sectionInfo.rawDims = { ...(props.dims || {}) };
                    }
                } catch (e) { /* ignore */ }

                // Ê≠£Ë¶èÂåñ: rawDims „ÅÆ„Ç≠„Éº/ÂÄ§„ÇíÊï∞ÂÄ§Âåñ„Åó„Å¶ canonical keys „ÅÆ„Åø„ÇíÊÆã„Åô
                try {
                    const allowedKeyMap = { h: 'H', b: 'B', a: 'A', d: 'D', t: 't', t1: 't1', t2: 't2', c: 'C', tw: 't1', tf: 't2', phi: 'D', r: 'D' };
                    const normalizeRawDimsObject = (source) => {
                        const out = {};
                        if (!source || typeof source !== 'object') return out;
                        Object.entries(source).forEach(([k, v]) => {
                            try {
                                const lkey = String(k).replace(/[\sÔºø‚ÄêÔºç‚Äì‚Äî\u00A0]/g, '').replace(/[Ôºä*√ó‚úï‚úñ]/g, 'x').replace(/[ÔºàÔºâ()]/g, '').toLowerCase();
                                const canonical = allowedKeyMap[lkey] || (allowedKeyMap[lkey.replace('œÜ','phi')] || null) || (typeof k === 'string' && /^[HBtTdCa]{1,3}$/.test(k) ? k : null);
                                const num = Number(v);
                                if (canonical && Number.isFinite(num)) out[canonical] = num;
                            } catch (_) { /* ignore */ }
                        });
                        return out;
                    };

                    if (props.sectionInfo.rawDims && typeof props.sectionInfo.rawDims === 'object') {
                        props.sectionInfo.rawDims = normalizeRawDimsObject(props.sectionInfo.rawDims);
                    }
                } catch (e) { console.warn('updateMemberProperties: rawDims normalization failed', e); }

                // dataset „Å´‰øùÂ≠òÔºà„Ç®„É≥„Ç≥„Éº„Éâ„Åó„Å¶ JSON ÂåñÔºâ
                try {
                    const json = JSON.stringify(props.sectionInfo);
                    row.dataset.sectionInfo = encodeURIComponent(json);
                    if (props.sectionInfo.label) row.dataset.sectionLabel = props.sectionInfo.label;
                } catch (e) {
                    console.error('sectionInfo save error:', e);
                }
            }

            // „Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó„ÅåÈñã„ÅÑ„Å¶„ÅÑ„Å¶ÁèæÂú®Á∑®ÈõÜ‰∏≠„ÅÆÈÉ®Êùê„Å®‰∏ÄËá¥„Åô„ÇãÂ†¥Âêà„ÄÅ„Éù„ÉÉ„Éó„Ç¢„ÉÉ„ÉóÂÜÖ„ÅÆÊñ≠Èù¢Ë°®Á§∫„ÇíÊõ¥Êñ∞
            try {
                const popup = document.getElementById('member-props-popup');
                if (popup && popup.style && popup.style.display === 'block' && window.selectedMemberIndex === memberIndex) {
                    // „Éù„ÉÉ„Éó„Ç¢„ÉÉ„ÉóÂÜÖ„ÅÆ I/A/Z „Éï„Ç£„Éº„É´„Éâ„ÇíÊõ¥Êñ∞Ôºàprops ÂÑ™ÂÖàÔºâ
                    try {
                        if (props.I !== undefined) document.getElementById('popup-i').value = props.I;
                        if (props.A !== undefined) document.getElementById('popup-a').value = props.A;
                        if (props.Z !== undefined) document.getElementById('popup-z').value = props.Z;
                    } catch (_) { /* ignore popup input updates */ }

                    const popupSectionLabelEl = document.getElementById('popup-section-label');
                    if (popupSectionLabelEl) {
                        // Ëª∏ÊñπÂêë„ÅÆË°®Á§∫Êõ¥Êñ∞ (displaySectionName, displayAxisLabel „ÅØÈñ¢Êï∞ÂÜíÈ†≠„ÅßÁÆóÂá∫Ê∏à„Åø)
                        const axisText = (displayAxisLabel && displayAxisLabel !== 'ÈÅ∏Êäû') ? displayAxisLabel : '';
                        popupSectionLabelEl.innerHTML = `Êñ≠Èù¢: ${displaySectionName}${axisText ? `<br><span style="font-weight:normal; font-size:0.9em;">Ëª∏ÊñπÂêë: ${axisText}</span>` : ''}`;
                    }

                    // Êñ≠Èù¢2Ê¨°ÂçäÂæÑÂÖ•Âäõ„ÇÇÊõ¥Êñ∞Ôºàix/iy „ÅÆ„ÅÜ„Å°Â∞è„Åï„ÅÑÊñπ„ÇíÂÑ™ÂÖà„Åó„Å¶Ë°®Á§∫Ôºâ
                    const popupRadiusEl = document.getElementById('popup-radius-i');
                    if (popupRadiusEl) {
                        try {
                            if (props.i !== undefined && props.i !== null && props.i !== '') {
                                popupRadiusEl.value = Number(props.i).toFixed(2);
                            } else {
                                const pIx = (props.ix !== undefined && props.ix !== null && props.ix !== '') ? parseFloat(props.ix) : NaN;
                                const pIy = (props.iy !== undefined && props.iy !== null && props.iy !== '') ? parseFloat(props.iy) : NaN;
                                if (!isNaN(pIx) && !isNaN(pIy)) {
                                    popupRadiusEl.value = Math.min(pIx, pIy).toFixed(2);
                                } else if (!isNaN(pIx)) {
                                    popupRadiusEl.value = pIx.toFixed(2);
                                } else if (!isNaN(pIy)) {
                                    popupRadiusEl.value = pIy.toFixed(2);
                                } else {
                                    // fallback to dataset values
                                    const rawIx = row.dataset.ix;
                                    const rawIy = row.dataset.iy;
                                    const nIx = (rawIx !== undefined && rawIx !== '') ? parseFloat(rawIx) : NaN;
                                    const nIy = (rawIy !== undefined && rawIy !== '') ? parseFloat(rawIy) : NaN;
                                    if (!isNaN(nIx) && !isNaN(nIy)) popupRadiusEl.value = Math.min(nIx, nIy).toFixed(2);
                                    else if (!isNaN(nIx)) popupRadiusEl.value = nIx.toFixed(2);
                                    else if (!isNaN(nIy)) popupRadiusEl.value = nIy.toFixed(2);
                                }
                            }
                        } catch (_) { /* ignore */ }
                    }
                }
            } catch (err) { /* ignore popup update errors */ }

            // Ëª∏ÊÉÖÂ†±„ÅÆ dataset ‰øùÂ≠ò
            if (props.sectionAxis) {
                if (typeof window.applySectionAxisDataset === 'function') {
                    window.applySectionAxisDataset(row, props.sectionAxis);
                }
            }

            // Êñ≠Èù¢2Ê¨°ÂçäÂæÑ i „ÅÆÊõ¥Êñ∞ÔºàUIÂÖ•ÂäõÊ¨Ñ„Åå„ÅÇ„Çå„Å∞ÂÄ§„Çí„Çª„ÉÉ„ÉàÔºâ
            try {
                const iInput = row.querySelector('.radius-i-input');
                if (iInput) {
                    let newVal = null;
                    if (props.i !== undefined && props.i !== null && props.i !== '') newVal = Number(props.i);
                    else {
                        const pIx = (props.ix !== undefined && props.ix !== null && props.ix !== '') ? parseFloat(props.ix) : NaN;
                        const pIy = (props.iy !== undefined && props.iy !== null && props.iy !== '') ? parseFloat(props.iy) : NaN;
                        if (!isNaN(pIx) && !isNaN(pIy)) newVal = Math.min(pIx, pIy);
                        else if (!isNaN(pIx)) newVal = pIx;
                        else if (!isNaN(pIy)) newVal = pIy;
                    }

                    if (newVal !== null && !isNaN(newVal)) {
                        // Ë°®Á§∫„ÅØ cm Âçò‰Ωç„ÅßÂõ∫ÂÆö
                        iInput.value = Number(newVal).toFixed(2);
                        try { row.dataset.ix = String(Number(newVal)); } catch(_){ }
                        try { row.dataset.iy = String(Number(newVal)); } catch(_){ }
                    }
                }
            } catch (e) { /* ignore */ }

            // DOM Êõ¥Êñ∞„ÇíÁ¢∫ÂÆü„Å´„Åó„Å¶„Åã„Çâ 3D „Éì„É•„Éº„Ç¢„Å∏ÈÄÅ‰ø°Ôºà100ms ÈÅÖÂª∂Ôºâ
            if (typeof sendModelToViewer === 'function') {
                setTimeout(() => {
                    try {
                        sendModelToViewer();
                        console.log(`üîß ÈÉ®Êùê${memberIndex + 1}„ÅÆÊÉÖÂ†±„Çí3D„Éì„É•„Éº„Ç¢„Å∏ÈÄÅ‰ø°„Åó„Åæ„Åó„Åü`);
                    } catch (e) {
                        console.warn('sendModelToViewer failed', e);
                    }
                }, 100);
            }
        } else {
            console.warn(`updateMemberProperties: ÁÑ°Âäπ„Å™ÈÉ®Êùê„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ ${memberIndex} ‚Äî „Ç≠„É•„Éº„Å´‰øùÂ≠ò„Åó„Å¶ÂÜçË©¶Ë°å„Åó„Åæ„Åô`);
            try {
                window.pendingSectionUpdates.set(String(memberIndex), props);
            } catch (qErr) {
                console.error('updateMemberProperties: „Ç≠„É•„Éº‰øùÂ≠ò„Å´Â§±Êïó„Åó„Åæ„Åó„Åü', qErr);
            }
        }
    }

            


    window.addEventListener('storage', (e) => {
        if (e.key === 'steelSelectionForFrameAnalyzer' && e.newValue) {
            try {
                const data = JSON.parse(e.newValue);
                console.log('[storage event] steelSelectionForFrameAnalyzer received:', data);
                if (data && data.targetMemberIndex !== undefined && data.properties) {
                    if (data.targetMemberIndex === 'bulk') {
                        window.bulkSectionProperties = data.properties;
                        if (typeof updateBulkSectionInfo === 'function') {
                            updateBulkSectionInfo(data.properties);
                        }
                    } else if (data.targetMemberIndex === 'addDefaults') {
                        // Êñ∞Ë¶èÈÉ®ÊùêËøΩÂä†ÊôÇ„ÅÆÂá¶ÁêÜ
                        const props = data.properties;
                        console.log('‚úÖ ÈÉ®ÊùêËøΩÂä†Ë®≠ÂÆö(addDefaults)„ÅÆÊñ≠Èù¢„Éá„Éº„Çø„ÇíÂèó‰ø°:', props);

                        // „Éù„ÉÉ„Éó„Ç¢„ÉÉ„ÉóÂÜÖ„ÅÆÂÖ•ÂäõÊ¨Ñ„ÇíÊõ¥Êñ∞
                        document.getElementById('add-popup-i').value = props.I;
                        document.getElementById('add-popup-a').value = props.A;
                        document.getElementById('add-popup-z').value = props.Z;
                        // Êñ≠Èù¢2Ê¨°ÂçäÂæÑ„ÇÑÂ∫ßÂ±à‰øÇÊï∞„ÅåÈÄÅ„Çâ„Çå„Å¶„Åè„Çå„Å∞„Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó„Å´„Çª„ÉÉ„Éà
                        try { document.getElementById('add-popup-radius-i').value = props.i || props.i_radius || props.ix || props.iy || ''; } catch(_){ }
                        try { document.getElementById('add-popup-buckling-k').value = props.bucklingK || ''; } catch(_){ }

                        // „Éá„Éï„Ç©„É´„ÉàÂÄ§„ÇíÊõ¥Êñ∞
                        newMemberDefaults.I = props.I;
                        newMemberDefaults.A = props.A;
                        newMemberDefaults.Z = props.Z;
                        if (props.bucklingK !== undefined) newMemberDefaults.bucklingK = props.bucklingK;

                        // Êñ≠Èù¢ÊÉÖÂ†±ÔºàÂêçÁß∞„Å®Ëª∏Ôºâ„Çí‰øùÂ≠ò„ÉªË°®Á§∫
                        const sectionName = props.sectionName || props.sectionLabel || '';
                        const axisLabel = props.selectedAxis || props.sectionAxisLabel || (props.sectionAxis ? props.sectionAxis.label : null) || '-';

                        if (sectionName) {
                            newMemberDefaults.sectionName = sectionName;
                            newMemberDefaults.sectionAxis = axisLabel;

                            const infoDiv = document.getElementById('add-popup-section-info');
                            const nameSpan = document.getElementById('add-popup-section-name');
                            const axisSpan = document.getElementById('add-popup-section-axis');

                            if (infoDiv && nameSpan && axisSpan) {
                                nameSpan.textContent = sectionName;
                                axisSpan.textContent = axisLabel;
                                infoDiv.style.display = 'block';
                            }
                        }
                        // ‚òÖ ËøΩÂä†: Âèó‰ø°„Åó„Åü sectionInfo „Å® ix/iy „Çí newMemberDefaults „Å´‰øùÂ≠òÔºà3DÊèèÁîªÁî®Ôºâ
                        try {
                            if (props) {
                                if (props.sectionInfo) {
                                    // ‰øùÂ≠òÔºàÁõ¥Êé•‰ª£ÂÖ•„ÅßOKÔºâ
                                    newMemberDefaults.sectionInfo = props.sectionInfo;

                                    // ÊúÄ‰ΩéÈôê„ÅÆË£úÂÆå: typeKey „Å® rawDims
                                    if ((!newMemberDefaults.sectionInfo.typeKey || String(newMemberDefaults.sectionInfo.typeKey).trim() === '') && (props.typeKey || props.selectedTypeKey)) {
                                        newMemberDefaults.sectionInfo.typeKey = props.typeKey || props.selectedTypeKey;
                                    }
                                    if ((!newMemberDefaults.sectionInfo.rawDims || Object.keys(newMemberDefaults.sectionInfo.rawDims || {}).length === 0) && props.dims) {
                                        newMemberDefaults.sectionInfo.rawDims = props.dims;
                                    }
                                }

                                // ix / iy „ÇíÁõ¥Êé•Âèó„ÅëÂèñ„Çå„ÇãÂ†¥Âêà„ÅØ‰øùÂ≠ò
                                if (props.ix !== undefined) newMemberDefaults.ix = props.ix;
                                if (props.iy !== undefined) newMemberDefaults.iy = props.iy;
                                if (props.Ix !== undefined) newMemberDefaults.ix = props.Ix;
                                if (props.Iy !== undefined) newMemberDefaults.iy = props.Iy;

                                // „Å™„Åë„Çå„Å∞ I „Å® A „Åã„ÇâÊé®ÂÆöÔºàË°®Á§∫Âçò‰Ωç„Å´Âêà„Çè„Åõ„Å¶ cm Âçò‰Ωç„Åß‰øùÂ≠òÔºâ
                                if ((newMemberDefaults.ix === undefined || newMemberDefaults.ix === null || newMemberDefaults.ix === '') && props.I && props.A) {
                                    const Ival = Number(props.I);
                                    const Aval = Number(props.A);
                                    if (Number.isFinite(Ival) && Number.isFinite(Aval) && Aval > 0) {
                                        try { newMemberDefaults.ix = (Math.sqrt(Ival / Aval) * 100).toFixed(3); } catch(_) { /* ignore */ }
                                    }
                                }
                                if ((newMemberDefaults.iy === undefined || newMemberDefaults.iy === null || newMemberDefaults.iy === '') && props.I && props.A) {
                                    // Âêå„ÅòÊé®ÂÆö„Çí‰Ωø„ÅÜÔºàÂØæÁß∞Êñ≠Èù¢ÊôÇ„Å™„Å©Ôºâ
                                    if (newMemberDefaults.ix !== undefined) newMemberDefaults.iy = newMemberDefaults.ix;
                                }
                            }
                        } catch (saveErr) {
                            console.warn('storage:addDefaults - failed to save sectionInfo or ix/iy to newMemberDefaults', saveErr);
                        }
                    } else {
                        // Âèó‰ø°„Éó„É≠„Éë„ÉÜ„Ç£„Å´ sectionInfo „ÅåÁÑ°„ÅÑÂ†¥Âêà„ÄÅË¶™ÂÅ¥„ÅßÊúÄÂ∞èÈôê„ÅÆ sectionInfo „ÇíË£úÂÆå„Åó„Å¶„Åä„Åè
                            try {
                                const props = data.properties || {};
                                // „ÄêËøΩÂä†‰øÆÊ≠£„ÄëÂèó‰ø°Áõ¥Âæå„Å´„ÇÇ typeKey „ÅÆË£úÂÆå„ÇíË°å„ÅÜ
                                try {
                                    const typeKey = props.typeKey || props.selectedTypeKey || props.sectionTypeKey;
                                    if (props.sectionInfo && typeof props.sectionInfo === 'object') {
                                        const currentKey = props.sectionInfo.typeKey;
                                        const isInvalidKey = !currentKey || /^(unknown|‰∏çÊòé|„Åù„ÅÆ‰ªñ|n\/a|na|none|unk)$/i.test(String(currentKey));
                                        if (isInvalidKey && typeKey) {
                                            console.log(`üîß storage event: sectionInfo.typeKey (${currentKey}) „Çí ${typeKey} „ÅßË£úÂÆå„Åó„Åæ„Åô`);
                                            props.sectionInfo.typeKey = typeKey;
                                        }
                                    }
                                } catch (typeKeyErr) {
                                    console.warn('storage event: typeKey Ë£úÂÆåÂá¶ÁêÜ„Åß„Ç®„É©„Éº', typeKeyErr);
                                }
                            // ËøΩÂä†„Éà„É¨„Éº„Çπ: Âèó‰ø°Áîü„Éá„Éº„Çø„ÅÆË¶ÅÁ¥Ñ„ÇíÂá∫Âäõ
                            try {
                                console.log('[storage event] raw e.key:', e.key);
                                console.log('[storage event] raw e.newValue length:', e.newValue ? e.newValue.length : 0);
                                console.log('[storage event] parsed data.targetMemberIndex:', data.targetMemberIndex);
                                console.log('[storage event] parsed properties keys:', Object.keys(props));
                            } catch (tErr) {
                                console.warn('storage event: summary logging failed', tErr);
                            }

                            if (!props.sectionInfo) {
                                const fallback = {};
                                // „É©„Éô„É´/ÂêçÁß∞
                                if (props.sectionLabel || props.sectionName) {
                                    fallback.label = props.sectionLabel || props.sectionName;
                                }

                                // Ëª∏ÊÉÖÂ†±„ÅÆË£úÂÆå
                                if (props.sectionAxis) {
                                    fallback.axis = props.sectionAxis;
                                } else if (props.selectedAxis || props.sectionAxisLabel) {
                                    fallback.axis = { label: props.selectedAxis || props.sectionAxisLabel };
                                }

                                // Âûã„ÇÑÂØ∏Ê≥ï„ÅåÊ∏°„Åï„Çå„Å¶„ÅÑ„Çå„Å∞‰øùÊåÅ
                                const typeKey = props.typeKey || props.selectedTypeKey || props.sectionTypeKey;
                                if (typeKey) fallback.typeKey = typeKey;
                                if (props.dims) fallback.rawDims = typeof props.dims === 'object' ? { ...props.dims } : props.dims;

                                // „Åß„Åç„Çå„Å∞ SVG „ÇíÁîüÊàê„Åó„Å¶Âüã„ÇÅ„ÇãÔºàË¶™ÂÅ¥„ÅÆ ensureSectionSvgMarkup / buildSectionDiagramData „ÇíÂà©Áî®Ôºâ
                                try {
                                    if (typeof window.ensureSectionSvgMarkup === 'function') {
                                        const enriched = window.ensureSectionSvgMarkup(fallback);
                                        props.sectionInfo = enriched;
                                    } else if (typeKey && props.dims && typeof window.buildSectionDiagramData === 'function') {
                                        try {
                                            const diagram = window.buildSectionDiagramData(typeKey, props.dims, { labelScaleMultiplier: 0.5, showDimensions: false });
                                            if (diagram && diagram.markup) {
                                                fallback.svgMarkup = `<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"${diagram.viewBox}\" width=\"240\" height=\"180\" role=\"img\" aria-label=\"Êñ≠Èù¢Âõ≥\">${diagram.markup}</svg>`;
                                            }
                                        } catch (bdErr) {
                                            console.warn('buildSectionDiagramData „Å´„Çà„Çã SVG ÁîüÊàê„Å´Â§±Êïó„Åó„Åæ„Åó„Åü', bdErr);
                                        }
                                        props.sectionInfo = fallback;
                                    } else {
                                        // ÊúÄ‰Ωé„Åß„ÇÇ„É©„Éô„É´/Ëª∏„Å†„Åë„ÇíÂÖ•„Çå„Å¶„Åä„Åè
                                        if (Object.keys(fallback).length > 0) props.sectionInfo = fallback;
                                    }
                                } catch (innerErr) {
                                    console.warn('sectionInfo „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÁîüÊàê„Åß„Ç®„É©„Éº', innerErr);
                                    if (Object.keys(fallback).length > 0) props.sectionInfo = fallback;
                                }
                                    }
                                } catch (err) {
                                    console.warn('Âèó‰ø°„Éá„Éº„Çø„ÅÆË£úÂÆåÂá¶ÁêÜ„Åß„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü', err);
                                }

                                // „Çø„Éº„Ç≤„ÉÉ„ÉàË°å„Å´Èñ¢„Åô„ÇãË©≥Á¥∞„Éà„É¨„Éº„Çπ
                                try {
                                    const tgt = data.targetMemberIndex;
                                    const propsForUpdate = data.properties || {};
                                    let targetRow = null;
                                    if (typeof tgt === 'number' && elements && elements.membersTable && elements.membersTable.rows[tgt]) {
                                        targetRow = elements.membersTable.rows[tgt];
                                    }
                                    console.log('[storage event] about to verify target row before update', { targetMemberIndex: tgt, targetRowExists: !!targetRow });
                                    if (targetRow) {
                                        try { console.log('[storage event] targetRow.dataset (before)=', Object.assign({}, targetRow.dataset)); } catch (dErr) { console.warn('dataset before logging failed', dErr); }
                                    } else {
                                        // Ë°å„ÅåË¶ã„Å§„Åã„Çâ„Å™„Åë„Çå„Å∞„ÄÅË°åÊï∞„ÇÑÁØÑÂõ≤ÊÉÖÂ†±„ÇÇÂá∫„Åô
                                        try { console.log('[storage event] membersTable rows count=', elements && elements.membersTable ? elements.membersTable.rows.length : 'no-membersTable'); } catch (_) {}
                                    }

                                    // If the target row is missing or appears to represent a different section (label mismatch), queue the update instead of forcing it now.
                                    let shouldQueue = false;
                                    try {
                                        if (!targetRow) {
                                            // Try an immediate best-effort match by stable identifiers or sectionLabel
                                            let immediateFound = -1;
                                            try {
                                                const rows = Array.from(elements.membersTable.rows || []);
                                                const candidateId = propsForUpdate && typeof propsForUpdate === 'object' ? (propsForUpdate.memberId || propsForUpdate.member_index || propsForUpdate.memberIndex || propsForUpdate.id) : null;
                                                const candidateLabel = propsForUpdate && typeof propsForUpdate === 'object' ? (propsForUpdate.sectionLabel || (propsForUpdate.sectionInfo && propsForUpdate.sectionInfo.label) || null) : null;
                                                if (candidateId != null) {
                                                    for (let r = 0; r < rows.length; r++) {
                                                        const ds = rows[r].dataset || {};
                                                        if (ds.memberId && String(ds.memberId) === String(candidateId)) { immediateFound = r; break; }
                                                        if (ds.memberIndex && String(ds.memberIndex) === String(candidateId)) { immediateFound = r; break; }
                                                    }
                                                }
                                                if (immediateFound === -1 && candidateLabel) {
                                                    for (let r = 0; r < rows.length; r++) {
                                                        const ds = rows[r].dataset || {};
                                                        if (ds.sectionLabel && ds.sectionLabel === candidateLabel) { immediateFound = r; break; }
                                                    }
                                                }
                                            } catch (matchErr) {
                                                console.warn('storage event: immediate match search failed', matchErr);
                                            }

                                            if (immediateFound >= 0) {
                                                console.log(`[storage event] immediate match found for queued index ${tgt} -> applying to row ${immediateFound}`);
                                                try { updateMemberProperties(immediateFound, propsForUpdate); } catch (applyErr) { console.warn('storage event: immediate apply failed', applyErr); }
                                            } else {
                                                shouldQueue = true;
                                                console.warn(`[storage event] targetRow not found for index ${tgt} ‚Äî queuing update`);
                                            }
                                        } else if (propsForUpdate && propsForUpdate.sectionLabel) {
                                            const currentLabel = (targetRow.dataset && targetRow.dataset.sectionLabel) ? String(targetRow.dataset.sectionLabel) : null;
                                            if (currentLabel && currentLabel !== propsForUpdate.sectionLabel) {
                                                // Labels differ ‚Äî possible row mismatch or stale indexing. Try to find the correct row first.
                                                let immediateFound = -1;
                                                try {
                                                    const rows = Array.from(elements.membersTable.rows || []);
                                                    for (let r = 0; r < rows.length; r++) {
                                                        const ds = rows[r].dataset || {};
                                                        if (ds.sectionLabel && ds.sectionLabel === propsForUpdate.sectionLabel) { immediateFound = r; break; }
                                                    }
                                                } catch (matchErr2) {
                                                    console.warn('storage event: label match search failed', matchErr2);
                                                }

                                                if (immediateFound >= 0) {
                                                    console.log(`[storage event] label-based immediate match found -> applying to row ${immediateFound}`);
                                                    try { updateMemberProperties(immediateFound, propsForUpdate); } catch (applyErr2) { console.warn('storage event: immediate apply after label-match failed', applyErr2); }
                                                } else {
                                                    shouldQueue = true;
                                                    console.warn(`[storage event] targetRow label mismatch (rowLabel='${currentLabel}' vs propsLabel='${propsForUpdate.sectionLabel}') ‚Äî queuing update for index ${tgt}`);
                                                }
                                            }
                                        }
                                    } catch (chkErr) {
                                        console.warn('storage event: target row verification error', chkErr);
                                    }

                                    if (shouldQueue) {
                                        try {
                                            window.pendingSectionUpdates.set(String(tgt), propsForUpdate);
                                            console.log(`[storage event] queued pendingSectionUpdates[${tgt}] (pending size=${window.pendingSectionUpdates.size})`);
                                            // Try to process pending updates immediately (fast-path)
                                            try { processPendingSectionUpdates(); } catch (procErr) { console.warn('processPendingSectionUpdates immediate call failed', procErr); }
                                        } catch (qErr) {
                                            console.error('storage event: failed to queue pendingSectionUpdates', qErr);
                                            // fallback: attempt to apply immediately
                                            try { updateMemberProperties(data.targetMemberIndex, propsForUpdate); } catch (eApply) { console.warn('storage event: immediate apply failed after queue failure', eApply); }
                                        }
                                    } else {
                                        // Safe to apply immediately
                                        updateMemberProperties(data.targetMemberIndex, propsForUpdate);

                                        // Áõ¥Âæå„Å´ dataset „ÅÆÁä∂ÊÖã„ÇíÁ¢∫Ë™çÔºàupdateMemberProperties „ÅØÂ§ßÈÉ®ÂàÜ„ÅåÂêåÊúü„Åßdataset„Å´Êõ∏„ÅçËæº„ÇÄÔºâ
                                        if (targetRow) {
                                            try { console.log('[storage event] targetRow.dataset (after)=', Object.assign({}, targetRow.dataset)); } catch (dErr2) { console.warn('dataset after logging failed', dErr2); }
                                        }
                                    }
                                } catch (traceErr) {
                                    console.warn('storage event: tracing around updateMemberProperties failed', traceErr);
                                }
                    }
                    localStorage.removeItem('steelSelectionForFrameAnalyzer');
                }
            } catch (error) {
                console.error('localStorage„Åã„Çâ„ÅÆ„Éá„Éº„ÇøËß£Êûê„Å´Â§±Êïó„Åó„Åæ„Åó„Åü:', error);
            }
        }
    });

    // Ëá™Âãï„Çπ„Ç±„Éº„É™„É≥„Ç∞Ê©üËÉΩÔºàÊâãÂãï„Éú„Çø„É≥Áî®Ôºâ
    window.triggerAutoScale = () => {
        console.log('Auto scale button clicked - resetting panZoomState');
        panZoomState.isInitialized = false;
        drawOnCanvas();
        console.log('Auto scale completed. New panZoomState:', panZoomState);
    };
    
    // ÊâãÂãï„Åß„É™„Çµ„Ç§„Ç∫„ÇíÂÆüË°å„Åô„ÇãÈñ¢Êï∞Ôºà„Éá„Éê„ÉÉ„Ç∞Áî®Ôºâ
    window.triggerManualResize = () => {
        console.log('Manual resize triggered');
        panZoomState.isInitialized = false;
        drawOnCanvas();
    };

    // „É™„Çµ„Ç§„Ç∫Ê§úÂá∫Ê©üËÉΩÔºàResizeObserver„Çí‰ΩøÁî®Ôºâ
    const modelCanvasContainer = document.querySelector('.input-section .canvas-container');
    console.log('modelCanvasContainer element:', modelCanvasContainer);
    
    if (modelCanvasContainer) {
        console.log('Container found, setting up ResizeObserver...');
        let lastKnownSize = { width: 0, height: 0 };
        
        // ResizeObserverÂØæÂøúÁ¢∫Ë™ç
        if (typeof ResizeObserver === 'undefined') {
            console.error('ResizeObserver is not supported in this browser');
            return;
        }
        
        console.log('ResizeObserver is supported, creating observer...');
        
        // ResizeObserver„Çí‰ΩøÁî®„Åó„Å¶„Ç≥„É≥„ÉÜ„Éä„ÅÆ„É™„Çµ„Ç§„Ç∫„ÇíÁõ£Ë¶ñ
        const resizeObserver = new ResizeObserver((entries) => {
            console.log('=== ResizeObserver triggered ===');
            console.log('Entries count:', entries.length);
            
            for (const entry of entries) {
                const { width, height } = entry.contentRect;
                const currentSize = { width: Math.round(width), height: Math.round(height) };
                
                console.log('Current size:', currentSize, 'Last known size:', lastKnownSize);
                
                // „Çµ„Ç§„Ç∫„ÅåÂÆüÈöõ„Å´Â§âÊõ¥„Åï„Çå„ÅüÂ†¥Âêà„ÅÆ„ÅøÂá¶ÁêÜ
                if (currentSize.width !== lastKnownSize.width || currentSize.height !== lastKnownSize.height) {
                    console.log('ResizeObserver: Container resized from', lastKnownSize, 'to', currentSize);
                    lastKnownSize = currentSize;
                    
                    console.log('panZoomState before reset:', JSON.stringify(panZoomState));
                    // Ëá™Âãï„Çπ„Ç±„Éº„É™„É≥„Ç∞„ÇíÂÆüË°å
                    panZoomState.isInitialized = false;
                    console.log('panZoomState after reset:', JSON.stringify(panZoomState));
                    console.log('Calling drawOnCanvas...');
                    drawOnCanvas();
                    console.log('drawOnCanvas completed');
                } else {
                    console.log('Size unchanged, skipping resize processing');
                }
            }
            console.log('=== ResizeObserver processing completed ===');
        });
        
        console.log('ResizeObserver created, now observing container...');
        resizeObserver.observe(modelCanvasContainer);
        console.log('ResizeObserver.observe() called successfully');
        
        // ÂàùÊúü„Çµ„Ç§„Ç∫„ÇíË®òÈå≤
        setTimeout(() => {
            const rect = modelCanvasContainer.getBoundingClientRect();
            lastKnownSize = { width: Math.round(rect.width), height: Math.round(rect.height) };
            console.log('Initial container size recorded:', lastKnownSize);
        }, 100);
    } else {
        console.error('modelCanvasContainer not found! Selector: .input-section .canvas-container');
        
        // „Éá„Éê„ÉÉ„Ç∞Áî®: Â≠òÂú®„Åô„ÇãË¶ÅÁ¥†„ÇíÁ¢∫Ë™ç
        const inputSection = document.querySelector('.input-section');
        const canvasContainers = document.querySelectorAll('.canvas-container');
        console.log('inputSection found:', inputSection);
        console.log('All canvas-container elements:', canvasContainers);
    }

    // ‰ª£Êõø„É™„Çµ„Ç§„Ç∫Ê§úÂá∫ÊñπÊ≥ïÔºà„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÔºâ
    let fallbackLastSize = { width: 0, height: 0 };
    
    const fallbackResizeCheck = () => {
        const container = document.querySelector('.input-section .canvas-container');
        if (container) {
            const rect = container.getBoundingClientRect();
            const currentSize = { width: Math.round(rect.width), height: Math.round(rect.height) };
            
            if (currentSize.width !== fallbackLastSize.width || currentSize.height !== fallbackLastSize.height) {
                console.log('=== FALLBACK RESIZE DETECTED ===');
                console.log('Size changed from', fallbackLastSize, 'to', currentSize);
                fallbackLastSize = currentSize;
                
                console.log('panZoomState before reset:', JSON.stringify(panZoomState));
                panZoomState.isInitialized = false;
                console.log('panZoomState after reset:', JSON.stringify(panZoomState));
                console.log('Calling drawOnCanvas...');
                drawOnCanvas();
                console.log('Fallback resize processing completed');
            }
        }
    };
    
    // ÂàùÊúü„Çµ„Ç§„Ç∫„ÇíË®òÈå≤Ôºà„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÁî®Ôºâ
    setTimeout(() => {
        const container = document.querySelector('.input-section .canvas-container');
        if (container) {
            const rect = container.getBoundingClientRect();
            fallbackLastSize = { width: Math.round(rect.width), height: Math.round(rect.height) };
            console.log('Fallback initial size recorded:', fallbackLastSize);
        }
    }, 200);
    
    // ÂÆöÊúüÁöÑ„Å™„Çµ„Ç§„Ç∫„ÉÅ„Çß„ÉÉ„ÇØÔºà„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÔºâ
    setInterval(fallbackResizeCheck, 500);
    
    // „Éû„Ç¶„Çπ„Ç§„Éô„É≥„ÉàÊôÇ„ÅÆ„ÉÅ„Çß„ÉÉ„ÇØÔºà„É™„Çµ„Ç§„Ç∫„Éè„É≥„Éâ„É´Êìç‰ΩúÊ§úÂá∫Ôºâ
    document.addEventListener('mouseup', () => {
        console.log('Mouse up detected, checking for resize...');
        setTimeout(fallbackResizeCheck, 50);
    });
    
    document.addEventListener('mousemove', (e) => {
        // „É™„Çµ„Ç§„Ç∫‰∏≠„Åã„Å©„ÅÜ„Åã„Çí„ÉÅ„Çß„ÉÉ„ÇØÔºà„Ç´„Éº„ÇΩ„É´„Åå„É™„Çµ„Ç§„Ç∫Áî®„ÅÆÂ†¥ÂêàÔºâ
        if (e.target && e.target.closest && e.target.closest('.input-section .canvas-container')) {
            const container = e.target.closest('.input-section .canvas-container');
            const rect = container.getBoundingClientRect();
            const isNearBottomRight = (e.clientY > rect.bottom - 20) && (e.clientX > rect.right - 20);
            
            if (isNearBottomRight) {
                // „É™„Çµ„Ç§„Ç∫„Éè„É≥„Éâ„É´‰ªòËøë„Åß„ÅÆ„Éû„Ç¶„ÇπÁßªÂãï„ÇíÊ§úÂá∫
                setTimeout(fallbackResizeCheck, 100);
            }
        }
    });



    // SheetJS„É©„Ç§„Éñ„É©„É™„ÅÆÂãïÁöÑË™≠„ÅøËæº„Åø
    function loadSheetJS() {
        return new Promise((resolve, reject) => {
            const script = document.createElement('script');
            script.src = 'https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js';
            script.onload = () => {
                console.log('SheetJS„É©„Ç§„Éñ„É©„É™„ÅåË™≠„ÅøËæº„Åæ„Çå„Åæ„Åó„Åü');
                resolve();
            };
            script.onerror = () => {
                reject(new Error('SheetJS„É©„Ç§„Éñ„É©„É™„ÅÆË™≠„ÅøËæº„Åø„Å´Â§±Êïó„Åó„Åæ„Åó„Åü'));
            };
            document.head.appendChild(script);
        });
    }

    // „Ç®„ÇØ„Çª„É´„Éï„Ç°„Ç§„É´ÁîüÊàê„ÉªÂá∫Âäõ
    async function exportToExcel() {
        console.log('„Ç®„ÇØ„Çª„É´„Éï„Ç°„Ç§„É´„ÇíÁîüÊàê‰∏≠...');
        
        // „ÉØ„Éº„ÇØ„Éñ„ÉÉ„ÇØ‰ΩúÊàê
        const workbook = XLSX.utils.book_new();
        
        try {
            // 1. ÂÖ•Âäõ„Éá„Éº„Çø„Ç∑„Éº„Éà
            await addInputDataSheet(workbook);
            
            // 2. Ëß£ÊûêÁµêÊûú„Ç∑„Éº„Éà
            if (lastAnalysisResult && lastAnalysisResult.displacements) {
                await addAnalysisResultSheet(workbook);
            }
            
            // 3. Êñ≠Èù¢Ê§úÂÆöÁµêÊûú„Ç∑„Éº„ÉàÔºàÊñ≠Èù¢Ê§úÂÆö/„Åü„Çè„Åø/Ê®™Â∫ßÂ±àÔºâ
            if ((lastAnalysisResult && lastAnalysisResult.sectionCheckResults && lastAnalysisResult.sectionCheckResults.length > 0) ||
                (lastSectionCheckResults && lastSectionCheckResults.length > 0) ||
                (lastAnalysisResult && lastAnalysisResult.deflectionCheckResults && lastAnalysisResult.deflectionCheckResults.length > 0) ||
                (lastDeflectionCheckResults && lastDeflectionCheckResults.length > 0) ||
                (lastAnalysisResult && lastAnalysisResult.ltbCheckResults && lastAnalysisResult.ltbCheckResults.length > 0) ||
                (lastLtbCheckResults && lastLtbCheckResults.length > 0)) {
                await addSectionCheckSheet(workbook);
            }
            
            // 4. Â∫ßÂ±àËß£ÊûêÁµêÊûú„Ç∑„Éº„Éà
            if (lastBucklingResults && lastBucklingResults.length > 0) {
                await addBucklingAnalysisSheet(workbook);
            }
            
            // „Éï„Ç°„Ç§„É´ÂêçÁîüÊàê
            const timestamp = new Date().toISOString().slice(0, 19).replace(/[:\-T]/g, '');
            const filename = `ÊßãÈÄ†Ëß£ÊûêÁµêÊûú_${timestamp}.xlsx`;
            
            // „Ç®„ÇØ„Çª„É´„Éï„Ç°„Ç§„É´Âá∫Âäõ
            XLSX.writeFile(workbook, filename);
            
            console.log('„Ç®„ÇØ„Çª„É´„Éï„Ç°„Ç§„É´„ÅåÊ≠£Â∏∏„Å´Âá∫Âäõ„Åï„Çå„Åæ„Åó„Åü:', filename);
            safeAlert('„Ç®„ÇØ„Çª„É´„Éï„Ç°„Ç§„É´„ÅåÊ≠£Â∏∏„Å´Âá∫Âäõ„Åï„Çå„Åæ„Åó„Åü: ' + filename);
            
        } catch (error) {
            console.error('„Ç®„ÇØ„Çª„É´„Éï„Ç°„Ç§„É´ÁîüÊàê„Åß„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü:', error);
            throw error;
        }
    }

    // ÂÖ•Âäõ„Éá„Éº„Çø„Ç∑„Éº„Éà‰ΩúÊàêÔºàÂÖ®È†ÖÁõÆÁ∂≤ÁæÖÁâàÔºâ
    async function addInputDataSheet(workbook) {
        console.log('ÂÖ•Âäõ„Éá„Éº„Çø„Ç∑„Éº„Éà„Çí‰ΩúÊàê‰∏≠...');
        
        const data = [];
        
        // „Éò„ÉÉ„ÉÄ„ÉºÊÉÖÂ†±
        data.push(['2Ê¨°ÂÖÉ„Éï„É¨„Éº„É†„ÅÆÊßãÈÄ†Ëß£ÊûêÁµêÊûú']);
        data.push(['ÁîüÊàêÊó•ÊôÇ', new Date().toLocaleString('ja-JP')]);
        data.push([]);
        
        try {
            const inputs = parseInputs();
            
            // --- 1. ÁØÄÁÇπ„Éá„Éº„Çø ---
            data.push(['‚ñ† ÁØÄÁÇπ„Éá„Éº„Çø']);
            data.push(['ÁØÄÁÇπÁï™Âè∑', 'XÂ∫ßÊ®ô(m)', 'YÂ∫ßÊ®ô(m)', 'Â¢ÉÁïåÊù°‰ª∂', 'Âº∑Âà∂Â§â‰ΩçX(mm)', 'Âº∑Âà∂Â§â‰ΩçY(mm)', 'Âº∑Âà∂ÂõûËª¢(rad)']);
            inputs.nodes.forEach((node, i) => {
                data.push([
                    i + 1, 
                    node.x, 
                    node.y, 
                    node.support,
                    (node.dx_forced * 1000) || 0,
                    (node.dy_forced * 1000) || 0,
                    node.r_forced || 0
                ]);
            });
            data.push([]);
            
            // --- 2. ÈÉ®Êùê„Éá„Éº„Çø ---
            data.push(['‚ñ† ÈÉ®Êùê„Éá„Éº„Çø']);
            // „Éò„ÉÉ„ÉÄ„ÉºË°å„Çí2ÊÆµÊßãÊàê„Å´„Åô„Çã„Å™„Å©„ÅÆÂ∑•Â§´„ÇÇÂèØËÉΩ„Åß„Åô„Åå„ÄÅ„Åì„Åì„Åß„ÅØ„Éï„É©„ÉÉ„Éà„Å´‰∏¶„Åπ„Åæ„Åô
            const memberHeader = [
                'ÈÉ®ÊùêÁï™Âè∑', 'iÁØÄÁÇπ', 'jÁØÄÁÇπ', 'Èï∑„Åï(m)', 'ÊùêÊñô', 'E(N/mm¬≤)', 'F(N/mm¬≤)', 
                'I(cm‚Å¥)', 'A(cm¬≤)', 'Z(cm¬≥)', 'Êñ≠Èù¢2Ê¨°ÂçäÂæÑ i(cm)', 'Â∫ßÂ±à‰øÇÊï∞K',
                'iÁ´ØÊé•Âêà', 'iÁ´ØKx(kN/mm)', 'iÁ´ØKy(kN/mm)', 'iÁ´ØKr(kN¬∑mm/rad)',
                'jÁ´ØÊé•Âêà', 'jÁ´ØKx(kN/mm)', 'jÁ´ØKy(kN/mm)', 'jÁ´ØKr(kN¬∑mm/rad)',
                'Êñ≠Èù¢ÂêçÁß∞', 'Ëª∏ÊñπÂêë'
            ];
            data.push(memberHeader);

            inputs.members.forEach((member, i) => {
                // „Éê„ÉçÊÉÖÂ†±„ÅÆÊï¥ÂΩ¢
                const formatSpring = (connType, springData, key) => {
                    if (connType !== 'spring' || !springData) return '-';
                    const rigidKey = `rigid${key}`; // rigidKx, rigidKy...
                    if (springData[rigidKey]) return 'Ââõ';
                    
                    // ÂÄ§„ÅÆÂèñÂæó„Å®Âçò‰ΩçË™øÊï¥
                    let val = springData[key] || 0;
                    // ÂÜÖÈÉ®Âçò‰Ωç„Åã„ÇâË°®Á§∫Âçò‰Ωç„Å∏Êàª„Åô (Kx,Ky: kN/m -> kN/mm, Kr: kN¬∑m -> kN¬∑mm)
                    if (key === 'Kr') {
                        val *= 1000; // kN¬∑m -> kN¬∑mm
                    } else {
                        val /= 1000; // kN/m -> kN/mm
                    }
                    
                    // 0„Å´Ëøë„ÅÑÂ†¥Âêà„ÅØ0Ë°®Á§∫
                    if (Math.abs(val) < 1e-6) return 0;
                    return parseFloat(val.toFixed(2));
                };

                // FÂÄ§„ÅÆÂèñÂæó
                let fVal = member.strengthProps?.value || member.F || '-';
                if (member.strengthProps?.type === 'wood-type') fVal = 'Êú®Êùê';

                    data.push([
                    i + 1, 
                    member.i + 1, 
                    member.j + 1, 
                    member.length.toFixed(3),
                    member.material || '‰∏çÊòé',
                    (member.E / 1000).toLocaleString(), // kN/mm2 -> N/mm2
                    fVal,
                    (member.I * 1e8).toFixed(2), // m4 -> cm4
                    (member.A * 1e4).toFixed(2), // m2 -> cm2
                    (member.Z * 1e6).toFixed(2), // m3 -> cm3
                    ((member.i_radius || member.ix || member.iy) ? ( (member.i_radius ? (member.i_radius*100) : (Math.min(member.ix||0, member.iy||0)) ) ).toFixed(2) : ''), // m -> cm
                    member.bucklingK || 'Ëá™Âãï',
                    
                    // iÁ´Ø
                    member.i_conn,
                    formatSpring(member.i_conn, member.spring_i, 'Kx'),
                    formatSpring(member.i_conn, member.spring_i, 'Ky'),
                    formatSpring(member.i_conn, member.spring_i, 'Kr'),
                    
                    // jÁ´Ø
                    member.j_conn,
                    formatSpring(member.j_conn, member.spring_j, 'Kx'),
                    formatSpring(member.j_conn, member.spring_j, 'Ky'),
                    formatSpring(member.j_conn, member.spring_j, 'Kr'),

                    member.sectionName || '-',
                    member.sectionAxisLabel || '-'
                ]);
            });
            data.push([]);
            
            // --- 3. Ëç∑Èáç„Éá„Éº„Çø ---
            if (inputs.nodeLoads && inputs.nodeLoads.length > 0) {
                data.push(['‚ñ† ÁØÄÁÇπËç∑Èáç„Éá„Éº„Çø']);
                data.push(['ÁØÄÁÇπÁï™Âè∑', 'Px(kN)', 'Py(kN)', 'Mz(kN¬∑m)']);
                inputs.nodeLoads.forEach(load => {
                    if (load.px !== 0 || load.py !== 0 || load.mz !== 0) {
                        data.push([load.nodeIndex + 1, load.px, load.py, load.mz]);
                    }
                });
                data.push([]);
            }
            
            if (inputs.memberLoads && inputs.memberLoads.length > 0) {
                data.push(['‚ñ† ÈÉ®ÊùêËç∑Èáç„Éá„Éº„Çø']);
                data.push(['ÈÉ®ÊùêÁï™Âè∑', 'Á≠âÂàÜÂ∏ÉËç∑Èáç w (kN/m)']);
                inputs.memberLoads.forEach(load => {
                    if (load.w !== 0) {
                        data.push([load.memberIndex + 1, load.w]);
                    }
                });
            }
            
        } catch (error) {
            console.error('ÂÖ•Âäõ„Éá„Éº„Çø„ÅÆËß£Êûê„Åß„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü:', error);
            data.push(['‚ÄªÂÖ•Âäõ„Éá„Éº„Çø„ÅÆËß£Êûê„Åß„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü: ' + error.message]);
        }
        
        const worksheet = XLSX.utils.aoa_to_sheet(data);
        
        // ÂàóÂπÖ„ÅÆË™øÊï¥ (Ë¶ñË™çÊÄßÂêë‰∏ä„ÅÆ„Åü„ÇÅ)
        const wscols = [
            {wch: 10}, // A
            {wch: 10}, // B
            {wch: 10}, // C
            {wch: 10}, // D
            {wch: 15}, // E (ÊùêÊñô)
            {wch: 12}, // F (E)
            {wch: 12}, // G (F)
            {wch: 10}, // H (I)
            {wch: 10}, // I (A)
            {wch: 10}, // J (Z)
            {wch: 10}, // K (i radius)
            {wch: 10}, // L (Â∫ßÂ±àK)
            {wch: 10}, // L (iÁ´Ø)
            {wch: 12}, // M (iKx)
            {wch: 12}, // N (iKy)
            {wch: 12}, // O (iKr)
            {wch: 10}, // P (jÁ´Ø)
            {wch: 12}, // Q (jKx)
            {wch: 12}, // R (jKy)
            {wch: 12}, // S (jKr)
            {wch: 20}, // T (Êñ≠Èù¢Âêç)
            {wch: 10}  // U (Ëª∏)
        ];
        worksheet['!cols'] = wscols;

        XLSX.utils.book_append_sheet(workbook, worksheet, 'ÂÖ•Âäõ„Éá„Éº„Çø');
    }

    // Ëß£ÊûêÁµêÊûú„Ç∑„Éº„Éà‰ΩúÊàê
    async function addAnalysisResultSheet(workbook) {
        console.log('Ëß£ÊûêÁµêÊûú„Ç∑„Éº„Éà„Çí‰ΩúÊàê‰∏≠...');
        
        const data = [];
        data.push(['‚ñ† Ëß£ÊûêÁµêÊûú']);
        data.push([]);
        
        if (lastAnalysisResult && lastAnalysisResult.displacements && lastAnalysisResult.displacements.length > 0) {
            data.push(['‚ñ† ÁØÄÁÇπÂ§â‰ΩçÁµêÊûú']);
            data.push(['ÁØÄÁÇπÁï™Âè∑', 'XÂ§â‰Ωç(mm)', 'YÂ§â‰Ωç(mm)', 'ÂõûËª¢(rad)']);
            lastAnalysisResult.displacements.forEach((disp, i) => {
                data.push([i + 1, (disp.x * 1000).toFixed(3), (disp.y * 1000).toFixed(3), disp.rotation.toFixed(6)]);
            });
            data.push([]);
        } else {
            data.push(['‚Äª ÁØÄÁÇπÂ§â‰ΩçÁµêÊûú„Åå„ÅÇ„Çä„Åæ„Åõ„Çì']);
            data.push([]);
        }
        
        if (lastAnalysisResult && lastAnalysisResult.forces && lastAnalysisResult.forces.length > 0) {
            data.push(['‚ñ† ÈÉ®ÊùêÂäõÁµêÊûú']);
            data.push(['ÈÉ®ÊùêÁï™Âè∑', 'iÁ´ØËª∏Âäõ(kN)', 'iÁ´Ø„Åõ„ÇìÊñ≠Âäõ(kN)', 'iÁ´ØÊõ≤„Åí„É¢„Éº„É°„É≥„Éà(kN¬∑m)', 'jÁ´ØËª∏Âäõ(kN)', 'jÁ´Ø„Åõ„ÇìÊñ≠Âäõ(kN)', 'jÁ´ØÊõ≤„Åí„É¢„Éº„É°„É≥„Éà(kN¬∑m)']);
            lastAnalysisResult.forces.forEach((force, i) => {
                data.push([
                    i + 1, 
                    force.i.N.toFixed(2), 
                    force.i.Q.toFixed(2), 
                    force.i.M.toFixed(2),
                    force.j.N.toFixed(2), 
                    force.j.Q.toFixed(2), 
                    force.j.M.toFixed(2)
                ]);
            });
        } else {
            data.push(['‚Äª ÈÉ®ÊùêÂäõÁµêÊûú„Åå„ÅÇ„Çä„Åæ„Åõ„Çì']);
        }
        
        const worksheet = XLSX.utils.aoa_to_sheet(data);
        XLSX.utils.book_append_sheet(workbook, worksheet, 'Ëß£ÊûêÁµêÊûú');
    }

    // Êñ≠Èù¢Ê§úÂÆöÁµêÊûú„Ç∑„Éº„Éà‰ΩúÊàê
    async function addSectionCheckSheet(workbook) {
        console.log('Êñ≠Èù¢Ê§úÂÆöÁµêÊûú„Ç∑„Éº„Éà„Çí‰ΩúÊàê‰∏≠...');
        
        const data = [];
        data.push(['‚ñ† Êñ≠Èù¢Ê§úÂÆöÁµêÊûú']);
        data.push([]);
        data.push(['ÈÉ®ÊùêÁï™Âè∑', 'Ëª∏Âäõ(kN)', 'Êõ≤„Åí„É¢„Éº„É°„É≥„Éà(kN¬∑m)', 'Ê§úÂÆöÈ†ÖÁõÆ', 'Ê§úÂÆöÊØî', 'Âà§ÂÆö', 'ÊùêÊñôÊÉÖÂ†±', 'Ë©≥Á¥∞Ë®àÁÆóÁµêÊûú']);
        
        // ÂÑ™ÂÖàÈ†Ü‰Ωç: lastAnalysisResult.sectionCheckResults > lastSectionCheckResults
        const sectionResults = (lastAnalysisResult && lastAnalysisResult.sectionCheckResults) || lastSectionCheckResults;
        
        if (sectionResults && sectionResults.length > 0) {
            sectionResults.forEach((result, i) => {
                // Ê§úÂÆöÊØî„ÅÆË°®Á§∫
                let ratioText = '-';
                if (typeof result.maxRatio === 'number' && isFinite(result.maxRatio)) {
                    ratioText = result.maxRatio.toFixed(3);
                } else if (result.maxRatio) {
                    ratioText = result.maxRatio.toString();
                }
                
                // Âà§ÂÆö
                let judgment = '-';
                if (result.status) {
                    judgment = result.status === 'NG' ? 'NG' : 'OK';
                } else if (typeof result.maxRatio === 'number') {
                    judgment = result.maxRatio <= 1.0 ? 'OK' : 'NG';
                }
                
                // ÊùêÊñôÊÉÖÂ†±„ÅÆÂèñÂæóÔºàÂºæÊÄß‰øÇÊï∞„Åã„ÇâÊùêÊñôÂêç„ÇíÂèñÂæóÔºâ
                let materialInfo = '';
                if (lastAnalysisResult && lastAnalysisResult.members && lastAnalysisResult.members[i]) {
                    const member = lastAnalysisResult.members[i];
                    
                    // ÂºæÊÄß‰øÇÊï∞„Åã„ÇâÊùêÊñôÂêç„ÇíÂèñÂæó
                    const getMaterialNameFromE = (eValue) => {
                        const materials = { 
                            "205000000": "„Çπ„ÉÅ„Éº„É´", 
                            "193000000": "„Çπ„ÉÜ„É≥„É¨„Çπ", 
                            "70000000": "„Ç¢„É´„Éü„Éã„Ç¶„É†", 
                            "7000000": "Êú®Êùê", 
                            "8000000": "Êú®Êùê", 
                            "9000000": "Êú®Êùê", 
                            "10000000": "Êú®Êùê" 
                        };
                        const eStr = Math.round(eValue).toString();
                        return materials[eStr] || `‰ªªÊÑèÊùêÊñô(E=${(eValue/1000000).toLocaleString()}GPa)`;
                    };
                    
                    if (member.E) {
                        const materialName = getMaterialNameFromE(member.E);
                        if (member.strengthProps && member.strengthProps.value) {
                            materialInfo = `${materialName} (F=${member.strengthProps.value})`;
                        } else {
                            materialInfo = materialName;
                        }
                    } else if (member.strengthProps) {
                        materialInfo = `${member.strengthProps.type}: ${member.strengthProps.value}`;
                    } else if (member.material) {
                        materialInfo = member.material;
                    }
                }
                
                // Ë©≥Á¥∞Ë®àÁÆóÁµêÊûú„ÅÆ‰ΩúÊàê
                let detailResults = '';
                if (result.details) {
                    detailResults = result.details;
                } else if (result.ratios && result.ratios.length > 0) {
                    // ÂøúÂäõÂ∫¶„Å®Ë®±ÂÆπÂøúÂäõÂ∫¶„ÅÆË©≥Á¥∞
                    const details = [];
                    if (result.œÉt !== undefined && result.ft !== undefined) {
                        details.push(`ÂºïÂºµ: œÉt=${result.œÉt?.toFixed(2) || 0} ‚â§ ft=${result.ft?.toFixed(2) || 0} (${(result.œÉt/result.ft)?.toFixed(3) || 0})`);
                    }
                    if (result.œÉc !== undefined && result.fc !== undefined) {
                        details.push(`ÂúßÁ∏Æ: œÉc=${result.œÉc?.toFixed(2) || 0} ‚â§ fc=${result.fc?.toFixed(2) || 0} (${(result.œÉc/result.fc)?.toFixed(3) || 0})`);
                    }
                    if (result.œÉb !== undefined && result.fb !== undefined) {
                        details.push(`Êõ≤„Åí: œÉb=${result.œÉb?.toFixed(2) || 0} ‚â§ fb=${result.fb?.toFixed(2) || 0} (${(result.œÉb/result.fb)?.toFixed(3) || 0})`);
                    }
                    if (result.œÑ !== undefined && result.fs !== undefined) {
                        details.push(`„Åõ„ÇìÊñ≠: œÑ=${result.œÑ?.toFixed(2) || 0} ‚â§ fs=${result.fs?.toFixed(2) || 0} (${(result.œÑ/result.fs)?.toFixed(3) || 0})`);
                    }
                    
                    if (details.length > 0) {
                        detailResults = details.join('; ');
                    } else if (lastAnalysisResult && lastAnalysisResult.members && lastAnalysisResult.members[i]) {
                        const member = lastAnalysisResult.members[i];
                        const N = result.N || 0;
                        const M = result.M || 0;
                        const A = member.A || 1;
                        const Z = member.Z || 1;
                        
                        const œÉ_axial = Math.abs(N * 1000 / (A * 1e6)); // N/mm¬≤
                        const œÉ_bending = Math.abs(M * 1e6 / (Z * 1e9)); // N/mm¬≤
                        const œÉ_combined = œÉ_axial + œÉ_bending;
                        
                        detailResults = `Ëª∏ÂøúÂäõÂ∫¶: ${œÉ_axial.toFixed(2)} N/mm¬≤; Êõ≤„ÅíÂøúÂäõÂ∫¶: ${œÉ_bending.toFixed(2)} N/mm¬≤; ÂêàÊàê: ${œÉ_combined.toFixed(2)} N/mm¬≤`;
                    }
                }
                
                data.push([
                    i + 1,
                    (result.N || 0).toFixed(2),
                    (result.M || 0).toFixed(2),
                    result.checkType || '‰∏çÊòé',
                    ratioText,
                    judgment,
                    materialInfo || '‰∏çÊòé',
                    detailResults || '-'
                ]);
            });

            // „Åü„Çè„ÅøÂà∂ÈôêÊ§úÂÆöÁµêÊûú„ÇíËøΩÂä†
            data.push([]);
            data.push(['‚ñ† „Åü„Çè„ÅøÂà∂ÈôêÊ§úÂÆöÁµêÊûú']);
            data.push([]);

            const deflSettings = (lastAnalysisResult && lastAnalysisResult.deflectionCheckSettings)
                ? lastAnalysisResult.deflectionCheckSettings
                : (window.settings?.deflectionCheck || { amplificationFactor: 1.0, allowableDeflectionMm: 0, spanRatio: 200 });

            data.push(['Ë®≠ÂÆö', 'ÂÄ§', 'Âçò‰Ωç', 'ÂÇôËÄÉ']);
            data.push(['Â§âÂΩ¢Â¢óÂ§ß‰øÇÊï∞', Number(deflSettings.amplificationFactor ?? 1.0), '', '']);
            data.push(['Ë®±ÂÆπ„Åü„Çè„Åø', Number(deflSettings.allowableDeflectionMm ?? 0), 'mm', '0=„Çπ„Éë„É≥ÊØî„Çí‰ΩøÁî®']);
            data.push(['„Çπ„Éë„É≥ÊØî', `L/${Number(deflSettings.spanRatio ?? 200)}`, '', '']);
            data.push([]);

            data.push(['ÈÉ®ÊùêÁï™Âè∑', '„Çπ„Éë„É≥L(m)', 'ÊúÄÂ§ß„Åü„Çè„Åø(mm)', 'Â¢óÂ§ßÂæå(mm)', 'Ë®±ÂÆπ„Åü„Çè„Åø(mm)', '„Çπ„Éë„É≥ÊØî L/Œ¥', 'Ê§úÂÆöÊØî', 'Âà§ÂÆö']);
            const deflResults = (lastAnalysisResult && lastAnalysisResult.deflectionCheckResults) || lastDeflectionCheckResults;
            if (deflResults && deflResults.length > 0) {
                deflResults.forEach((r) => {
                    const spanRatioText = (typeof r.actualSpanRatio === 'number' && isFinite(r.actualSpanRatio)) ? r.actualSpanRatio.toFixed(1) : '‚àû';
                    const ratioText2 = (typeof r.ratio === 'number' && isFinite(r.ratio)) ? r.ratio.toFixed(3) : '-';
                    data.push([
                        (r.memberIndex ?? 0) + 1,
                        (r.length ?? 0).toFixed(3),
                        (r.maxDeflectionMm ?? 0).toFixed(3),
                        (r.amplifiedDeflectionMm ?? 0).toFixed(3),
                        (r.allowableMm ?? 0).toFixed(3),
                        spanRatioText,
                        ratioText2,
                        r.status || '-'
                    ]);
                });
            } else {
                data.push(['‚Äª „Åü„Çè„ÅøÂà∂ÈôêÊ§úÂÆöÁµêÊûú„Åå„ÅÇ„Çä„Åæ„Åõ„Çì']);
            }
            
            // Ê®™Â∫ßÂ±àÔºàÊõ≤„ÅíÊùêÔºâÊ§úÂÆöÁµêÊûú„ÇíËøΩÂä†
            data.push([]);
            data.push(['‚ñ† Ê®™Â∫ßÂ±àÔºàÊõ≤„ÅíÊùêÔºâÊ§úÂÆöÁµêÊûú']);
            data.push([]);

            const ltbSettings = (lastAnalysisResult && lastAnalysisResult.ltbCheckSettings)
                ? lastAnalysisResult.ltbCheckSettings
                : (window.settings?.ltbCheck || { unbracedLengthFactor: 1.0, cb: 1.0, nu: 0.30 });

            data.push(['Ë®≠ÂÆö', 'ÂÄ§', 'Âçò‰Ωç', 'ÂÇôËÄÉ']);
            data.push(['Lb/L ‰øÇÊï∞', Number(ltbSettings.unbracedLengthFactor ?? 1.0), '', 'Lb = ‰øÇÊï∞ √ó L']);
            data.push(['Cb', Number(ltbSettings.cb ?? 1.0), '', '„É¢„Éº„É°„É≥„ÉàÂãæÈÖç‰øÇÊï∞ÔºàÁ∞°ÊòìÂÖ•ÂäõÔºâ']);
            data.push(['„Éù„Ç¢„ÇΩ„É≥ÊØî ŒΩ', Number(ltbSettings.nu ?? 0.30), '', 'G=E/(2(1+ŒΩ))']);
            data.push([]);

            data.push(['ÈÉ®ÊùêÁï™Âè∑', 'L(m)', 'Lb(m)', 'Ëç∑Èáç', '‰øÇÊï∞', 'fbÂü∫Ê∫ñ(N/mm¬≤)', '|M|max(kN¬∑m)', 'Mcr(kN¬∑m)', 'œÉb(N/mm¬≤)', 'fb(Ê®™Â∫ßÂ±à)(N/mm¬≤)', 'Ê§úÂÆöÊØî', 'Âà§ÂÆö', 'ÂÇôËÄÉ']);
            const ltbResults = (lastAnalysisResult && lastAnalysisResult.ltbCheckResults) || lastLtbCheckResults;
            if (ltbResults && ltbResults.length > 0) {
                ltbResults.forEach((r) => {
                    const ratioText2 = (typeof r.ratio === 'number' && isFinite(r.ratio)) ? r.ratio.toFixed(3) : '-';
                    const loadTermText = (r.loadTerm === 'long') ? 'Èï∑Êúü' : (r.loadTerm === 'short' ? 'Áü≠Êúü' : '-');
                    const factorText = (typeof r.allowableFactor === 'number' && isFinite(r.allowableFactor)) ? r.allowableFactor.toFixed(2) : '-';
                    const fbBaseText = (typeof r.fb_base === 'number' && isFinite(r.fb_base)) ? r.fb_base.toFixed(3) : '-';
                    data.push([
                        (r.memberIndex ?? 0) + 1,
                        (typeof r.L === 'number' && isFinite(r.L)) ? r.L.toFixed(3) : '-',
                        (typeof r.Lb === 'number' && isFinite(r.Lb)) ? r.Lb.toFixed(3) : '-',
                        loadTermText,
                        factorText,
                        fbBaseText,
                        (typeof r.Mmax === 'number' && isFinite(r.Mmax)) ? r.Mmax.toFixed(3) : '-',
                        (typeof r.Mcr === 'number' && isFinite(r.Mcr)) ? r.Mcr.toFixed(3) : '-',
                        (typeof r.sigma_b === 'number' && isFinite(r.sigma_b)) ? r.sigma_b.toFixed(3) : (r.message || '-'),
                        (typeof r.fb_allow === 'number' && isFinite(r.fb_allow)) ? r.fb_allow.toFixed(3) : '-',
                        ratioText2,
                        r.status || '-',
                        r.message || ''
                    ]);
                });
            } else {
                data.push(['‚Äª Ê®™Â∫ßÂ±àÔºàÊõ≤„ÅíÊùêÔºâÊ§úÂÆöÁµêÊûú„Åå„ÅÇ„Çä„Åæ„Åõ„Çì']);
            }

            // ÂêÑÈÉ®Êùê„ÅÆË©≥Á¥∞ÂøúÂäõÂ∫¶Ë®àÁÆóÁµêÊûú„ÇíËøΩÂä†
            data.push([]);
            data.push(['‚ñ† ÂêÑÈÉ®Êùê„ÅÆË©≥Á¥∞ÂøúÂäõÂ∫¶Ë®àÁÆóÁµêÊûú']);
            data.push([]);
            
            // Ë®àÁÆó„Å´ÂøÖË¶Å„Å™„Éá„Éº„Çø„ÇíÂèñÂæó
            if (lastResults) {
                const { members, forces, memberLoads } = lastResults;
                const selectedTerm = document.querySelector('input[name="load-term"]:checked')?.value || 'short';
                
                sectionResults.forEach((result, memberIndex) => {
                    const member = members[memberIndex];
                    const force = forces[memberIndex];
                    const load = memberLoads.find(l => l.memberIndex === memberIndex);
                    const w = load ? load.w : 0;
                    const L = member.length;
                    
                    // ÊùêÊñôÁâπÊÄß„ÅÆÂèñÂæó
                    const { strengthProps, A, Z, ix, iy, E } = member;
                    let materialInfo = '';
                    let allowableStresses = { ft: 0, fc: 0, fb: 0, fs: 0 };
                    
                    // ÂºæÊÄß‰øÇÊï∞„Åã„ÇâÊùêÊñôÂêç„ÇíÂèñÂæó„Åô„ÇãÈñ¢Êï∞
                    const getMaterialNameFromE_Detail = (eValue) => {
                        const materials = { 
                            "205000000": "„Çπ„ÉÅ„Éº„É´", 
                            "193000000": "„Çπ„ÉÜ„É≥„É¨„Çπ", 
                            "70000000": "„Ç¢„É´„Éü„Éã„Ç¶„É†", 
                            "7000000": "Êú®Êùê", 
                            "8000000": "Êú®Êùê", 
                            "9000000": "Êú®Êùê", 
                            "10000000": "Êú®Êùê" 
                        };
                        const eStr = Math.round(eValue).toString();
                        return materials[eStr] || `‰ªªÊÑèÊùêÊñô(E=${(eValue/1000000).toLocaleString()}GPa)`;
                    };
                    
                    const termIndex = (selectedTerm === 'long') ? 0 : 1;
                    
                    switch(strengthProps.type) {
                        case 'F-value':
                        case 'F-stainless':
                        case 'F-aluminum':
                            const F = strengthProps.value;
                            const factor = (selectedTerm === 'long') ? 1.5 : 1.0;
                            const materialName = getMaterialNameFromE_Detail(E);
                            materialInfo = `${materialName} (F=${F} N/mm¬≤)`;
                            allowableStresses.ft = F / factor;
                            allowableStresses.fb = F / factor;
                            allowableStresses.fs = F / (factor * Math.sqrt(3));
                            
                            // Â∫ßÂ±à„ÇíËÄÉÊÖÆ„Åó„ÅüÂúßÁ∏ÆË®±ÂÆπÂøúÂäõÂ∫¶
                            const lk = L, i_min = Math.min(ix, iy);
                            allowableStresses.fc = allowableStresses.ft;
                            if (i_min > 1e-9) {
                                const lambda = lk / i_min, E_n_mm2 = E * 1e-3;
                                const lambda_p = Math.PI * Math.sqrt(E_n_mm2 / (0.6 * F));
                                if (lambda <= lambda_p) {
                                    allowableStresses.fc = (1 - 0.4 * (lambda / lambda_p)**2) * F / factor;
                                } else {
                                    allowableStresses.fc = (0.277 * F) / ((lambda / lambda_p)**2);
                                }
                            }
                            break;
                        case 'wood-type':
                            const woodPreset = strengthProps.preset;
                            const woodMaterialName = getMaterialNameFromE_Detail(E);
                            if (woodPreset === 'custom') {
                                materialInfo = `${woodMaterialName} (‰ªªÊÑèÂÖ•Âäõ)`;
                                const customShortStresses = strengthProps.stresses;
                                if (selectedTerm === 'long') {
                                    allowableStresses.ft = customShortStresses.ft * 1.1 / 2;
                                    allowableStresses.fc = customShortStresses.fc * 1.1 / 2;
                                    allowableStresses.fb = customShortStresses.fb * 1.1 / 2;
                                    allowableStresses.fs = customShortStresses.fs * 1.1 / 2;
                                } else {
                                    allowableStresses.ft = customShortStresses.ft;
                                    allowableStresses.fc = customShortStresses.fc;
                                    allowableStresses.fb = customShortStresses.fb;
                                    allowableStresses.fs = customShortStresses.fs;
                                }
                            } else {
                                const baseStresses = WOOD_BASE_STRENGTH_DATA[woodPreset];
                                materialInfo = `${woodMaterialName} (${baseStresses.name})`;
                                const factor = (selectedTerm === 'long') ? (1.1 / 3) : (2 / 3);
                                allowableStresses.ft = baseStresses.ft * factor;
                                allowableStresses.fc = baseStresses.fc * factor;
                                allowableStresses.fb = baseStresses.fb * factor;
                                allowableStresses.fs = baseStresses.fs * factor;
                            }
                            break;
                        default:
                            const defaultMaterialName = getMaterialNameFromE_Detail(E);
                            materialInfo = defaultMaterialName;
                    }
                    
                    // ÈÉ®Êùê„ÅÆË©≥Á¥∞ÊÉÖÂ†±„ÇíÂá∫Âäõ
                    data.push([`ÈÉ®Êùê ${memberIndex + 1} „ÅÆË©≥Á¥∞Ë®àÁÆó`]);
                    data.push([]);
                    data.push(['È†ÖÁõÆ', 'ÂÄ§', 'Âçò‰Ωç', 'ÂÇôËÄÉ']);
                    
                    // ÈÉ®ÊùêÊÉÖÂ†±
                    data.push(['ÊùêÊñô', materialInfo, '', '']);
                    data.push(['ÈÉ®ÊùêÈï∑', L.toFixed(3), 'm', '']);
                    data.push(['Êñ≠Èù¢Á©ç A', (A * 1e4).toFixed(2), 'cm¬≤', '']);
                    data.push(['Êñ≠Èù¢‰øÇÊï∞ Z', (Z * 1e6).toFixed(2), 'cm¬≥', '']);
                    data.push(['ÂõûËª¢ÂçäÂæÑ ix', (ix * 1e2).toFixed(2), 'cm', '']);
                    data.push(['ÂõûËª¢ÂçäÂæÑ iy', (iy * 1e2).toFixed(2), 'cm', '']);
                    if (w !== 0) data.push(['Á≠âÂàÜÂ∏ÉËç∑Èáç', w, 'kN/m', '']);
                    data.push([]);
                    
                    // Ë®±ÂÆπÂøúÂäõÂ∫¶
                    data.push(['Ë®±ÂÆπÂøúÂäõÂ∫¶', `(${selectedTerm === 'long' ? 'Èï∑Êúü' : 'Áü≠Êúü'})`, '', '']);
                    data.push(['ÂºïÂºµË®±ÂÆπÂøúÂäõÂ∫¶ ft', allowableStresses.ft.toFixed(2), 'N/mm¬≤', '']);
                    data.push(['ÂúßÁ∏ÆË®±ÂÆπÂøúÂäõÂ∫¶ fc', allowableStresses.fc.toFixed(2), 'N/mm¬≤', '']);
                    data.push(['Êõ≤„ÅíË®±ÂÆπÂøúÂäõÂ∫¶ fb', allowableStresses.fb.toFixed(2), 'N/mm¬≤', '']);
                    data.push(['„Åõ„ÇìÊñ≠Ë®±ÂÆπÂøúÂäõÂ∫¶ fs', allowableStresses.fs.toFixed(2), 'N/mm¬≤', '']);
                    data.push([]);
                    
                    // ÈÉ®ÊùêÁ´ØÂäõ
                    data.push(['ÈÉ®ÊùêÁ´ØÂäõ']);
                    data.push(['iÁ´Ø Ëª∏Âäõ', (-force.N_i).toFixed(2), 'kN', '']);
                    data.push(['iÁ´Ø „Åõ„ÇìÊñ≠Âäõ', force.Q_i.toFixed(2), 'kN', '']);
                    data.push(['iÁ´Ø Êõ≤„Åí„É¢„Éº„É°„É≥„Éà', force.M_i.toFixed(2), 'kN¬∑m', '']);
                    data.push(['jÁ´Ø Ëª∏Âäõ', force.N_j.toFixed(2), 'kN', '']);
                    data.push(['jÁ´Ø „Åõ„ÇìÊñ≠Âäõ', (-force.Q_j).toFixed(2), 'kN', '']);
                    data.push(['jÁ´Ø Êõ≤„Åí„É¢„Éº„É°„É≥„Éà', force.M_j.toFixed(2), 'kN¬∑m', '']);
                    data.push([]);
                    
                    // ÂøúÂäõÂ∫¶Ë®àÁÆóÁµêÊûúÔºà21ÁÇπ„Åß„ÅÆË©≥Á¥∞Ë®àÁÆóÔºâ
                    data.push(['‰ΩçÁΩÆÂà•ÂøúÂäõÂ∫¶Ë®àÁÆóÁµêÊûú']);
                    data.push(['‰ΩçÁΩÆ(m)', 'Ëª∏Âäõ(kN)', '„É¢„Éº„É°„É≥„Éà(kN¬∑m)', 'Ëª∏ÂøúÂäõÂ∫¶(N/mm¬≤)', 'Êõ≤„ÅíÂøúÂäõÂ∫¶(N/mm¬≤)', 'ÂêàÊàêÂøúÂäõÂ∫¶(N/mm¬≤)', 'Ê§úÂÆöÊØî']);
                    
                    const numPoints = result.ratios ? result.ratios.length : 21;
                    for (let k = 0; k < numPoints; k++) {
                        const x = (k / (numPoints - 1)) * L;
                        
                        // Ëª∏ÂäõÔºà‰∏ÄÂÆöÔºâ
                        const N = Math.abs(-force.N_i);
                        
                        // „É¢„Éº„É°„É≥„Éà„ÅÆË®àÁÆó
                        let M;
                        if (w !== 0) {
                            M = Math.abs(force.M_i + force.Q_i * x - 0.5 * w * x**2);
                        } else {
                            M = Math.abs(force.M_i + force.Q_i * x);
                        }
                        
                        // ÂøúÂäõÂ∫¶Ë®àÁÆó
                        const sigma_axial = N * 1000 / (A * 1e6);
                        const sigma_bending = M * 1e6 / (Z * 1e9);
                        const sigma_combined = sigma_axial + sigma_bending;
                        
                        // Ê§úÂÆöÊØîË®àÁÆó
                        let checkRatio = 0;
                        if (N >= 0) { // ÂºïÂºµ
                            checkRatio = sigma_combined / allowableStresses.ft;
                        } else { // ÂúßÁ∏Æ
                            checkRatio = sigma_combined / allowableStresses.fc;
                        }
                        
                        data.push([
                            x.toFixed(3),
                            N.toFixed(2),
                            M.toFixed(2),
                            sigma_axial.toFixed(2),
                            sigma_bending.toFixed(2),
                            sigma_combined.toFixed(2),
                            (result.ratios ? result.ratios[k] : checkRatio).toFixed(3)
                        ]);
                    }
                    data.push([]);
                });
            }
            
        } else {
            data.push(['‚Äª Êñ≠Èù¢Ê§úÂÆöÁµêÊûú„Åå„ÅÇ„Çä„Åæ„Åõ„Çì']);
            data.push(['‚Äª „ÄåË®àÁÆóÂÆüË°å & „Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥Ë°®Á§∫„Äç„Éú„Çø„É≥„ÅßËß£Êûê„ÇíÂÆüË°å„Åó„Å¶„Åã„ÇâÂá∫Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ']);
        }
        
        const worksheet = XLSX.utils.aoa_to_sheet(data);
        XLSX.utils.book_append_sheet(workbook, worksheet, 'Êñ≠Èù¢Ê§úÂÆöÁµêÊûú');
    }

    // Â∫ßÂ±àËß£ÊûêÁµêÊûú„Ç∑„Éº„Éà‰ΩúÊàê
    async function addBucklingAnalysisSheet(workbook) {
        console.log('Â∫ßÂ±àËß£ÊûêÁµêÊûú„Ç∑„Éº„Éà„Çí‰ΩúÊàê‰∏≠...');
        console.log('Â∫ßÂ±àËß£ÊûêÁµêÊûú„Éá„Éº„Çø:', lastBucklingResults);
        
        const data = [];
        data.push(['‚ñ† Â∫ßÂ±àËß£ÊûêÁµêÊûú']);
        data.push([]);
        
        if (lastBucklingResults && lastBucklingResults.length > 0) {
            data.push(['ÈÉ®ÊùêÁï™Âè∑', 'Ëª∏Âäõ(kN)', 'Â∫ßÂ±àÈï∑„Åï(m)', 'Â∫ßÂ±àËç∑Èáç(kN)', 'ÂÆâÂÖ®Áéá', 'Âà§ÂÆö', 'Á¥∞Èï∑ÊØî', 'Â∫ßÂ±à„É¢„Éº„Éâ', 'ÁêÜË´ñÁöÑËÉåÊôØ']);
            
            // „Éò„É´„Éë„Éº: ÂÆâÂÖ®ÁéáÁ≠â„ÇíÂÆâÂÖ®„Å´Êï∞ÂÄ§Âåñ„Åô„Çã
            const toNum = (v) => (v !== undefined && v !== null && !isNaN(Number(v))) ? Number(v) : null;

            lastBucklingResults.forEach((result, i) => {
                // Âà§ÂÆöÔºàÂÆâÂÖ®„Å´Êï∞ÂÄ§Âåñ„Åó„Å¶„Åã„ÇâÊØîËºÉÔºâ
                let judgment = '-';
                const sf = toNum(result.safetyFactor);
                if (sf !== null) {
                    if (sf >= 2.0) judgment = 'OK';
                    else if (sf >= 1.0) judgment = 'Ë¶ÅÊ≥®ÊÑè';
                    else judgment = 'NG';
                }
                
                // Â∫ßÂ±à„É¢„Éº„Éâ„ÅÆÊ±∫ÂÆö
                let bucklingMode = '-';
                if (result.slendernessRatio < 50) {
                    bucklingMode = 'Áü≠Êü±ÔºàÂ±ÄÈÉ®Â∫ßÂ±àÔºâ';
                } else if (result.slendernessRatio < 200) {
                    bucklingMode = '‰∏≠ÈñìÊü±ÔºàÂÖ®‰ΩìÂ∫ßÂ±àÔºâ';
                } else {
                    bucklingMode = 'Èï∑Êü±Ôºà„Ç™„Ç§„É©„ÉºÂ∫ßÂ±àÔºâ';
                }
                
                // ÁêÜË´ñÁöÑËÉåÊôØ
                const bucklingFactor = result.bucklingLengthFactor !== undefined ? result.bucklingLengthFactor : '-';
                const theory = `„Ç™„Ç§„É©„ÉºÂ∫ßÂ±àÁêÜË´ñ: P_cr = œÄ¬≤EI/(lk)¬≤, Â∫ßÂ±àÈï∑„Åï‰øÇÊï∞k=${bucklingFactor}`;
                
                    const axialForceStr = (toNum(result.axialForce) !== null) ? toNum(result.axialForce).toFixed(2) : '-';
                    const bucklingLengthStr = (toNum(result.bucklingLength) !== null) ? toNum(result.bucklingLength).toFixed(3) : '-';
                    const bucklingLoadStr = (toNum(result.bucklingLoad) !== null) ? toNum(result.bucklingLoad).toFixed(2) : '-';
                    const safetyFactorStr = (sf !== null) ? sf.toFixed(2) : '-';
                    const slendernessStr = (toNum(result.slendernessRatio) !== null) ? Math.round(toNum(result.slendernessRatio)) : '-';

                    data.push([
                        i + 1,
                        axialForceStr,
                        bucklingLengthStr,
                        bucklingLoadStr,
                        safetyFactorStr,
                        judgment,
                        slendernessStr,
                        bucklingMode,
                        theory
                    ]);
            });
            
            data.push([]);
            data.push(['‚ñ† Â∫ßÂ±àËß£Êûê„ÅÆË©≥Á¥∞Ë®àÁÆóÈÅéÁ®ã']);
            data.push([]);
            
            lastBucklingResults.forEach((result, i) => {
                // Âà§ÂÆö„ÇíÂÜçË®àÁÆóÔºàË©≥Á¥∞Ë®àÁÆóÈÅéÁ®ãÁî®Ôºâ ‚Äî ÂÆâÂÖ®„Å´Êï∞ÂÄ§Âåñ„Åó„Å¶„Åã„ÇâÂà§ÂÆö
                const sf_detail = toNum(result.safetyFactor);
                let detailJudgment = '-';
                if (sf_detail !== null) {
                    if (sf_detail >= 2.0) detailJudgment = 'OK';
                    else if (sf_detail >= 1.0) detailJudgment = 'Ë¶ÅÊ≥®ÊÑè';
                    else detailJudgment = 'NG';
                }
                
                data.push([`ÈÉ®Êùê ${i + 1} „ÅÆË©≥Á¥∞Ë®àÁÆó`]);
                data.push(['Ë®àÁÆóÈ†ÖÁõÆ', 'ÂÄ§', 'Âçò‰Ωç', 'Âºè„ÉªÂÇôËÄÉ']);
                data.push(['Ëª∏Âäõ P', result.axialForce !== undefined ? result.axialForce.toFixed(2) : '-', 'kN', 'Ë≤†„ÅÆÂÄ§„ÅåÂúßÁ∏Æ„ÄÅÊ≠£„ÅÆÂÄ§„ÅåÂºïÂºµ']);
                data.push(['ÈÉ®ÊùêÈï∑ L', result.memberLength !== undefined ? result.memberLength.toFixed(3) : '-', 'm', '']);
                data.push(['Â∫ßÂ±àÈï∑„Åï lk', result.bucklingLength !== undefined ? result.bucklingLength.toFixed(3) : '-', 'm', 'lk = k √ó L']);
                data.push(['Êñ≠Èù¢‰∫åÊ¨°„É¢„Éº„É°„É≥„Éà I', result.momentOfInertia !== undefined ? (result.momentOfInertia * 1e12).toFixed(2) : '-', 'mm‚Å¥', '']);
                data.push(['ÂõûËª¢ÂçäÂæÑ i', result.radiusOfGyration !== undefined ? (result.radiusOfGyration * 1e3).toFixed(2) : '-', 'mm', 'i = ‚àö(I/A)']);
                data.push(['Á¥∞Èï∑ÊØî Œª', result.slendernessRatio !== undefined ? Math.round(result.slendernessRatio) : '-', '', 'Œª = lk/i']);
                data.push(['ÂºæÊÄß‰øÇÊï∞ E', result.elasticModulus !== undefined ? (result.elasticModulus / 1000).toFixed(0) : '-', 'GPa', '']);
                data.push(['„Ç™„Ç§„É©„ÉºÂ∫ßÂ±àËç∑Èáç P_cr', result.bucklingLoad !== undefined ? result.bucklingLoad.toFixed(2) : '-', 'kN', 'P_cr = œÄ¬≤EI/(lk)¬≤']);
                data.push(['Â∫ßÂ±àÈï∑„Åï‰øÇÊï∞ k', toNum(result.bucklingLengthFactor) !== null ? toNum(result.bucklingLengthFactor).toFixed(1) : '-', '', 'Á´ØÈÉ®Êù°‰ª∂„Å´„Çà„Çã']);
                data.push(['ÂÆâÂÖ®Áéá SF', sf_detail !== null ? sf_detail.toFixed(2) : '-', '', 'SF = P_cr / P']);
                data.push(['Â∫ßÂ±àÂà§ÂÆö', detailJudgment, '', 'SF‚â•2.0:OK, 1.0‚â§SF<2.0:Ë¶ÅÊ≥®ÊÑè, SF<1.0:NG']);
                data.push([]);
            });
            
        } else {
            data.push(['‚Äª Â∫ßÂ±àËß£ÊûêÁµêÊûú„Åå„ÅÇ„Çä„Åæ„Åõ„Çì']);
            data.push(['‚Äª ÂúßÁ∏ÆËç∑Èáç„ÇíÂèó„Åë„ÇãÈÉ®Êùê„Åå„Å™„ÅÑÂ†¥Âêà„ÅØÂ∫ßÂ±àËß£Êûê„ÅØÂÆüË°å„Åï„Çå„Åæ„Åõ„Çì']);
        }
        
        const worksheet = XLSX.utils.aoa_to_sheet(data);
        XLSX.utils.book_append_sheet(workbook, worksheet, 'Â∫ßÂ±àËß£ÊûêÁµêÊûú');
    }

    // „Ç®„ÇØ„Çª„É´Âá∫Âäõ„ÅÆ„Ç§„Éô„É≥„Éà„Éè„É≥„Éâ„É©„Éº
    async function exportToExcelHandler() {
        console.log('=== „Ç®„ÇØ„Çª„É´Âá∫Âäõ„Éú„Çø„É≥„Åå„ÇØ„É™„ÉÉ„ÇØ„Åï„Çå„Åæ„Åó„Åü ===');
        try {
            console.log('„Ç®„ÇØ„Çª„É´Âá∫Âäõ„ÇíÈñãÂßã„Åó„Åæ„Åô...');
            
            // SheetJS„É©„Ç§„Éñ„É©„É™„ÅÆÂãïÁöÑË™≠„ÅøËæº„Åø
            if (typeof XLSX === 'undefined') {
                console.log('SheetJS„É©„Ç§„Éñ„É©„É™„ÇíË™≠„ÅøËæº„Åø‰∏≠...');
                await loadSheetJS();
            }
            
            await exportToExcel();
            console.log('„Ç®„ÇØ„Çª„É´Âá∫Âäõ„ÅåÂÆå‰∫Ü„Åó„Åæ„Åó„Åü');
        } catch (error) {
            console.error('„Ç®„ÇØ„Çª„É´Âá∫Âäõ„Åß„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü:', error);
            safeAlert('„Ç®„ÇØ„Çª„É´Âá∫Âäõ„Åß„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü: ' + error.message);
        }
    }

    // ==========================================================================
    // „Ç™„É≥„Ç≠„É£„É≥„Éê„ÇπÁõ¥Êé•Á∑®ÈõÜÊ©üËÉΩ
    // ==========================================================================
    let activeEditor = null;

    const showInPlaceEditor = (labelInfo) => {
        // Êó¢Â≠ò„ÅÆ„Ç®„Éá„Ç£„Çø„Åå„ÅÇ„Çå„Å∞ÂâäÈô§
        if (activeEditor) activeEditor.remove();

        const canvasRect = elements.modelCanvas.getBoundingClientRect();
        const editor = document.createElement('input');
        editor.type = 'number';
        editor.className = 'on-canvas-editor';
        editor.value = labelInfo.value;

        // „Ç®„Éá„Ç£„Çø„ÅÆ‰ΩçÁΩÆ„Å®„Çµ„Ç§„Ç∫„ÇíË™øÊï¥
        editor.style.left = `${canvasRect.left + window.scrollX + labelInfo.center.x}px`;
        editor.style.top = `${canvasRect.top + window.scrollY + labelInfo.center.y}px`;
        editor.style.width = `${labelInfo.width + 20}px`; // Â∞ë„ÅóÂπÖ„Å´‰ΩôË£ï„ÇíÊåÅ„Åü„Åõ„Çã

        document.body.appendChild(editor);
        activeEditor = editor;

        editor.focus();
        editor.select();

        const commitEdit = () => {
            if (!activeEditor) return;

            // „Ç®„Éá„Ç£„Çø„ÅÆÂèÇÁÖß„Çí‰øùÂ≠ò„Åó„Å¶„ÇØ„É™„Ç¢
            const editorToRemove = activeEditor;
            activeEditor = null;

            // ÂÄ§„ÇíÂèñÂæó„Åó„Å¶Êõ¥Êñ∞
            const newValue = parseFloat(editorToRemove.value);
            if (!isNaN(newValue)) {
                updateModelData(labelInfo, newValue);
            }

            // „Ç®„Éá„Ç£„Çø„ÇíÂâäÈô§ÔºàÊó¢„Å´ÂâäÈô§„Åï„Çå„Å¶„ÅÑ„ÇãÂ†¥Âêà„ÇÇ„ÅÇ„Çã„ÅÆ„Åßtry-catch„Åß‰øùË≠∑Ôºâ
            try {
                if (editorToRemove && editorToRemove.parentNode) {
                    editorToRemove.remove();
                }
            } catch (e) {
                // „Ç®„Éá„Ç£„Çø„ÅåÊó¢„Å´ÂâäÈô§„Åï„Çå„Å¶„ÅÑ„ÇãÂ†¥Âêà„ÅØÁÑ°Ë¶ñ
            }
        };

        const cancelEdit = () => {
            if (!activeEditor) return;

            // „Ç®„Éá„Ç£„Çø„ÅÆÂèÇÁÖß„Çí‰øùÂ≠ò„Åó„Å¶„ÇØ„É™„Ç¢
            const editorToRemove = activeEditor;
            activeEditor = null;

            // „Ç®„Éá„Ç£„Çø„ÇíÂâäÈô§
            try {
                if (editorToRemove && editorToRemove.parentNode) {
                    editorToRemove.remove();
                }
            } catch (e) {
                // „Ç®„Éá„Ç£„Çø„ÅåÊó¢„Å´ÂâäÈô§„Åï„Çå„Å¶„ÅÑ„ÇãÂ†¥Âêà„ÅØÁÑ°Ë¶ñ
            }
        };

        editor.addEventListener('blur', commitEdit);
        editor.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                commitEdit();
            } else if (e.key === 'Escape') {
                e.preventDefault();
                cancelEdit();
            }
        });
    };

    const updateModelData = (labelInfo, newValue) => {
        pushState(); // Â§âÊõ¥„ÇíÂ±•Ê≠¥„Å´‰øùÂ≠ò
        const { type, index } = labelInfo;

        switch (type) {
            case 'node-load-px':
            case 'node-load-py':
            case 'node-load-mz': {
                let loadRow = Array.from(elements.nodeLoadsTable.rows).find(r => parseInt(r.cells[0].querySelector('input').value) - 1 === index);
                if (!loadRow) {
                    // Ëç∑ÈáçË°å„ÅåÂ≠òÂú®„Åó„Å™„ÅÑÂ†¥Âêà„ÅØÊñ∞Ë¶è‰ΩúÊàê
                    addRow(elements.nodeLoadsTable, [`<input type="number" value="${index + 1}">`, '<input type="number" value="0">', '<input type="number" value="0">', '<input type="number" value="0">']);
                    loadRow = elements.nodeLoadsTable.rows[elements.nodeLoadsTable.rows.length - 1];
                }
                const cellIndex = { 'node-load-px': 1, 'node-load-py': 2, 'node-load-mz': 3 }[type];
                loadRow.cells[cellIndex].querySelector('input').value = newValue;
                break;
            }
            case 'member-load-w': {
                let loadRow = Array.from(elements.memberLoadsTable.rows).find(r => parseInt(r.cells[0].querySelector('input').value) - 1 === index);
                if (!loadRow) {
                    addRow(elements.memberLoadsTable, [`<input type="number" value="${index + 1}">`, '<input type="number" value="0">']);
                    loadRow = elements.memberLoadsTable.rows[elements.memberLoadsTable.rows.length - 1];
                }
                loadRow.cells[1].querySelector('input').value = newValue;
                break;
            }
        }

        // „Éá„Éº„Çø„ÇíÊõ¥Êñ∞Âæå„Å´Âç≥Â∫ß„Å´ÂÜçÊèèÁîª
        drawOnCanvas();

        // Ëß£ÊûêÁµêÊûú„Åå„ÅÇ„ÇãÂ†¥Âêà„ÅØÂÜçË®àÁÆó„ÇÇÂÆüË°å
        runFullAnalysis();
    };

    elements.modelCanvas.addEventListener('dblclick', (e) => {
        console.log('üñ±Ô∏è „ÉÄ„Éñ„É´„ÇØ„É™„ÉÉ„ÇØ„Ç§„Éô„É≥„ÉàÁô∫Áîü');
        
        // ‰ªñ„ÅÆ„Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó„ÅåË°®Á§∫„Åï„Çå„Å¶„ÅÑ„ÇãÂ†¥Âêà„ÅØ‰Ωï„ÇÇ„Åó„Å™„ÅÑ
        const existingPopup = document.querySelector('.popup-box[style*="display: block"]');
        if (existingPopup) {
            console.log('‚ùå „Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó„ÅåÊó¢„Å´Ë°®Á§∫„Åï„Çå„Å¶„ÅÑ„Çã„Åü„ÇÅÂá¶ÁêÜ„ÇíÂÅúÊ≠¢:', existingPopup);
            return;
        }

        const rect = elements.modelCanvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;

        // „Åæ„ÅöËç∑Èáç„É©„Éô„É´„ÅÆ„ÇØ„É™„ÉÉ„ÇØ„Çí„ÉÅ„Çß„ÉÉ„ÇØ
        let labelClicked = false;
        if (window.lastLabelManager) {
            const clickedLabel = window.lastLabelManager.getLabelAt(mouseX, mouseY);
            if (clickedLabel && clickedLabel.type && clickedLabel.index !== undefined) {
                e.preventDefault();
                e.stopPropagation();
                showInPlaceEditor(clickedLabel);
                labelClicked = true;
            }
        }

        // Ëç∑Èáç„É©„Éô„É´„Åå„ÇØ„É™„ÉÉ„ÇØ„Åï„Çå„Å¶„ÅÑ„Å™„ÅÑÂ†¥Âêà„ÄÅÁØÄÁÇπ„Åæ„Åü„ÅØÈÉ®Êùê„Çí„ÉÅ„Çß„ÉÉ„ÇØ
        if (!labelClicked) {
            const clickedNodeIndex = getNodeAt(mouseX, mouseY);
            const clickedMemberIndex = getMemberAt(mouseX, mouseY);
            
            console.log('üîç „ÉÄ„Éñ„É´„ÇØ„É™„ÉÉ„ÇØË¶ÅÁ¥†„ÉÅ„Çß„ÉÉ„ÇØ:', {
                mouseX, mouseY, 
                clickedNodeIndex, 
                clickedMemberIndex,
                labelClicked
            });

            if (clickedNodeIndex !== -1) {
                // ÁØÄÁÇπ„ÅÆ„Éó„É≠„Éë„ÉÜ„Ç£Á∑®ÈõÜ„Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó„ÇíË°®Á§∫
                e.preventDefault();
                e.stopPropagation();
                openNodeEditor(clickedNodeIndex);
                drawOnCanvas();
            } else if (clickedMemberIndex !== -1) {
                // ÈÉ®Êùê„ÅÆ„Éó„É≠„Éë„ÉÜ„Ç£Á∑®ÈõÜ„Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó„ÇíË°®Á§∫
                console.log('üîß ÈÉ®Êùê„ÉÄ„Éñ„É´„ÇØ„É™„ÉÉ„ÇØÂá¶ÁêÜÈñãÂßã:', {
                    clickedMemberIndex,
                    selectedMemberIndex
                });
                
                e.preventDefault();
                e.stopPropagation();
                selectedMemberIndex = clickedMemberIndex;
                window.selectedMemberIndex = clickedMemberIndex;

                // Âè≥„ÇØ„É™„ÉÉ„ÇØ„É°„Éã„É•„Éº„ÅÆ„Äåmenu-edit-member„Äç„Çí„ÇØ„É™„ÉÉ„ÇØ„Åó„ÅüÊôÇ„Å®Âêå„ÅòÂá¶ÁêÜ„ÇíÂÆüË°å
                // „Åì„ÅÆÂá¶ÁêÜ„ÅØË°å7025-7180‰ªòËøë„Å´„ÅÇ„Çã
                const memberRow = elements.membersTable.rows[selectedMemberIndex];
                console.log('üìã ÈÉ®ÊùêË°å„Éá„Éº„Çø:', {
                    memberRow: memberRow,
                    rowExists: !!memberRow,
                    selectedMemberIndex: selectedMemberIndex,
                    totalRows: elements.membersTable.rows.length
                });
                
                if (!memberRow) {
                    console.error('‚ùå ÈÉ®ÊùêË°å„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì');
                    return;
                }
                const e_select = memberRow.cells[3].querySelector('select');
                const e_input = memberRow.cells[3].querySelector('input[type="number"]');
                const currentE = (e_select.value === 'custom') ? e_input.value : e_select.value;

                // „Éù„ÉÉ„Éó„Ç¢„ÉÉ„ÉóÂÜÖ„ÅÆEÂÖ•ÂäõÊ¨Ñ„ÇíÁîüÊàê
                const eContainer = document.getElementById('popup-e-container');
                eContainer.innerHTML = createEInputHTML('popup-e', currentE);

                // ÁèæÂú®„ÅÆÊùêÊñô„Çø„Ç§„Éó„Å®Âü∫Ê∫ñÂº∑Â∫¶„ÇíÂèñÂæó
                const strengthContainer = memberRow.cells[4].firstElementChild;
                if (!strengthContainer) {
                    console.error('Âº∑Â∫¶ÂÖ•Âäõ„Ç≥„É≥„ÉÜ„Éä„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì');
                    return;
                }
                const strengthType = strengthContainer.dataset.strengthType;
                let currentStrength;
                if (strengthType === 'wood-type') {
                    const presetSelect = strengthContainer.querySelector('select');
                    if (presetSelect.value === 'custom') {
                        currentStrength = { baseStrengths: {} };
                        ['ft', 'fc', 'fb', 'fs'].forEach(key => {
                            currentStrength.baseStrengths[key] = parseFloat(strengthContainer.querySelector(`input[id*="-${key}"]`).value);
                        });
                    } else {
                        currentStrength = presetSelect.value;
                    }
                } else {
                    currentStrength = strengthContainer.querySelector('input').value;
                }

                const popupFContainer = document.getElementById('popup-f-container');
                const selectedOption = e_select.options[e_select.selectedIndex];
                let materialType = 'steel';
                if (selectedOption.textContent.includes('Êú®Êùê')) materialType = 'wood';
                else if (selectedOption.textContent.includes('„Çπ„ÉÜ„É≥„É¨„Çπ')) materialType = 'stainless';
                else if (selectedOption.textContent.includes('„Ç¢„É´„Éü„Éã„Ç¶„É†')) materialType = 'aluminum';

                // „Éù„ÉÉ„Éó„Ç¢„ÉÉ„ÉóÂÜÖ„ÅÆFÂÖ•ÂäõÊ¨Ñ„ÇíÁîüÊàê
                popupFContainer.innerHTML = '';
                popupFContainer.appendChild(createStrengthInputHTML(materialType, 'popup-f', currentStrength));

                // „Åù„ÅÆ‰ªñ„ÅÆ„Éó„É≠„Éë„ÉÜ„Ç£„ÇíË®≠ÂÆö
                // „ÉÜ„Éº„Éñ„É´„ÅÆÂàóÈÖçÁΩÆ: 0:'#',1:i,2:j,3:E,4:strength,5:I,6:A,7:Z,...
                const tableStartNodeCell = memberRow.cells[1];
                const tableAcell = memberRow.cells[6];
                const tableZcell = memberRow.cells[7];
                const popupIEl = document.getElementById('popup-i');
                const popupAEl = document.getElementById('popup-a');
                const popupZEl = document.getElementById('popup-z');
                if (popupIEl) popupIEl.value = tableStartNodeCell ? (tableStartNodeCell.querySelector('input')?.value || '') : '';
                if (popupAEl) popupAEl.value = tableAcell ? (tableAcell.querySelector('input')?.value || '') : '';
                if (popupZEl) popupZEl.value = tableZcell ? (tableZcell.querySelector('input')?.value || '') : '';

                // ÂØÜÂ∫¶Ê¨Ñ„ÅÆË°®Á§∫/ÈùûË°®Á§∫„Å®ÂÄ§Ë®≠ÂÆö
                const hasDensityColumn = document.querySelector('.density-column') && document.querySelector('.density-column').style.display !== 'none';
                let existingDensityLabel = document.getElementById('popup-density-label');
                let existingDensityContainer = document.getElementById('popup-density-container');

                if (hasDensityColumn) {
                    // ÂØÜÂ∫¶Ê¨Ñ„ÅåË°®Á§∫„Åï„Çå„Å¶„ÅÑ„ÇãÂ†¥Âêà„ÅÆÂá¶ÁêÜ
                    if (!existingDensityLabel || !existingDensityContainer) {
                        // „Éù„ÉÉ„Éó„Ç¢„ÉÉ„ÉóÂÜÖ„Å´ÂØÜÂ∫¶ÂÖ•ÂäõÊ¨Ñ„ÇíÊåøÂÖ•
                        const popupZContainer = document.getElementById('popup-z').parentElement.parentElement;
                        const densityLabel = document.createElement('label');
                        densityLabel.textContent = 'ÂØÜÂ∫¶ (kg/m¬≥):';
                        densityLabel.id = 'popup-density-label';

                        const densityContainer = document.createElement('div');
                        densityContainer.id = 'popup-density-container';

                        popupZContainer.parentElement.insertBefore(densityLabel, popupZContainer.nextSibling);
                        popupZContainer.parentElement.insertBefore(densityContainer, densityLabel.nextSibling);

                        existingDensityLabel = densityLabel;
                        existingDensityContainer = densityContainer;
                    }

                    // ÂØÜÂ∫¶ÂÄ§„ÇíÂèñÂæó„Åó„Å¶„Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó„Å´Ë®≠ÂÆö
                    const densityCell = memberRow.cells[8];
                    if (densityCell && densityCell.classList.contains('density-cell')) {
                        const densitySelect = densityCell.querySelector('select');
                        const densityInput = densityCell.querySelector('input[type="number"]');
                        const currentDensity = (densitySelect && densitySelect.value === 'custom') ? densityInput.value : (densitySelect ? densitySelect.value : '7850');

                        if (existingDensityContainer) {
                            existingDensityContainer.innerHTML = createDensityInputHTML('popup-density', currentDensity);
                        }
                    }

                    if (existingDensityLabel) existingDensityLabel.style.display = '';
                    if (existingDensityContainer) existingDensityContainer.style.display = '';
                } else {
                    if (existingDensityLabel) existingDensityLabel.style.display = 'none';
                    if (existingDensityContainer) existingDensityContainer.style.display = 'none';
                }

                // Êé•Á∂öÊù°‰ª∂„ÇíË®≠ÂÆöÔºàconn-select „Çí‰Ωø„Å£„Å¶ÂÆâÂÖ®„Å´ÂèñÂæóÔºâ
                const popupIConnEl = document.getElementById('popup-i-conn');
                const popupJConnEl = document.getElementById('popup-j-conn');
                const connSelectsRow = Array.from(memberRow.querySelectorAll('.conn-select'));
                const iConnSelEl = connSelectsRow[0] || null;
                const jConnSelEl = connSelectsRow[1] || null;
                if (popupIConnEl) {
                    if (iConnSelEl) {
                        popupIConnEl.value = iConnSelEl.value;
                        popupIConnEl.dispatchEvent(new Event('change'));
                    }
                    else console.warn('popup sync: i_conn select not found', { memberRow });
                }
                if (popupJConnEl) {
                    if (jConnSelEl) {
                        popupJConnEl.value = jConnSelEl.value;
                        popupJConnEl.dispatchEvent(new Event('change'));
                    }
                    else console.warn('popup sync: j_conn select not found', { memberRow });
                }

                // „Éù„ÉÉ„Éó„Ç¢„ÉÉ„ÉóÂÜÖ„ÅÆ„Éê„ÉçÂÖ•Âäõ„Å´„ÉÜ„Éº„Éñ„É´Ë°å„ÅÆÂÄ§„ÇíÂèçÊò†Ôºàconn „Çª„É´Âçò‰Ωç„ÅßÊé¢„ÅôÔºâ
                try {
                    const iConnCell = iConnSelEl ? (iConnSelEl.closest('.conn-cell') || iConnSelEl.parentElement) : null;
                    const jConnCell = jConnSelEl ? (jConnSelEl.closest('.conn-cell') || jConnSelEl.parentElement) : null;

                    const piKx = document.getElementById('popup-i-spring-kx');
                    const piKy = document.getElementById('popup-i-spring-ky');
                    const piKr = document.getElementById('popup-i-spring-kr');
                    if (iConnCell) {
                        const iSpringBox = iConnCell.querySelector('.spring-inputs');
                        if (iSpringBox) {
                            const kx = iSpringBox.querySelector('.spring-kx')?.value || '0';
                            const ky = iSpringBox.querySelector('.spring-ky')?.value || '0';
                            const kr = iSpringBox.querySelector('.spring-kr')?.value || '0';
                            const rKx = iSpringBox.querySelector('.spring-rigid-kx')?.checked || false;
                            const rKy = iSpringBox.querySelector('.spring-rigid-ky')?.checked || false;
                            const rKr = iSpringBox.querySelector('.spring-rigid-kr')?.checked || false;
                            if (piKx) piKx.value = kx;
                            if (piKy) piKy.value = ky;
                            if (piKr) piKr.value = kr;
                            const piRKx = document.getElementById('popup-i-spring-rigid-kx');
                            const piRKy = document.getElementById('popup-i-spring-rigid-ky');
                            const piRKr = document.getElementById('popup-i-spring-rigid-kr');
                            if (piRKx) { piRKx.checked = rKx; if (piKx) piKx.disabled = rKx; }
                            if (piRKy) { piRKy.checked = rKy; if (piKy) piKy.disabled = rKy; }
                            if (piRKr) { piRKr.checked = rKr; if (piKr) piKr.disabled = rKr; }
                        } else {
                            if (piKx) piKx.value = '0';
                            if (piKy) piKy.value = '0';
                            if (piKr) piKr.value = '0';
                            const piRKx = document.getElementById('popup-i-spring-rigid-kx');
                            const piRKy = document.getElementById('popup-i-spring-rigid-ky');
                            const piRKr = document.getElementById('popup-i-spring-rigid-kr');
                            if (piRKx) { piRKx.checked = false; if (piKx) piKx.disabled = false; }
                            if (piRKy) { piRKy.checked = false; if (piKy) piKy.disabled = false; }
                            if (piRKr) { piRKr.checked = false; if (piKr) piKr.disabled = false; }
                        }
                    }

                    const pjKx = document.getElementById('popup-j-spring-kx');
                    const pjKy = document.getElementById('popup-j-spring-ky');
                    const pjKr = document.getElementById('popup-j-spring-kr');
                    if (jConnCell) {
                        const jSpringBox = jConnCell.querySelector('.spring-inputs');
                        if (jSpringBox) {
                            const kx = jSpringBox.querySelector('.spring-kx')?.value || '0';
                            const ky = jSpringBox.querySelector('.spring-ky')?.value || '0';
                            const kr = jSpringBox.querySelector('.spring-kr')?.value || '0';
                            const rKx = jSpringBox.querySelector('.spring-rigid-kx')?.checked || false;
                            const rKy = jSpringBox.querySelector('.spring-rigid-ky')?.checked || false;
                            const rKr = jSpringBox.querySelector('.spring-rigid-kr')?.checked || false;
                            if (pjKx) pjKx.value = kx;
                            if (pjKy) pjKy.value = ky;
                            if (pjKr) pjKr.value = kr;
                            const pjRKx = document.getElementById('popup-j-spring-rigid-kx');
                            const pjRKy = document.getElementById('popup-j-spring-rigid-ky');
                            const pjRKr = document.getElementById('popup-j-spring-rigid-kr');
                            if (pjRKx) { pjRKx.checked = rKx; if (pjKx) pjKx.disabled = rKx; }
                            if (pjRKy) { pjRKy.checked = rKy; if (pjKy) pjKy.disabled = rKy; }
                            if (pjRKr) { pjRKr.checked = rKr; if (pjKr) pjKr.disabled = rKr; }
                        } else {
                            if (pjKx) pjKx.value = '0';
                            if (pjKy) pjKy.value = '0';
                            if (pjKr) pjKr.value = '0';
                            const pjRKx = document.getElementById('popup-j-spring-rigid-kx');
                            const pjRKy = document.getElementById('popup-j-spring-rigid-ky');
                            const pjRKr = document.getElementById('popup-j-spring-rigid-kr');
                            if (pjRKx) { pjRKx.checked = false; if (pjKx) pjKx.disabled = false; }
                            if (pjRKy) { pjRKy.checked = false; if (pjKy) pjKy.disabled = false; }
                            if (pjRKr) { pjRKr.checked = false; if (pjKr) pjKr.disabled = false; }
                        }
                    }
                } catch (e) {
                    console.warn('popup sync spring read error', e);
                }

                // ÈÉ®ÊùêËç∑Èáç„ÇíË®≠ÂÆö
                const memberLoadRow = Array.from(elements.memberLoadsTable.rows).find(row => parseInt(row.cells[0].querySelector('input').value)-1 === selectedMemberIndex);
                document.getElementById('popup-w').value = memberLoadRow ? memberLoadRow.cells[1].querySelector('input').value : '0';

                // „Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó„ÇíË°®Á§∫
                const popup = elements.memberPropsPopup;
                console.log('üì¶ ÈÉ®Êùê„Éó„É≠„Éë„ÉÜ„Ç£„Éù„ÉÉ„Éó„Ç¢„ÉÉ„ÉóË°®Á§∫:', {
                    popup: popup,
                    popupExists: !!popup,
                    popupDisplay: popup ? popup.style.display : 'undefined'
                });
                
                if (popup) {
                    popup.style.display = 'block';
                    // Ë°®Á§∫ÊôÇ„Å´Ââõ„Éï„É©„Ç∞„Åå„ÅÇ„ÇãÂÖ•Âäõ„ÇíÁÑ°ÂäπÂåñ
                    try {
                        const piKx = document.getElementById('popup-i-spring-kx');
                        const piKy = document.getElementById('popup-i-spring-ky');
                        const piKr = document.getElementById('popup-i-spring-kr');
                        const pjKx = document.getElementById('popup-j-spring-kx');
                        const pjKy = document.getElementById('popup-j-spring-ky');
                        const pjKr = document.getElementById('popup-j-spring-kr');
                        const piRKx = document.getElementById('popup-i-spring-rigid-kx');
                        const piRKy = document.getElementById('popup-i-spring-rigid-ky');
                        const piRKr = document.getElementById('popup-i-spring-rigid-kr');
                        const pjRKx = document.getElementById('popup-j-spring-rigid-kx');
                        const pjRKy = document.getElementById('popup-j-spring-rigid-ky');
                        const pjRKr = document.getElementById('popup-j-spring-rigid-kr');
                        if (piKx && piRKx) piKx.disabled = !!piRKx.checked;
                        if (piKy && piRKy) piKy.disabled = !!piRKy.checked;
                        if (piKr && piRKr) piKr.disabled = !!piRKr.checked;
                        if (pjKx && pjRKx) pjKx.disabled = !!pjRKx.checked;
                        if (pjKy && pjRKy) pjKy.disabled = !!pjRKy.checked;
                        if (pjKr && pjRKr) pjKr.disabled = !!pjRKr.checked;
                    } catch (e) { console.warn('popup init disable error', e); }
                    console.log('‚úÖ „Éù„ÉÉ„Éó„Ç¢„ÉÉ„ÉóË°®Á§∫Ë®≠ÂÆöÂÆå‰∫Ü:', popup.style.display);
                } else {
                    console.error('‚ùå memberPropsPopupË¶ÅÁ¥†„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì');
                }

                // „Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó‰ΩçÁΩÆ„ÇíË™øÊï¥
                setTimeout(() => {
                    console.log('üìç „Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó‰ΩçÁΩÆË™øÊï¥ÂÆüË°å');
                    adjustPopupPosition(elements.memberPropsPopup);
                }, 0);

                drawOnCanvas();
            }
        }
    });
});

// ==========================================================================
// „Éï„É¨„Éº„É†„Ç∏„Çß„Éç„É¨„Éº„Çø„ÉºÊ©üËÉΩ
// ==========================================================================

// „Éï„É¨„Éº„É†„Ç∏„Çß„Éç„É¨„Éº„Çø„Éº„ÅÆÂàùÊúüÂåñ
const initializeFrameGenerator = () => {
    const frameGeneratorBtn = document.getElementById('frame-generator-btn');
    const frameGeneratorModal = document.getElementById('frame-generator-modal');
    const modalClose = frameGeneratorModal.querySelector('.modal-close');
    const cancelBtn = document.getElementById('frame-generator-cancel');
    const generateBtn = document.getElementById('frame-generator-generate');
    
    // ÂÖ•ÂäõË¶ÅÁ¥†
    const floorsInput = document.getElementById('frame-floors');
    const spansInput = document.getElementById('frame-spans');
    const spanLengthInput = document.getElementById('frame-span-length');
    const floorHeightInput = document.getElementById('frame-floor-height');
    const fixBaseCheckbox = document.getElementById('frame-fix-base');
    const startXInput = document.getElementById('frame-start-x');
    const startYInput = document.getElementById('frame-start-y');
    
    // „Éó„É¨„Éì„É•„ÉºË¶ÅÁ¥†
    const previewNodes = document.getElementById('preview-nodes');
    const previewMembers = document.getElementById('preview-members');
    const previewSupport = document.getElementById('preview-support');
    
    // „Éó„É¨„Éì„É•„ÉºÊõ¥Êñ∞Èñ¢Êï∞
    const updatePreview = () => {
        const floors = parseInt(floorsInput.value) || 1;
        const spans = parseInt(spansInput.value) || 1;
        const fixBase = fixBaseCheckbox.checked;
        
        const totalNodes = (spans + 1) * (floors + 1);
        const horizontalMembers = spans * (floors + 1); // ÂêÑÈöé„ÅÆÊ¢Å
        const verticalMembers = (spans + 1) * floors; // ÂêÑÊü±
        const totalMembers = horizontalMembers + verticalMembers;
        
        previewNodes.textContent = totalNodes;
        previewMembers.textContent = totalMembers;
        previewSupport.textContent = fixBase ? 'Âõ∫ÂÆöÊîØÁÇπ' : '„Éî„É≥ÊîØÁÇπ';
    };
    
    // ÂÖ•ÂäõÂÄ§Â§âÊõ¥ÊôÇ„ÅÆ„Éó„É¨„Éì„É•„ÉºÊõ¥Êñ∞
    [floorsInput, spansInput].forEach(input => {
        input.addEventListener('input', updatePreview);
    });
    
    // „ÉÅ„Çß„ÉÉ„ÇØ„Éú„ÉÉ„ÇØ„ÇπÂ§âÊõ¥ÊôÇ„ÅÆ„Éó„É¨„Éì„É•„ÉºÊõ¥Êñ∞
    fixBaseCheckbox.addEventListener('change', updatePreview);
    
    // „É¢„Éº„ÉÄ„É´Ë°®Á§∫
    const showModal = () => {
        frameGeneratorModal.style.display = 'flex';
        updatePreview();
    };
    
    // „É¢„Éº„ÉÄ„É´ÈùûË°®Á§∫
    const hideModal = () => {
        frameGeneratorModal.style.display = 'none';
    };
    
    // „Éï„É¨„Éº„É†ÁîüÊàêÈñ¢Êï∞
    // „Éï„É¨„Éº„É†„Ç∏„Çß„Éç„É¨„Éº„Çø„ÉºÁî®„Éò„É´„Éë„ÉºÈñ¢Êï∞
    const clearAllTables = () => {
        // ÂÖ®„Å¶„ÅÆ„ÉÜ„Éº„Éñ„É´Ë°å„ÇíÂâäÈô§Ôºà„Éò„ÉÉ„ÉÄ„Éº„ÇíÈô§„ÅèÔºâ
        const nodesTable = document.getElementById('nodes-table')?.getElementsByTagName('tbody')[0];
        const membersTable = document.getElementById('members-table')?.getElementsByTagName('tbody')[0];
        const nodeLoadsTable = document.getElementById('node-loads-table')?.getElementsByTagName('tbody')[0];
        const memberLoadsTable = document.getElementById('member-loads-table')?.getElementsByTagName('tbody')[0];
        
        const tables = [nodesTable, membersTable, nodeLoadsTable, memberLoadsTable];
        
        tables.forEach(table => {
            if (table && table.rows) {
                // ÈÄÜÈ†Ü„ÅßÂâäÈô§Ôºà„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ„ÅÆÂ§âÊõ¥„ÇíÈÅø„Åë„Çã„Åü„ÇÅÔºâ
                for (let i = table.rows.length - 1; i >= 0; i--) {
                    table.deleteRow(i);
                }
            }
        });
    };
    
    const addNodeToTable = (id, x, y, support) => {
        const nodesTable = document.getElementById('nodes-table')?.getElementsByTagName('tbody')[0];
        if (!nodesTable) {
            console.error('nodes-table not found');
            return null;
        }
        
        const cells = [
            '#', // Âæå„Åß renumberTables() „ÅßÁï™Âè∑„ÅåÊåØ„ÇäÁõ¥„Åï„Çå„Åæ„Åô
            `<input type="number" step="0.001" value="${x}">`,
            `<input type="number" step="0.001" value="${y}">`,
            `<select>
                <option value="free" ${support === 'free' ? 'selected' : ''}>Ëá™Áî±</option>
                <option value="pinned" ${support === 'pinned' ? 'selected' : ''}>„Éî„É≥</option>
                <option value="fixed" ${support === 'fixed' ? 'selected' : ''}>Âõ∫ÂÆö</option>
                <option value="roller_x_fixed" ${support === 'roller_x_fixed' ? 'selected' : ''}>„É≠„Éº„É©„Éº(ÂûÇÁõ¥Ëá™Áî±)</option>
                <option value="roller_y_fixed" ${support === 'roller_y_fixed' || support === 'roller' ? 'selected' : ''}>„É≠„Éº„É©„Éº(Ê∞¥Âπ≥Ëá™Áî±)</option>
            </select>`,
            `<input type="number" value="0" step="0.1">`, // Âº∑Âà∂Â§â‰Ωç Œ¥x (mm)
            `<input type="number" value="0" step="0.1">`, // Âº∑Âà∂Â§â‰Ωç Œ¥y (mm)
            `<input type="number" value="0" step="0.001">` // Âº∑Âà∂ÂõûËª¢ Œ∏z (rad)
        ];
        
        // Ë°å„ÇíÊâãÂãï„Åß‰ΩúÊàê
        const newRow = nodesTable.insertRow();
        cells.forEach(cellHTML => { 
            const cell = newRow.insertCell(); 
            cell.innerHTML = cellHTML; 
        });
        
        // ÂâäÈô§„Éú„Çø„É≥„Çª„É´„ÇíËøΩÂä†
        const deleteCell = newRow.insertCell();
        deleteCell.innerHTML = '<button class="delete-row-btn">√ó</button>';
        
        // ÂâäÈô§„Éú„Çø„É≥„ÅÆ„Ç§„Éô„É≥„Éà„É™„Çπ„Éä„Éº„ÇíË®≠ÂÆö
        const deleteBtn = deleteCell.querySelector('.delete-row-btn');
        if (deleteBtn) {
            deleteBtn.onclick = () => {
                if (confirm('„Åì„ÅÆË°å„ÇíÂâäÈô§„Åó„Åæ„Åô„ÅãÔºü')) {
                    newRow.remove();
                    if (typeof drawOnCanvas === 'function') {
                        drawOnCanvas();
                    }
                }
            };
        }
        
        return newRow;
    };
    
    const addMemberToTable = (id, nodeI, nodeJ, E, G, nu, A, Iz, J, startPin, endPin) => {
        try {
            // Êó¢Â≠ò„ÅÆ„Ç∑„Çπ„ÉÜ„É†„ÅåÊúüÂæÖ„Åô„ÇãÂçò‰Ωç„Å´Â§âÊèõ
            const E_GPa = E / 1000; // N/mm¬≤ ‚Üí GPa
            const F = '235'; // „Éá„Éï„Ç©„É´„Éà„ÅÆÈôç‰ºèÂº∑Â∫¶
            const I_m4 = Iz; // Êñ≠Èù¢‰∫åÊ¨°„É¢„Éº„É°„É≥„Éà (m‚Å¥)
            const A_m2 = A;  // Êñ≠Èù¢Á©ç (m¬≤)
            const Z_m3 = J;  // Êñ≠Èù¢‰øÇÊï∞ (m¬≥) - Êö´ÂÆöÁöÑ„Å´„Å≠„Åò„ÇäÂÆöÊï∞„Çí‰ΩøÁî®
            
            // ÂºæÊÄß‰øÇÊï∞ÈÅ∏Êäû„Éï„Ç£„Éº„É´„Éâ„ÇíÊâãÂãï„Åß‰ΩúÊàêÔºà205GPa„Çπ„ÉÅ„Éº„É´„ÇíÈÅ∏ÊäûÔºâ
            const eSelectHTML = `<div style="display: flex; flex-direction: column; gap: 2px;">
                <select id="member-e-${nodeI}-${nodeJ}-select">
                    <option value="205000" selected>„Çπ„ÉÅ„Éº„É´</option>
                    <option value="193000">„Çπ„ÉÜ„É≥„É¨„Çπ</option>
                    <option value="70000">„Ç¢„É´„Éü„Éã„Ç¶„É†</option>
                    <option value="8000">Êú®Êùê</option>
                    <option value="custom">‰ªªÊÑèÂÖ•Âäõ</option>
                </select>
                <input id="member-e-${nodeI}-${nodeJ}-input" type="number" value="205000" title="ÂºæÊÄß‰øÇÊï∞ E (N/mm¬≤)" readonly>
            </div>`;
            
            // Èôç‰ºèÂº∑Â∫¶ÈÅ∏Êäû„Éï„Ç£„Éº„É´„Éâ„ÇíÊâãÂãï„Åß‰ΩúÊàê
            const strengthSelectHTML = `<div style="display: flex; flex-direction: column; gap: 2px;">
                <select id="member-strength-${nodeI}-${nodeJ}-select">
                    <option value="235" selected>SS400 (235N/mm¬≤)</option>
                    <option value="325">SS490 (325N/mm¬≤)</option>
                    <option value="400">SM490A (400N/mm¬≤)</option>
                    <option value="custom">‰ªªÊÑèÂÖ•Âäõ</option>
                </select>
                <input id="member-strength-${nodeI}-${nodeJ}-input" type="number" value="235" title="Èôç‰ºèÂº∑Â∫¶ F (N/mm¬≤)" readonly>
            </div>`;
            
            const cells = [
                '#', // Âæå„Åß renumberTables() „ÅßÁï™Âè∑„ÅåÊåØ„ÇäÁõ¥„Åï„Çå„Åæ„Åô
                `<input type="number" value="${nodeI}">`,
                `<input type="number" value="${nodeJ}">`,
                eSelectHTML,
                strengthSelectHTML,
                `<div class="cell-input-wrapper reduction-wrapper" data-reduction-decimals="2">
                    <input type="number" class="reduction-base-input section-I-input" value="${(I_m4 * 1e8).toFixed(2)}" title="Êñ≠Èù¢‰∫åÊ¨°„É¢„Éº„É°„É≥„Éà I (cm‚Å¥)">
                    <input type="number" class="reduction-factor-input section-I-factor" value="1.0" step="0.01" title="‰ΩéÊ∏õ‰øÇÊï∞" placeholder="‰ΩéÊ∏õ‰øÇÊï∞">
                    <div class="reduced-label" style="display:none;">‰ΩéÊ∏õÂæåÔºö<span class="reduced-value"></span></div>
                </div>`,
                `<div class="cell-input-wrapper reduction-wrapper" data-reduction-decimals="2">
                    <input type="number" class="reduction-base-input section-A-input" value="${(A_m2 * 1e4).toFixed(2)}" title="Êñ≠Èù¢Á©ç A (cm¬≤)">
                    <input type="number" class="reduction-factor-input section-A-factor" value="1.0" step="0.01" title="‰ΩéÊ∏õ‰øÇÊï∞" placeholder="‰ΩéÊ∏õ‰øÇÊï∞">
                    <div class="reduced-label" style="display:none;">‰ΩéÊ∏õÂæåÔºö<span class="reduced-value"></span></div>
                </div>`,
                `<div class="cell-input-wrapper reduction-wrapper" data-reduction-decimals="2">
                    <input type="number" class="reduction-base-input section-Z-input" value="${(Z_m3 * 1e6).toFixed(2)}" title="Êñ≠Èù¢‰øÇÊï∞ Z (cm¬≥)">
                    <input type="number" class="reduction-factor-input section-Z-factor" value="1.0" step="0.01" title="‰ΩéÊ∏õ‰øÇÊï∞" placeholder="‰ΩéÊ∏õ‰øÇÊï∞">
                    <div class="reduced-label" style="display:none;">‰ΩéÊ∏õÂæåÔºö<span class="reduced-value"></span></div>
                </div>`,
                `<input type="number" value="7850" title="ÂØÜÂ∫¶ œÅ (kg/m¬≥)" style="display: none;">`, // ÂØÜÂ∫¶ÂàóÔºà„Éá„Éï„Ç©„É´„ÉàÈùûË°®Á§∫Ôºâ
                `<button class="section-select-btn">Êñ≠Èù¢ÈÅ∏Êäû</button>`, // ÈÉ®ÊùêÊñ≠Èù¢ÈÅ∏Êäû„Éú„Çø„É≥
                `<select><option value="rigid" ${startPin === 'rigid' ? 'selected' : ''}>Ââõ</option><option value="pinned" ${startPin === 'pinned' ? 'selected' : ''}>„Éî„É≥</option></select>`,
                `<select><option value="rigid" ${endPin === 'rigid' ? 'selected' : ''}>Ââõ</option><option value="pinned" ${endPin === 'pinned' ? 'selected' : ''}>„Éî„É≥</option></select>`
            ];
            
            const membersTable = document.getElementById('members-table')?.getElementsByTagName('tbody')[0];
            if (!membersTable) {
                console.error('members-table not found');
                return null;
            }
            
            // Ë°å„Çí‰ΩúÊàê
            const newRow = membersTable.insertRow();
            cells.forEach((cellHTML, index) => { 
                const cell = newRow.insertCell(); 
                cell.innerHTML = cellHTML;
                
                // ÂØÜÂ∫¶ÂàóÔºà8Áï™ÁõÆ„ÅÆ„Çª„É´Ôºâ„ÅÆË°®Á§∫/ÈùûË°®Á§∫Ë®≠ÂÆö
                if (index === 8) { // ÂØÜÂ∫¶Âàó
                    const densityColumns = document.querySelectorAll('.density-column');
                    const isDensityVisible = densityColumns.length > 0 && densityColumns[0].style.display !== 'none';
                    cell.style.display = isDensityVisible ? '' : 'none';
                    cell.classList.add('density-column');
                }
            });
            
            // ÂâäÈô§„Éú„Çø„É≥„Çª„É´„ÇíËøΩÂä†
            const deleteCell = newRow.insertCell();
            deleteCell.innerHTML = '<button class="delete-row-btn">√ó</button>';
            
            // ÂâäÈô§„Éú„Çø„É≥„ÅÆ„Ç§„Éô„É≥„Éà„É™„Çπ„Éä„Éº„ÇíË®≠ÂÆö
            const deleteBtn = deleteCell.querySelector('.delete-row-btn');
            if (deleteBtn) {
                deleteBtn.onclick = () => {
                    if (confirm('„Åì„ÅÆË°å„ÇíÂâäÈô§„Åó„Åæ„Åô„ÅãÔºü')) {
                        newRow.remove();
                        if (typeof drawOnCanvas === 'function') {
                            drawOnCanvas();
                        }
                    }
                };
            }
            
            // Êñ≠Èù¢ÈÅ∏Êäû„Éú„Çø„É≥„ÅÆ„Ç§„Éô„É≥„Éà„É™„Çπ„Éä„Éº„ÇíË®≠ÂÆö
            const sectionBtn = newRow.querySelector('.section-select-btn');
            if (sectionBtn) {
                sectionBtn.onclick = () => {
                    // ÈÉ®ÊùêËøΩÂä†„Éù„ÉÉ„Éó„Ç¢„ÉÉ„ÉóÂÜÖ„ÅÆË°åÁî®„ÅÆÊñ≠Èù¢ÈÅ∏ÊäûÊ©üËÉΩ
                    console.log('Êñ≠Èù¢ÈÅ∏Êäû„Éú„Çø„É≥„Åå„ÇØ„É™„ÉÉ„ÇØ„Åï„Çå„Åæ„Åó„Åü');

                    // steel_selector.html„ÇíÈñã„ÅèÔºàÁâπÂà•„Å™Ë≠òÂà•Â≠ê„Çí‰ΩøÁî®Ôºâ
                    const rowId = `add-temp-${nodeI}-${nodeJ}`;
                    const url = `steel_selector.html?targetMember=${encodeURIComponent(rowId)}`;
                    const popup = window.open(url, 'SteelSelector', 'width=1200,height=800,scrollbars=yes,resizable=yes');

                    if (!popup) {
                        alert('„Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó„Éñ„É≠„ÉÉ„Ç´„Éº„Å´„Çà„ÇäÊñ≠Èù¢ÈÅ∏Êäû„ÉÑ„Éº„É´„ÇíÈñã„Åë„Åæ„Åõ„Çì„Åß„Åó„Åü„ÄÇ„Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó„ÇíË®±ÂèØ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ');
                        return;
                    }

                    // „Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó„Åã„ÇâÊàª„Å£„ÅüÊôÇ„ÅÆÂá¶ÁêÜ
                    const checkPopup = setInterval(() => {
                        if (popup.closed) {
                            clearInterval(checkPopup);
                            const storedData = localStorage.getItem('steelSelectionForFrameAnalyzer');
                            if (storedData) {
                                try {
                                    const data = JSON.parse(storedData);
                                    if (data.targetMemberIndex === rowId && data.properties) {
                                        // Ë°åÂÜÖ„ÅÆÂÖ•Âäõ„Éï„Ç£„Éº„É´„Éâ„ÇíÊõ¥Êñ∞
                                        const iInput = newRow.querySelector('input[placeholder="Êñ≠Èù¢‰∫åÊ¨°„É¢„Éº„É°„É≥„Éà"]');
                                        const aInput = newRow.querySelector('input[placeholder="Êñ≠Èù¢Á©ç"]');
                                        const zInput = newRow.querySelector('input[placeholder="Êñ≠Èù¢‰øÇÊï∞"]');
                                        const eInput = document.getElementById(`member-e-${nodeI}-${nodeJ}-input`);
                                        const strengthInput = document.getElementById(`member-strength-${nodeI}-${nodeJ}-input`);

                                        if (iInput) iInput.value = data.properties.I;
                                        if (aInput) aInput.value = data.properties.A;
                                        if (zInput) zInput.value = data.properties.Z;
                                        if (eInput && data.properties.E) eInput.value = data.properties.E;
                                        if (strengthInput && data.properties.strengthValue) strengthInput.value = data.properties.strengthValue;

                                        // Êñ≠Èù¢ÊÉÖÂ†±„ÇíË°®Á§∫
                                        const sectionName = data.properties.sectionName || data.properties.sectionLabel || '';
                                        const selectedAxis = data.properties.selectedAxis || data.properties.sectionAxisLabel || '';

                                        if (sectionName) {
                                            // Êñ≠Èù¢ÊÉÖÂ†±Ë°®Á§∫„Ç®„É™„Ç¢„ÇíÊé¢„Åô
                                            const sectionInfoCell = newRow.cells[newRow.cells.length - 3]; // ÂâäÈô§„Éú„Çø„É≥„ÅÆ2„Å§Ââç
                                            if (sectionInfoCell) {
                                                // Êó¢Â≠ò„ÅÆÊñ≠Èù¢ÊÉÖÂ†±„Åå„ÅÇ„Çå„Å∞Êõ¥Êñ∞„ÄÅ„Å™„Åë„Çå„Å∞‰ΩúÊàê
                                                let infoDiv = sectionInfoCell.querySelector('.section-info-display');
                                                if (!infoDiv) {
                                                    infoDiv = document.createElement('div');
                                                    infoDiv.className = 'section-info-display';
                                                    infoDiv.style.cssText = 'font-size: 0.85em; color: #0066cc; margin-top: 4px;';
                                                    sectionInfoCell.appendChild(infoDiv);
                                                }

                                                infoDiv.innerHTML = `<strong>${sectionName}</strong> ${selectedAxis}`;
                                            }
                                        }

                                        // --- ËøΩÂä†Âá¶ÁêÜ: sectionInfo „Çí dataset „Å´‰øùÂ≠ò„Åó„ÄÅ3D „Éì„É•„Éº„Ç¢„Å´ÈÄöÁü• ---
                                        try {
                                            const props = data.properties || {};

                                            if (props.sectionInfo) {
                                                // typeKey „ÅÆÊúÄÁµÇË£úÂÆå
                                                if ((!props.sectionInfo.typeKey || String(props.sectionInfo.typeKey).trim() === '') && (props.typeKey || props.selectedTypeKey)) {
                                                    props.sectionInfo.typeKey = props.typeKey || props.selectedTypeKey;
                                                }

                                                if (typeof window.setRowSectionInfo === 'function') {
                                                    try { window.setRowSectionInfo(newRow, props.sectionInfo); } catch (_e) { /* ignore */ }
                                                } else {
                                                    try { newRow.dataset.sectionInfo = encodeURIComponent(JSON.stringify(props.sectionInfo)); } catch (_e) { /* ignore */ }
                                                }
                                            }

                                            // Ëª∏ÊÉÖÂ†±„ÇÇ dataset „Å´‰øùÂ≠ò
                                            if (props.sectionAxis) {
                                                if (typeof window.applySectionAxisDataset === 'function') {
                                                    try { window.applySectionAxisDataset(newRow, props.sectionAxis); } catch (_e) { /* ignore */ }
                                                } else if (props.sectionAxis.label) {
                                                    newRow.dataset.sectionAxisLabel = props.sectionAxis.label;
                                                }
                                            }

                                            // 3D „Éì„É•„Éº„Ç¢„Å∏Êõ¥Êñ∞„ÇíÈÄöÁü•
                                            if (typeof sendModelToViewer === 'function') {
                                                setTimeout(() => {
                                                    try { sendModelToViewer(); } catch (e) { console.warn('sendModelToViewer failed', e); }
                                                }, 100);
                                            }
                                        } catch (outerErr) {
                                            console.warn('addMemberToTable: sectionInfo ‰øùÂ≠òÂá¶ÁêÜ„Åß„Ç®„É©„Éº', outerErr);
                                        }

                                        localStorage.removeItem('steelSelectionForFrameAnalyzer');
                                        console.log('‚úÖ ÈÉ®ÊùêËøΩÂä†Ë°å: Êñ≠Èù¢„Éá„Éº„Çø„ÇíÈÅ©Áî®„Åó„ÄÅ‰øùÂ≠ò„Åó„Åæ„Åó„Åü');
                                    }
                                } catch (e) {
                                    console.error('Êñ≠Èù¢ÈÅ∏Êäû„Éá„Éº„Çø„ÅÆËß£Êûê„Ç®„É©„Éº:', e);
                                }
                            }
                        }
                    }, 500);
                };
            }
            
            // ÂºæÊÄß‰øÇÊï∞„Å®Èôç‰ºèÂº∑Â∫¶„ÅÆÈÅ∏Êäû„Éï„Ç£„Éº„É´„Éâ„Å´„Ç§„Éô„É≥„Éà„É™„Çπ„Éä„Éº„ÇíË®≠ÂÆö
            setTimeout(() => {
                const eSelect = document.getElementById(`member-e-${nodeI}-${nodeJ}-select`);
                const eInput = document.getElementById(`member-e-${nodeI}-${nodeJ}-input`);
                const strengthSelect = document.getElementById(`member-strength-${nodeI}-${nodeJ}-select`);
                const strengthInput = document.getElementById(`member-strength-${nodeI}-${nodeJ}-input`);
                
                if (eSelect && eInput) {
                    eSelect.addEventListener('change', function() {
                        if (this.value !== 'custom') {
                            eInput.value = this.value;
                        }
                        eInput.readOnly = (this.value !== 'custom');
                        eInput.dispatchEvent(new Event('change'));
                    });
                }
                
                if (strengthSelect && strengthInput) {
                    strengthSelect.addEventListener('change', function() {
                        if (this.value !== 'custom') {
                            strengthInput.value = this.value;
                        }
                        strengthInput.readOnly = (this.value !== 'custom');
                        strengthInput.dispatchEvent(new Event('change'));
                    });
                }
            }, 100);
            
            return newRow;
        } catch (error) {
            console.error('addMemberToTable error:', error);
            return null;
        }
    };

    const generateFrame = () => {
        try {
            const floors = parseInt(floorsInput.value) || 1;
            const spans = parseInt(spansInput.value) || 1;
            const spanLength = parseFloat(spanLengthInput.value) || 6.0;
            const floorHeight = parseFloat(floorHeightInput.value) || 3.5;
            const fixBase = fixBaseCheckbox.checked;
            const startX = parseFloat(startXInput.value) || 0.0;
            const startY = parseFloat(startYInput.value) || 0.0;
            
            // ÂÖ•ÂäõÂÄ§Ê§úË®º
            if (floors < 1 || floors > 20) {
                safeAlert('Â±§Êï∞„ÅØ1„Åã„Çâ20„ÅÆÈñì„ÅßË®≠ÂÆö„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ');
                return;
            }
            if (spans < 1 || spans > 20) {
                safeAlert('„Çπ„Éë„É≥Êï∞„ÅØ1„Åã„Çâ20„ÅÆÈñì„ÅßË®≠ÂÆö„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ');
                return;
            }
            if (spanLength <= 0 || spanLength > 50) {
                safeAlert('„Çπ„Éë„É≥Èï∑„ÅØ0„Çà„ÇäÂ§ß„Åç„Åè50‰ª•‰∏ã„ÅßË®≠ÂÆö„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ');
                return;
            }
            if (floorHeight <= 0 || floorHeight > 20) {
                safeAlert('ÈöéÈ´ò„ÅØ0„Çà„ÇäÂ§ß„Åç„Åè20‰ª•‰∏ã„ÅßË®≠ÂÆö„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ');
                return;
            }
            
            // ÁèæÂú®„ÅÆ„ÉÜ„Éº„Éñ„É´„Éá„Éº„Çø„Çí„ÇØ„É™„Ç¢ÔºàÁ¢∫Ë™ç„ÉÄ„Ç§„Ç¢„É≠„Ç∞Ôºâ
            const nodesTable = document.getElementById('nodes-table')?.getElementsByTagName('tbody')[0];
            const membersTable = document.getElementById('members-table')?.getElementsByTagName('tbody')[0];
            
            const existingNodes = nodesTable?.rows.length > 0;
            const existingMembers = membersTable?.rows.length > 0;
            
            if (existingNodes || existingMembers) {
                if (!confirm('ÁèæÂú®„ÅÆ„É¢„Éá„É´„Éá„Éº„Çø„ÅØ„ÇØ„É™„Ç¢„Åï„Çå„Åæ„Åô„ÄÇÁ∂öË°å„Åó„Åæ„Åô„ÅãÔºü')) {
                    return;
                }
                
                // „ÉÜ„Éº„Éñ„É´„Çí„ÇØ„É™„Ç¢
                clearAllTables();
            }
            
            // ÁØÄÁÇπÁîüÊàê„Å®„ÉÜ„Éº„Éñ„É´ËøΩÂä†
            let nodeIndex = 0;
            const totalNodes = (floors + 1) * (spans + 1);
            
            for (let floor = 0; floor <= floors; floor++) {
                for (let span = 0; span <= spans; span++) {
                    const x = startX + span * spanLength;
                    const y = startY + floor * floorHeight;
                    
                    let fixity = 'free';
                    if (floor === 0) {
                        if (fixBase) {
                            fixity = 'fixed'; // Âü∫Á§éÈÉ®„ÅØÂõ∫ÂÆöÊîØÁÇπ
                        } else {
                            fixity = 'pin';   // Âü∫Á§éÈÉ®„ÅØ„Éî„É≥ÊîØÁÇπ
                        }
                    }
                    
                    // ÁØÄÁÇπ„Çí„ÉÜ„Éº„Éñ„É´„Å´ËøΩÂä†
                    addNodeToTable(nodeIndex + 1, x.toFixed(2), y.toFixed(2), fixity);
                    nodeIndex++;
                }
            }
            
            // ÈÉ®ÊùêÁîüÊàê„Å®„ÉÜ„Éº„Éñ„É´ËøΩÂä†
            let memberIndex = 0;
            const nodesPerFloor = spans + 1;
            
            // Ê∞¥Âπ≥ÈÉ®ÊùêÔºàÊ¢ÅÔºâ„ÅÆÁîüÊàê
            for (let floor = 0; floor <= floors; floor++) {
                for (let span = 0; span < spans; span++) {
                    const nodeI = floor * nodesPerFloor + span + 1; // 1„Åã„ÇâÂßã„Åæ„ÇãÁØÄÁÇπÁï™Âè∑
                    const nodeJ = nodeI + 1;
                    
                    addMemberToTable(memberIndex + 1, nodeI, nodeJ, 210000, 30000, 0.3, 0.0002083, 0.0002083, 0.0001, 'rigid', 'rigid');
                    memberIndex++;
                }
            }
            
            // ÂûÇÁõ¥ÈÉ®ÊùêÔºàÊü±Ôºâ„ÅÆÁîüÊàê
            for (let floor = 0; floor < floors; floor++) {
                for (let span = 0; span <= spans; span++) {
                    const nodeI = floor * nodesPerFloor + span + 1; // 1„Åã„ÇâÂßã„Åæ„ÇãÁØÄÁÇπÁï™Âè∑Ôºà‰∏ãÂ±§Ôºâ
                    const nodeJ = (floor + 1) * nodesPerFloor + span + 1; // ‰∏äÂ±§
                    
                    addMemberToTable(memberIndex + 1, nodeI, nodeJ, 210000, 30000, 0.3, 0.0002083, 0.0002083, 0.0001, 'rigid', 'rigid');
                    memberIndex++;
                }
            }
            
            // „É¢„Éº„ÉÄ„É´„ÇíÈñâ„Åò„Çã
            hideModal();
            
            // „ÉÜ„Éº„Éñ„É´Áï™Âè∑„ÇíÊâãÂãï„ÅßÊõ¥Êñ∞
            const nodesTableForUpdate = document.getElementById('nodes-table')?.getElementsByTagName('tbody')[0];
            const membersTableForUpdate = document.getElementById('members-table')?.getElementsByTagName('tbody')[0];
            
            if (nodesTableForUpdate) {
                Array.from(nodesTableForUpdate.rows).forEach((row, i) => {
                    row.cells[0].textContent = i + 1;
                });
            }
            
            if (membersTableForUpdate) {
                Array.from(membersTableForUpdate.rows).forEach((row, i) => {
                    row.cells[0].textContent = i + 1;
                });
            }
            
            // Ëß£Êûê„Å®ÊèèÁîª„ÇíÂÆüË°å
            if (typeof runFullAnalysis === 'function') {
                runFullAnalysis();
            }
            
            // „Ç≠„É£„É≥„Éê„Çπ„ÇíÂÜçÊèèÁîª
            if (typeof drawOnCanvas === 'function') {
                drawOnCanvas();
            }
            
            // Ëá™Âãï„Çπ„Ç±„Éº„É™„É≥„Ç∞„ÇíÂÆüË°å
            setTimeout(() => {
                try {
                    console.log('„Éï„É¨„Éº„É†„Ç∏„Çß„Éç„É¨„Éº„Çø„Éº: Ëá™Âãï„Çπ„Ç±„Éº„É™„É≥„Ç∞„ÇíÂÆüË°å‰∏≠...');
                    
                    // ÊñπÊ≥ï1: Ëá™Âãï„Çπ„Ç±„Éº„É´„Éú„Çø„É≥„Çí„ÇØ„É™„ÉÉ„ÇØ„Åó„Å¶ÂÆüË°å
                    const autoScaleBtn = document.getElementById('auto-scale-btn');
                    if (autoScaleBtn) {
                        console.log('„Éï„É¨„Éº„É†„Ç∏„Çß„Éç„É¨„Éº„Çø„Éº: Ëá™Âãï„Çπ„Ç±„Éº„É´„Éú„Çø„É≥„ÇíÁô∫Ë¶ã„ÄÅ„ÇØ„É™„ÉÉ„ÇØÂÆüË°å');
                        autoScaleBtn.click();
                        return;
                    }
                    
                    // ÊñπÊ≥ï2: triggerAutoScaleÈñ¢Êï∞„ÇíÂëº„Å≥Âá∫„Åó
                    if (typeof window.triggerAutoScale === 'function') {
                        console.log('„Éï„É¨„Éº„É†„Ç∏„Çß„Éç„É¨„Éº„Çø„Éº: triggerAutoScaleÈñ¢Êï∞„ÇíÂÆüË°å');
                        window.triggerAutoScale();
                        return;
                    }
                    
                    // ÊñπÊ≥ï3: panZoomState„Å´Áõ¥Êé•„Ç¢„ÇØ„Çª„Çπ
                    if (typeof window.panZoomState !== 'undefined') {
                        console.log('„Éï„É¨„Éº„É†„Ç∏„Çß„Éç„É¨„Éº„Çø„Éº: panZoomStateÁõ¥Êé•„É™„Çª„ÉÉ„Éà');
                        window.panZoomState.isInitialized = false;
                        drawOnCanvas();
                        return;
                    }
                    
                    // ÊñπÊ≥ï4: ÊúÄÂæå„ÅÆÊâãÊÆµ„Å®„Åó„Å¶ÂÜçÊèèÁîª„ÅÆ„ÅøÂÆüË°å
                    console.log('„Éï„É¨„Éº„É†„Ç∏„Çß„Éç„É¨„Éº„Çø„Éº: ÈÄöÂ∏∏„ÅÆÂÜçÊèèÁîª„ÅÆ„ÅøÂÆüË°å');
                    drawOnCanvas();
                    
                } catch (error) {
                    console.error('„Éï„É¨„Éº„É†„Ç∏„Çß„Éç„É¨„Éº„Çø„Éº: Ëá™Âãï„Çπ„Ç±„Éº„É™„É≥„Ç∞„Ç®„É©„Éº:', error);
                    // „Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Å¶„ÇÇÊúÄ‰ΩéÈôêÂÜçÊèèÁîª„ÅØÂÆüË°å
                    try {
                        drawOnCanvas();
                    } catch (drawError) {
                        console.error('„Éï„É¨„Éº„É†„Ç∏„Çß„Éç„É¨„Éº„Çø„Éº: ÂÜçÊèèÁîª„Ç®„É©„Éº:', drawError);
                    }
                }
            }, 500); // „Åï„Çâ„Å´ÈÅÖÂª∂„ÇíÂ¢ó„ÇÑ„Åó„Å¶Á¢∫ÂÆü„Å´ÂÆüË°å
            
            // ÊàêÂäü„É°„ÉÉ„Çª„Éº„Ç∏
            const totalMembers = memberIndex;
            
            // „Ç¢„É©„Éº„ÉàÂâç„Å´„ÇÇËá™Âãï„Çπ„Ç±„Éº„É™„É≥„Ç∞„ÇíË©¶Ë°å
            setTimeout(() => {
                const autoScaleBtn = document.getElementById('auto-scale-btn');
                if (autoScaleBtn) {
                    console.log('„Éï„É¨„Éº„É†„Ç∏„Çß„Éç„É¨„Éº„Çø„Éº: „Ç¢„É©„Éº„ÉàÂâçÊúÄÁµÇËá™Âãï„Çπ„Ç±„Éº„É™„É≥„Ç∞Ë©¶Ë°å');
                    autoScaleBtn.click();
                }
            }, 700);
            
            safeAlert(`„Éï„É¨„Éº„É†ÊßãÈÄ†„ÇíÁîüÊàê„Åó„Åæ„Åó„ÅüÔºÅ\nÁØÄÁÇπÊï∞: ${totalNodes}\nÈÉ®ÊùêÊï∞: ${totalMembers}`);
            
        } catch (error) {
            console.error('„Éï„É¨„Éº„É†ÁîüÊàê„Ç®„É©„Éº:', error);
            safeAlert('„Éï„É¨„Éº„É†ÁîüÊàê‰∏≠„Å´„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü: ' + error.message);
        }
    };
    
    // „Ç§„Éô„É≥„Éà„É™„Çπ„Éä„Éº
    frameGeneratorBtn.addEventListener('click', showModal);
    modalClose.addEventListener('click', hideModal);
    cancelBtn.addEventListener('click', hideModal);
    generateBtn.addEventListener('click', generateFrame);
    
    // „É¢„Éº„ÉÄ„É´ËÉåÊôØ„ÇØ„É™„ÉÉ„ÇØ„ÅßÈñâ„Åò„Çã
    frameGeneratorModal.addEventListener('click', (e) => {
        if (e.target === frameGeneratorModal) {
            hideModal();
        }
    });
    
    // ESC„Ç≠„Éº„Åß„É¢„Éº„ÉÄ„É´„ÇíÈñâ„Åò„Çã
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && frameGeneratorModal.style.display === 'flex') {
            hideModal();
        }
    });
    
    // ÂàùÊúü„Éó„É¨„Éì„É•„ÉºÊõ¥Êñ∞
    updatePreview();
};

// „Éï„É¨„Éº„É†„Ç∏„Çß„Éç„É¨„Éº„Çø„Éº„ÅÆÂàùÊúüÂåñ„ÇíÂÆüË°å
document.addEventListener('DOMContentLoaded', () => {
    // ‰ªñ„ÅÆÂàùÊúüÂåñ„Ç≥„Éº„Éâ„ÅÆÂæå„ÅßÂÆüË°å„Åï„Çå„Çã„Çà„ÅÜ„Å´ÈÅÖÂª∂
    setTimeout(() => {
        console.log('„Éï„É¨„Éº„É†„Ç∏„Çß„Éç„É¨„Éº„Çø„Éº„ÅÆÂàùÊúüÂåñ„ÇíÈñãÂßã');
        try {
            initializeFrameGenerator();
            console.log('„Éï„É¨„Éº„É†„Ç∏„Çß„Éç„É¨„Éº„Çø„Éº„ÅÆÂàùÊúüÂåñ„ÅåÂÆå‰∫Ü');
        } catch (error) {
            console.error('„Éï„É¨„Éº„É†„Ç∏„Çß„Éç„É¨„Éº„Çø„Éº„ÅÆÂàùÊúüÂåñ„Ç®„É©„Éº:', error);
        }
    }, 100);
});

// Added to handle 'applySection' message from steel_selector
window.addEventListener('message', function(event) {
    if (event.defaultPrevented) {
        return;
    }

    if (event.data && event.data.type === 'applySection') {
        event.preventDefault();

        const sectionData = event.data.section;
        if (!sectionData) {
            console.error('applySection message is missing section data.');
            return;
        }

        if (!window.selectedMembers || window.selectedMembers.size === 0) {
            alert('Êñ≠Èù¢„ÇíÈÅ©Áî®„Åô„ÇãÈÉ®Êùê„ÇíÂÖà„Å´ÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ');
            return;
        }

        try {
            if (typeof pushState === 'function') {
                pushState();
            }

            let updatedCount = 0;
            for (const memberIndex of window.selectedMembers) {
                if (typeof updateMemberSectionInTable === 'function') {
                    updateMemberSectionInTable(memberIndex, sectionData);
                    updatedCount++;
                } else {
                    console.error('updateMemberSectionInTable function not found.');
                    break;
                }
            }

            if (updatedCount > 0) {
                console.log(`${updatedCount} ÂÄã„ÅÆÈÉ®Êùê„ÅÆÊñ≠Èù¢„ÇíÊõ¥Êñ∞„Åó„Åæ„Åó„Åü„ÄÇ`);
                
                if (typeof runFullAnalysis === 'function') {
                    runFullAnalysis(); 
                } else if (typeof drawOnCanvas === 'function') {
                    drawOnCanvas();
                }

                if (window.viewerWindow && !window.viewerWindow.closed) {
                     try {
                        const { nodes, members } = parseInputs();
                        const dataToSend = { nodes, members };
                        
                        localStorage.setItem('latestModelForViewer', JSON.stringify(dataToSend));
                        window.viewerWindow.postMessage({ type: 'updateModel', data: dataToSend }, '*');
                        
                        console.log('3D Viewer „Å´„É¢„Éá„É´Êõ¥Êñ∞„ÇíÈÄöÁü•„Åó„Åæ„Åó„Åü (Êñ≠Èù¢ÈÅ©Áî®Âæå)„ÄÇ');
                     } catch(e) {
                        console.error("3D Viewer„Å∏„ÅÆÊõ¥Êñ∞ÈÄöÁü•„Å´Â§±Êïó„Åó„Åæ„Åó„Åü (Êñ≠Èù¢ÈÅ©Áî®Âæå): ", e);
                     }
                }
            }
        } catch (error) {
            console.error('Êñ≠Èù¢„ÅÆ‰∏ÄÊã¨ÈÅ©Áî®‰∏≠„Å´„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü:', error);
            alert('Êñ≠Èù¢„ÅÆÈÅ©Áî®‰∏≠„Å´„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü„ÄÇË©≥Á¥∞„ÅØ„Ç≥„É≥„ÇΩ„Éº„É´„ÇíÁ¢∫Ë™ç„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ');
        }
    }
});

// „Éá„Éê„ÉÉ„Ç∞Áî®Ôºö„Éï„É¨„Éº„É†„Ç∏„Çß„Éç„É¨„Éº„Çø„ÉºË¶ÅÁ¥†„ÅÆÂ≠òÂú®„ÇíÁ¢∫Ë™ç„Åô„ÇãÈñ¢Êï∞
window.checkFrameGenerator = () => {
    console.log('=== „Éï„É¨„Éº„É†„Ç∏„Çß„Éç„É¨„Éº„Çø„ÉºË¶ÅÁ¥†„ÉÅ„Çß„ÉÉ„ÇØ ===');
    
    const elements = [
        'frame-generator-btn',
        'frame-generator-modal', 
        'modal-close',
        'floors-input',
        'spans-input',
        'span-length-input',
        'floor-height-input',
        'fix-base',
        'start-x',
        'start-y',
        'cancel-btn',
        'generate-btn'
    ];
    
    elements.forEach(id => {
        const element = document.getElementById(id);
        console.log(`${id}: ${element ? 'Ë¶ã„Å§„Åã„Çä„Åæ„Åó„Åü' : 'Ë¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì'}`);
    });
};

// ========================================
// 3D„Éì„É•„Éº„Ç¢Ê©üËÉΩÔºàÁã¨Á´ã„Ç¶„Ç£„É≥„Éâ„Ç¶ÁâàÔºâ
// ========================================

// 3D„Éì„É•„Éº„Ç¢„Ç¶„Ç£„É≥„Éâ„Ç¶„ÅÆÂèÇÁÖß„Çí‰øùÊåÅ
let viewerWindow = null;

// 3D„Éì„É•„Éº„Ç¢„Å´„É¢„Éá„É´„Éá„Éº„Çø„ÇíÈÄÅ‰ø°„Åô„ÇãÈñ¢Êï∞
function sendModelToViewer() {
    if (viewerWindow && !viewerWindow.closed) {
        try {
            const modelData = parseInputs();
            console.log('üîß 3D„Éì„É•„Éº„Ç¢„Å´ÈÄÅ‰ø°„Åô„Çã„É¢„Éá„É´„Éá„Éº„Çø:', modelData);
            console.log('üîß ÈÉ®Êùê„ÅÆÊñ≠Èù¢ÊÉÖÂ†±:', modelData.members.map((m, i) => ({
                memberIndex: i + 1,
                sectionInfo: m.sectionInfo,
                sectionAxis: m.sectionAxis
            })));
            // Always write latest model to localStorage as a fallback
            try {
                localStorage.setItem('latestModelForViewer', JSON.stringify(modelData));
                console.log('üîß latestModelForViewer written to localStorage (fallback)');
            } catch (lsErr) {
                console.warn('sendModelToViewer: failed to write latestModelForViewer to localStorage', lsErr);
            }

            // Then try to postMessage to the viewer window if available
            viewerWindow.postMessage({ type: 'updateModel', data: modelData }, '*');
        } catch (error) {
            console.error("3D„Éì„É•„Éº„Ç¢„Å∏„ÅÆ„É¢„Éá„É´Êõ¥Êñ∞ÈÄÅ‰ø°„Å´Â§±Êïó„Åó„Åæ„Åó„Åü:", error);
        }
    } else {
        viewerWindow = null;
    }
}

document.addEventListener('DOMContentLoaded', () => {
    const view3dBtn = document.getElementById('view-3d-btn');

    if (view3dBtn) {
        view3dBtn.addEventListener('click', () => {
            // Êó¢„Å´Èñã„ÅÑ„Å¶„ÅÑ„ÇãÂ†¥Âêà„ÅØ„Éï„Ç©„Éº„Ç´„Çπ„Åô„Çã„Å†„Åë
            if (viewerWindow && !viewerWindow.closed) {
                viewerWindow.focus();
                return;
            }

            try {
                const { nodes } = parseInputs();
                if (nodes.length === 0) {
                    safeAlert('3DË°®Á§∫„Åô„Çã„É¢„Éá„É´„Åå„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ');
                    return;
                }

                // Êñ∞„Åó„ÅÑ„Ç¶„Ç£„É≥„Éâ„Ç¶„Åß3D„Éì„É•„Éº„Ç¢„ÇíÈñã„Åè
                viewerWindow = window.open('viewer_3d.html', 'Statica3DViewer', 'width=800,height=600,resizable=yes,scrollbars=yes');

                if (!viewerWindow) {
                    safeAlert('„Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó„Åå„Éñ„É≠„ÉÉ„ÇØ„Åï„Çå„ÅüÂèØËÉΩÊÄß„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ3D„Éì„É•„Éº„Ç¢„ÇíÈñã„Åë„Åæ„Åõ„Çì„Åß„Åó„Åü„ÄÇ');
                    return;
                }

                // 1ÁßíÂæå„Å´ÊúÄÂàù„ÅÆ„É¢„Éá„É´„Éá„Éº„Çø„ÇíÈÄÅ‰ø°
                setTimeout(() => {
                    sendModelToViewer();
                }, 1000);

            } catch (error) {
                console.error('3D„Éì„É•„Éº„Ç¢„ÅÆËµ∑Âãï„Å´Â§±Êïó„Åó„Åæ„Åó„Åü:', error);
                safeAlert('3D„Éì„É•„Éº„Ç¢„ÅÆËµ∑Âãï„Å´Â§±Êïó„Åó„Åæ„Åó„Åü: ' + error.message);
            }
        });
    }
});

// ==========================================================================
// llama-3.3-70b-versatile„Å´„Çà„ÇãAI„É¢„Éá„É´ÁîüÊàêÊ©üËÉΩ
// ==========================================================================

/**
 * llama-3.3-70b-versatile„Çí‰ΩøÁî®„Åó„Å¶Ëá™ÁÑ∂Ë®ÄË™û„Åã„Çâ„É¢„Éá„É´„ÇíÁîüÊàê„Åô„Çã„É°„Ç§„É≥Èñ¢Êï∞
 * @param {string} userPrompt „É¶„Éº„Ç∂„Éº„ÅåÂÖ•Âäõ„Åó„ÅüÊåáÁ§∫
 */
// AIÁîüÊàê„Ç≠„É£„É≥„Çª„É´Áî®„ÅÆ„Ç∞„É≠„Éº„Éê„É´Â§âÊï∞
let aiGenerationCancelled = false;
let aiGenerationAbortController = null;
let aiGenerationPopup = null;
let isAIGenerationInProgress = false; // AIÁîüÊàê‰∏≠„ÅÆ„Éï„É©„Ç∞
let autoRetryCount = 0; // Ëá™ÂãïÂÜçË©¶Ë°åÂõûÊï∞
const MAX_AUTO_RETRY = 5; // Ëá™ÂãïÂÜçË©¶Ë°å„ÅÆÊúÄÂ§ßÂõûÊï∞

// „Ç∞„É≠„Éº„Éê„É´Â§âÊï∞„Å®„Åó„Å¶Êñ≠Èù¢ÊÉÖÂ†±„Éê„ÉÉ„ÇØ„Ç¢„ÉÉ„Éó„ÇíÂÆöÁæ©
let globalPreAISectionInfoBackup = [];

// AIÁîüÊàê‰∏≠„ÅÆ„Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó„ÇíË°®Á§∫„Åô„ÇãÈñ¢Êï∞
function showAIGenerationPopup() {
    // Êó¢Â≠ò„ÅÆ„Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó„Åå„ÅÇ„Çå„Å∞ÂâäÈô§
    if (aiGenerationPopup) {
        aiGenerationPopup.remove();
    }

    // „Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó„Çí‰ΩúÊàê
    aiGenerationPopup = document.createElement('div');
    aiGenerationPopup.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: white;
        border: 2px solid #6f42c1;
        border-radius: 8px;
        padding: 20px;
        box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        z-index: 10000;
        text-align: center;
        min-width: 300px;
    `;

    aiGenerationPopup.innerHTML = `
        <div style="margin-bottom: 15px;">
            <div style="display: inline-block; width: 20px; height: 20px; border: 3px solid #f3f3f3; border-top: 3px solid #6f42c1; border-radius: 50%; animation: spin 1s linear infinite; margin-right: 10px;"></div>
            <span style="font-size: 16px; font-weight: bold; color: #6f42c1;">AI„Åß„É¢„Éá„É´ÁîüÊàê‰∏≠...</span>
        </div>
        <div style="margin-bottom: 15px; color: #666; font-size: 14px;">
            „Åó„Å∞„Çâ„Åè„ÅäÂæÖ„Å°„Åè„Å†„Åï„ÅÑ„ÄÇÁîüÊàê„ÅåÂÆå‰∫Ü„Åô„Çã„Åæ„Åß„Åì„ÅÆÁîªÈù¢„ÅåË°®Á§∫„Åï„Çå„Åæ„Åô„ÄÇ
        </div>
        <button id="ai-cancel-btn" style="padding: 8px 20px; background-color: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px;">„Ç≠„É£„É≥„Çª„É´</button>
        <style>
            @keyframes spin {
                0% { transform: rotate(0deg); }
                100% { transform: rotate(360deg); }
            }
        </style>
    `;

    // „Ç≠„É£„É≥„Çª„É´„Éú„Çø„É≥„ÅÆ„Ç§„Éô„É≥„Éà„É™„Çπ„Éä„Éº„ÇíËøΩÂä†
    const cancelBtn = aiGenerationPopup.querySelector('#ai-cancel-btn');
    cancelBtn.addEventListener('click', () => {
        aiGenerationCancelled = true;
        if (aiGenerationAbortController) {
            aiGenerationAbortController.abort();
        }
        hideAIGenerationPopup();
        
        // „Éú„Çø„É≥„ÅÆÁä∂ÊÖã„Çí„É™„Çª„ÉÉ„Éà
        const aiGenerateBtn = document.getElementById('generate-model-btn');
        const aiStatus = document.getElementById('gemini-status-indicator');
        if (aiGenerateBtn) {
            aiGenerateBtn.disabled = false;
            aiGenerateBtn.textContent = 'AI„ÅßÁîüÊàê';
        }
        if (aiStatus) {
            aiStatus.style.display = 'none';
        }
    });

    document.body.appendChild(aiGenerationPopup);
}

// AIÁîüÊàê‰∏≠„ÅÆ„Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó„ÇíÈùûË°®Á§∫„Å´„Åô„ÇãÈñ¢Êï∞
function hideAIGenerationPopup() {
    if (aiGenerationPopup) {
        aiGenerationPopup.remove();
        aiGenerationPopup = null;
    }
}

// AIÁîüÊàê‰∏≠„ÅØ„Ç¢„É©„Éº„Éà„ÇíÈùûË°®Á§∫„Å´„Åô„ÇãÈñ¢Êï∞
function safeAlert(message) {
    if (isAIGenerationInProgress) {
        console.log('AIÁîüÊàê‰∏≠: „Ç¢„É©„Éº„Éà„Çí„Çπ„Ç≠„ÉÉ„Éó„Åó„Åæ„Åó„Åü -', message);
        return;
    }
    alert(message);
}

// AIÁîüÊàê‰∏≠„ÅØconfirm„ÇíÈùûË°®Á§∫„Å´„Åô„ÇãÈñ¢Êï∞
function safeConfirm(message) {
    if (isAIGenerationInProgress) {
        console.log('AIÁîüÊàê‰∏≠: confirm„Çí„Çπ„Ç≠„ÉÉ„Éó„Åó„Å¶Ëá™Âãï„Åßtrue„ÇíËøî„Åó„Åæ„Åô -', message);
        return true; // AIÁîüÊàê‰∏≠„ÅØËá™Âãï„Åßtrue„ÇíËøî„Åó„Å¶„É¢„Éá„É´„ÇíÈÅ©Áî®
    }
    return confirm(message);
}

// ÂÜÖÈÉ®Èñ¢Êï∞Ôºö„Éù„ÉÉ„Éó„Ç¢„ÉÉ„ÉóË°®Á§∫„Å™„Åó„ÅßAIÁîüÊàê„ÇíÂÆüË°å
async function generateModelWithAIInternal(userPrompt, mode = 'new', retryCount = 0, currentModel = null) {
    console.log('üîç generateModelWithAIInternalÂëº„Å≥Âá∫„ÅóÊôÇÂàª:', new Date().toISOString());
    console.log('üîç generateModelWithAIInternalÂëº„Å≥Âá∫„Åó„Éë„É©„É°„Éº„Çø:', { userPrompt, mode, retryCount, currentModel });
    
    // Èñ¢Êï∞ÈñãÂßãÊôÇ„ÅÆÊñ≠Èù¢ÊÉÖÂ†±Áä∂ÊÖã„ÇíË®òÈå≤
    const membersTable = document.getElementById('members-table');
    globalPreAISectionInfoBackup = []; // „Ç∞„É≠„Éº„Éê„É´Â§âÊï∞„Çí„É™„Çª„ÉÉ„Éà
    if (membersTable) {
        const rows = membersTable.querySelectorAll('tbody tr');
        console.log('üîç generateModelWithAIInternalÈñãÂßãÊôÇ„ÅÆÊñ≠Èù¢ÊÉÖÂ†±Áä∂ÊÖã:');
        rows.forEach((row, index) => {
            const sectionInfo = row.dataset.sectionInfo;
            const sectionNameCell = row.querySelector('.section-name-cell');
            const sectionAxisCell = row.querySelector('.section-axis-cell');
            console.log(`üîç ÈÉ®Êùê${index + 1}: dataset.sectionInfo=${!!sectionInfo}, Èï∑„Åï=${sectionInfo ? sectionInfo.length : 0}, Êñ≠Èù¢ÂêçÁß∞="${sectionNameCell ? sectionNameCell.textContent : 'N/A'}", Ëª∏ÊñπÂêë="${sectionAxisCell ? sectionAxisCell.textContent : 'N/A'}"`);
            
            // AI‰øÆÊ≠£Âá¶ÁêÜÂâç„Å´Êñ≠Èù¢ÊÉÖÂ†±„Çí„Éê„ÉÉ„ÇØ„Ç¢„ÉÉ„Éó
            let parsedSectionInfo = null;
            if (sectionInfo) {
                try {
                    const decoded = decodeURIComponent(sectionInfo);
                    parsedSectionInfo = JSON.parse(decoded);
                    console.log(`‚úÖ [AIÂâç„Éê„ÉÉ„ÇØ„Ç¢„ÉÉ„Éó] ÈÉ®Êùê${index + 1}„ÅÆÊñ≠Èù¢ÊÉÖÂ†±„Çí„Éê„ÉÉ„ÇØ„Ç¢„ÉÉ„Éó:`, parsedSectionInfo);
                } catch (error) {
                    console.error(`‚ùå [AIÂâç„Éê„ÉÉ„ÇØ„Ç¢„ÉÉ„Éó] ÈÉ®Êùê${index + 1}„ÅÆÊñ≠Èù¢ÊÉÖÂ†±„ÅÆ„Éë„Éº„Çπ„Å´Â§±Êïó:`, error);
                }
            } else {
                console.log(`‚ö†Ô∏è [AIÂâç„Éê„ÉÉ„ÇØ„Ç¢„ÉÉ„Éó] ÈÉ®Êùê${index + 1}„ÅÆdataset.sectionInfo„ÅåÂ≠òÂú®„Åó„Åæ„Åõ„Çì`);
            }
            
            globalPreAISectionInfoBackup[index] = {
                sectionName: sectionNameCell ? sectionNameCell.textContent : '',
                sectionAxis: sectionAxisCell ? sectionAxisCell.textContent : '',
                sectionInfo: parsedSectionInfo,
                sectionInfoEncoded: row.dataset.sectionInfoEncoded || '',
                sectionLabel: row.dataset.sectionLabel || '',
                sectionSummary: row.dataset.sectionSummary || '',
                sectionSource: row.dataset.sectionSource || '',
                sectionAxisKey: row.dataset.sectionAxisKey || '',
                sectionAxisMode: row.dataset.sectionAxisMode || '',
                sectionAxisLabel: row.dataset.sectionAxisLabel || ''
            };
        });
        console.log('üîß AI‰øÆÊ≠£Âá¶ÁêÜÂâç„ÅÆÊñ≠Èù¢ÊÉÖÂ†±„Éê„ÉÉ„ÇØ„Ç¢„ÉÉ„ÉóÂÆå‰∫Ü:', globalPreAISectionInfoBackup);
    }
    
    const aiGenerateBtn = document.getElementById('generate-model-btn');
    const aiStatus = document.getElementById('ai-status-indicator');

    // Check if required elements exist
    if (!aiGenerateBtn) {
        console.error('Error: Could not find element with id "generate-model-btn"');
        safeAlert('AIÁîüÊàê„Éú„Çø„É≥„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„ÄÇ„Éö„Éº„Ç∏„ÇíÂÜçË™≠„ÅøËæº„Åø„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ');
        return;
    }

    if (!aiStatus) {
        console.error('Error: Could not find element with id "ai-status-indicator"');
        safeAlert('AI„Çπ„ÉÜ„Éº„Çø„ÇπË°®Á§∫Ë¶ÅÁ¥†„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„ÄÇ„Éö„Éº„Ç∏„ÇíÂÜçË™≠„ÅøËæº„Åø„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ');
        return;
    }

    // llama-3.3-70b-versatileÂ∞ÇÁî®API
    const API_URL = '/api/generate-model';
    const MAX_RETRIES = 5; // „Çµ„Éº„Éê„Éº„Çµ„Ç§„Éâ„Å®Âêà„Çè„Åõ„Å¶5Âõû„Å´Â¢óÂä†
    const BASE_DELAY = 3000; // 3Áßí„Å´Â¢óÂä†
    const MAX_DELAY = 30000; // ÊúÄÂ§ß30Áßí

    // UI„Çí„ÄåÁîüÊàê‰∏≠„Äç„ÅÆÁä∂ÊÖã„Å´„Åó„Åæ„Åô
    aiGenerateBtn.disabled = true;
    aiGenerateBtn.textContent = 'ÁîüÊàê‰∏≠...';
    aiStatus.style.display = 'block';
    
    // AIÁîüÊàê‰∏≠„ÅÆ„Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó„ÇíË°®Á§∫
    showAIGenerationPopup();
    
    // „É™„Éà„É©„Ç§‰∏≠„ÅÆÂ†¥Âêà„ÅØÁâπÂà•„Å™„É°„ÉÉ„Çª„Éº„Ç∏„ÇíË°®Á§∫
    if (retryCount > 0) {
        aiStatus.textContent = `üîÑ „É™„Éà„É©„Ç§‰∏≠... (${retryCount}/${MAX_RETRIES})`;
        aiStatus.style.color = '#ffc107';
    } else {
        aiStatus.textContent = mode === 'edit' ? 'üß† AI„Åå„É¢„Éá„É´„ÇíÁ∑®ÈõÜ‰∏≠„Åß„Åô...' : 'üß† AI„Åå„É¢„Éá„É´„ÇíÁîüÊàê‰∏≠„Åß„Åô...';
        aiStatus.style.color = '#005A9C';
    }

    try {
        // ÁèæÂú®„ÅÆ„É¢„Éá„É´ÊÉÖÂ†±„ÇíÂèñÂæóÔºàËøΩÂä†Á∑®ÈõÜ„É¢„Éº„Éâ„ÅÆÂ†¥ÂêàÔºâ
        let currentModelData = null;
        if (mode === 'edit') {
            currentModelData = getCurrentModelData();
            console.log('üîç ËøΩÂä†Á∑®ÈõÜ„É¢„Éº„Éâ: ÁèæÂú®„ÅÆ„É¢„Éá„É´ÊÉÖÂ†±„ÇíÂèñÂæó„Åó„Åæ„Åó„Åü', currentModelData);
        }

        const requestBody = {
            prompt: userPrompt,
            mode: mode,
            currentModel: currentModelData
        };

        console.log(`üîç AI„É™„ÇØ„Ç®„Çπ„ÉàÈÄÅ‰ø°‰∏≠... („É™„Éà„É©„Ç§: ${retryCount}/${MAX_RETRIES})`);

        // „Ç≠„É£„É≥„Çª„É´„ÉÅ„Çß„ÉÉ„ÇØ
        if (aiGenerationCancelled) {
            console.log('üîç AIÁîüÊàê„Åå„Ç≠„É£„É≥„Çª„É´„Åï„Çå„Åæ„Åó„Åü');
            throw new Error('AIÁîüÊàê„Åå„Ç≠„É£„É≥„Çª„É´„Åï„Çå„Åæ„Åó„Åü');
        }

        // API„É™„ÇØ„Ç®„Çπ„Éà„ÇíÈÄÅ‰ø°ÔºàAbortController„ÇíËøΩÂä†Ôºâ
        console.error('üîç „Çµ„Éº„Éê„Éº„Çµ„Ç§„ÉâAPIÂëº„Å≥Âá∫„ÅóÈñãÂßã:');
        console.error('üîç API_URL:', API_URL);
        console.error('üîç „É™„ÇØ„Ç®„Çπ„Éà„Éú„Éá„Ç£:', JSON.stringify(requestBody, null, 2));
        console.error('üîç fetchÈñãÂßãÊôÇÂàª:', new Date().toISOString());
        
        // „Çø„Ç§„É†„Ç¢„Ç¶„ÉàÂà∂Âæ°
        const timeoutController = new AbortController();
        const timeoutId = setTimeout(() => {
            console.error('üîç fetch„Çø„Ç§„É†„Ç¢„Ç¶„ÉàÔºà300ÁßíÔºâ');
            timeoutController.abort('Request timeout after 300 seconds');
        }, 300000); // 300Áßí„Çø„Ç§„É†„Ç¢„Ç¶„Éà
        
        // AbortController„ÇíÁµêÂêà
        const combinedController = new AbortController();
        aiGenerationAbortController.signal.addEventListener('abort', () => {
            combinedController.abort('AI generation cancelled by user');
        });
        timeoutController.signal.addEventListener('abort', () => {
            combinedController.abort('Request timeout after 300 seconds');
        });
        
        const response = await fetch(API_URL, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(requestBody),
            signal: combinedController.signal
        });
        
        clearTimeout(timeoutId);
        console.error('üîç fetchÂÆå‰∫ÜÊôÇÂàª:', new Date().toISOString());

        console.error('üîç „Çµ„Éº„Éê„Éº„É¨„Çπ„Éù„É≥„ÇπÂèó‰ø°:');
        console.error('üîç „É¨„Çπ„Éù„É≥„Çπ„Çπ„ÉÜ„Éº„Çø„Çπ:', response.status);
        console.error('üîç „É¨„Çπ„Éù„É≥„ÇπOK:', response.ok);
        console.error('üîç „É¨„Çπ„Éù„É≥„Çπ„Éò„ÉÉ„ÉÄ„Éº:', response.headers);

        // ‰ª≤‰ªãÂΩπ„Åã„Çâ„ÅÆËøîÁ≠î„ÇíÂèó„ÅëÂèñ„Çä„Åæ„Åô
        console.error('üîç JSONËß£ÊûêÈñãÂßãÊôÇÂàª:', new Date().toISOString());
        let data;
        try {
            data = await response.json();
            console.error('üîç JSONËß£ÊûêÂÆå‰∫ÜÊôÇÂàª:', new Date().toISOString());
            console.error('üîç „É¨„Çπ„Éù„É≥„Çπ„Éá„Éº„Çø:', JSON.stringify(data, null, 2));
            console.error('üîç „É¨„Çπ„Éù„É≥„Çπ„Éá„Éº„Çø„ÅÆÂûã:', typeof data);
            console.error('üîç „É¨„Çπ„Éù„É≥„Çπ„Éá„Éº„Çø„ÅÆ„Ç≠„Éº:', Object.keys(data));
        } catch (jsonError) {
            console.error('üîç JSONËß£Êûê„Ç®„É©„Éº:', jsonError);
            console.error('üîç „É¨„Çπ„Éù„É≥„Çπ„ÉÜ„Ç≠„Çπ„Éà:', await response.text());
            throw new Error('„É¨„Çπ„Éù„É≥„Çπ„ÅÆJSONËß£Êûê„Å´Â§±Êïó„Åó„Åæ„Åó„Åü: ' + jsonError.message);
        }

        // ËøîÁ≠î„Å´ÂïèÈ°å„Åå„ÅÇ„Å£„ÅüÂ†¥Âêà„ÅÆ„Ç®„É©„ÉºÂá¶ÁêÜ
        if (!response.ok) {
            let errorMessage = '„Çµ„Éº„Éê„Éº„Åß„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü„ÄÇ';
            
            if (response.status === 500) {
                errorMessage = '„Çµ„Éº„Éê„ÉºÂÜÖÈÉ®„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü„ÄÇ';
                if (data.error) {
                    errorMessage = data.error;
                }
            } else if (data.error) {
                errorMessage = data.error;
            }
            
            throw new Error(errorMessage);
        }

        // llama-3.3-70b-versatile„ÅÆÂøúÁ≠î„Åã„ÇâJSONÈÉ®ÂàÜ„Å†„Åë„ÇíÂÆâÂÖ®„Å´Âèñ„ÇäÂá∫„Åó„Åæ„Åô
        let modelData;
    
        // AIÁîüÊàê„ÅÆ„É¨„Çπ„Éù„É≥„Çπ„ÇíÂá¶ÁêÜ
        console.log('üîç AIÁîüÊàê„ÅÆ„É¨„Çπ„Éù„É≥„Çπ„ÇíÂá¶ÁêÜ‰∏≠...');
        const jsonText = extractJsonFromResponse(data);
        modelData = JSON.parse(jsonText);

        aiStatus.textContent = '‚úÖ „É¢„Éá„É´„Éá„Éº„Çø„ÇíÈÅ©Áî®„Åó„Å¶„ÅÑ„Åæ„Åô...';
        aiStatus.style.color = '#28a745';

        // Âèñ„ÇäÂá∫„Åó„Åü„É¢„Éá„É´„Éá„Éº„Çø„Çí„ÄÅ„Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥„ÅÆ„ÉÜ„Éº„Éñ„É´„Å´ÂèçÊò†„Åï„Åõ„Åæ„Åô
        try {
            applyGeneratedModel(modelData, userPrompt, mode, currentModel);
        } catch (error) {
            console.error('„É¢„Éá„É´„Éá„Éº„Çø„ÅÆÈÅ©Áî®„Åß„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü:', error);
            console.error('„Ç®„É©„Éº„ÅÆË©≥Á¥∞:', error.message);
            console.error('„Ç®„É©„Éº„Çπ„Çø„ÉÉ„ÇØ:', error.stack);
            // „Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Å¶„ÇÇ„Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó„ÇíÈñâ„Åò„Çã
            hideAIGenerationPopup();
            isAIGenerationInProgress = false;
            throw error; // „Ç®„É©„Éº„ÇíÂÜç„Çπ„É≠„Éº„Åó„Å¶‰∏ä‰Ωç„ÅßÂá¶ÁêÜ
        }

        // AIÁîüÊàêÂÆå‰∫ÜÂæå„ÅÆÊñ≠Èù¢ÊÉÖÂ†±Áä∂ÊÖã„ÇíË®òÈå≤
        console.log('üîç AIÁîüÊàêÂÆå‰∫ÜÂæå„ÅÆÊñ≠Èù¢ÊÉÖÂ†±Áä∂ÊÖã:');
        if (membersTable) {
            const rows = membersTable.querySelectorAll('tbody tr');
            rows.forEach((row, index) => {
                const sectionInfo = row.dataset.sectionInfo;
                const sectionNameCell = row.querySelector('.section-name-cell');
                const sectionAxisCell = row.querySelector('.section-axis-cell');
                console.log(`üîç ÈÉ®Êùê${index + 1}: dataset.sectionInfo=${!!sectionInfo}, Èï∑„Åï=${sectionInfo ? sectionInfo.length : 0}, Êñ≠Èù¢ÂêçÁß∞="${sectionNameCell ? sectionNameCell.textContent : 'N/A'}", Ëª∏ÊñπÂêë="${sectionAxisCell ? sectionAxisCell.textContent : 'N/A'}"`);
            });
        }

        // „Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó„ÇíÈùûË°®Á§∫„Å´„Åô„Çã
        hideAIGenerationPopup();
        isAIGenerationInProgress = false; // AIÁîüÊàêÂÆå‰∫Ü„Éï„É©„Ç∞

        const successMessage = mode === 'edit' 
            ? 'AI„Å´„Çà„Çã„É¢„Éá„É´Á∑®ÈõÜ„ÅåÂÆå‰∫Ü„Åó„Åæ„Åó„Åü„ÄÇ'
            : 'AI„Å´„Çà„Çã„É¢„Éá„É´ÁîüÊàê„ÅåÂÆå‰∫Ü„Åó„Åæ„Åó„Åü„ÄÇ';
        // AIÁîüÊàê‰∏≠„ÅÆ„Ç¢„É©„Éº„Éà„ÅØË°®Á§∫„Åó„Å™„ÅÑ
        console.log(successMessage + (retryCount > 0 ? ` (${retryCount}Âõû„ÅÆ„É™„Éà„É©„Ç§Âæå„Å´ÊàêÂäü)` : ''));
        
        // 3D„Éì„É•„Éº„Ç¢„ÅåÈñã„ÅÑ„Å¶„ÅÑ„ÇãÂ†¥Âêà„ÅØÊõ¥Êñ∞„ÇíÈÄÅ‰ø°
        if (viewerWindow && !viewerWindow.closed) {
            console.log('üîç AIÁîüÊàêÂÆå‰∫ÜÂæå„ÄÅ3D„Éì„É•„Éº„Ç¢„Å´Êõ¥Êñ∞„ÇíÈÄÅ‰ø°‰∏≠...');
            setTimeout(() => {
                sendModelToViewer();
            }, 1000); // AIÁîüÊàêÂÆå‰∫ÜÂæå„Å´ÈÄÅ‰ø°
        }

        // Ëá™Âãï„Çπ„Ç±„Éº„É™„É≥„Ç∞„ÇíÂÆüË°å
        setTimeout(() => {
            try {
                console.log('üîç AIÁîüÊàêÂÆå‰∫ÜÂæå„ÄÅËá™Âãï„Çπ„Ç±„Éº„É™„É≥„Ç∞„ÇíÂÆüË°å‰∏≠...');
                
                // Ëá™Âãï„Çπ„Ç±„Éº„É´„Éú„Çø„É≥„Çí„ÇØ„É™„ÉÉ„ÇØ„Åó„Å¶ÂÆüË°å
                const autoScaleBtn = document.getElementById('auto-scale-btn');
                if (autoScaleBtn) {
                    console.log('üîç Ëá™Âãï„Çπ„Ç±„Éº„É´„Éú„Çø„É≥„ÇíÁô∫Ë¶ã„ÄÅ„ÇØ„É™„ÉÉ„ÇØÂÆüË°å');
                    autoScaleBtn.click();
                } else {
                    console.log('‚ö†Ô∏è Ëá™Âãï„Çπ„Ç±„Éº„É´„Éú„Çø„É≥„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì');
                }
            } catch (error) {
                console.error('Ëá™Âãï„Çπ„Ç±„Éº„É™„É≥„Ç∞ÂÆüË°å„Ç®„É©„Éº:', error);
            }
        }, 1500); // AIÁîüÊàêÂÆå‰∫ÜÂæå„ÄÅÂ∞ë„ÅóÈÅÖÂª∂„Åó„Å¶ÂÆüË°å

    } catch (error) {
        console.error('AI„É¢„Éá„É´ÁîüÊàê„Ç®„É©„Éº:', error);
        console.error('„Ç®„É©„Éº„ÅÆË©≥Á¥∞:', error.message);
        console.error('„Ç®„É©„Éº„Çπ„Çø„ÉÉ„ÇØ:', error.stack);
        console.error('„Ç®„É©„ÉºÁô∫ÁîüÊôÇ„ÅÆÁä∂ÊÖã:', {
            isAIGenerationInProgress,
            aiGenerationCancelled,
            retryCount
        });
        
        // „Ç≠„É£„É≥„Çª„É´„Åï„Çå„ÅüÂ†¥Âêà„ÅØÁâπÂà•„Å™Âá¶ÁêÜ
        if (aiGenerationCancelled || (error.name === 'AbortError')) {
            console.log('üîç AIÁîüÊàê„Åå„Ç≠„É£„É≥„Çª„É´„Åï„Çå„Åæ„Åó„Åü');
            hideAIGenerationPopup();
            isAIGenerationInProgress = false; // AIÁîüÊàê„Ç≠„É£„É≥„Çª„É´„Éï„É©„Ç∞
            
            // UI„Çí„É™„Çª„ÉÉ„Éà
            if (aiGenerateBtn) {
                aiGenerateBtn.disabled = false;
                aiGenerateBtn.textContent = 'AI„ÅßÁîüÊàê';
            }
            if (aiStatus) {
                aiStatus.style.display = 'none';
            }
            return;
        }
        
        // „Çø„Ç§„É†„Ç¢„Ç¶„Éà„Ç®„É©„Éº„ÅÆÂá¶ÁêÜ
        if (error.name === 'AbortError' && error.message.includes('timeout')) {
            console.error('üîç „É™„ÇØ„Ç®„Çπ„Éà„Åå„Çø„Ç§„É†„Ç¢„Ç¶„Éà„Åó„Åæ„Åó„ÅüÔºà300ÁßíÔºâ');
            aiStatus.textContent = '‚è∞ „É™„ÇØ„Ç®„Çπ„Éà„Åå„Çø„Ç§„É†„Ç¢„Ç¶„Éà„Åó„Åæ„Åó„ÅüÔºà300ÁßíÔºâ„ÄÇAIÂÆπÈáèÂà∂Èôê„Å´„Çà„ÇäÂá¶ÁêÜ„Å´ÊôÇÈñì„Åå„Åã„Åã„Å£„Å¶„ÅÑ„Åæ„Åô„ÄÇ„Åó„Å∞„Çâ„ÅèÂæÖ„Å£„Å¶„Åã„ÇâÂÜçË©¶Ë°å„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ';
            aiStatus.style.color = '#dc3545';
            hideAIGenerationPopup();
            isAIGenerationInProgress = false;
            return;
        }
        
        // ÂÆπÈáèË∂ÖÈÅé„Ç®„É©„Éº„ÅÆÂ†¥Âêà„ÅØ„É™„Éà„É©„Ç§„ÇíË©¶Ë°å
        if (error.message && (
            error.message.includes('Service tier capacity exceeded') ||
            error.message.includes('AIÂÆπÈáèÂà∂Èôê') ||
            error.message.includes('ÂÆπÈáèÂà∂Èôê')
        ) && retryCount < MAX_RETRIES) {
            const delay = Math.min(BASE_DELAY * Math.pow(2, retryCount), MAX_DELAY); // ÊåáÊï∞„Éê„ÉÉ„ÇØ„Ç™„ÉïÔºà‰∏äÈôê„ÅÇ„ÇäÔºâ
            console.warn(`üîÑ AIÂÆπÈáèÂà∂Èôê„Ç®„É©„Éº„ÅåÁô∫Áîü„ÄÇ${delay/1000}ÁßíÂæå„Å´„É™„Éà„É©„Ç§„Åó„Åæ„Åô... (${retryCount + 1}/${MAX_RETRIES})`);
            
            aiStatus.textContent = `‚è≥ AIÂÆπÈáèÂà∂Èôê„ÅÆ„Åü„ÇÅ${delay/1000}ÁßíÂæÖÊ©ü‰∏≠... (${retryCount + 1}/${MAX_RETRIES})`;
            aiStatus.style.color = '#ffc107';
            
            // „É™„Éà„É©„Ç§Ââç„Å´Â∞ë„ÅóÂæÖÊ©ü
            await new Promise(resolve => setTimeout(resolve, delay));
            
            // „Ç≠„É£„É≥„Çª„É´„ÉÅ„Çß„ÉÉ„ÇØÔºà„É™„Éà„É©„Ç§ÂâçÔºâ
            if (aiGenerationCancelled) {
                console.log('üîç „É™„Éà„É©„Ç§Ââç„Å´AIÁîüÊàê„Åå„Ç≠„É£„É≥„Çª„É´„Åï„Çå„Åæ„Åó„Åü');
                hideAIGenerationPopup();
                isAIGenerationInProgress = false;
                return;
            }
            
            // „É™„Éà„É©„Ç§ÂÆüË°åÔºà„Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó„ÅØÂÜçË°®Á§∫„Åó„Å™„ÅÑÔºâ
            return generateModelWithAIInternal(userPrompt, mode, retryCount + 1, currentModel);
        }
        
        // „É™„Éà„É©„Ç§‰∏çÂèØËÉΩ„Åæ„Åü„ÅØ„É™„Éà„É©„Ç§‰∏äÈôê„Å´ÈÅî„Åó„ÅüÂ†¥Âêà„ÅÆ„Ç®„É©„ÉºÂá¶ÁêÜ
        hideAIGenerationPopup(); // „Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó„ÇíÈùûË°®Á§∫„Å´„Åô„Çã
        isAIGenerationInProgress = false; // AIÁîüÊàê„Ç®„É©„ÉºÂÆå‰∫Ü„Éï„É©„Ç∞
        
        if (aiStatus) {
            if (error && error.message) {
                if (error.message.includes('Service tier capacity exceeded')) {
                    // ÂÆπÈáèË∂ÖÈÅé„Ç®„É©„Éº„ÅÆÂ†¥Âêà„ÅØËá™ÂãïÂÜçË©¶Ë°å„ÇíÂÆüË°å
                    if (autoRetryCount < MAX_AUTO_RETRY) {
                        aiStatus.textContent = `‚ùå AI„Çµ„Éº„Éì„Çπ„Åå‰∏ÄÊôÇÁöÑ„Å´Âà©Áî®„Åß„Åç„Åæ„Åõ„Çì„ÄÇËá™ÂãïÂÜçË©¶Ë°å‰∏≠... (${autoRetryCount + 1}/${MAX_AUTO_RETRY})`;
                        aiStatus.style.color = '#ffc107';
                        
                        console.log(`üîÑ ÂÆπÈáèË∂ÖÈÅé„Ç®„É©„Éº„Å´„Çà„ÇãËá™ÂãïÂÜçË©¶Ë°å„ÇíÂÆüË°å„Åó„Åæ„Åô (${autoRetryCount + 1}/${MAX_AUTO_RETRY})`);
                        
                        // Â∞ë„ÅóÂæÖÊ©ü„Åó„Å¶„Åã„ÇâËá™ÂãïÂÜçË©¶Ë°å
                        setTimeout(() => {
                            if (!aiGenerationCancelled) {
                                autoRetryCount++;
                                console.log(`üîÑ Ëá™ÂãïÂÜçË©¶Ë°å„ÇíÈñãÂßã„Åó„Åæ„Åô (${autoRetryCount}/${MAX_AUTO_RETRY})`);
                                generateModelWithAI(userPrompt, mode, 0, currentModel); // „É™„Éà„É©„Ç§„Ç´„Ç¶„É≥„Éà„Çí„É™„Çª„ÉÉ„Éà
                            }
                        }, 5000); // 5ÁßíÂæå„Å´Ëá™ÂãïÂÜçË©¶Ë°å
                    } else {
                        // Ëá™ÂãïÂÜçË©¶Ë°å‰∏äÈôê„Å´ÈÅî„Åó„ÅüÂ†¥Âêà
                        aiStatus.textContent = '‚ùå AI„Çµ„Éº„Éì„Çπ„Åå‰∏ÄÊôÇÁöÑ„Å´Âà©Áî®„Åß„Åç„Åæ„Åõ„Çì„ÄÇ„Åó„Å∞„Çâ„ÅèÊôÇÈñì„Çí„Åä„ÅÑ„Å¶„Åã„ÇâÂÜçÂ∫¶„ÅäË©¶„Åó„Åè„Å†„Åï„ÅÑ„ÄÇ';
                        aiStatus.style.color = '#dc3545';
                        console.log('üîÑ Ëá™ÂãïÂÜçË©¶Ë°å‰∏äÈôê„Å´ÈÅî„Åó„Åæ„Åó„Åü');
                    }
                } else {
                    aiStatus.textContent = `‚ùå „Ç®„É©„Éº: ${error.message}`;
                    aiStatus.style.color = '#dc3545';
                }
            } else {
                aiStatus.textContent = `‚ùå AI„Å´„Çà„Çã„É¢„Éá„É´ÁîüÊàê„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇ`;
                aiStatus.style.color = '#dc3545';
            }
        }
        
        // „É¶„Éº„Ç∂„Éº„Å∏„ÅÆÈÄöÁü•ÔºàAIÁîüÊàê‰∏≠„ÅØ„Ç¢„É©„Éº„Éà„ÇíË°®Á§∫„Åó„Å™„ÅÑÔºâ
        if (error && error.message) {
            console.error(`AI„Å´„Çà„Çã„É¢„Éá„É´ÁîüÊàê„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇ„Ç®„É©„Éº: ${error.message}`);
        } else {
            console.error(`AI„Å´„Çà„Çã„É¢„Éá„É´ÁîüÊàê„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇ`);
        }
    } finally {
        // UI„ÅÆÁä∂ÊÖã„ÇíÂÖÉ„Å´Êàª„Åó„Åæ„Åô
        isAIGenerationInProgress = false; // ÊúÄÁµÇÁöÑ„Å´„Éï„É©„Ç∞„Çí„É™„Çª„ÉÉ„Éà
        if (aiGenerateBtn) {
            aiGenerateBtn.disabled = false;
            aiGenerateBtn.textContent = 'AI„ÅßÁîüÊàê';
        }
        
        if (aiStatus) {
            setTimeout(() => {
                if (aiStatus.textContent && aiStatus.textContent.startsWith('‚ùå')) {
                     // „Ç®„É©„Éº„É°„ÉÉ„Çª„Éº„Ç∏„ÅØÂ∞ë„ÅóÈï∑„ÇÅ„Å´Ë°®Á§∫
                } else {
                    aiStatus.style.display = 'none';
                }
            }, 5000);
        }
    }
}

// ÂÖ¨ÈñãÈñ¢Êï∞ÔºöÊúÄÂàù„ÅÆÂëº„Å≥Âá∫„ÅóÊôÇ„Å´„Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó„ÇíË°®Á§∫
async function generateModelWithAI(userPrompt, mode = 'new', retryCount = 0, currentModel = null) {
    // „Ç≠„É£„É≥„Çª„É´„Éï„É©„Ç∞„Çí„É™„Çª„ÉÉ„Éà
    aiGenerationCancelled = false;
    aiGenerationAbortController = new AbortController();
    isAIGenerationInProgress = true; // AIÁîüÊàêÈñãÂßã„Éï„É©„Ç∞
    
    // ÊâãÂãïÈñãÂßãÊôÇ„ÅØËá™ÂãïÂÜçË©¶Ë°å„Ç´„Ç¶„É≥„Éà„Çí„É™„Çª„ÉÉ„Éà
    if (retryCount === 0) {
        autoRetryCount = 0; // ÊâãÂãïÈñãÂßãÊôÇ„ÅØËá™ÂãïÂÜçË©¶Ë°å„Ç´„Ç¶„É≥„Éà„Çí„É™„Çª„ÉÉ„Éà
    }
    
    // „Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó„ÇíË°®Á§∫ÔºàÊúÄÂàù„ÅÆÂëº„Å≥Âá∫„ÅóÊôÇ„ÅÆ„ÅøÔºâ
    if (retryCount === 0) {
        showAIGenerationPopup();
    }
    
    // ÂÜÖÈÉ®Èñ¢Êï∞„ÇíÂëº„Å≥Âá∫„Åó
    return generateModelWithAIInternal(userPrompt, mode, retryCount, currentModel);
}

/**
 * Gemini API„ÅÆ„É¨„Çπ„Éù„É≥„Çπ„Åã„ÇâJSONÈÉ®ÂàÜ„ÇíÂÆâÂÖ®„Å´ÊäΩÂá∫„Åô„ÇãÈñ¢Êï∞
 * @param {object} apiResponse API„Åã„Çâ„ÅÆ„É¨„Çπ„Éù„É≥„Çπ„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà
 * @returns {string} ÊäΩÂá∫„Åï„Çå„ÅüJSONÊñáÂ≠óÂàó
 */
function extractJsonFromResponse(apiResponse) {
    if (!apiResponse.candidates || !apiResponse.candidates[0].content.parts || !apiResponse.candidates[0].content.parts[0].text) {
        throw new Error('API„Åã„Çâ„ÅÆ„É¨„Çπ„Éù„É≥„ÇπÂΩ¢Âºè„Åå‰∏çÊ≠£„Åß„Åô„ÄÇ');
    }
    
    let text = apiResponse.candidates[0].content.parts[0].text;
    
    const jsonMatch = text.match(/```(json)?\s*([\s\S]*?)\s*```/);
    if (jsonMatch && jsonMatch[2]) {
        text = jsonMatch[2];
    }
    
    const startIndex = text.indexOf('{');
    const endIndex = text.lastIndexOf('}');
    
    if (startIndex === -1 || endIndex === -1 || endIndex < startIndex) {
        throw new Error('„É¨„Çπ„Éù„É≥„ÇπÂÜÖ„Å´ÊúâÂäπ„Å™JSON„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„ÄÇ');
    }
    
    return text.substring(startIndex, endIndex + 1);
}

/**
 * ÁèæÂú®„ÅÆ„É¢„Éá„É´ÊÉÖÂ†±„ÇíÂèñÂæó„Åô„ÇãÈñ¢Êï∞
 * @returns {Object} ÁèæÂú®„ÅÆ„É¢„Éá„É´„Éá„Éº„Çø
 */
function getCurrentModelData() {
    console.log('üîç ÁèæÂú®„ÅÆ„É¢„Éá„É´ÊÉÖÂ†±„ÇíÂÆåÂÖ®ÂèñÂæó‰∏≠...');
    
    // Check if elements object exists
    if (!elements) {
        console.error('Error: elements object is not available');
        return {
            nodes: [],
            members: [],
            nodeLoads: [],
            memberLoads: []
        };
    }
    
    const nodes = [];
    const members = [];
    const nodeLoads = [];
    const memberLoads = [];
    
    // ÁØÄÁÇπÊÉÖÂ†±„ÇíÂèñÂæó
    if (elements.nodesTable && elements.nodesTable.rows) {
        console.log('üîç ÁØÄÁÇπ„ÉÜ„Éº„Éñ„É´ÂÖ®‰ΩìÊÉÖÂ†±:', {
            totalRows: elements.nodesTable.rows.length,
            headerRow: elements.nodesTable.rows[0]?.cells?.length,
            firstDataRow: elements.nodesTable.rows[1]?.cells?.length,
            lastDataRow: elements.nodesTable.rows[elements.nodesTable.rows.length - 1]?.cells?.length
        });
        
        // „Éò„ÉÉ„ÉÄ„ÉºË°å„ÅÆÂÜÖÂÆπ„ÇíÁ¢∫Ë™ç
        if (elements.nodesTable.rows[0]) {
            const headerCells = [];
            for (let j = 0; j < Math.min(elements.nodesTable.rows[0].cells.length, 10); j++) {
                headerCells.push(`col${j}: "${elements.nodesTable.rows[0].cells[j]?.textContent || ''}"`);
            }
            console.log('üîç ÁØÄÁÇπ„ÉÜ„Éº„Éñ„É´„Éò„ÉÉ„ÉÄ„Éº:', headerCells.join(', '));
        }
        
        // ÁØÄÁÇπ„ÉÜ„Éº„Éñ„É´„ÅÆÂÆüÈöõ„ÅÆÊßãÈÄ†„ÇíÁ¢∫Ë™ç
        // „Éò„ÉÉ„ÉÄ„ÉºË°å„ÅÆcol0„Åå"1"„Å™„ÅÆ„Åß„ÄÅ„Éá„Éº„ÇøË°å„ÅÆÊßãÈÄ†„ÅåÁï∞„Å™„ÇãÂèØËÉΩÊÄß
        console.log('üîç ÁØÄÁÇπ„ÉÜ„Éº„Éñ„É´Ë°å„ÅÆË©≥Á¥∞Á¢∫Ë™ç - „Éê„Éº„Ç∏„Éß„É≥2:');
        for (let i = 0; i < Math.min(elements.nodesTable.rows.length, 3); i++) {
            const row = elements.nodesTable.rows[i];
            if (row && row.cells) {
                const cells = [];
                for (let j = 0; j < Math.min(row.cells.length, 8); j++) {
                    cells.push(`cell${j}: "${row.cells[j]?.textContent || ''}"`);
                }
                console.log(`üîç ÁØÄÁÇπ„ÉÜ„Éº„Éñ„É´Ë°å ${i}:`, cells.join(', '));
            }
        }
        
        for (let i = 0; i < elements.nodesTable.rows.length; i++) {
            const row = elements.nodesTable.rows[i];
            
            // Ë°å„Å®„Çª„É´„ÅåÂ≠òÂú®„Åô„Çã„Åã„ÉÅ„Çß„ÉÉ„ÇØ
            if (!row || !row.cells || row.cells.length < 4) {
                console.warn(`ÁØÄÁÇπ„ÉÜ„Éº„Éñ„É´„ÅÆË°å ${i} „Å´ÂøÖË¶Å„Å™„Çª„É´„Åå‰∏çË∂≥„Åó„Å¶„ÅÑ„Åæ„Åô`);
                continue;
            }
            
            // „Çª„É´„ÅÆÂÜÖÂÆπ„ÇíÁ¢∫Ë™ç„Åó„Å¶ÈÅ©Âàá„Å™Âàó„ÇíÁâπÂÆö
            const firstCellText = row.cells[0]?.textContent?.trim();
            
            // „Éò„ÉÉ„ÉÄ„ÉºË°å„ÅÆË≠òÂà•ÔºàÊï∞ÂÄ§‰ª•Â§ñ„Åæ„Åü„ÅØÁâπÂÆö„Ç≠„Éº„ÉØ„Éº„Éâ„ÇíÂê´„ÇÄÂ†¥Âêà„ÅØ„Éò„ÉÉ„ÉÄ„Éº„Å®„Åø„Å™„ÅôÔºâ
            const isHeader = !firstCellText || 
                            isNaN(parseInt(firstCellText)) || 
                            firstCellText.includes('ÁØÄÁÇπ') || 
                            firstCellText.includes('Node') ||
                            firstCellText.includes('Áï™Âè∑') ||
                            firstCellText.includes('#');
            
            if (isHeader) {
                console.log(`üîç ÁØÄÁÇπ„ÉÜ„Éº„Éñ„É´Ë°å ${i} „ÅØ„Éò„ÉÉ„ÉÄ„ÉºË°å„ÅÆ„Åü„ÇÅ„Çπ„Ç≠„ÉÉ„Éó: "${firstCellText}"`);
                continue;
            }
            
            // „Çª„É´0„Å´Êï∞ÂÄ§„Åå„ÅÇ„ÇãÂ†¥Âêà
            const nodeNumber = parseInt(firstCellText);
            
            // XÂ∫ßÊ®ô„ÅØcell1„ÅÆinputË¶ÅÁ¥†„Åã„ÇâÂèñÂæó
            const xInput = row.cells[1]?.querySelector('input');
            const x = xInput ? parseFloat(xInput.value) : 0;
            
            // YÂ∫ßÊ®ô„ÅØcell2„ÅÆinputË¶ÅÁ¥†„Åã„ÇâÂèñÂæó
            const yInput = row.cells[2]?.querySelector('input');
            const y = yInput ? parseFloat(yInput.value) : 0;
            
            // Â¢ÉÁïåÊù°‰ª∂„ÅØcell3„ÅÆselectË¶ÅÁ¥†„Åã„ÇâÂèñÂæó
            const supportSelect = row.cells[3]?.querySelector('select');
            const support = supportSelect ? supportSelect.value : 'free';
            
            console.log(`üîç ÁØÄÁÇπ ${nodeNumber} „ÅÆÂ∫ßÊ®ô: (${x}, ${y}), Â¢ÉÁïåÊù°‰ª∂: ${support}`);
            
            // Âº∑Âà∂Â§â‰Ωç„ÉªÂõûËª¢„ÅÆÂèñÂæó
            const dxInput = row.cells[4]?.querySelector('input');
            const dyInput = row.cells[5]?.querySelector('input');
            const drInput = row.cells[6]?.querySelector('input');
            
            const dx_forced = dxInput ? parseFloat(dxInput.value) || 0 : 0;
            const dy_forced = dyInput ? parseFloat(dyInput.value) || 0 : 0;
            const r_forced = drInput ? parseFloat(drInput.value) || 0 : 0;
            
            // Â∫ßÊ®ô„ÅåÊúâÂäπ„Å™Â†¥Âêà„ÅÆ„ÅøËøΩÂä†
            if (!isNaN(x) && !isNaN(y)) {
                const nodeData = {
                    x: x,
                    y: y,
                    s: support,
                    dx_forced: dx_forced,
                    dy_forced: dy_forced,
                    r_forced: r_forced
                };
                console.log(`üîç ÁØÄÁÇπ ${nodeNumber} ÂÆåÂÖ®„Éá„Éº„ÇøÂèñÂæó:`, nodeData);
                nodes.push(nodeData);
            }
        }
    }
    
    // ÈÉ®ÊùêÊÉÖÂ†±„ÇíÂèñÂæó
    if (elements.membersTable && elements.membersTable.rows) {
        console.log('üîç ÈÉ®Êùê„ÉÜ„Éº„Éñ„É´ÂÖ®‰ΩìÊÉÖÂ†±:', {
            totalRows: elements.membersTable.rows.length,
            headerRow: elements.membersTable.rows[0]?.cells?.length,
            firstDataRow: elements.membersTable.rows[1]?.cells?.length
        });
        
        // „Éò„ÉÉ„ÉÄ„ÉºË°å„ÅÆÂÜÖÂÆπ„ÇíÁ¢∫Ë™ç
        if (elements.membersTable.rows[0]) {
            const headerCells = [];
            for (let j = 0; j < Math.min(elements.membersTable.rows[0].cells.length, 14); j++) {
                headerCells.push(`col${j}: "${elements.membersTable.rows[0].cells[j]?.textContent || ''}"`);
            }
            console.log('üîç ÈÉ®Êùê„ÉÜ„Éº„Éñ„É´„Éò„ÉÉ„ÉÄ„Éº:', headerCells.join(', '));
        }
        
        // ÈÉ®Êùê„ÉÜ„Éº„Éñ„É´„ÅÆÂÆüÈöõ„ÅÆÊßãÈÄ†„ÇíÁ¢∫Ë™ç
        console.log('üîç ÈÉ®Êùê„ÉÜ„Éº„Éñ„É´Ë°å„ÅÆË©≥Á¥∞Á¢∫Ë™ç - „Éê„Éº„Ç∏„Éß„É≥2:');
        for (let i = 0; i < Math.min(elements.membersTable.rows.length, 3); i++) {
            const row = elements.membersTable.rows[i];
            if (row && row.cells) {
                const cells = [];
                for (let j = 0; j < Math.min(row.cells.length, 14); j++) {
                    cells.push(`cell${j}: "${row.cells[j]?.textContent || ''}"`);
                }
                console.log(`üîç ÈÉ®Êùê„ÉÜ„Éº„Éñ„É´Ë°å ${i}:`, cells.join(', '));
            }
        }
        
        for (let i = 0; i < elements.membersTable.rows.length; i++) {
            const row = elements.membersTable.rows[i];
            
            // Ë°å„Å®„Çª„É´„ÅåÂ≠òÂú®„Åô„Çã„Åã„ÉÅ„Çß„ÉÉ„ÇØ
            if (!row || !row.cells || row.cells.length < 3) {
                console.warn(`ÈÉ®Êùê„ÉÜ„Éº„Éñ„É´„ÅÆË°å ${i} „Å´ÂøÖË¶Å„Å™„Çª„É´„Åå‰∏çË∂≥„Åó„Å¶„ÅÑ„Åæ„Åô`);
                continue;
            }
            
            // „Çª„É´„ÅÆÂÜÖÂÆπ„ÇíÁ¢∫Ë™ç„Åó„Å¶ÈÅ©Âàá„Å™Âàó„ÇíÁâπÂÆö
            const firstCellText = row.cells[0]?.textContent?.trim();
            
            // „Éò„ÉÉ„ÉÄ„ÉºË°å„ÅÆË≠òÂà•ÔºàÊï∞ÂÄ§‰ª•Â§ñ„Åæ„Åü„ÅØÁâπÂÆö„Ç≠„Éº„ÉØ„Éº„Éâ„ÇíÂê´„ÇÄÂ†¥Âêà„ÅØ„Éò„ÉÉ„ÉÄ„Éº„Å®„Åø„Å™„ÅôÔºâ
            const isHeader = !firstCellText || 
                            isNaN(parseInt(firstCellText)) || 
                            firstCellText.includes('ÈÉ®Êùê') || 
                            firstCellText.includes('Member') ||
                            firstCellText.includes('Áï™Âè∑') ||
                            firstCellText.includes('#');
            
            if (isHeader) {
                console.log(`üîç ÈÉ®Êùê„ÉÜ„Éº„Éñ„É´Ë°å ${i} „ÅØ„Éò„ÉÉ„ÉÄ„ÉºË°å„ÅÆ„Åü„ÇÅ„Çπ„Ç≠„ÉÉ„Éó: "${firstCellText}"`);
                continue;
            }
            
            // „Çª„É´0„Å´Êï∞ÂÄ§„Åå„ÅÇ„ÇãÂ†¥Âêà„ÅÆ„ÅøÂá¶ÁêÜ
            const memberNumber = parseInt(firstCellText);
            
            // ÈñãÂßãÁØÄÁÇπ„ÅØcell1„ÅÆinputË¶ÅÁ¥†„Åã„ÇâÂèñÂæó
            const startNodeInput = row.cells[1]?.querySelector('input');
            const startNode = startNodeInput ? parseInt(startNodeInput.value) : 0;
            
            // ÁµÇÁÇπÁØÄÁÇπ„ÅØcell2„ÅÆinputË¶ÅÁ¥†„Åã„ÇâÂèñÂæó
            const endNodeInput = row.cells[2]?.querySelector('input');
            const endNode = endNodeInput ? parseInt(endNodeInput.value) : 0;
            
            // Êñ≠Èù¢ÊÉÖÂ†±„ÅØcell8„ÅÆtextContent„Åã„ÇâÂèñÂæó
            const section = row.cells[8]?.textContent || 'H-300x150x6.5x9';
            
            console.log(`üîç ÈÉ®Êùê ${memberNumber}: ÁØÄÁÇπ ${startNode} ‚Üí ${endNode}, Êñ≠Èù¢: ${section}`);
            
            // ÊùêÊñôÁâπÊÄß„Å®Êñ≠Èù¢ÊÄßËÉΩ„ÅÆÂèñÂæó
            const eInput = row.cells[3]?.querySelector('input');
            const fSelect = row.cells[4]?.querySelector('select');
            const fInput = row.cells[4]?.querySelector('input');
            const iInput = row.cells[5]?.querySelector('input');
            const aInput = row.cells[6]?.querySelector('input');
            const zInput = row.cells[7]?.querySelector('input');
            const sectionName = row.cells[8]?.textContent || '';
            const sectionAxis = row.cells[9]?.textContent || '';
            const iConnSelect = row.cells[11]?.querySelector('select');
            const jConnSelect = row.cells[12]?.querySelector('select');
            
            const E = eInput ? parseFloat(eInput.value) || 205000 : 205000;
            
            // FÂÄ§„ÅÆÂèñÂæóÔºà„Çª„É¨„ÇØ„Éà„Éú„ÉÉ„ÇØ„Çπ„Åæ„Åü„ÅØ„Ç§„É≥„Éó„ÉÉ„ÉàÔºâ
            let F = 235;
            if (fSelect) {
                F = parseFloat(fSelect.value) || 235;
            } else if (fInput) {
                F = parseFloat(fInput.value) || 235;
            }
            
            const I = iInput ? parseFloat(iInput.value) || 0 : 0;
            const A = aInput ? parseFloat(aInput.value) || 0 : 0;
            const Z = zInput ? parseFloat(zInput.value) || 0 : 0;
            const i_conn = iConnSelect ? iConnSelect.value : 'rigid';
            const j_conn = jConnSelect ? jConnSelect.value : 'rigid';
            
            // ÈñãÂßãÁØÄÁÇπ„Å®ÁµÇ‰∫ÜÁØÄÁÇπ„ÅåÊúâÂäπ„Å™Â†¥Âêà„ÅÆ„ÅøËøΩÂä†
            if (!isNaN(startNode) && !isNaN(endNode) && startNode !== endNode) {
                // ÁØÄÁÇπÂ∫ßÊ®ô„Åã„ÇâÈï∑„Åï„ÇíË®àÁÆó
                let length = 0;
                if (startNode <= nodes.length && endNode <= nodes.length) {
                    const startNodeData = nodes[startNode - 1];
                    const endNodeData = nodes[endNode - 1];
                    if (startNodeData && endNodeData) {
                        const dx = endNodeData.x - startNodeData.x;
                        const dy = endNodeData.y - startNodeData.y;
                        length = Math.sqrt(dx * dx + dy * dy);
                    }
                }
                
                const memberData = {
                    i: startNode,
                    j: endNode,
                    E: E,
                    F: F,
                    I: I,
                    A: A,
                    Z: Z,
                    i_conn: i_conn,
                    j_conn: j_conn,
                    sectionName: sectionName,
                    sectionAxis: sectionAxis,
                    length: length // ÈÉ®Êùê„ÅÆÈï∑„Åï„ÇíËøΩÂä†
                };
                console.log(`üîç ÈÉ®Êùê ${memberNumber} ÂÆåÂÖ®„Éá„Éº„ÇøÂèñÂæó:`, memberData);
                members.push(memberData);
            }
        }
    }
    
    // ÁØÄÁÇπËç∑ÈáçÊÉÖÂ†±„ÇíÂèñÂæó
    if (elements.nodeLoadsTable && elements.nodeLoadsTable.rows) {
        console.log('üîç ÁØÄÁÇπËç∑Èáç„ÉÜ„Éº„Éñ„É´„Åã„ÇâÂÆåÂÖ®ÊÉÖÂ†±„ÇíÂèñÂæó‰∏≠...');
        console.log('üîç ÁØÄÁÇπËç∑Èáç„ÉÜ„Éº„Éñ„É´Ë°åÊï∞:', elements.nodeLoadsTable.rows.length);
        
        // „ÉÜ„Éº„Éñ„É´„ÅÆÊßãÈÄ†„Çí„Éá„Éê„ÉÉ„Ç∞Âá∫Âäõ
        if (elements.nodeLoadsTable.rows.length > 0) {
            console.log('üîç ÁØÄÁÇπËç∑Èáç„ÉÜ„Éº„Éñ„É´Á¨¨1Ë°å„ÅÆ„Çª„É´Êï∞:', elements.nodeLoadsTable.rows[0]?.cells?.length);
            console.log('üîç ÁØÄÁÇπËç∑Èáç„ÉÜ„Éº„Éñ„É´Á¨¨1Ë°å„ÅÆÂÜÖÂÆπ:', 
                Array.from(elements.nodeLoadsTable.rows[0]?.cells || []).map(cell => cell?.textContent?.trim()).join(' | '));
            
            // ÂêÑ„Çª„É´„ÅÆË©≥Á¥∞„ÇíÁ¢∫Ë™ç
            Array.from(elements.nodeLoadsTable.rows[0]?.cells || []).forEach((cell, index) => {
                console.log(`üîç ÁØÄÁÇπËç∑Èáç„ÉÜ„Éº„Éñ„É´Á¨¨1Ë°å„Çª„É´${index}:`, {
                    textContent: cell?.textContent?.trim(),
                    innerHTML: cell?.innerHTML?.trim(),
                    hasInput: cell?.querySelector('input') !== null,
                    inputValue: cell?.querySelector('input')?.value
                });
            });
        }
        
        for (let i = 0; i < elements.nodeLoadsTable.rows.length; i++) {
            const row = elements.nodeLoadsTable.rows[i];
            
            console.log(`üîç ÁØÄÁÇπËç∑Èáç„ÉÜ„Éº„Éñ„É´Ë°å${i}„ÅÆË©≥Á¥∞:`, {
                hasRow: !!row,
                hasCells: !!row?.cells,
                cellCount: row?.cells?.length,
                firstCellText: row?.cells?.[0]?.textContent?.trim(),
                firstCellHTML: row?.cells?.[0]?.innerHTML?.trim(),
                hasInputs: Array.from(row?.cells || []).map(cell => cell?.querySelector('input') !== null)
            });
            
            // Ë°å„Å®„Çª„É´„ÅåÂ≠òÂú®„Åô„Çã„Åã„ÉÅ„Çß„ÉÉ„ÇØ
            if (!row || !row.cells || row.cells.length < 4) {
                console.log(`üîç ÁØÄÁÇπËç∑Èáç„ÉÜ„Éº„Éñ„É´Ë°å${i}: „Çπ„Ç≠„ÉÉ„ÉóÔºà„Çª„É´‰∏çË∂≥Ôºâ`);
                continue;
            }
            
            // „Éò„ÉÉ„ÉÄ„ÉºË°å„ÅÆË≠òÂà•Ôºà„Çà„ÇäÂé≥ÂØÜ„Å´Ôºâ
            const firstCellText = row.cells[0]?.textContent?.trim();
            const firstCellInput = row.cells[0]?.querySelector('input');
            
            // inputË¶ÅÁ¥†„Åå„Å™„ÅÑÂ†¥Âêà„ÅÆ„Åø„Éò„ÉÉ„ÉÄ„ÉºË°å„Å®Âà§ÂÆö
            const isHeader = !firstCellInput || 
                            firstCellText.includes('ÁØÄÁÇπ') || 
                            firstCellText.includes('Node') ||
                            firstCellText.includes('Áï™Âè∑') ||
                            firstCellText.includes('#');
            
            if (isHeader) {
                console.log(`üîç ÁØÄÁÇπËç∑Èáç„ÉÜ„Éº„Éñ„É´Ë°å${i}: „Çπ„Ç≠„ÉÉ„ÉóÔºà„Éò„ÉÉ„ÉÄ„ÉºË°åÔºâ`);
                continue;
            }
            
            const nodeInput = row.cells[0]?.querySelector('input');
            const fxInput = row.cells[1]?.querySelector('input');
            const fyInput = row.cells[2]?.querySelector('input');
            const mzInput = row.cells[3]?.querySelector('input');
            
            if (!nodeInput || !fxInput || !fyInput || !mzInput) {
                console.log(`üîç ÁØÄÁÇπËç∑Èáç„ÉÜ„Éº„Éñ„É´Ë°å${i}: „Çπ„Ç≠„ÉÉ„ÉóÔºàinputË¶ÅÁ¥†‰∏çË∂≥Ôºâ`);
                continue;
            }
            
            const node = parseInt(nodeInput.value) || 1;
            const fx = parseFloat(fxInput.value) || 0;
            const fy = parseFloat(fyInput.value) || 0;
            const mz = parseFloat(mzInput.value) || 0;
            
            // Á©∫„ÅÆË°åÔºàÂÖ®„Å¶„ÅÆËç∑Èáç„Åå0Ôºâ„ÅØ„Çπ„Ç≠„ÉÉ„Éó
            if (fx === 0 && fy === 0 && mz === 0) {
                continue;
            }
            
            const loadData = {
                n: node,
                px: fx,
                py: fy,
                mz: mz
            };
            console.log(`üîç ÁØÄÁÇπËç∑Èáç ${node} ÂÆåÂÖ®„Éá„Éº„ÇøÂèñÂæó:`, loadData);
            nodeLoads.push(loadData);
        }
    } else {
        console.log('üîç ÁØÄÁÇπËç∑Èáç„ÉÜ„Éº„Éñ„É´„ÅåË¶ã„Å§„Åã„Çâ„Å™„ÅÑ„Åã„ÄÅË°å„ÅåÂ≠òÂú®„Åó„Åæ„Åõ„Çì');
    }
    
    // ÈÉ®ÊùêËç∑ÈáçÊÉÖÂ†±„ÇíÂèñÂæó
    if (elements.memberLoadsTable && elements.memberLoadsTable.rows) {
        console.log('üîç ÈÉ®ÊùêËç∑Èáç„ÉÜ„Éº„Éñ„É´„Åã„ÇâÂÆåÂÖ®ÊÉÖÂ†±„ÇíÂèñÂæó‰∏≠...');
        console.log('üîç ÈÉ®ÊùêËç∑Èáç„ÉÜ„Éº„Éñ„É´Ë°åÊï∞:', elements.memberLoadsTable.rows.length);
        
        // „ÉÜ„Éº„Éñ„É´„ÅÆÊßãÈÄ†„Çí„Éá„Éê„ÉÉ„Ç∞Âá∫Âäõ
        if (elements.memberLoadsTable.rows.length > 0) {
            console.log('üîç ÈÉ®ÊùêËç∑Èáç„ÉÜ„Éº„Éñ„É´Á¨¨1Ë°å„ÅÆ„Çª„É´Êï∞:', elements.memberLoadsTable.rows[0]?.cells?.length);
            console.log('üîç ÈÉ®ÊùêËç∑Èáç„ÉÜ„Éº„Éñ„É´Á¨¨1Ë°å„ÅÆÂÜÖÂÆπ:', 
                Array.from(elements.memberLoadsTable.rows[0]?.cells || []).map(cell => cell?.textContent?.trim()).join(' | '));
            
            // ÂêÑ„Çª„É´„ÅÆË©≥Á¥∞„ÇíÁ¢∫Ë™ç
            Array.from(elements.memberLoadsTable.rows[0]?.cells || []).forEach((cell, index) => {
                console.log(`üîç ÈÉ®ÊùêËç∑Èáç„ÉÜ„Éº„Éñ„É´Á¨¨1Ë°å„Çª„É´${index}:`, {
                    textContent: cell?.textContent?.trim(),
                    innerHTML: cell?.innerHTML?.trim(),
                    hasInput: cell?.querySelector('input') !== null,
                    inputValue: cell?.querySelector('input')?.value
                });
            });
        }
        
        for (let i = 0; i < elements.memberLoadsTable.rows.length; i++) {
            const row = elements.memberLoadsTable.rows[i];
            
            console.log(`üîç ÈÉ®ÊùêËç∑Èáç„ÉÜ„Éº„Éñ„É´Ë°å${i}„ÅÆË©≥Á¥∞:`, {
                hasRow: !!row,
                hasCells: !!row?.cells,
                cellCount: row?.cells?.length,
                firstCellText: row?.cells?.[0]?.textContent?.trim(),
                firstCellHTML: row?.cells?.[0]?.innerHTML?.trim(),
                hasInputs: Array.from(row?.cells || []).map(cell => cell?.querySelector('input') !== null)
            });
            
            // Ë°å„Å®„Çª„É´„ÅåÂ≠òÂú®„Åô„Çã„Åã„ÉÅ„Çß„ÉÉ„ÇØ
            if (!row || !row.cells || row.cells.length < 2) {
                console.log(`üîç ÈÉ®ÊùêËç∑Èáç„ÉÜ„Éº„Éñ„É´Ë°å${i}: „Çπ„Ç≠„ÉÉ„ÉóÔºà„Çª„É´‰∏çË∂≥Ôºâ`);
                continue;
            }
            
            // „Éò„ÉÉ„ÉÄ„ÉºË°å„ÅÆË≠òÂà•Ôºà„Çà„ÇäÂé≥ÂØÜ„Å´Ôºâ
            const firstCellText = row.cells[0]?.textContent?.trim();
            const firstCellInput = row.cells[0]?.querySelector('input');
            
            // inputË¶ÅÁ¥†„Åå„Å™„ÅÑÂ†¥Âêà„ÅÆ„Åø„Éò„ÉÉ„ÉÄ„ÉºË°å„Å®Âà§ÂÆö
            const isHeader = !firstCellInput || 
                            firstCellText.includes('ÈÉ®Êùê') || 
                            firstCellText.includes('Member') ||
                            firstCellText.includes('Áï™Âè∑') ||
                            firstCellText.includes('#');
            
            if (isHeader) {
                console.log(`üîç ÈÉ®ÊùêËç∑Èáç„ÉÜ„Éº„Éñ„É´Ë°å${i}: „Çπ„Ç≠„ÉÉ„ÉóÔºà„Éò„ÉÉ„ÉÄ„ÉºË°åÔºâ`);
                continue;
            }
            
            const memberInput = row.cells[0]?.querySelector('input');
            const wInput = row.cells[1]?.querySelector('input');
            
            if (!memberInput || !wInput) {
                console.log(`üîç ÈÉ®ÊùêËç∑Èáç„ÉÜ„Éº„Éñ„É´Ë°å${i}: „Çπ„Ç≠„ÉÉ„ÉóÔºàinputË¶ÅÁ¥†‰∏çË∂≥Ôºâ`);
                continue;
            }
            
            const member = parseInt(memberInput.value) || 1;
            const w = parseFloat(wInput.value) || 0;
            
            // Á©∫„ÅÆË°åÔºàËç∑Èáç„Åå0Ôºâ„ÅØ„Çπ„Ç≠„ÉÉ„Éó
            if (w === 0) {
                continue;
            }
            
            const loadData = {
                m: member,
                w: w
            };
            console.log(`üîç ÈÉ®ÊùêËç∑Èáç ${member} ÂÆåÂÖ®„Éá„Éº„ÇøÂèñÂæó:`, loadData);
            memberLoads.push(loadData);
        }
    } else {
        console.log('üîç ÈÉ®ÊùêËç∑Èáç„ÉÜ„Éº„Éñ„É´„ÅåË¶ã„Å§„Åã„Çâ„Å™„ÅÑ„Åã„ÄÅË°å„ÅåÂ≠òÂú®„Åó„Åæ„Åõ„Çì');
    }
    
    const modelData = {
        nodes: nodes,
        members: members,
        nodeLoads: nodeLoads,
        memberLoads: memberLoads
    };
    
    console.log('üîç ÂÆåÂÖ®ÂèñÂæó„Åó„Åü„É¢„Éá„É´ÊÉÖÂ†±:', {
        nodeCount: nodes.length,
        memberCount: members.length,
        nodeLoadCount: nodeLoads.length,
        memberLoadCount: memberLoads.length
    });
    console.log('üîç ÁØÄÁÇπ„Éá„Éº„ÇøË©≥Á¥∞:', modelData.nodes);
    console.log('üîç ÈÉ®Êùê„Éá„Éº„ÇøË©≥Á¥∞:', modelData.members);
    console.log('üîç ÁØÄÁÇπËç∑Èáç„Éá„Éº„ÇøË©≥Á¥∞:', modelData.nodeLoads);
    console.log('üîç ÈÉ®ÊùêËç∑Èáç„Éá„Éº„ÇøË©≥Á¥∞:', modelData.memberLoads);
    
    return modelData;
}

/**
 * AIÊ©üËÉΩ„ÅÆË°®Á§∫Âàá„ÇäÊõø„Åà„ÇíË®≠ÂÆö„Åô„ÇãÈñ¢Êï∞
 */
function setupAIFeaturesToggle() {
    console.log('üîç AIÊ©üËÉΩ„ÅÆË°®Á§∫Âàá„ÇäÊõø„Åà„ÇíË®≠ÂÆö‰∏≠...');
    
    const aiToggleCheckbox = document.getElementById('ai-features-toggle');
    const aiGeneratorSection = document.getElementById('ai-generator-section');
    
    if (!aiToggleCheckbox || !aiGeneratorSection) {
        console.error('Error: AIÊ©üËÉΩ„ÅÆÂàá„ÇäÊõø„ÅàË¶ÅÁ¥†„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì');
        return;
    }
    
    // „ÉÅ„Çß„ÉÉ„ÇØ„Éú„ÉÉ„ÇØ„Çπ„ÅÆ„Ç§„Éô„É≥„Éà„É™„Çπ„Éä„Éº
    aiToggleCheckbox.addEventListener('change', (event) => {
        const isChecked = event.target.checked;
        
        if (isChecked) {
            aiGeneratorSection.style.display = 'block';
            console.log('‚úÖ AIÊ©üËÉΩ„ÇíË°®Á§∫„Åó„Åæ„Åó„Åü');
        } else {
            aiGeneratorSection.style.display = 'none';
            console.log('‚ùå AIÊ©üËÉΩ„ÇíÈùûË°®Á§∫„Å´„Åó„Åæ„Åó„Åü');
        }
    });
    
    console.log('‚úÖ AIÊ©üËÉΩ„ÅÆË°®Á§∫Âàá„ÇäÊõø„ÅàË®≠ÂÆöÂÆå‰∫Ü');
}

/**
 * AI„É¢„Éá„É´ÁîüÊàê„ÅÆ„Ç§„Éô„É≥„Éà„É™„Çπ„Éä„Éº„ÇíË®≠ÂÆö„Åô„ÇãÈñ¢Êï∞
 */
function setupAIModelGenerationListeners() {
    console.log('üîç AI„É¢„Éá„É´ÁîüÊàê„ÅÆ„Ç§„Éô„É≥„Éà„É™„Çπ„Éä„Éº„ÇíË®≠ÂÆö‰∏≠...');
    
    // AI„É¢„Éá„É´ÁîüÊàê„Éú„Çø„É≥„ÅÆ„Ç§„Éô„É≥„Éà„É™„Çπ„Éä„Éº
    const aiGenerateBtn = document.getElementById('generate-model-btn');
    if (aiGenerateBtn) {
        aiGenerateBtn.addEventListener('click', async () => {
            const promptInput = document.getElementById('natural-language-input');
            if (!promptInput) {
                console.error('Error: Could not find element with id "natural-language-input"');
                safeAlert('ÂÖ•Âäõ„Éï„Ç£„Éº„É´„Éâ„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„ÄÇ„Éö„Éº„Ç∏„ÇíÂÜçË™≠„ÅøËæº„Åø„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ');
                return;
            }
            
            const userPrompt = promptInput.value.trim();
            const modeRadios = document.getElementsByName('ai-generation-mode');
            const selectedMode = Array.from(modeRadios).find(radio => radio.checked)?.value || 'new';
            
            if (userPrompt) {
                console.log(`üîç AIÁîüÊàê„É¢„Éº„Éâ: ${selectedMode}, ÊåáÁ§∫: "${userPrompt}"`);
                
                // ÈãºÊùêÊñ≠Èù¢ÊåáÂÆö„ÇíÊ§úÂá∫„Åó„Å¶Êñ≠Èù¢ÊÄßËÉΩ„ÇíÂèñÂæó
                try {
                    const steelDetectionResult = await detectAndFetchSteelProperties(userPrompt);
                    const enhancedPrompt = steelDetectionResult.prompt;
                    const steelData = steelDetectionResult.steelData;
                    
                    if (steelData && steelData.length > 0) {
                        console.log('‚úÖ ÈãºÊùêÊñ≠Èù¢ÊÄßËÉΩ„ÇíÂèñÂæó„Åó„Åæ„Åó„Åü:', steelData);
                        // „Çπ„ÉÜ„Éº„Çø„ÇπË°®Á§∫„ÇíÊõ¥Êñ∞
                        const aiStatus = document.getElementById('gemini-status-indicator');
                        if (aiStatus) {
                            aiStatus.textContent = `üîç ${steelData.length}ÂÄã„ÅÆÈãºÊùêÊñ≠Èù¢„ÇíÊ§úÂá∫„Åó„ÄÅÊñ≠Èù¢ÊÄßËÉΩ„ÇíÂèñÂæó„Åó„Åæ„Åó„Åü`;
                            aiStatus.style.display = 'block';
                            setTimeout(() => {
                                aiStatus.style.display = 'none';
                            }, 5000);
                        }
                    }
                    
                    // Á∑®ÈõÜ„É¢„Éº„Éâ„ÅÆÂ†¥Âêà„ÅØÁèæÂú®„ÅÆ„É¢„Éá„É´ÊÉÖÂ†±„ÇíÂèñÂæó
                    let currentModel = null;
                    if (selectedMode === 'edit') {
                        console.log('üîç ÁèæÂú®„ÅÆ„É¢„Éá„É´ÊÉÖÂ†±„ÇíÂÆåÂÖ®ÂèñÂæó‰∏≠...');
                        currentModel = getCurrentModelData();
                        console.log('üîç ËøΩÂä†Á∑®ÈõÜ„É¢„Éº„Éâ: ÁèæÂú®„ÅÆ„É¢„Éá„É´ÊÉÖÂ†±„ÇíÂèñÂæó„Åó„Åæ„Åó„Åü', currentModel);
                    }
                    
                    generateModelWithAI(enhancedPrompt, selectedMode, 0, currentModel);
                } catch (error) {
                    console.error('‚ùå ÈãºÊùêÊñ≠Èù¢Ê§úÂá∫„Ç®„É©„Éº:', error);
                    // „Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„ÅüÂ†¥Âêà„ÅØÂÖÉ„ÅÆ„Éó„É≠„É≥„Éó„Éà„ÅßÁ∂öË°å
                    let currentModel = null;
                    if (selectedMode === 'edit') {
                        currentModel = getCurrentModelData();
                    }
                    generateModelWithAI(userPrompt, selectedMode, 0, currentModel);
                }
            } else {
                safeAlert('ÊåáÁ§∫ÂÜÖÂÆπ„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ');
            }
        });
    } else {
        console.error('Error: Could not find element with id "generate-model-btn"');
    }
    
    
    // „É¢„Éº„ÉâÂàá„ÇäÊõø„Åà„ÅÆ„Ç§„Éô„É≥„Éà„É™„Çπ„Éä„Éº
    const modeRadios = document.getElementsByName('ai-generation-mode');
    Array.from(modeRadios).forEach(radio => {
        radio.addEventListener('change', updateModeDescription);
    });
    
    // ÂàùÊúüÁä∂ÊÖã„ÇíË®≠ÂÆö
    updateModeDescription();
    
    console.log('‚úÖ AI„É¢„Éá„É´ÁîüÊàê„ÅÆ„Ç§„Éô„É≥„Éà„É™„Çπ„Éä„ÉºË®≠ÂÆöÂÆå‰∫Ü');
}

/**
 * ÈãºÊùêÊñ≠Èù¢ÊåáÂÆö„ÇíÊ§úÂá∫„Åó„ÄÅÊñ≠Èù¢ÊÄßËÉΩ„ÇíÂèñÂæó„Åô„ÇãÈñ¢Êï∞
 * @param {string} prompt - „É¶„Éº„Ç∂„Éº„ÅÆÊåáÁ§∫Êñá
 * @returns {Object} Êñ≠Èù¢ÊÉÖÂ†±„ÇíÂê´„ÇÄÊã°Âºµ„Åï„Çå„Åü„Éó„É≠„É≥„Éó„Éà„Å®Êñ≠Èù¢„Éá„Éº„Çø
 */
async function detectAndFetchSteelProperties(prompt) {
    console.log('üîç ÈãºÊùêÊñ≠Èù¢ÊåáÂÆö„ÅÆÊ§úÂá∫„ÇíÈñãÂßã:', prompt);
    
    // ÈãºÊùêÊñ≠Èù¢„ÅÆ„Éë„Çø„Éº„É≥„ÇíÊ§úÂá∫
    const steelPatterns = [
        // HÂΩ¢Èãº„ÅÆ„Éë„Çø„Éº„É≥Ôºà4„Å§„ÅÆÂØ∏Ê≥ï: H√óB√ót1√ót2Ôºâ
        /H-(\d+(?:\.\d+)?)\s*[√óx]\s*(\d+(?:\.\d+)?)\s*[√óx]\s*(\d+(?:\.\d+)?)\s*[√óx]\s*(\d+(?:\.\d+)?)/gi,
        /H(\d+(?:\.\d+)?)\s*[√óx]\s*(\d+(?:\.\d+)?)\s*[√óx]\s*(\d+(?:\.\d+)?)\s*[√óx]\s*(\d+(?:\.\d+)?)/gi,
        // HÂΩ¢Èãº„ÅÆ„Éë„Çø„Éº„É≥Ôºà2„Å§„ÅÆÂØ∏Ê≥ï: H√óBÔºâ
        /H-(\d+(?:\.\d+)?)\s*[√óx]\s*(\d+(?:\.\d+)?)/gi,
        /H(\d+(?:\.\d+)?)\s*[√óx]\s*(\d+(?:\.\d+)?)/gi,
        // Ëßí„Éë„Ç§„Éó„ÅÆ„Éë„Çø„Éº„É≥
        /‚ñ°(\d+(?:\.\d+)?)\s*[√óx]\s*(\d+(?:\.\d+)?)\s*[√óx]\s*(\d+(?:\.\d+)?)/gi,
        // ÂÜÜ„Éë„Ç§„Éó„ÅÆ„Éë„Çø„Éº„É≥
        /œÜ(\d+(?:\.\d+)?)\s*[√óx]\s*(\d+(?:\.\d+)?)/gi,
        // „ÉÅ„É£„É≥„Éç„É´„ÅÆ„Éë„Çø„Éº„É≥
        /C-(\d+(?:\.\d+)?)\s*[√óx]\s*(\d+(?:\.\d+)?)\s*[√óx]\s*(\d+(?:\.\d+)?)\s*[√óx]\s*(\d+(?:\.\d+)?)/gi,
        // ËßíÈãº„ÅÆ„Éë„Çø„Éº„É≥
        /L-(\d+(?:\.\d+)?)\s*[√óx]\s*(\d+(?:\.\d+)?)\s*[√óx]\s*(\d+(?:\.\d+)?)/gi
    ];
    
    // ÈÉ®Êùê„Çø„Ç§„Éó„ÅÆ„Éë„Çø„Éº„É≥„ÇíÊ§úÂá∫
    const memberTypePatterns = [
        { pattern: /Êü±ÈÉ®Êùê|Êü±|ÂûÇÁõ¥ÈÉ®Êùê|„Ç≥„É©„É†/gi, type: 'column' },
        { pattern: /Ê¢ÅÈÉ®Êùê|Ê¢Å|Ê∞¥Âπ≥ÈÉ®Êùê|„Éì„Éº„É†/gi, type: 'beam' }
    ];
    
    let detectedSteels = [];
    let detectedMemberTypes = [];
    let enhancedPrompt = prompt;
    
    // ÈÉ®Êùê„Çø„Ç§„Éó„ÇíÊ§úÂá∫
    memberTypePatterns.forEach(({ pattern, type }) => {
        const matches = [...prompt.matchAll(pattern)];
        matches.forEach(match => {
            detectedMemberTypes.push({
                type: type,
                match: match[0],
                position: match.index
            });
        });
    });
    
    console.log('üîç Ê§úÂá∫„Åï„Çå„ÅüÈÉ®Êùê„Çø„Ç§„Éó:', detectedMemberTypes);
    
    // ÈãºÊùêÊñ≠Èù¢„Å®ÈÉ®Êùê„Çø„Ç§„Éó„ÅÆÈñ¢ÈÄ£‰ªò„Åë
    const steelMemberAssociations = [];
    
    // ÂêÑÈãºÊùêÊñ≠Èù¢„Å´„Å§„ÅÑ„Å¶„ÄÅÊúÄ„ÇÇËøë„ÅÑÈÉ®Êùê„Çø„Ç§„Éó„ÇíË¶ã„Å§„Åë„Çã
    steelPatterns.forEach((pattern, index) => {
        console.log(`üîç „Éë„Çø„Éº„É≥${index}„Çí„ÉÜ„Çπ„Éà‰∏≠:`, pattern);
        const matches = [...prompt.matchAll(pattern)];
        console.log(`üîç „Éë„Çø„Éº„É≥${index}„ÅÆ„Éû„ÉÉ„ÉÅÊï∞:`, matches.length);
        
        matches.forEach(match => {
            const steelSpec = match[0];
            const dimensions = match.slice(1).map(d => parseFloat(d));
            const steelPosition = match.index;
            
            console.log(`üîç ÈãºÊùêÊñ≠Èù¢„ÇíÊ§úÂá∫: ${steelSpec}`, dimensions, `‰ΩçÁΩÆ: ${steelPosition}`);
            
            // „Åì„ÅÆÈãºÊùêÊñ≠Èù¢„Å´ÊúÄ„ÇÇËøë„ÅÑÈÉ®Êùê„Çø„Ç§„Éó„ÇíË¶ã„Å§„Åë„Çã
            let closestMemberType = null;
            let minDistance = Infinity;
            
            detectedMemberTypes.forEach(memberType => {
                const distance = Math.abs(steelPosition - memberType.position);
                if (distance < minDistance) {
                    minDistance = distance;
                    closestMemberType = memberType;
                }
            });
            
            // Èñ¢ÈÄ£‰ªò„Åë„Çí‰ΩúÊàê
            steelMemberAssociations.push({
                steelSpec: steelSpec,
                dimensions: dimensions,
                type: getSteelTypeFromPattern(index),
                originalMatch: match,
                memberType: closestMemberType,
                distance: minDistance
            });
            
            console.log(`üîç ÈãºÊùêÊñ≠Èù¢„Äå${steelSpec}„Äç„Å®ÈÉ®Êùê„Çø„Ç§„Éó„Äå${closestMemberType?.type || 'none'}„Äç„ÇíÈñ¢ÈÄ£‰ªò„Åë (Ë∑ùÈõ¢: ${minDistance})`);
        });
    });
    
    console.log('üîç ÈãºÊùêÊñ≠Èù¢„Å®ÈÉ®Êùê„Çø„Ç§„Éó„ÅÆÈñ¢ÈÄ£‰ªò„Åë:', steelMemberAssociations);
    
    // Èñ¢ÈÄ£‰ªò„Åë„Åï„Çå„ÅüÈãºÊùêÊñ≠Èù¢„ÇídetectedSteels„Å´ËøΩÂä†
    steelMemberAssociations.forEach(association => {
        detectedSteels.push({
            spec: association.steelSpec,
            dimensions: association.dimensions,
            type: association.type,
            originalMatch: association.originalMatch,
            memberType: association.memberType
        });
    });
    
    if (detectedSteels.length === 0) {
        console.log('üîç ÈãºÊùêÊñ≠Èù¢ÊåáÂÆö„ÅØÊ§úÂá∫„Åï„Çå„Åæ„Åõ„Çì„Åß„Åó„Åü');
        return { prompt: enhancedPrompt, steelData: null };
    }
    
    console.log(`üîç ${detectedSteels.length}ÂÄã„ÅÆÈãºÊùêÊñ≠Èù¢„ÇíÊ§úÂá∫„Åó„Åæ„Åó„Åü`);
    
    // ÂêÑÊ§úÂá∫„Åï„Çå„ÅüÈãºÊùê„Å´„Å§„ÅÑ„Å¶Êñ≠Èù¢ÊÄßËÉΩ„ÇíÂèñÂæó
    const steelProperties = [];
    
    for (const steel of detectedSteels) {
        try {
            const properties = await fetchSteelProperties(steel);
            if (properties) {
                steelProperties.push(properties);
                console.log('‚úÖ Êñ≠Èù¢ÊÄßËÉΩ„ÇíÂèñÂæó:', properties.sectionName);
            } else {
                console.warn('‚ö†Ô∏è Êñ≠Èù¢ÊÄßËÉΩ„ÅÆÂèñÂæó„Å´Â§±Êïó:', steel.spec);
            }
        } catch (error) {
            console.error('‚ùå Êñ≠Èù¢ÊÄßËÉΩÂèñÂæó„Ç®„É©„Éº:', error);
        }
    }
    
    // „Éó„É≠„É≥„Éó„Éà„ÇíÊã°Âºµ
    if (steelProperties.length > 0) {
        const enhancedResult = enhancePromptWithSteelData(enhancedPrompt, steelProperties, detectedMemberTypes);
        enhancedPrompt = enhancedResult.prompt;
    }
    
    return {
        prompt: enhancedPrompt,
        steelData: steelProperties.length > 0 ? steelProperties : null,
        memberTypes: detectedMemberTypes
    };
}

/**
 * „Éë„Çø„Éº„É≥„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ„Åã„ÇâÈãºÊùê„Çø„Ç§„Éó„ÇíÂà§ÂÆö
 */
function getSteelTypeFromPattern(patternIndex) {
    const types = [
        'hkatakou_hiro',  // H-xxx√óxxx√óxxx√óxxx (4„Å§„ÅÆÂØ∏Ê≥ï)
        'hkatakou_hiro',  // Hxxx√óxxx√óxxx√óxxx (4„Å§„ÅÆÂØ∏Ê≥ï)
        'hkatakou_hoso',  // H-xxx√óxxx (2„Å§„ÅÆÂØ∏Ê≥ï) - Á¥∞ÂπÖHÂΩ¢Èãº„ÇíÂÑ™ÂÖà
        'hkatakou_hoso',  // Hxxx√óxxx (2„Å§„ÅÆÂØ∏Ê≥ï) - Á¥∞ÂπÖHÂΩ¢Èãº„ÇíÂÑ™ÂÖà
        'seihoukei',      // ‚ñ°xxx√óxxx√óxxx
        'koukan',         // œÜxxx√óxxx
        'mizogatakou',    // C-xxx√óxxx√óxxx√óxxx
        'touhenyamakatakou' // L-xxx√óxxx√óxxx
    ];
    return types[patternIndex] || 'hkatakou_hiro';
}

/**
 * steel_selector.js„Åã„ÇâÊñ≠Èù¢ÊÄßËÉΩ„ÇíÂèñÂæó„Åô„ÇãÈñ¢Êï∞
 */
async function fetchSteelProperties(steelInfo) {
    console.log('üîç Êñ≠Èù¢ÊÄßËÉΩ„ÇíÂèñÂæó‰∏≠:', steelInfo);
    
    try {
        // steel_selector.js„ÅÆÈñ¢Êï∞„ÇíÂëº„Å≥Âá∫„Åó„Å¶Êñ≠Èù¢ÊÄßËÉΩ„ÇíÂèñÂæó
        const properties = await findSteelPropertiesFromLibrary(steelInfo);
        
        // ÈÉ®Êùê„Çø„Ç§„ÉóÊÉÖÂ†±„ÇíËøΩÂä†
        if (properties && steelInfo.memberType) {
            properties.memberType = steelInfo.memberType.type;
            properties.memberTypeMatch = steelInfo.memberType.match;
            console.log(`üîç ÈÉ®Êùê„Çø„Ç§„ÉóÊÉÖÂ†±„ÇíËøΩÂä†: ${properties.memberType} (${properties.memberTypeMatch})`);
        }
        
        return properties;
    } catch (error) {
        console.error('Êñ≠Èù¢ÊÄßËÉΩÂèñÂæó„Ç®„É©„Éº:', error);
        return null;
    }
}

/**
 * steel_selector.js„ÅÆ„É©„Ç§„Éñ„É©„É™„Åã„ÇâÊñ≠Èù¢ÊÄßËÉΩ„ÇíÊ§úÁ¥¢„Åô„ÇãÈñ¢Êï∞
 */
async function findSteelPropertiesFromLibrary(steelInfo) {
    console.log('üîç „É©„Ç§„Éñ„É©„É™„Åã„ÇâÊñ≠Èù¢ÊÄßËÉΩ„ÇíÊ§úÁ¥¢:', steelInfo);
    
    // steel_selector.js„ÅÆwindow.steelData„Å´„Ç¢„ÇØ„Çª„Çπ
    if (typeof window.steelData === 'undefined') {
        console.warn('window.steelData„ÅåÂà©Áî®„Åß„Åç„Åæ„Åõ„Çì');
        console.log('üîç window.steelData:', window.steelData);
        console.log('üîç window.steelImages:', window.steelImages);
        console.log('üîç Âà©Áî®ÂèØËÉΩ„Å™window„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà:', Object.keys(window).filter(key => key.includes('steel')));
        return null;
    }
    
    console.log('‚úÖ steelData„É©„Ç§„Éñ„É©„É™„ÅåÂà©Áî®ÂèØËÉΩ:', Object.keys(window.steelData));
    
    const steelType = steelInfo.type;
    const dimensions = steelInfo.dimensions;
    const spec = steelInfo.spec;
    
    // HÂΩ¢Èãº„ÅÆÂ†¥Âêà„ÅØ„ÄÅ„Åæ„ÅöÊ≠£Á¢∫„Å™Êñ≠Èù¢Âêç„ÅßÊ§úÁ¥¢„ÇíË©¶Ë°å
    if (steelType.startsWith('hkatakou') && spec) {
        console.log('üîç HÂΩ¢Èãº„ÅÆÊ≠£Á¢∫„Å™Êñ≠Èù¢Âêç„ÅßÊ§úÁ¥¢:', spec);
        
        // AI„Åã„ÇâÊèê‰æõ„Åï„Çå„ÅüÊñ≠Èù¢Âêç„Åã„ÇâÂØ∏Ê≥ï„ÇíÊäΩÂá∫Ôºà‰æã: "H-200√ó200√ó8√ó12" ‚Üí "200√ó200"Ôºâ
        let targetDimensions = '';
        if (spec.startsWith('H-')) {
            // "H-200√ó200√ó8√ó12" ‚Üí "200√ó200"
            const parts = spec.substring(2).split('√ó');
            if (parts.length >= 2) {
                targetDimensions = `${parts[0]}√ó${parts[1]}`;
            }
        } else {
            // Êó¢„Å´ÂØ∏Ê≥ï„ÅÆ„Åø„ÅÆÂΩ¢Âºè„ÅÆÂ†¥Âêà
            targetDimensions = spec;
        }
        
        console.log('üîç ÊäΩÂá∫„Åï„Çå„ÅüÂØ∏Ê≥ï:', targetDimensions);
        
        // ÂÖ®„Å¶„ÅÆHÂΩ¢Èãº„Ç´„ÉÜ„Ç¥„É™„ÇíÊ§úÁ¥¢
        const hBeamCategories = ['hkatakou_hiro', 'hkatakou_naka', 'hkatakou_hoso'];
        
        for (const category of hBeamCategories) {
            if (window.steelData[category]) {
                console.log(`üîç ${category} „ÅßÊñ≠Èù¢Âêç "${targetDimensions}" „ÇíÊ§úÁ¥¢`);
                
                for (let i = 0; i < window.steelData[category].data.length; i++) {
                    const rowData = window.steelData[category].data[i];
                    const sectionName = rowData[0] ? String(rowData[0]) : '';
                    
                    // Êñ≠Èù¢Âêç„ÅåÂÆåÂÖ®‰∏ÄËá¥„Åô„ÇãÂ†¥ÂêàÔºàÂØ∏Ê≥ï„ÅÆ„Åø„ÅßÊØîËºÉÔºâ
                    if (sectionName === targetDimensions) {
                        console.log(`‚úÖ Ê≠£Á¢∫„Å™Êñ≠Èù¢Âêç„ÅßÁô∫Ë¶ã: ${category} - ${sectionName}`);
                        
                        const rowDims = getDimensionsFromRow(category, rowData, window.steelData[category].headers);
                        
                        // Êñ≠Èù¢ÊÄßËÉΩ„ÇíÂèñÂæó
                        const actualHeaders = window.steelData[category].headers;
                        const normalizedHeaders = actualHeaders.map(normalizeHeaderKey);
                        const getProp = (...keys) => findRowValueByKeys(actualHeaders, normalizedHeaders, rowData, ...keys);
                        
                        const areaValue = getProp('Êñ≠Èù¢Á©ç', 'Èù¢Á©ç', 'A');
                        const ixValue = getProp('Ix', 'Âº∑Ëª∏Êñ≠Èù¢2Ê¨°„É¢„Éº„É°„É≥„Éà', 'I');
                        const iyValue = getProp('Iy', 'Âº±Ëª∏Êñ≠Èù¢2Ê¨°„É¢„Éº„É°„É≥„Éà', 'I');
                        const zxValue = getProp('Zx', 'Âº∑Ëª∏Êñ≠Èù¢‰øÇÊï∞', 'Z');
                        const zyValue = getProp('Zy', 'Âº±Ëª∏Êñ≠Èù¢‰øÇÊï∞', 'Z');
                        const radiusXValue = (function(){
                            const v = getProp('ix', 'Âº∑Ëª∏Êñ≠Èù¢2Ê¨°ÂçäÂæÑ');
                            if (v !== undefined) return v;
                            try {
                                for (let idx=0; idx<actualHeaders.length; idx++){
                                    const raw = (actualHeaders[idx]||'').toString();
                                    const nh = normalizedHeaders[idx] || normalizeHeaderKey(raw);
                                    const hasRadiusWord = /ÂçäÂæÑ|radius|Êñ≠Èù¢2Ê¨°ÂçäÂæÑ/i.test(raw);
                                    const looksLikeMoment = /cm\s*\^?4|cm‚Å¥|cm4|cm4/i.test(raw) || /Êñ≠Èù¢2Ê¨°„É¢„Éº„É°„É≥„Éà|moment of inertia|‰∫åÊ¨°„É¢„Éº„É°„É≥„Éà/i.test(raw);
                                    if (!hasRadiusWord || looksLikeMoment) continue;
                                    if (nh === 'i' || nh.includes('ÂçäÂæÑ') || /\bi\b/.test(raw.trim())) return rowData[idx];
                                }
                            } catch(_){}
                            return undefined;
                        })();
                        const radiusYValue = (function(){
                            const v = getProp('iy', 'Âº±Ëª∏Êñ≠Èù¢2Ê¨°ÂçäÂæÑ');
                            if (v !== undefined) return v;
                            try {
                                for (let idx=0; idx<actualHeaders.length; idx++){
                                    const raw = (actualHeaders[idx]||'').toString();
                                    const nh = normalizedHeaders[idx] || normalizeHeaderKey(raw);
                                    const hasRadiusWord = /ÂçäÂæÑ|radius|Êñ≠Èù¢2Ê¨°ÂçäÂæÑ/i.test(raw);
                                    const looksLikeMoment = /cm\s*\^?4|cm‚Å¥|cm4|cm4/i.test(raw) || /Êñ≠Èù¢2Ê¨°„É¢„Éº„É°„É≥„Éà|moment of inertia|‰∫åÊ¨°„É¢„Éº„É°„É≥„Éà/i.test(raw);
                                    if (!hasRadiusWord || looksLikeMoment) continue;
                                    if (nh === 'i' || nh.includes('ÂçäÂæÑ') || /\bi\b/.test(raw.trim())) return rowData[idx];
                                }
                            } catch(_){}
                            return undefined;
                        })();
                        const t1Value = getProp('t1', 't1', 't1');
                        const t2Value = getProp('t2', 't2', 't2');
                        
                        // AI„Åã„ÇâÊèê‰æõ„Åï„Çå„ÅüÂÖÉ„ÅÆÊñ≠Èù¢Âêç„ÇíÂÑ™ÂÖà
                        const finalSectionName = steelInfo.spec || (rowData[0] ? String(rowData[0]) : '');
                        
                        // ÈãºÊùê„Çø„Ç§„Éó„Åã„Çâ„É©„Éô„É´„ÇíÁîüÊàê
                        const getTypeLabel = (steelType) => {
                            const typeLabels = {
                                'hkatakou_hiro': 'HÂΩ¢ÈãºÔºàÂ∫ÉÂπÖÔºâ',
                                'hkatakou_naka': 'HÂΩ¢ÈãºÔºà‰∏≠ÂπÖÔºâ',
                                'hkatakou_hoso': 'HÂΩ¢ÈãºÔºàÁ¥∞ÂπÖÔºâ',
                                'ikatakou': 'IÂΩ¢Èãº',
                                'keiryouhkatakou': 'ËªΩÈáèHÂΩ¢Èãº',
                                'keiryourippuhkatakou': 'ËªΩÈáè„É™„ÉÉ„ÉóHÂΩ¢Èãº',
                                'mizogatakou': '„Åø„ÅûÂΩ¢Èãº',
                                'keimizogatakou': 'ËªΩ„Åø„ÅûÂΩ¢Èãº',
                                'rippumizokatakou': '„É™„ÉÉ„Éó„Åø„ÅûÂΩ¢Èãº',
                                'touhenyamakatakou': 'Á≠âËæ∫Â±±ÂΩ¢Èãº',
                                'futouhenyamagata': '‰∏çÁ≠âËæ∫Â±±ÂΩ¢Èãº',
                                'seihoukei': 'ËßíÂΩ¢ÈãºÁÆ°ÔºàÊ≠£ÊñπÂΩ¢Ôºâ',
                                'tyouhoukei': 'ËßíÂΩ¢ÈãºÁÆ°ÔºàÈï∑ÊñπÂΩ¢Ôºâ',
                                'koukan': '‰∏∏ÂΩ¢ÈãºÁÆ°'
                            };
                            return typeLabels[steelType] || steelType;
                        };
                        
                        const typeLabel = getTypeLabel(category);
                        const designation = rowData[0] ? String(rowData[0]) : '';
                        
                        // Ëª∏ÊñπÂêë„ÅÆÂà§ÂÆö
                        const isStrongAxisX = (ixValue && iyValue) ? ixValue > iyValue : true;
                        const axisDirection = isStrongAxisX ? 'XËª∏' : 'YËª∏';
                        
                        // ÊùøÂéöÊÉÖÂ†±„ÇíÂê´„ÇÄÂÆåÂÖ®„Å™ÂØ∏Ê≥ïÊÉÖÂ†±„Çí‰ΩúÊàê
                        const fullDimensions = {
                            ...rowDims,
                            t1: t1Value,
                            t2: t2Value
                        };
                        
                        return {
                            sectionName: finalSectionName,
                            sectionSpec: steelInfo.spec,
                            sectionType: category,
                            typeLabel: typeLabel,
                            designation: designation,
                            dimensions: fullDimensions,
                            axisDirection: axisDirection,
                            isStrongAxisX: isStrongAxisX,
                            properties: {
                                A: areaValue,
                                Ix: ixValue,
                                Iy: iyValue,
                                Zx: zxValue,
                                Zy: zyValue,
                                ix: radiusXValue,
                                iy: radiusYValue
                            },
                            matchDistance: 0,
                            sectionInfo: {
                                typeKey: category,
                                typeLabel: typeLabel,
                                designation: designation,
                                dims: fullDimensions,
                                properties: {
                                    A: areaValue,
                                    Ix: ixValue,
                                    Iy: iyValue,
                                    Zx: zxValue,
                                    Zy: zyValue,
                                    ix: radiusXValue,
                                    iy: radiusYValue
                                },
                                label: `${typeLabel} ${designation}`,
                                source: 'AIÁîüÊàê'
                            },
                            sectionInfoEncoded: '',
                            sectionLabel: `${typeLabel} ${designation}`,
                            index: i,
                            rowData: rowData,
                            distance: 0,
                            steelType: category
                        };
                    }
                    
                    // Êñ≠Èù¢Âêç„Å´Âê´„Åæ„Çå„ÇãÂ†¥ÂêàÔºàÈÉ®ÂàÜ‰∏ÄËá¥Ôºâ- ÊäΩÂá∫„Åï„Çå„ÅüÂØ∏Ê≥ï„Çí‰ΩøÁî®
                    if (sectionName.includes(targetDimensions) || targetDimensions.includes(sectionName)) {
                        console.log(`üîç ÈÉ®ÂàÜ‰∏ÄËá¥Áô∫Ë¶ã: ${category} - ${sectionName}`);
                        
                        const rowDims = getDimensionsFromRow(category, rowData, window.steelData[category].headers);
                        
                        // Êñ≠Èù¢ÊÄßËÉΩ„ÇíÂèñÂæó
                        const actualHeaders = window.steelData[category].headers;
                        const normalizedHeaders = actualHeaders.map(normalizeHeaderKey);
                        const getProp = (...keys) => findRowValueByKeys(actualHeaders, normalizedHeaders, rowData, ...keys);
                        
                        const areaValue = getProp('Êñ≠Èù¢Á©ç', 'Èù¢Á©ç', 'A');
                        const ixValue = getProp('Ix', 'Âº∑Ëª∏Êñ≠Èù¢2Ê¨°„É¢„Éº„É°„É≥„Éà', 'I');
                        const iyValue = getProp('Iy', 'Âº±Ëª∏Êñ≠Èù¢2Ê¨°„É¢„Éº„É°„É≥„Éà', 'I');
                        const zxValue = getProp('Zx', 'Âº∑Ëª∏Êñ≠Èù¢‰øÇÊï∞', 'Z');
                        const zyValue = getProp('Zy', 'Âº±Ëª∏Êñ≠Èù¢‰øÇÊï∞', 'Z');
                        const radiusXValue = getProp('ix', 'Âº∑Ëª∏Êñ≠Èù¢2Ê¨°ÂçäÂæÑ');
                        const radiusYValue = getProp('iy', 'Âº±Ëª∏Êñ≠Èù¢2Ê¨°ÂçäÂæÑ');
                        const t1Value = getProp('t1', 't1', 't1');
                        const t2Value = getProp('t2', 't2', 't2');
                        
                        // AI„Åã„ÇâÊèê‰æõ„Åï„Çå„ÅüÂÖÉ„ÅÆÊñ≠Èù¢Âêç„ÇíÂÑ™ÂÖà
                        const finalSectionName = steelInfo.spec || (rowData[0] ? String(rowData[0]) : '');
                        
                        // ÈãºÊùê„Çø„Ç§„Éó„Åã„Çâ„É©„Éô„É´„ÇíÁîüÊàê
                        const getTypeLabel = (steelType) => {
                            const typeLabels = {
                                'hkatakou_hiro': 'HÂΩ¢ÈãºÔºàÂ∫ÉÂπÖÔºâ',
                                'hkatakou_naka': 'HÂΩ¢ÈãºÔºà‰∏≠ÂπÖÔºâ',
                                'hkatakou_hoso': 'HÂΩ¢ÈãºÔºàÁ¥∞ÂπÖÔºâ',
                                'ikatakou': 'IÂΩ¢Èãº',
                                'keiryouhkatakou': 'ËªΩÈáèHÂΩ¢Èãº',
                                'keiryourippuhkatakou': 'ËªΩÈáè„É™„ÉÉ„ÉóHÂΩ¢Èãº',
                                'mizogatakou': '„Åø„ÅûÂΩ¢Èãº',
                                'keimizogatakou': 'ËªΩ„Åø„ÅûÂΩ¢Èãº',
                                'rippumizokatakou': '„É™„ÉÉ„Éó„Åø„ÅûÂΩ¢Èãº',
                                'touhenyamakatakou': 'Á≠âËæ∫Â±±ÂΩ¢Èãº',
                                'futouhenyamagata': '‰∏çÁ≠âËæ∫Â±±ÂΩ¢Èãº',
                                'seihoukei': 'ËßíÂΩ¢ÈãºÁÆ°ÔºàÊ≠£ÊñπÂΩ¢Ôºâ',
                                'tyouhoukei': 'ËßíÂΩ¢ÈãºÁÆ°ÔºàÈï∑ÊñπÂΩ¢Ôºâ',
                                'koukan': '‰∏∏ÂΩ¢ÈãºÁÆ°'
                            };
                            return typeLabels[steelType] || steelType;
                        };
                        
                        const typeLabel = getTypeLabel(category);
                        const designation = rowData[0] ? String(rowData[0]) : '';
                        
                        // Ëª∏ÊñπÂêë„ÅÆÂà§ÂÆö
                        const isStrongAxisX = (ixValue && iyValue) ? ixValue > iyValue : true;
                        const axisDirection = isStrongAxisX ? 'XËª∏' : 'YËª∏';
                        
                        // ÊùøÂéöÊÉÖÂ†±„ÇíÂê´„ÇÄÂÆåÂÖ®„Å™ÂØ∏Ê≥ïÊÉÖÂ†±„Çí‰ΩúÊàê
                        const fullDimensions = {
                            ...rowDims,
                            t1: t1Value,
                            t2: t2Value
                        };
                        
                        return {
                            sectionName: finalSectionName,
                            sectionSpec: steelInfo.spec,
                            sectionType: category,
                            typeLabel: typeLabel,
                            designation: designation,
                            dimensions: fullDimensions,
                            axisDirection: axisDirection,
                            isStrongAxisX: isStrongAxisX,
                            properties: {
                                A: areaValue,
                                Ix: ixValue,
                                Iy: iyValue,
                                Zx: zxValue,
                                Zy: zyValue,
                                ix: radiusXValue,
                                iy: radiusYValue
                            },
                            matchDistance: 0.1, // ÈÉ®ÂàÜ‰∏ÄËá¥„ÅØ‰Ωé„ÅÑË∑ùÈõ¢
                            sectionInfo: {
                                typeKey: category,
                                typeLabel: typeLabel,
                                designation: designation,
                                dims: fullDimensions,
                                properties: {
                                    A: areaValue,
                                    Ix: ixValue,
                                    Iy: iyValue,
                                    Zx: zxValue,
                                    Zy: zyValue,
                                    ix: radiusXValue,
                                    iy: radiusYValue
                                },
                                label: `${typeLabel} ${designation}`,
                                source: 'AIÁîüÊàê'
                            },
                            sectionInfoEncoded: '',
                            sectionLabel: `${typeLabel} ${designation}`,
                            index: i,
                            rowData: rowData,
                            distance: 0.1,
                            steelType: category
                        };
                    }
                }
            }
        }
    }
    
    if (!window.steelData[steelType]) {
        console.warn(`ÈãºÊùê„Çø„Ç§„Éó ${steelType} „ÅÆ„Éá„Éº„Çø„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì`);
        return null;
    }
    
    const steel = window.steelData[steelType];
    const headers = steel.headers;
    const data = steel.data;
    
    // ÂØ∏Ê≥ï„Å´Âü∫„Å•„ÅÑ„Å¶ÊúÄÈÅ©„Å™Êñ≠Èù¢„ÇíÊ§úÁ¥¢
    let bestMatch = null;
    let minDistance = Infinity;
    
    for (let i = 0; i < data.length; i++) {
        const rowData = data[i];
        const rowDims = getDimensionsFromRow(steelType, rowData, headers);
        
        const distance = calculateDimensionDistance(dimensions, rowDims, steelType);
        
        if (distance < minDistance) {
            minDistance = distance;
            bestMatch = {
                index: i,
                rowData: rowData,
                dimensions: rowDims,
                distance: distance
            };
        }
    }
    
    // HÂΩ¢Èãº„ÅÆÂ†¥Âêà„ÄÅ‰ªñ„ÅÆ„Ç´„ÉÜ„Ç¥„É™„ÇÇÊ§úÁ¥¢
    if (steelType.startsWith('hkatakou')) {
        console.log('üîç HÂΩ¢Èãº„ÅÆ‰ªñ„ÅÆ„Ç´„ÉÜ„Ç¥„É™„ÇÇÊ§úÁ¥¢');
        
        const hBeamCategories = ['hkatakou_hiro', 'hkatakou_naka', 'hkatakou_hoso'];
        
        for (const category of hBeamCategories) {
            if (category !== steelType && window.steelData[category]) {
                console.log(`üîç ${category} „ÅßÂØ∏Ê≥ï„Éô„Éº„ÇπÊ§úÁ¥¢`);
                
                for (let i = 0; i < window.steelData[category].data.length; i++) {
                    const rowData = window.steelData[category].data[i];
                    const rowDims = getDimensionsFromRow(category, rowData, window.steelData[category].headers);
                    
                    const distance = calculateDimensionDistance(dimensions, rowDims, category);
                    
                    if (distance < minDistance) {
                        minDistance = distance;
                        bestMatch = {
                            index: i,
                            rowData: rowData,
                            dimensions: rowDims,
                            distance: distance,
                            steelType: category
                        };
                        console.log(`üîç Êñ∞„Åó„ÅÑÊúÄÈÅ©„Éû„ÉÉ„ÉÅ (${category}):`, bestMatch);
                    }
                }
            }
        }
    }
    
    if (!bestMatch) {
        console.warn('ÈÅ©Âêà„Åô„ÇãÊñ≠Èù¢„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„Åß„Åó„Åü');
        return null;
    }
    
    console.log('‚úÖ ÊúÄÈÅ©„Å™Êñ≠Èù¢„ÇíÁô∫Ë¶ã:', bestMatch);
    
    // Êñ≠Èù¢ÊÄßËÉΩ„ÇíÂèñÂæó
    const actualSteelType = bestMatch.steelType || steelType;
    const actualSteelData = window.steelData[actualSteelType];
    const actualHeaders = actualSteelData.headers;
    const normalizedHeaders = actualHeaders.map(normalizeHeaderKey);
    const getProp = (...keys) => findRowValueByKeys(actualHeaders, normalizedHeaders, bestMatch.rowData, ...keys);
    
    const areaValue = getProp('Êñ≠Èù¢Á©ç', 'Èù¢Á©ç', 'A');
    const ixValue = getProp('Ix', 'Âº∑Ëª∏Êñ≠Èù¢2Ê¨°„É¢„Éº„É°„É≥„Éà', 'I');
    const iyValue = getProp('Iy', 'Âº±Ëª∏Êñ≠Èù¢2Ê¨°„É¢„Éº„É°„É≥„Éà', 'I');
    const zxValue = getProp('Zx', 'Âº∑Ëª∏Êñ≠Èù¢‰øÇÊï∞', 'Z');
    const zyValue = getProp('Zy', 'Âº±Ëª∏Êñ≠Èù¢‰øÇÊï∞', 'Z');
    const radiusXValue = (function(){
        const v = getProp('ix', 'Âº∑Ëª∏Êñ≠Èù¢2Ê¨°ÂçäÂæÑ');
        if (v !== undefined) return v;
        try {
            for (let idx=0; idx<actualHeaders.length; idx++){
                const raw = (actualHeaders[idx]||'').toString();
                const nh = normalizedHeaders[idx] || normalizeHeaderKey(raw);
                const hasRadiusWord = /ÂçäÂæÑ|radius|Êñ≠Èù¢2Ê¨°ÂçäÂæÑ/i.test(raw);
                const looksLikeMoment = /cm\s*\^?4|cm‚Å¥|cm4|cm4/i.test(raw) || /Êñ≠Èù¢2Ê¨°„É¢„Éº„É°„É≥„Éà|moment of inertia|‰∫åÊ¨°„É¢„Éº„É°„É≥„Éà/i.test(raw);
                if (!hasRadiusWord || looksLikeMoment) continue;
                if (nh === 'i' || nh.includes('ÂçäÂæÑ') || /\bi\b/.test(raw.trim())) return rowData[idx];
            }
        } catch(_){}
        return undefined;
    })();
    const radiusYValue = (function(){
        const v = getProp('iy', 'Âº±Ëª∏Êñ≠Èù¢2Ê¨°ÂçäÂæÑ');
        if (v !== undefined) return v;
        try {
            for (let idx=0; idx<actualHeaders.length; idx++){
                const raw = (actualHeaders[idx]||'').toString();
                const nh = normalizedHeaders[idx] || normalizeHeaderKey(raw);
                const hasRadiusWord = /ÂçäÂæÑ|radius|Êñ≠Èù¢2Ê¨°ÂçäÂæÑ/i.test(raw);
                const looksLikeMoment = /cm\s*\^?4|cm‚Å¥|cm4|cm4/i.test(raw) || /Êñ≠Èù¢2Ê¨°„É¢„Éº„É°„É≥„Éà|moment of inertia|‰∫åÊ¨°„É¢„Éº„É°„É≥„Éà/i.test(raw);
                if (!hasRadiusWord || looksLikeMoment) continue;
                if (nh === 'i' || nh.includes('ÂçäÂæÑ') || /\bi\b/.test(raw.trim())) return rowData[idx];
            }
        } catch(_){}
        return undefined;
    })();
    
    // ÊùøÂéöÊÉÖÂ†±„ÇÇÂèñÂæó
    const t1Value = getProp('t1', 't1', 't1');
    const t2Value = getProp('t2', 't2', 't2');
    
    // AI„Åã„ÇâÊèê‰æõ„Åï„Çå„ÅüÂÖÉ„ÅÆÊñ≠Èù¢Âêç„ÇíÂÑ™ÂÖà„Åó„ÄÅ„É©„Ç§„Éñ„É©„É™„ÅÆÊñ≠Èù¢Âêç„ÅØ„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ„Å®„Åó„Å¶‰ΩøÁî®
    const sectionName = steelInfo.spec || (bestMatch.rowData[0] ? String(bestMatch.rowData[0]) : '');
    
    // ÈãºÊùê„Çø„Ç§„Éó„Åã„Çâ„É©„Éô„É´„ÇíÁîüÊàê
    const getTypeLabel = (steelType) => {
        const typeLabels = {
            'hkatakou_hiro': 'HÂΩ¢ÈãºÔºàÂ∫ÉÂπÖÔºâ',
            'hkatakou_naka': 'HÂΩ¢ÈãºÔºà‰∏≠ÂπÖÔºâ',
            'hkatakou_hoso': 'HÂΩ¢ÈãºÔºàÁ¥∞ÂπÖÔºâ',
            'ikatakou': 'IÂΩ¢Èãº',
            'keiryouhkatakou': 'ËªΩÈáèHÂΩ¢Èãº',
            'keiryourippuhkatakou': 'ËªΩÈáè„É™„ÉÉ„ÉóHÂΩ¢Èãº',
            'mizogatakou': '„Åø„ÅûÂΩ¢Èãº',
            'keimizogatakou': 'ËªΩ„Åø„ÅûÂΩ¢Èãº',
            'rippumizokatakou': '„É™„ÉÉ„Éó„Åø„ÅûÂΩ¢Èãº',
            'touhenyamakatakou': 'Á≠âËæ∫Â±±ÂΩ¢Èãº',
            'futouhenyamagata': '‰∏çÁ≠âËæ∫Â±±ÂΩ¢Èãº',
            'seihoukei': 'ËßíÂΩ¢ÈãºÁÆ°ÔºàÊ≠£ÊñπÂΩ¢Ôºâ',
            'tyouhoukei': 'ËßíÂΩ¢ÈãºÁÆ°ÔºàÈï∑ÊñπÂΩ¢Ôºâ',
            'koukan': '‰∏∏ÂΩ¢ÈãºÁÆ°'
        };
        return typeLabels[steelType] || steelType;
    };
    
    const typeLabel = getTypeLabel(actualSteelType);
    const designation = bestMatch.rowData[0] ? String(bestMatch.rowData[0]) : '';
    
    // Ëª∏ÊñπÂêë„ÅÆÂà§ÂÆöÔºàIx > Iy „ÅÆÂ†¥Âêà„ÅØÂº∑Ëª∏„ÅåXËª∏„ÄÅ„Åù„ÅÜ„Åß„Å™„Åë„Çå„Å∞YËª∏Ôºâ
    const isStrongAxisX = (ixValue && iyValue) ? ixValue > iyValue : true;
    const axisDirection = isStrongAxisX ? 'XËª∏' : 'YËª∏';
    
    // ÊùøÂéöÊÉÖÂ†±„ÇíÂê´„ÇÄÂÆåÂÖ®„Å™ÂØ∏Ê≥ïÊÉÖÂ†±„Çí‰ΩúÊàê
    const fullDimensions = {
        ...bestMatch.dimensions,
        t1: t1Value,
        t2: t2Value
    };
    
    return {
        sectionName: sectionName,
        sectionSpec: steelInfo.spec,
        sectionType: actualSteelType,
        typeLabel: typeLabel,
        designation: designation,
        dimensions: fullDimensions,
        axisDirection: axisDirection,
        isStrongAxisX: isStrongAxisX,
        properties: {
            A: areaValue,
            Ix: ixValue,
            Iy: iyValue,
            Zx: zxValue,
            Zy: zyValue,
            ix: radiusXValue,
            iy: radiusYValue
        },
        matchDistance: bestMatch.distance,
        // Êñ≠Èù¢ÊÉÖÂ†±„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÇíËøΩÂä†
        sectionInfo: {
            typeKey: actualSteelType,
            typeLabel: typeLabel,
            designation: designation,
            dims: fullDimensions,
            properties: {
                A: areaValue,
                Ix: ixValue,
                Iy: iyValue,
                Zx: zxValue,
                Zy: zyValue,
                ix: radiusXValue,
                iy: radiusYValue
            },
            label: `${typeLabel} ${designation}`,
            source: 'AIÁîüÊàê'
        },
        // „Åù„ÅÆ‰ªñ„ÅÆÊñ≠Èù¢ÊÉÖÂ†±„Éó„É≠„Éë„ÉÜ„Ç£„ÇÇËøΩÂä†
        sectionInfoEncoded: '',
        sectionLabel: `${typeLabel} ${designation}`,
        sectionSummary: `${typeLabel} ${designation}`,
        sectionSource: 'AIÁîüÊàê',
        sectionAxisKey: isStrongAxisX ? 'X' : 'Y',
        sectionAxisMode: 'strong',
        sectionAxisLabel: isStrongAxisX ? 'Âº∑Ëª∏ (XËª∏)' : 'Âº∑Ëª∏ (YËª∏)'
    };
}

/**
 * ÂØ∏Ê≥ïÈñì„ÅÆË∑ùÈõ¢„ÇíË®àÁÆó„Åô„ÇãÈñ¢Êï∞
 */
function calculateDimensionDistance(targetDims, actualDims, steelType) {
    let distance = 0;
    
    switch (steelType) {
        case 'hkatakou_hiro':
        case 'hkatakou_naka':
        case 'hkatakou_hoso':
        case 'ikatakou':
        case 'keiryouhkatakou':
            // HÂΩ¢Èãº: H, B, t1, t2 „Åæ„Åü„ÅØ H, B „ÅÆ„Åø
            if (targetDims.length >= 4 && actualDims.H && actualDims.B && actualDims.t1 && actualDims.t2) {
                // 4„Å§„ÅÆÂØ∏Ê≥ï„ÅåÊåáÂÆö„Åï„Çå„Å¶„ÅÑ„ÇãÂ†¥Âêà
                distance += Math.pow(targetDims[0] - actualDims.H, 2) * 2;  // H
                distance += Math.pow(targetDims[1] - actualDims.B, 2) * 2;  // B
                distance += Math.pow(targetDims[2] - actualDims.t1, 2);     // t1
                distance += Math.pow(targetDims[3] - actualDims.t2, 2);     // t2
            } else if (targetDims.length >= 2 && actualDims.H && actualDims.B) {
                // 2„Å§„ÅÆÂØ∏Ê≥ïÔºàH, BÔºâ„ÅÆ„Åø„ÅåÊåáÂÆö„Åï„Çå„Å¶„ÅÑ„ÇãÂ†¥Âêà
                distance += Math.pow(targetDims[0] - actualDims.H, 2) * 3;  // H (Èáç„Åø„Çí‰∏ä„Åí„Çã)
                distance += Math.pow(targetDims[1] - actualDims.B, 2) * 3;  // B (Èáç„Åø„Çí‰∏ä„Åí„Çã)
            } else {
                distance = Infinity;
            }
            break;
        case 'seihoukei':
        case 'tyouhoukei':
            // Ëßí„Éë„Ç§„Éó: A, B, t
            if (targetDims.length >= 3 && actualDims.A && actualDims.B && actualDims.t) {
                distance += Math.pow(targetDims[0] - actualDims.A, 2) * 2;  // A
                distance += Math.pow(targetDims[1] - actualDims.B, 2) * 2;  // B
                distance += Math.pow(targetDims[2] - actualDims.t, 2);      // t
            } else {
                distance = Infinity;
            }
            break;
        case 'koukan':
            // ÂÜÜ„Éë„Ç§„Éó: D, t
            if (targetDims.length >= 2 && actualDims.D && actualDims.t) {
                distance += Math.pow(targetDims[0] - actualDims.D, 2) * 3;  // D
                distance += Math.pow(targetDims[1] - actualDims.t, 2);      // t
            } else {
                distance = Infinity;
            }
            break;
        case 'mizogatakou':
        case 'keimizogatakou':
        case 'rippumizokatakou':
            // „ÉÅ„É£„É≥„Éç„É´: H, B, t1, t2
            if (targetDims.length >= 4 && actualDims.H && actualDims.B && actualDims.t1 && actualDims.t2) {
                distance += Math.pow(targetDims[0] - actualDims.H, 2) * 2;  // H
                distance += Math.pow(targetDims[1] - actualDims.B, 2) * 2;  // B
                distance += Math.pow(targetDims[2] - actualDims.t1, 2);     // t1
                distance += Math.pow(targetDims[3] - actualDims.t2, 2);     // t2
            } else {
                distance = Infinity;
            }
            break;
        case 'touhenyamakatakou':
        case 'futouhenyamagata':
            // ËßíÈãº: A, B, t
            if (targetDims.length >= 3 && actualDims.A && actualDims.B && actualDims.t) {
                distance += Math.pow(targetDims[0] - actualDims.A, 2) * 2;  // A
                distance += Math.pow(targetDims[1] - actualDims.B, 2) * 2;  // B
                distance += Math.pow(targetDims[2] - actualDims.t, 2);      // t
            } else {
                distance = Infinity;
            }
            break;
        default:
            distance = Infinity;
    }
    
    return Math.sqrt(distance);
}

/**
 * steel_selector.js„ÅÆÈñ¢Êï∞„ÇíÂëº„Å≥Âá∫„Åô„Åü„ÇÅ„ÅÆ„Éò„É´„Éë„ÉºÈñ¢Êï∞
 */
function getDimensionsFromRow(type, rowData, headers) {
    const dims = {};
    
    const findValue = (namePart) => {
        const name = namePart.toLowerCase();
        const index = headers.findIndex(h => h.toLowerCase().startsWith(name));
        const value = index !== -1 ? parseFloat(rowData[index]) : NaN;
        return isNaN(value) ? 0 : value;
    };
    
    try {
        switch (type) {
            case 'hkatakou_hiro':
            case 'hkatakou_naka':
            case 'hkatakou_hoso':
            case 'ikatakou':
            case 'keiryouhkatakou':
                const hSizes = String(rowData[0] || '0√ó0').split('√ó').map(v => parseFloat(v) || 0);
                [dims.H, dims.B] = hSizes.length >= 2 ? hSizes : [0, 0];
                dims.t1 = findValue('t1');
                dims.t2 = findValue('t2');
                console.log(`üîç getDimensionsFromRow: ${rowData[0]} ‚Üí H=${dims.H}, B=${dims.B}, t1=${dims.t1}, t2=${dims.t2}`);
                break;
            case 'seihoukei':
            case 'tyouhoukei':
                const kakuSizes = String(rowData[0] || '0√ó0').split('√ó').map(v => parseFloat(v) || 0);
                [dims.A, dims.B] = kakuSizes.length >= 2 ? kakuSizes : [0, 0];
                dims.t = findValue('t');
                break;
            case 'koukan':
                dims.D = parseFloat(rowData[0]) || 0;
                dims.t = findValue('ÊùøÂéö');
                break;
        }
    } catch (error) {
        console.error('Error parsing dimensions:', error);
    }
    
    return dims;
}

/**
 * steel_selector.js„ÅÆÈñ¢Êï∞„ÇíÂëº„Å≥Âá∫„Åô„Åü„ÇÅ„ÅÆ„Éò„É´„Éë„ÉºÈñ¢Êï∞
 */
function normalizeHeaderKey(header) {
    if (header === undefined || header === null) return '';
    return header
        .toString()
        .trim()
        .normalize('NFKC')
        .replace(/[Ôºà(].*?[)Ôºâ]/g, '')
        .replace(/[\sÔºø‚ÄêÔºç‚Äì‚Äî]/g, '')
        .replace(/[Ôºä*√ó‚úï‚úñ]/g, 'x')
        .toLowerCase();
}

/**
 * steel_selector.js„ÅÆÈñ¢Êï∞„ÇíÂëº„Å≥Âá∫„Åô„Åü„ÇÅ„ÅÆ„Éò„É´„Éë„ÉºÈñ¢Êï∞
 */
function findRowValueByKeys(headers, normalizedHeaders, rowData, ...keys) {
    if (!Array.isArray(headers) || !Array.isArray(rowData)) return undefined;

    const normalizedTokens = keys
        .flatMap(key => {
            if (key === undefined || key === null) return [];
            const str = key.toString();
            return [normalizeHeaderKey(str), normalizeKey(str)];
        })
        .filter(Boolean);

    if (normalizedTokens.length === 0) return undefined;

    const longTokens = normalizedTokens.filter(token => token.length > 1);
    const shortTokens = normalizedTokens.filter(token => token.length <= 1);

    const ensureNormalizedHeader = (index) => normalizedHeaders?.[index] ?? normalizeHeaderKey(headers[index]);

    if (longTokens.length > 0) {
        for (let index = 0; index < headers.length; index++) {
            const normalizedHeader = ensureNormalizedHeader(index);
            if (!normalizedHeader) continue;
            if (longTokens.some(token => normalizedHeader.includes(token))) {
                return rowData[index];
            }
        }
    }

    if (shortTokens.length > 0) {
        for (let index = 0; index < headers.length; index++) {
            const normalizedHeader = ensureNormalizedHeader(index);
            if (!normalizedHeader) continue;
            if (shortTokens.some(token => normalizedHeader === token)) {
                return rowData[index];
            }
        }
    }

    return undefined;
}

/**
 * steel_selector.js„ÅÆÈñ¢Êï∞„ÇíÂëº„Å≥Âá∫„Åô„Åü„ÇÅ„ÅÆ„Éò„É´„Éë„ÉºÈñ¢Êï∞
 */
function normalizeKey(key) {
    return (key ?? '').toString().trim().toLowerCase();
}

/**
 * „Éó„É≠„É≥„Éó„Éà„Å´ÈãºÊùê„Éá„Éº„Çø„ÇíËøΩÂä†„Åô„ÇãÈñ¢Êï∞
 */
function enhancePromptWithSteelData(originalPrompt, steelProperties, detectedMemberTypes = []) {
    let enhancedPrompt = originalPrompt;
    
    enhancedPrompt += '\n\n=== ÊåáÂÆö„Åï„Çå„ÅüÈãºÊùêÊñ≠Èù¢„ÅÆË©≥Á¥∞ÊÉÖÂ†± ===\n';
    
    steelProperties.forEach((steel, index) => {
        enhancedPrompt += `\n„ÄêÈãºÊùê${index + 1}„Äë: ${steel.sectionName}\n`;
        enhancedPrompt += `- ÊåáÂÆöÊñ≠Èù¢: ${steel.sectionSpec}\n`;
        enhancedPrompt += `- Êñ≠Èù¢„Çø„Ç§„Éó: ${steel.sectionType}\n`;
        enhancedPrompt += `- Âº∑Ëª∏ÊñπÂêë: ${steel.axisDirection}\n`;
        enhancedPrompt += `- Êñ≠Èù¢Á©ç A: ${steel.properties.A || 'N/A'} cm¬≤\n`;
        enhancedPrompt += `- Êñ≠Èù¢‰∫åÊ¨°„É¢„Éº„É°„É≥„Éà Ix: ${steel.properties.Ix || 'N/A'} cm‚Å¥\n`;
        enhancedPrompt += `- Êñ≠Èù¢‰∫åÊ¨°„É¢„Éº„É°„É≥„Éà Iy: ${steel.properties.Iy || 'N/A'} cm‚Å¥\n`;
        enhancedPrompt += `- Êñ≠Èù¢‰øÇÊï∞ Zx: ${steel.properties.Zx || 'N/A'} cm¬≥\n`;
        enhancedPrompt += `- Êñ≠Èù¢‰øÇÊï∞ Zy: ${steel.properties.Zy || 'N/A'} cm¬≥\n`;
        enhancedPrompt += `- Êñ≠Èù¢‰∫åÊ¨°ÂçäÂæÑ ix: ${steel.properties.ix || 'N/A'} cm\n`;
        enhancedPrompt += `- Êñ≠Èù¢‰∫åÊ¨°ÂçäÂæÑ iy: ${steel.properties.iy || 'N/A'} cm\n`;
        
        if (steel.matchDistance < Infinity) {
            enhancedPrompt += `- „Éû„ÉÉ„ÉÅ„É≥„Ç∞Á≤æÂ∫¶: ${(100 - steel.matchDistance).toFixed(1)}%\n`;
        }
    });
    
    enhancedPrompt += '\n‰∏äË®ò„ÅÆÊñ≠Èù¢ÊÄßËÉΩÂÄ§„ÇíÁî®„ÅÑ„Å¶ÊßãÈÄ†„É¢„Éá„É´„ÇíÁîüÊàê„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ\n';
    
    return { 
        prompt: enhancedPrompt, 
        steelData: steelProperties,
        memberTypes: detectedMemberTypes
    };
}

/**
 * ÈÉ®Êùê„ÅÆ„Çø„Ç§„Éó„ÇíÂà§ÂÆö„Åô„ÇãÈñ¢Êï∞
 * @param {Object} member - ÈÉ®Êùê„Éá„Éº„Çø
 * @param {Array} nodes - ÁØÄÁÇπ„Éá„Éº„ÇøÈÖçÂàó
 * @returns {string} 'column' | 'beam' | 'other'
 */
function identifyMemberType(member, nodes) {
    if (!member || !nodes || member.i < 1 || member.j < 1) {
        return 'other';
    }
    
    const startNode = nodes[member.i - 1];
    const endNode = nodes[member.j - 1];
    
    if (!startNode || !endNode) {
        return 'other';
    }
    
    // Êü±ÈÉ®Êùê: XÂ∫ßÊ®ô„ÅåÂêå„ÅòÔºàÂûÇÁõ¥ÈÉ®ÊùêÔºâ
    if (Math.abs(startNode.x - endNode.x) < 1e-6) {
        return 'column';
    }
    
    // Ê¢ÅÈÉ®Êùê: YÂ∫ßÊ®ô„ÅåÂêå„ÅòÔºàÊ∞¥Âπ≥ÈÉ®ÊùêÔºâ
    if (Math.abs(startNode.y - endNode.y) < 1e-6) {
        return 'beam';
    }
    
    return 'other';
}

/**
 * ÊåáÂÆö„Åï„Çå„ÅüÈÉ®Êùê„Çø„Ç§„Éó„ÅÆÈÉ®Êùê„ÅÆ„Åø„Å´Êñ≠Èù¢Â§âÊõ¥„ÇíÈÅ©Áî®„Åô„ÇãÈñ¢Êï∞
 * @param {string} targetMemberType - ÂØæË±°ÈÉ®Êùê„Çø„Ç§„Éó ('column' | 'beam')
 * @param {Object} steelData - ÈÅ©Áî®„Åô„ÇãÊñ≠Èù¢„Éá„Éº„Çø
 * @param {Array} nodes - ÁØÄÁÇπ„Éá„Éº„ÇøÈÖçÂàó
 * @param {Array} members - ÈÉ®Êùê„Éá„Éº„ÇøÈÖçÂàó
 */
function applySectionChangesToMemberType(targetMemberType, steelData, nodes, members) {
    console.log(`üîß ${targetMemberType === 'column' ? 'Êü±ÈÉ®Êùê' : targetMemberType === 'beam' ? 'Ê¢ÅÈÉ®Êùê' : '„Åù„ÅÆ‰ªñ'}„ÅÆÊñ≠Èù¢Â§âÊõ¥„ÇíÈÅ©Áî®‰∏≠...`);
    console.log(`üîç ÂØæË±°ÈÉ®Êùê„Çø„Ç§„Éó: ${targetMemberType}, Á∑èÈÉ®ÊùêÊï∞: ${members.length}`);
    
    let changedCount = 0;
    
    members.forEach((member, index) => {
        const memberType = identifyMemberType(member, nodes);
        console.log(`üîç ÈÉ®Êùê${index + 1} (${member.i}-${member.j}): Ë≠òÂà•„Åï„Çå„Åü„Çø„Ç§„Éó=${memberType}, ÂØæË±°„Çø„Ç§„Éó=${targetMemberType}`);
        
        if (memberType === targetMemberType) {
            console.log(`üîß ÈÉ®Êùê${index + 1} (${member.i}-${member.j}) „Çí${targetMemberType}„Å®„Åó„Å¶Ë≠òÂà•„ÄÅÊñ≠Èù¢„ÇíÂ§âÊõ¥`);
            
            // ÈÉ®Êùê„ÉÜ„Éº„Éñ„É´„ÅÆË©≤ÂΩìË°å„ÇíÊõ¥Êñ∞
            updateMemberSectionInTable(index, steelData);
            changedCount++;
        }
    });
    
    console.log(`‚úÖ ${changedCount}ÂÄã„ÅÆ${targetMemberType === 'column' ? 'Êü±ÈÉ®Êùê' : targetMemberType === 'beam' ? 'Ê¢ÅÈÉ®Êùê' : 'ÈÉ®Êùê'}„ÅÆÊñ≠Èù¢„ÇíÂ§âÊõ¥„Åó„Åæ„Åó„Åü`);
    
    // 3D„Éì„É•„Éº„Ç¢„ÇíÊõ¥Êñ∞
    if (typeof sendModelToViewer === 'function') {
        console.log('üîß Êñ≠Èù¢Â§âÊõ¥Âæå„Å´3D„Éì„É•„Éº„Ç¢„ÇíÊõ¥Êñ∞');
        sendModelToViewer();
    }
    
    return changedCount;
}

/**
 * ÈÉ®Êùê„ÉÜ„Éº„Éñ„É´„ÅÆÊåáÂÆöË°å„ÅÆÊñ≠Èù¢ÊÉÖÂ†±„ÇíÊõ¥Êñ∞„Åô„ÇãÈñ¢Êï∞
 * @param {number} memberIndex - ÈÉ®Êùê„ÅÆ„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ
 * @param {Object} steelData - ÈÅ©Áî®„Åô„ÇãÊñ≠Èù¢„Éá„Éº„Çø
 */
function updateMemberSectionInTable(memberIndex, steelData) {
    const membersTable = document.getElementById('members-table');
    if (!membersTable || !membersTable.rows || memberIndex >= membersTable.rows.length) {
        console.warn(`‚ö†Ô∏è ÈÉ®Êùê„ÉÜ„Éº„Éñ„É´„ÅÆË°å${memberIndex}„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì`);
        return;
    }
    
    const row = membersTable.rows[memberIndex + 1]; // +1 for header row
    if (!row || !row.cells || row.cells.length < 9) {
        console.warn(`‚ö†Ô∏è ÈÉ®Êùê„ÉÜ„Éº„Éñ„É´„ÅÆË°å${memberIndex}„ÅÆ„Çª„É´„Åå‰∏çË∂≥„Åó„Å¶„ÅÑ„Åæ„Åô`);
        return;
    }
    
    // Êñ≠Èù¢ÂêçÁß∞„ÇíË®≠ÂÆöÔºàAI„Åã„ÇâÊèê‰æõ„Åï„Çå„ÅüÂÖÉ„ÅÆÊñ≠Èù¢Âêç„ÇíÂÑ™ÂÖàÔºâ
    let sectionName = '';
    
    // 1. „Åæ„ÅösteelData.sectionName„ÇíÂÑ™ÂÖàÔºàAI„Åã„ÇâÊèê‰æõ„Åï„Çå„ÅüÂÖÉ„ÅÆÊñ≠Èù¢ÂêçÔºâ
    if (steelData.sectionName) {
        sectionName = steelData.sectionName;
        console.log(`üîß ÈÉ®Êùê${memberIndex}„ÅÆÊñ≠Èù¢ÂêçÁß∞„ÇísteelData.sectionName„Åã„ÇâË®≠ÂÆö: ${sectionName}`);
    }
    // 2. steelData.sectionSpec„ÇÇÁ¢∫Ë™çÔºàAI„Åã„ÇâÊèê‰æõ„Åï„Çå„ÅüÂÖÉ„ÅÆÊñ≠Èù¢‰ªïÊßòÔºâ
    else if (steelData.sectionSpec) {
        sectionName = steelData.sectionSpec;
        console.log(`üîß ÈÉ®Êùê${memberIndex}„ÅÆÊñ≠Èù¢ÂêçÁß∞„ÇísteelData.sectionSpec„Åã„ÇâË®≠ÂÆö: ${sectionName}`);
    }
    // 3. „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ: typeLabel„Å®dimensions„Åã„ÇâÁîüÊàê
    else if (steelData.typeLabel && steelData.dimensions) {
        // ÊùøÂéöÊÉÖÂ†±„Åæ„ÅßÂê´„ÇÄÂÆåÂÖ®„Å™ÂΩ¢Âºè„ÅßÁîüÊàê
        const dims = steelData.dimensions;
        if (steelData.sectionType === 'hkatakou_hiro' || steelData.sectionType === 'hkatakou_naka' || 
            steelData.sectionType === 'hkatakou_hoso' || steelData.sectionType === 'ikatakou' ||
            steelData.sectionType === 'keiryouhkatakou' || steelData.sectionType === 'keiryourippuhkatakou') {
            // HÂΩ¢Èãº„ÄÅIÂΩ¢Èãº„ÅÆÂ†¥Âêà: H√óB√ót1√ót2
            if (dims.H && dims.B && dims.t1 && dims.t2) {
                sectionName = `${steelData.typeLabel} ${dims.H}√ó${dims.B}√ó${dims.t1}√ó${dims.t2}`;
            } else if (dims.H && dims.B) {
                sectionName = `${steelData.typeLabel} ${dims.H}√ó${dims.B}`;
            }
        } else if (steelData.sectionType === 'seihoukei' || steelData.sectionType === 'tyouhoukei') {
            // ËßíÂΩ¢ÈãºÁÆ°„ÅÆÂ†¥Âêà: A√óB√ót
            if (dims.A && dims.B && dims.t) {
                sectionName = `${steelData.typeLabel} ${dims.A}√ó${dims.B}√ó${dims.t}`;
            } else if (dims.A && dims.B) {
                sectionName = `${steelData.typeLabel} ${dims.A}√ó${dims.B}`;
            }
        } else if (steelData.sectionType === 'koukan') {
            // ‰∏∏ÂΩ¢ÈãºÁÆ°„ÅÆÂ†¥Âêà: œÜD√ót
            if (dims.D && dims.t) {
                sectionName = `${steelData.typeLabel} œÜ${dims.D}√ó${dims.t}`;
            } else if (dims.D) {
                sectionName = `${steelData.typeLabel} œÜ${dims.D}`;
            }
        } else {
            // „Åù„ÅÆ‰ªñ„ÅÆÂ†¥Âêà„ÅØÊó¢Â≠ò„ÅÆÂΩ¢Âºè
            sectionName = `${steelData.typeLabel} ${steelData.designation}`.trim();
        }
        console.log(`üîß ÈÉ®Êùê${memberIndex}„ÅÆÊñ≠Èù¢ÂêçÁß∞„ÇítypeLabel„Å®dimensions„Åã„ÇâÁîüÊàê: ${sectionName}`);
    } else if (steelData.typeLabel && steelData.designation) {
        sectionName = `${steelData.typeLabel} ${steelData.designation}`.trim();
        console.log(`üîß ÈÉ®Êùê${memberIndex}„ÅÆÊñ≠Èù¢ÂêçÁß∞„ÇítypeLabel„Å®designation„Åã„ÇâÁîüÊàê: ${sectionName}`);
    } else if (steelData.typeLabel) {
        sectionName = steelData.typeLabel;
        console.log(`üîß ÈÉ®Êùê${memberIndex}„ÅÆÊñ≠Èù¢ÂêçÁß∞„ÇítypeLabel„Åã„ÇâË®≠ÂÆö: ${sectionName}`);
    }
    
    // Êñ≠Èù¢ÂêçÁß∞„ÇíÊõ¥Êñ∞ (cell 8)
    if (row.cells[8]) {
        // section-name-cell„ÇØ„É©„Çπ„ÅÆË¶ÅÁ¥†„ÇíÊõ¥Êñ∞
        const sectionNameCell = row.cells[8].querySelector('.section-name-cell');
        if (sectionNameCell) {
            sectionNameCell.textContent = sectionName;
        } else {
            row.cells[8].textContent = sectionName;
        }
    }
    
    // Êñ≠Èù¢ÊÄßËÉΩ„ÇíÊõ¥Êñ∞
    {
        // steel_selector Áî±Êù•: „Éà„ÉÉ„Éó„É¨„Éô„É´(props) / AIÁî±Êù•: steelData.properties „ÅÆ‰∏°Êñπ„Å´ÂØæÂøú
        const props = (steelData && steelData.properties && typeof steelData.properties === 'object')
            ? steelData.properties
            : (steelData || {});

        // „ÉÜ„Éº„Éñ„É´Âàó: 0:'#',1:i,2:j,3:E,4:strength,5:I,6:A,7:Z
        const inertiaInput = row.cells[5]?.querySelector('input');
        const areaInput = row.cells[6]?.querySelector('input');
        const modulusInput = row.cells[7]?.querySelector('input');

        if (areaInput && props.A !== undefined && props.A !== null && props.A !== '') {
            areaInput.value = props.A;
        }

        // 2DÂÅ¥„ÅÆI„ÅØÊõ≤„Åí‰∏ªËª∏„ÅÆI(cm^4)„ÅåÂÖ•„ÇãÊÉ≥ÂÆö„ÄÇIx/Iy„Åó„ÅãÁÑ°„ÅÑÂ†¥Âêà„ÅØ I „ÇíÂÑ™ÂÖàÂ∫¶‰Ωé„ÇÅ„Å´Ë£úÂÆå„ÄÇ
        const iToApply = (props.I !== undefined && props.I !== null && props.I !== '')
            ? props.I
            : (props.Ix !== undefined && props.Ix !== null && props.Ix !== '' ? props.Ix : undefined);
        if (inertiaInput && iToApply !== undefined) {
            inertiaInput.value = iToApply;
        }

        const zToApply = (props.Z !== undefined && props.Z !== null && props.Z !== '')
            ? props.Z
            : (props.Zx !== undefined && props.Zx !== null && props.Zx !== '' ? props.Zx : undefined);
        if (modulusInput && zToApply !== undefined) {
            modulusInput.value = zToApply;
        }

        // Ê®™Â∫ßÂ±àÁ≠â„Å´ÂøÖË¶Å„Å™ÂÄ§„ÅØ dataset „Å´‰øùÂ≠òÔºàcmÁ≥ªÔºâ
        if (props.Zx !== undefined && props.Zx !== null && props.Zx !== '') row.dataset.zx = props.Zx;
        if (props.Zy !== undefined && props.Zy !== null && props.Zy !== '') row.dataset.zy = props.Zy;
        if (props.ix !== undefined && props.ix !== null && props.ix !== '') row.dataset.ix = props.ix;
        if (props.iy !== undefined && props.iy !== null && props.iy !== '') row.dataset.iy = props.iy;

        // data-ix-mom / data-iy-mom / data-j / data-iw
        if (props.Ix !== undefined && props.Ix !== null && props.Ix !== '') row.dataset.ixMom = props.Ix;
        if (props.Iy !== undefined && props.Iy !== null && props.Iy !== '') row.dataset.iyMom = props.Iy;
        if (props.J !== undefined && props.J !== null && props.J !== '') row.dataset.j = props.J;
        if (props.Iw !== undefined && props.Iw !== null && props.Iw !== '') row.dataset.iw = props.Iw;
    }
    
    // Êñ≠Èù¢ÊÉÖÂ†±„ÅÆdatasetÂ±ûÊÄß„ÇíË®≠ÂÆöÔºàsetRowSectionInfoÈñ¢Êï∞„Çí‰ΩøÁî®Ôºâ
    if (steelData.sectionInfo && typeof window.setRowSectionInfo === 'function') {
        console.log(`üîß ÈÉ®Êùê${memberIndex}„ÅÆÊñ≠Èù¢ÊÉÖÂ†±„ÇísetRowSectionInfo„ÅßË®≠ÂÆö:`, steelData.sectionInfo);
        window.setRowSectionInfo(row, steelData.sectionInfo);
    } else if (steelData.sectionInfo) {
        // „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ: Áõ¥Êé•Ë®≠ÂÆöÔºà„Ç®„É≥„Ç≥„Éº„Éâ„Å™„ÅóÔºâ
        console.log(`üîß ÈÉ®Êùê${memberIndex}„ÅÆÊñ≠Èù¢ÊÉÖÂ†±„ÇíÁõ¥Êé•Ë®≠ÂÆöÔºà„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÔºâ:`, steelData.sectionInfo);
        row.dataset.sectionInfo = JSON.stringify(steelData.sectionInfo);
    }
    
    // Ëª∏ÊÉÖÂ†±„ÇÇÊõ¥Êñ∞ (cell 9)
    if (row.cells[9] && steelData.axisDirection) {
        const sectionAxisCell = row.cells[9].querySelector('.section-axis-cell');
        if (sectionAxisCell) {
            sectionAxisCell.textContent = steelData.axisDirection;
        } else {
            row.cells[9].textContent = steelData.axisDirection;
        }
    }
    
    console.log(`‚úÖ ÈÉ®Êùê„ÉÜ„Éº„Éñ„É´Ë°å${memberIndex}„ÅÆÊñ≠Èù¢ÊÉÖÂ†±„ÇíÊõ¥Êñ∞: ${sectionName}`);
}

/**
 * AIÁîüÊàêÊôÇ„Å´ÈÉ®Êùê„ÅÆÊñ≠Èù¢ÂêçÁß∞„Å®Ëª∏ÊñπÂêë„ÇíË®≠ÂÆö„Åô„ÇãÈñ¢Êï∞
 */
function setMemberSectionInfoFromAI(memberIndex, steelData) {
    console.log('üîç AIÁîüÊàêÊôÇ„Å´ÈÉ®Êùê„ÅÆÊñ≠Èù¢ÊÉÖÂ†±„ÇíË®≠ÂÆö:', memberIndex, steelData);
    
    const membersTable = document.getElementById('members-table');
    if (!membersTable) {
        console.warn('ÈÉ®Êùê„ÉÜ„Éº„Éñ„É´„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì');
        return;
    }
    
    const rows = membersTable.querySelectorAll('tbody tr');
    console.log(`üîç ÈÉ®Êùê„ÉÜ„Éº„Éñ„É´„ÅÆË°åÊï∞: ${rows.length}, ÂØæË±°ÈÉ®Êùê: ${memberIndex}`);
    
    if (memberIndex >= rows.length) {
        console.warn(`ÈÉ®Êùê${memberIndex}„ÅÆË°å„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì (Á∑èË°åÊï∞: ${rows.length})`);
        return;
    }
    
    const row = rows[memberIndex];
    if (!row) {
        console.warn(`ÈÉ®Êùê${memberIndex}„ÅÆË°å„ÅåÁÑ°Âäπ„Åß„Åô`);
        return;
    }
    
    console.log(`üîç ÈÉ®Êùê${memberIndex}„ÅÆË°å„ÇíÁ¢∫Ë™ç:`, row);
    
    // ÈÉ®ÊùêÊñ≠Èù¢ÈÅ∏Êäû„Å®Âêå„ÅòÂΩ¢Âºè„ÅßÊñ≠Èù¢ÂêçÁß∞„ÇíÁîüÊàê
    const getTypeLabel = (sectionType) => {
        const typeLabelMap = {
            'hkatakou_hiro': 'HÂΩ¢ÈãºÔºàÂ∫ÉÂπÖÔºâ',
            'hkatakou_naka': 'HÂΩ¢ÈãºÔºà‰∏≠ÂπÖÔºâ',
            'hkatakou_hoso': 'HÂΩ¢ÈãºÔºàÁ¥∞ÂπÖÔºâ',
            'ikatakou': 'IÂΩ¢Èãº',
            'mizogatakou': '„Åø„ÅûÂΩ¢Èãº',
            'touhenyamakatakou': 'Á≠âËæ∫Â±±ÂΩ¢Èãº',
            'futouhenyamagata': '‰∏çÁ≠âËæ∫Â±±ÂΩ¢Èãº',
            'keiryouhkatakou': 'ËªΩÈáèHÂΩ¢Èãº',
            'keimizogatakou': 'ËªΩ„Åø„ÅûÂΩ¢Èãº',
            'keiryourippuhkatakou': 'ËªΩÈáè„É™„ÉÉ„ÉóHÂΩ¢Èãº',
            'rippumizokatakou': '„É™„ÉÉ„Éó„Åø„ÅûÂΩ¢Èãº',
            'seihoukei': 'ËßíÂΩ¢ÈãºÁÆ°ÔºàÊ≠£ÊñπÂΩ¢Ôºâ',
            'tyouhoukei': 'ËßíÂΩ¢ÈãºÁÆ°ÔºàÈï∑ÊñπÂΩ¢Ôºâ',
            'maru': 'ÂÜÜÂΩ¢ÈãºÁÆ°'
        };
        return typeLabelMap[sectionType] || sectionType;
    };
    
    const typeLabel = getTypeLabel(steelData.sectionType);
    const designation = steelData.sectionName || '';
    
    // ÊùøÂéöÊÉÖÂ†±„Åæ„ÅßÂê´„ÇÄÂÆåÂÖ®„Å™Êñ≠Èù¢ÂêçÁß∞„ÇíÁîüÊàê
    let fullLabel = typeLabel;
    if (designation) {
        // designation„ÅåÊó¢„Å´ÊùøÂéöÊÉÖÂ†±„Åæ„ÅßÂê´„Çì„Åß„ÅÑ„ÇãÂ†¥Âêà„ÅØ„Åù„ÅÆ„Åæ„Åæ‰ΩøÁî®
        fullLabel = `${typeLabel} ${designation}`.trim();
    } else if (steelData.dimensions) {
        // designation„Åå„Å™„ÅÑÂ†¥Âêà„ÅØÂØ∏Ê≥ïÊÉÖÂ†±„Åã„ÇâÁîüÊàê
        const dims = steelData.dimensions;
        if (steelData.sectionType === 'hkatakou_hiro' || steelData.sectionType === 'hkatakou_naka' || 
            steelData.sectionType === 'hkatakou_hoso' || steelData.sectionType === 'ikatakou' ||
            steelData.sectionType === 'keiryouhkatakou' || steelData.sectionType === 'keiryourippuhkatakou') {
            // HÂΩ¢Èãº„ÄÅIÂΩ¢Èãº„ÅÆÂ†¥Âêà: H√óB√ót1√ót2
            if (dims.H && dims.B && dims.t1 && dims.t2) {
                fullLabel = `${typeLabel} ${dims.H}√ó${dims.B}√ó${dims.t1}√ó${dims.t2}`;
            } else if (dims.H && dims.B) {
                fullLabel = `${typeLabel} ${dims.H}√ó${dims.B}`;
            }
        } else if (steelData.sectionType === 'seihoukei' || steelData.sectionType === 'tyouhoukei') {
            // ËßíÂΩ¢ÈãºÁÆ°„ÅÆÂ†¥Âêà: A√óB√ót
            if (dims.A && dims.B && dims.t) {
                fullLabel = `${typeLabel} ${dims.A}√ó${dims.B}√ó${dims.t}`;
            } else if (dims.A && dims.B) {
                fullLabel = `${typeLabel} ${dims.A}√ó${dims.B}`;
            }
        } else if (steelData.sectionType === 'koukan') {
            // ‰∏∏ÂΩ¢ÈãºÁÆ°„ÅÆÂ†¥Âêà: œÜD√ót
            if (dims.D && dims.t) {
                fullLabel = `${typeLabel} œÜ${dims.D}√ó${dims.t}`;
            } else if (dims.D) {
                fullLabel = `${typeLabel} œÜ${dims.D}`;
            }
        }
    }
    
    // Êó¢Â≠ò„ÅÆÈÉ®ÊùêÊñ≠Èù¢ÈÅ∏ÊäûÊ©üËÉΩ„Å®Âêå„ÅòÂΩ¢Âºè„ÅßsectionInfo„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„Çí‰ΩúÊàê
    // 3D„Éì„É•„Éº„Ç¢„Å´ÂøÖË¶Å„Å™rawDims„Å®typeKey„ÇíÂê´„ÇÅ„Çã
    const sectionInfo = {
        typeKey: steelData.sectionType, // 3D„Éì„É•„Éº„Ç¢„ÅßÊñ≠Èù¢ÂΩ¢Áä∂„ÇíÊ±∫ÂÆö„Åô„Çã„Åü„ÇÅ„Å´ÂøÖË¶Å
        label: fullLabel,
        dimensionSummary: steelData.sectionSpec || '',
        source: 'AIÁîüÊàê',
        rawDims: { // 3D„Éì„É•„Éº„Ç¢„ÅßÊñ≠Èù¢ÂΩ¢Áä∂„ÇíÁîüÊàê„Åô„Çã„Åü„ÇÅ„Å´ÂøÖË¶Å
            H: steelData.dimensions?.H || 0,
            B: steelData.dimensions?.B || 0,
            t1: steelData.dimensions?.t1 || 0,
            t2: steelData.dimensions?.t2 || 0
        },
        axis: {
            key: steelData.isStrongAxisX ? 'x' : 'y',
            mode: steelData.isStrongAxisX ? 'strong' : 'weak',
            label: steelData.isStrongAxisX ? 'Âº∑Ëª∏ (XËª∏)' : 'Âº±Ëª∏ (YËª∏)'
        },
        dimensions: [
            { key: 'H', label: 'H', value: steelData.dimensions?.H || 0 },
            { key: 'B', label: 'B', value: steelData.dimensions?.B || 0 },
            { key: 't1', label: 't1', value: steelData.dimensions?.t1 || 0 },
            { key: 't2', label: 't2', value: steelData.dimensions?.t2 || 0 }
        ].filter(dim => dim.value > 0)
    };
    
    console.log(`üîç ‰ΩúÊàê„Åó„ÅüsectionInfo:`, sectionInfo);
    
    // Êó¢Â≠ò„ÅÆsetRowSectionInfoÈñ¢Êï∞„Çí‰ΩøÁî®„Åó„Å¶Ë®≠ÂÆö
    try {
        if (typeof window.setRowSectionInfo === 'function') {
            window.setRowSectionInfo(row, sectionInfo);
            console.log(`‚úÖ ÈÉ®Êùê${memberIndex}„ÅÆÊñ≠Èù¢ÊÉÖÂ†±„ÇíÊó¢Â≠òÂΩ¢Âºè„ÅßË®≠ÂÆöÂÆå‰∫Ü`);
        } else {
            console.error(`‚ùå setRowSectionInfoÈñ¢Êï∞„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì`);
            // „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ: Áõ¥Êé•„Çª„É´„ÇíÊõ¥Êñ∞
            const hasDensityColumn = (row.cells && row.cells.length >= 15);
            // Â∫ßÂ±à‰øÇÊï∞KÂàó(„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ8)„ÅåÂ¢ó„Åà„Åü„Åü„ÇÅ„ÄÅ‰ª•Èôç„ÅÆÂàó„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ„Çí1„Å§„Åö„Çâ„Åô
            const sectionNameCellIndex = hasDensityColumn ? 10 : 9;
            const sectionAxisCellIndex = hasDensityColumn ? 11 : 10;
            
            // Êñ≠Èù¢ÂêçÁß∞„Çª„É´„ÇíÊõ¥Êñ∞
            const sectionNameCell = row.cells[sectionNameCellIndex];
            if (sectionNameCell) {
                const nameSpan = sectionNameCell.querySelector('.section-name-cell');
                if (nameSpan) {
                    nameSpan.textContent = sectionInfo.label || '-';
                }
            }
            
            // Ëª∏ÊñπÂêë„Çª„É´„ÇíÊõ¥Êñ∞
            const sectionAxisCell = row.cells[sectionAxisCellIndex];
            if (sectionAxisCell) {
                const axisSpan = sectionAxisCell.querySelector('.section-axis-cell');
                if (axisSpan) {
                    axisSpan.textContent = sectionInfo.axis?.label || '-';
                }
            }
            
            // „Éá„Éº„Çø„Çª„ÉÉ„ÉàÂ±ûÊÄß„ÇíÊõ¥Êñ∞
            row.dataset.sectionLabel = sectionInfo.label || '';
            row.dataset.sectionSummary = sectionInfo.dimensionSummary || '';
            row.dataset.sectionSource = sectionInfo.source || '';
            if (sectionInfo.axis) {
                row.dataset.sectionAxisKey = sectionInfo.axis.key || '';
                row.dataset.sectionAxisMode = sectionInfo.axis.mode || '';
                row.dataset.sectionAxisLabel = sectionInfo.axis.label || '';
            }
            
            console.log(`‚ö†Ô∏è „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÂá¶ÁêÜ„ÅßÈÉ®Êùê${memberIndex}„ÅÆÊñ≠Èù¢ÊÉÖÂ†±„ÇíË®≠ÂÆöÂÆå‰∫Ü`);
        }
    } catch (error) {
        console.error(`‚ùå ÈÉ®Êùê${memberIndex}„ÅÆÊñ≠Èù¢ÊÉÖÂ†±Ë®≠ÂÆö„Åß„Ç®„É©„Éº„ÅåÁô∫Áîü:`, error);
    }
}

/**
 * ÈÉ®Êùê„ÅåÊü±ÔºàÂûÇÁõ¥Ôºâ„ÅãÊ¢ÅÔºàÊ∞¥Âπ≥Ôºâ„Åã„ÇíÂà§ÂÆö„Åô„ÇãÈñ¢Êï∞
 * @param {number} memberIndex - ÈÉ®Êùê„ÅÆ„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ
 * @returns {string} 'column' | 'beam' | 'unknown'
 */
function getMemberType(memberIndex) {
    try {
        const membersTable = document.getElementById('members-table');
        if (!membersTable) return 'unknown';
        
        const rows = membersTable.querySelectorAll('tbody tr');
        if (memberIndex >= rows.length) return 'unknown';
        
        const row = rows[memberIndex];
        const cells = row.cells;
        
        // ÁØÄÁÇπÁï™Âè∑„ÇíÂèñÂæó
        const iCell = cells[0]; // iÁØÄÁÇπ
        const jCell = cells[1]; // jÁØÄÁÇπ
        
        if (!iCell || !jCell) return 'unknown';
        
        const iNodeIndex = parseInt(iCell.querySelector('input')?.value) - 1;
        const jNodeIndex = parseInt(jCell.querySelector('input')?.value) - 1;
        
        if (isNaN(iNodeIndex) || isNaN(jNodeIndex)) return 'unknown';
        
        // ÁØÄÁÇπÂ∫ßÊ®ô„ÇíÂèñÂæó
        const nodesTable = document.getElementById('nodes-table');
        if (!nodesTable) return 'unknown';
        
        const nodeRows = nodesTable.querySelectorAll('tbody tr');
        const iNodeRow = nodeRows[iNodeIndex];
        const jNodeRow = nodeRows[jNodeIndex];
        
        if (!iNodeRow || !jNodeRow) return 'unknown';
        
        const iX = parseFloat(iNodeRow.cells[1].querySelector('input')?.value) || 0;
        const iY = parseFloat(iNodeRow.cells[2].querySelector('input')?.value) || 0;
        const jX = parseFloat(jNodeRow.cells[1].querySelector('input')?.value) || 0;
        const jY = parseFloat(jNodeRow.cells[2].querySelector('input')?.value) || 0;
        
        // XÂ∫ßÊ®ô„ÅÆÂ∑Æ„Å®YÂ∫ßÊ®ô„ÅÆÂ∑Æ„ÇíË®àÁÆó
        const deltaX = Math.abs(jX - iX);
        const deltaY = Math.abs(jY - iY);
        
        console.log(`üîç ÈÉ®Êùê${memberIndex}: ÁØÄÁÇπ${iNodeIndex + 1}(${iX}, ${iY}) ‚Üí ÁØÄÁÇπ${jNodeIndex + 1}(${jX}, ${jY})`);
        console.log(`üîç ÈÉ®Êùê${memberIndex}: deltaX=${deltaX}, deltaY=${deltaY}`);
        
        // „É¶„Éº„Ç∂„ÉºÂÆöÁæ©„Å´Âæì„Å£„ÅüÂà§ÂÆö:
        // Êü±ÈÉ®Êùê: ÂßãÁÇπ#i„Å®ÁµÇÁÇπ#j„ÅÆXÂ∫ßÊ®ô„ÅåÂêå„ÅòÂÄ§
        // Ê¢ÅÈÉ®Êùê: ÂßãÁÇπ#i„Å®ÁµÇÁÇπ#j„ÅÆYÂ∫ßÊ®ô„ÅåÂêå„ÅòÂÄ§
        if (deltaX < 0.001) { // XÂ∫ßÊ®ô„ÅåÂêå„ÅòÔºàË®±ÂÆπË™§Â∑Æ0.001mÔºâ
            console.log(`üîç ÈÉ®Êùê${memberIndex}: Êü±ÈÉ®Êùê„Å®Âà§ÂÆö (deltaX=${deltaX} < 0.001)`);
            return 'column'; // Êü±ÔºàÂûÇÁõ¥Ôºâ
        } else if (deltaY < 0.001) { // YÂ∫ßÊ®ô„ÅåÂêå„ÅòÔºàË®±ÂÆπË™§Â∑Æ0.001mÔºâ
            console.log(`üîç ÈÉ®Êùê${memberIndex}: Ê¢ÅÈÉ®Êùê„Å®Âà§ÂÆö (deltaY=${deltaY} < 0.001)`);
            return 'beam';   // Ê¢ÅÔºàÊ∞¥Âπ≥Ôºâ
        } else {
            console.log(`üîç ÈÉ®Êùê${memberIndex}: ÊñúÊùê„Å®Âà§ÂÆö (deltaX=${deltaX}, deltaY=${deltaY})`);
            return 'unknown'; // ÊñúÊùê„Å™„Å©
        }
    } catch (error) {
        console.warn(`ÈÉ®Êùê${memberIndex}„ÅÆ„Çø„Ç§„ÉóÂà§ÂÆö„Åß„Ç®„É©„Éº:`, error);
        return 'unknown';
    }
}

/**
 * 4Â±§4„Çπ„Éë„É≥ÊßãÈÄ†Áî®„ÅÆ„Éá„Éï„Ç©„É´„ÉàÈãºÊùêÊñ≠Èù¢„Éá„Éº„Çø„ÇíÁîüÊàê„Åô„ÇãÈñ¢Êï∞
 * @returns {Array} „Éá„Éï„Ç©„É´„Éà„ÅÆÈãºÊùêÊñ≠Èù¢„Éá„Éº„ÇøÈÖçÂàó
 */
function generateDefaultSteelDataFor4Layer4Span() {
    console.log('üîß 4Â±§4„Çπ„Éë„É≥ÊßãÈÄ†Áî®„ÅÆ„Éá„Éï„Ç©„É´„ÉàÈãºÊùêÊñ≠Èù¢„Éá„Éº„Çø„ÇíÁîüÊàê');
    
    // Êü±Áî®„ÅÆHÂΩ¢ÈãºÊñ≠Èù¢ÔºàH-200√ó200√ó8√ó12Ôºâ
    const columnSteelData = {
        typeKey: 'hkatakou_hiro',
        typeLabel: 'HÂΩ¢Èãº',
        designation: 'H-200√ó200√ó8√ó12',
        dims: {
            H: 200,
            B: 200,
            t1: 8,
            t2: 12
        },
        properties: {
            A: 64.7, // cm¬≤
            Ix: 4720, // cm‚Å¥
            Iy: 1600, // cm‚Å¥
            Zx: 472, // cm¬≥
            Zy: 160 // cm¬≥
        },
        source: 'default_4layer4span'
    };
    
    // Ê¢ÅÁî®„ÅÆHÂΩ¢ÈãºÊñ≠Èù¢ÔºàH-300√ó150√ó6.5√ó9Ôºâ
    const beamSteelData = {
        typeKey: 'hkatakou_hiro',
        typeLabel: 'HÂΩ¢Èãº',
        designation: 'H-300√ó150√ó6.5√ó9',
        dims: {
            H: 300,
            B: 150,
            t1: 6.5,
            t2: 9
        },
        properties: {
            A: 46.8, // cm¬≤
            Ix: 7210, // cm‚Å¥
            Iy: 508, // cm‚Å¥
            Zx: 481, // cm¬≥
            Zy: 67.7 // cm¬≥
        },
        source: 'default_4layer4span'
    };
    
    // ÂÖ®„Å¶„ÅÆÈÉ®Êùê„Å´ÈÅ©Áî®„Åô„Çã„Éá„Éï„Ç©„É´„ÉàÊñ≠Èù¢„Éá„Éº„Çø
    const defaultSteelDataArray = [
        columnSteelData, // Êü±Áî®
        beamSteelData    // Ê¢ÅÁî®
    ];
    
    console.log('üîß ÁîüÊàê„Åï„Çå„Åü„Éá„Éï„Ç©„É´„ÉàÈãºÊùêÊñ≠Èù¢„Éá„Éº„Çø:', defaultSteelDataArray);
    return defaultSteelDataArray;
}

/**
 * AIÁîüÊàêÊôÇ„Å´Ë§áÊï∞„ÅÆÈÉ®Êùê„ÅÆÊñ≠Èù¢ÊÉÖÂ†±„ÇíË®≠ÂÆö„Åô„ÇãÈñ¢Êï∞
 * @param {Array} steelDataArray - ÈãºÊùêÊñ≠Èù¢„Éá„Éº„Çø„ÅÆÈÖçÂàó
 * @param {Array} memberTypes - ÈÉ®Êùê„Çø„Ç§„ÉóÊÉÖÂ†±„ÅÆÈÖçÂàó
 */
function setMultipleMembersSectionInfoFromAI(steelDataArray, memberTypes = [], preAISectionInfoBackup = null) {
    // „Ç∞„É≠„Éº„Éê„É´Â§âÊï∞„Çí‰ΩøÁî®
    if (preAISectionInfoBackup === null) {
        preAISectionInfoBackup = globalPreAISectionInfoBackup;
    }
    try {
        console.log('üîç AIÁîüÊàêÊôÇ„Å´Ë§áÊï∞ÈÉ®Êùê„ÅÆÊñ≠Èù¢ÊÉÖÂ†±„ÇíË®≠ÂÆö:', steelDataArray, memberTypes);
        console.log('üîç setMultipleMembersSectionInfoFromAIÂëº„Å≥Âá∫„ÅóÊôÇÂàª:', new Date().toISOString());
        
        if (!Array.isArray(steelDataArray)) {
            console.warn('steelDataArray„ÅåÈÖçÂàó„Åß„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì');
            return;
        }
        
        const membersTable = document.getElementById('members-table');
        if (!membersTable) {
            console.warn('ÈÉ®Êùê„ÉÜ„Éº„Éñ„É´„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì');
            return;
        }
        
        const rows = membersTable.querySelectorAll('tbody tr');
        console.log(`üîç ÈÉ®Êùê„ÉÜ„Éº„Éñ„É´„ÅÆË°åÊï∞: ${rows.length}, Ê§úÂá∫„Åï„Çå„ÅüÈãºÊùêÊñ≠Èù¢Êï∞: ${steelDataArray.length}`);
        
        if (rows.length === 0) {
            console.warn('ÈÉ®Êùê„ÉÜ„Éº„Éñ„É´„Å´ÈÉ®Êùê„Åå„ÅÇ„Çä„Åæ„Åõ„Çì');
            return;
        }
    
    // Èñ¢Êï∞ÈñãÂßãÊôÇ„ÅÆÊñ≠Èù¢ÊÉÖÂ†±Áä∂ÊÖã„ÇíË®òÈå≤
    console.log('üîç Èñ¢Êï∞ÈñãÂßãÊôÇ„ÅÆÊñ≠Èù¢ÊÉÖÂ†±Áä∂ÊÖã:');
    rows.forEach((row, index) => {
        const sectionInfo = row.dataset.sectionInfo;
        const sectionNameCell = row.querySelector('.section-name-cell');
        const sectionAxisCell = row.querySelector('.section-axis-cell');
        console.log(`üîç ÈÉ®Êùê${index + 1}: dataset.sectionInfo=${!!sectionInfo}, Èï∑„Åï=${sectionInfo ? sectionInfo.length : 0}, Êñ≠Èù¢ÂêçÁß∞="${sectionNameCell ? sectionNameCell.textContent : 'N/A'}", Ëª∏ÊñπÂêë="${sectionAxisCell ? sectionAxisCell.textContent : 'N/A'}"`);
    });
    
    // ÁèæÂú®„ÅÆ„É¢„Éá„É´„Éá„Éº„Çø„ÇíÂèñÂæó
    const currentModel = getCurrentModelData();
    if (!currentModel || !currentModel.nodes || !currentModel.members) {
        console.warn('ÁèæÂú®„ÅÆ„É¢„Éá„É´„Éá„Éº„Çø„ÇíÂèñÂæó„Åß„Åç„Åæ„Åõ„Çì');
        return;
    }
    
    // ÈÉ®Êùê„Çø„Ç§„ÉóÂà•„ÅÆÂá¶ÁêÜ
    if (memberTypes && memberTypes.length > 0) {
        console.log('üîç ÈÉ®Êùê„Çø„Ç§„ÉóÂà•„ÅÆÊñ≠Èù¢ÊÉÖÂ†±Ë®≠ÂÆö„ÇíÂÆüË°å');
        
        // Êó¢Â≠ò„ÅÆÊñ≠Èù¢ÊÉÖÂ†±„Çí„Éê„ÉÉ„ÇØ„Ç¢„ÉÉ„Éó
        const existingSectionInfo = [];
        rows.forEach((row, index) => {
            const sectionNameCell = row.querySelector('.section-name-cell');
            const sectionAxisCell = row.querySelector('.section-axis-cell');
            const sectionInfo = row.dataset.sectionInfo;
            
            console.log(`üîç [„Éê„ÉÉ„ÇØ„Ç¢„ÉÉ„Éó] ÈÉ®Êùê${index + 1}: dataset.sectionInfoÂ≠òÂú®=${!!sectionInfo}, Èï∑„Åï=${sectionInfo ? sectionInfo.length : 0}`);
            
            // AIÂâç„ÅÆ„Éê„ÉÉ„ÇØ„Ç¢„ÉÉ„Éó„Éá„Éº„Çø„ÇíÂÑ™ÂÖàÁöÑ„Å´‰ΩøÁî®
            let parsedSectionInfo = null;
            if (preAISectionInfoBackup && preAISectionInfoBackup[index] && preAISectionInfoBackup[index].sectionInfo) {
                parsedSectionInfo = preAISectionInfoBackup[index].sectionInfo;
                console.log(`‚úÖ [„Éê„ÉÉ„ÇØ„Ç¢„ÉÉ„Éó] ÈÉ®Êùê${index + 1}„ÅÆÊñ≠Èù¢ÊÉÖÂ†±„ÇíAIÂâç„Éê„ÉÉ„ÇØ„Ç¢„ÉÉ„Éó„Åã„ÇâÂèñÂæó:`, parsedSectionInfo);
            } else if (sectionInfo) {
                console.log(`üîç [„Éê„ÉÉ„ÇØ„Ç¢„ÉÉ„Éó] ÈÉ®Êùê${index + 1}: Áîü„ÅÆsectionInfo=${sectionInfo.substring(0, 100)}...`);
                try {
                    // URL„Éá„Ç≥„Éº„Éâ„Åó„Å¶„Åã„ÇâJSON„Éë„Éº„Çπ
                    const decoded = decodeURIComponent(sectionInfo);
                    console.log(`üîç [„Éê„ÉÉ„ÇØ„Ç¢„ÉÉ„Éó] ÈÉ®Êùê${index + 1}: „Éá„Ç≥„Éº„ÉâÂæå=${decoded.substring(0, 100)}...`);
                    parsedSectionInfo = JSON.parse(decoded);
                    console.log(`‚úÖ [„Éê„ÉÉ„ÇØ„Ç¢„ÉÉ„Éó] ÈÉ®Êùê${index + 1}„ÅÆÊñ≠Èù¢ÊÉÖÂ†±„Çídataset„Åã„Çâ„Éê„ÉÉ„ÇØ„Ç¢„ÉÉ„Éó:`, parsedSectionInfo);
                } catch (error) {
                    console.error(`‚ùå [„Éê„ÉÉ„ÇØ„Ç¢„ÉÉ„Éó] ÈÉ®Êùê${index + 1}„ÅÆÊñ≠Èù¢ÊÉÖÂ†±„ÅÆ„Éë„Éº„Çπ„Å´Â§±Êïó:`, error);
                    console.log(`üîç [„Éê„ÉÉ„ÇØ„Ç¢„ÉÉ„Éó] ÈÉ®Êùê${index + 1}„ÅÆÁîü„ÅÆsectionInfo:`, sectionInfo);
                }
            } else {
                console.log(`‚ö†Ô∏è [„Éê„ÉÉ„ÇØ„Ç¢„ÉÉ„Éó] ÈÉ®Êùê${index + 1}„ÅÆdataset.sectionInfo„ÅåÂ≠òÂú®„Åó„Åæ„Åõ„Çì`);
            }
            
            // dataset„Åã„ÇâÂèñÂæó„Åß„Åç„Å™„ÅÑÂ†¥Âêà„ÅØ„ÄÅcurrentModel„Åã„ÇâÂèñÂæó„Åó„Åü„Éá„Éº„Çø„Çí‰ΩøÁî®
            if (!parsedSectionInfo && currentModel.members[index] && currentModel.members[index].sectionInfo) {
                parsedSectionInfo = currentModel.members[index].sectionInfo;
                console.log(`üîÑ [„Éê„ÉÉ„ÇØ„Ç¢„ÉÉ„Éó] ÈÉ®Êùê${index + 1}„ÅÆÊñ≠Èù¢ÊÉÖÂ†±„ÇícurrentModel„Åã„Çâ„Éê„ÉÉ„ÇØ„Ç¢„ÉÉ„Éó:`, parsedSectionInfo);
            }
            
            // AIÂâç„ÅÆ„Éê„ÉÉ„ÇØ„Ç¢„ÉÉ„Éó„Éá„Éº„Çø„Åã„ÇâÊñ≠Èù¢ÂêçÁß∞„Å®Ëª∏ÊñπÂêë„ÇíÂèñÂæóÔºàÂÑ™ÂÖàÔºâ
            const backupData = preAISectionInfoBackup && preAISectionInfoBackup[index];
            existingSectionInfo[index] = {
                sectionName: backupData?.sectionName || (sectionNameCell ? sectionNameCell.textContent : ''),
                sectionAxis: backupData?.sectionAxis || (sectionAxisCell ? sectionAxisCell.textContent : ''),
                sectionInfo: parsedSectionInfo,
                sectionInfoEncoded: backupData?.sectionInfoEncoded || row.dataset.sectionInfoEncoded || '',
                sectionLabel: backupData?.sectionLabel || row.dataset.sectionLabel || '',
                sectionSummary: backupData?.sectionSummary || row.dataset.sectionSummary || '',
                sectionSource: backupData?.sectionSource || row.dataset.sectionSource || '',
                sectionAxisKey: backupData?.sectionAxisKey || row.dataset.sectionAxisKey || '',
                sectionAxisMode: backupData?.sectionAxisMode || row.dataset.sectionAxisMode || '',
                sectionAxisLabel: backupData?.sectionAxisLabel || row.dataset.sectionAxisLabel || ''
            };
        });
        
        console.log('üîß Êó¢Â≠ò„ÅÆÊñ≠Èù¢ÊÉÖÂ†±„Çí„Éê„ÉÉ„ÇØ„Ç¢„ÉÉ„Éó:', existingSectionInfo);
        
        // ÂêÑÈÉ®Êùê„Çø„Ç§„Éó„Å´ÂØæ„Åó„Å¶Âá¶ÁêÜ
        memberTypes.forEach((memberTypeInfo, index) => {
            const steelData = steelDataArray[index] || steelDataArray[0]; // ÂØæÂøú„Åô„ÇãÈãºÊùêÊñ≠Èù¢„Åæ„Åü„ÅØÊúÄÂàù„ÅÆÊñ≠Èù¢
            const targetType = memberTypeInfo.type;
            
            console.log(`üîç ${targetType}ÈÉ®Êùê„Å´Êñ≠Èù¢ÊÉÖÂ†±„ÇíË®≠ÂÆö:`, steelData);
            console.log(`üîç ÂØæË±°ÈÉ®Êùê„Çø„Ç§„Éó: ${targetType}, Ê§úÂá∫„Åï„Çå„ÅüÈÉ®Êùê„Çø„Ç§„Éó:`, memberTypes.map(mt => mt.type));
            
            // Êñ∞„Åó„ÅÑÈñ¢Êï∞„Çí‰ΩøÁî®„Åó„Å¶ÊåáÂÆö„Åï„Çå„ÅüÈÉ®Êùê„Çø„Ç§„Éó„ÅÆ„Åø„Å´Êñ≠Èù¢Â§âÊõ¥„ÇíÈÅ©Áî®
            const changedCount = applySectionChangesToMemberType(targetType, steelData, currentModel.nodes, currentModel.members);
            
            if (changedCount > 0) {
                console.log(`‚úÖ ${changedCount}ÂÄã„ÅÆ${targetType === 'column' ? 'Êü±ÈÉ®Êùê' : targetType === 'beam' ? 'Ê¢ÅÈÉ®Êùê' : 'ÈÉ®Êùê'}„ÅÆÊñ≠Èù¢„ÇíÂ§âÊõ¥„Åó„Åæ„Åó„Åü`);
            } else {
                console.log(`‚ö†Ô∏è ${targetType === 'column' ? 'Êü±ÈÉ®Êùê' : targetType === 'beam' ? 'Ê¢ÅÈÉ®Êùê' : 'ÈÉ®Êùê'}„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„Åß„Åó„Åü`);
            }
        });
        
        // Â§âÊõ¥„Åï„Çå„Å™„Åã„Å£„ÅüÈÉ®Êùê„ÅÆÊñ≠Èù¢ÊÉÖÂ†±„ÇíÂæ©ÂÖÉ
        setTimeout(() => {
            console.log('üîß Â§âÊõ¥„Åï„Çå„Å™„Åã„Å£„ÅüÈÉ®Êùê„ÅÆÊñ≠Èù¢ÊÉÖÂ†±„ÇíÂæ©ÂÖÉ (500msÂæå):', new Date().toISOString());
            rows.forEach((row, index) => {
                const memberType = identifyMemberType(currentModel.members[index], currentModel.nodes);
                const shouldChange = memberTypes.some(mt => mt.type === memberType);

                console.log(`üîç ÈÉ®Êùê${index + 1}: „Çø„Ç§„Éó=${memberType}, Â§âÊõ¥ÂØæË±°=${shouldChange}`);

                if (!shouldChange && existingSectionInfo[index]) {
                    const backup = existingSectionInfo[index];
                    const sectionNameCell = row.querySelector('.section-name-cell');
                    const sectionAxisCell = row.querySelector('.section-axis-cell');

                    // Êñ≠Èù¢ÂêçÁß∞„ÇíÂæ©ÂÖÉ
                    if (sectionNameCell && backup.sectionName) {
                        sectionNameCell.textContent = backup.sectionName;
                        console.log(`üîß ÈÉ®Êùê${index + 1}„ÅÆÊñ≠Èù¢ÂêçÁß∞„ÇíÂæ©ÂÖÉ: ${backup.sectionName}`);
                    }

                    // Ëª∏ÊñπÂêë„ÇíÂæ©ÂÖÉ
                    if (sectionAxisCell && backup.sectionAxis) {
                        sectionAxisCell.textContent = backup.sectionAxis;
                        console.log(`üîß ÈÉ®Êùê${index + 1}„ÅÆËª∏ÊñπÂêë„ÇíÂæ©ÂÖÉ: ${backup.sectionAxis}`);
                    }

                   // Êñ≠Èù¢ÊÉÖÂ†±„ÅÆdatasetÂ±ûÊÄß„ÇíÂæ©ÂÖÉÔºàsetRowSectionInfoÈñ¢Êï∞„Çí‰ΩøÁî®Ôºâ
                   console.log(`üîç [Âæ©ÂÖÉ] ÈÉ®Êùê${index + 1}„ÅÆÂæ©ÂÖÉÊù°‰ª∂„ÉÅ„Çß„ÉÉ„ÇØ:`, {
                       hasBackupSectionInfo: !!backup.sectionInfo,
                       backupSectionInfoType: typeof backup.sectionInfo,
                       backupSectionInfo: backup.sectionInfo,
                       hasSetRowSectionInfo: typeof window.setRowSectionInfo === 'function'
                   });
                   
                   if (backup.sectionInfo && typeof window.setRowSectionInfo === 'function') {
                       console.log(`‚úÖ [Âæ©ÂÖÉ] ÈÉ®Êùê${index + 1}„ÅÆsectionInfo„ÇísetRowSectionInfo„ÅßÂæ©ÂÖÉ:`, backup.sectionInfo);
                       window.setRowSectionInfo(row, backup.sectionInfo);
                        
                        // Âæ©ÂÖÉÁõ¥Âæå„Å´dataset.sectionInfo„ÅÆÁä∂ÊÖã„ÇíÁ¢∫Ë™ç
                        const restoredSectionInfo = row.dataset.sectionInfo;
                        console.log(`üîß ÈÉ®Êùê${index + 1}„ÅÆÂæ©ÂÖÉÁõ¥Âæå„ÅÆdataset.sectionInfo:`, restoredSectionInfo ? 'Â≠òÂú®' : '‰∏çÂ≠òÂú®');
                        if (restoredSectionInfo) {
                            try {
                                const decoded = decodeURIComponent(restoredSectionInfo);
                                const parsed = JSON.parse(decoded);
                                console.log(`üîß ÈÉ®Êùê${index + 1}„ÅÆÂæ©ÂÖÉÁõ¥Âæå„ÅÆsectionInfoÂÜÖÂÆπ:`, parsed);
                            } catch (error) {
                                console.log(`üîß ÈÉ®Êùê${index + 1}„ÅÆÂæ©ÂÖÉÁõ¥Âæå„ÅÆsectionInfoËß£Êûê„Ç®„É©„Éº:`, error);
                            }
                        }
                    } else if (backup.sectionInfo) {
                        // „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ: Áõ¥Êé•Ë®≠ÂÆö
                        console.log(`üîß ÈÉ®Êùê${index + 1}„ÅÆsectionInfo„ÇíÁõ¥Êé•Âæ©ÂÖÉÔºà„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÔºâ:`, backup.sectionInfo);
                        row.dataset.sectionInfo = JSON.stringify(backup.sectionInfo);
                        
                        // „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÂæ©ÂÖÉÁõ¥Âæå„Å´dataset.sectionInfo„ÅÆÁä∂ÊÖã„ÇíÁ¢∫Ë™ç
                        const restoredSectionInfo = row.dataset.sectionInfo;
                        console.log(`üîß ÈÉ®Êùê${index + 1}„ÅÆ„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÂæ©ÂÖÉÁõ¥Âæå„ÅÆdataset.sectionInfo:`, restoredSectionInfo ? 'Â≠òÂú®' : '‰∏çÂ≠òÂú®');
                    } else {
                        console.log(`‚ö†Ô∏è ÈÉ®Êùê${index + 1}„ÅÆbackup.sectionInfo„ÅåÂ≠òÂú®„Åó„Å™„ÅÑ„Åü„ÇÅ„ÄÅÂæ©ÂÖÉ„Çí„Çπ„Ç≠„ÉÉ„Éó`);
                    }
                    // „Åù„ÅÆ‰ªñ„ÅÆdatasetÂ±ûÊÄß„ÅØsetRowSectionInfo„ÅßÂá¶ÁêÜ„Åï„Çå„Çã„Åü„ÇÅ„ÄÅÂÄãÂà•Ë®≠ÂÆö„ÅØ‰∏çË¶Å

                    console.log(`üîß ÈÉ®Êùê${index + 1} (${memberType})„ÅÆÊñ≠Èù¢ÊÉÖÂ†±„ÇíÂæ©ÂÖÉÂÆå‰∫Ü: ${backup.sectionName}`);
                } else if (shouldChange) {
                    console.log(`üîß ÈÉ®Êùê${index + 1} (${memberType})„ÅØÂ§âÊõ¥ÂØæË±°„ÅÆ„Åü„ÇÅÂæ©ÂÖÉ„Çí„Çπ„Ç≠„ÉÉ„Éó`);
                } else {
                    console.log(`‚ö†Ô∏è ÈÉ®Êùê${index + 1} (${memberType})„ÅÆ„Éê„ÉÉ„ÇØ„Ç¢„ÉÉ„ÉóÊÉÖÂ†±„Åå„ÅÇ„Çä„Åæ„Åõ„Çì`);
                    
                    // „Éê„ÉÉ„ÇØ„Ç¢„ÉÉ„ÉóÊÉÖÂ†±„Åå„Å™„ÅÑÂ†¥Âêà„ÅØ„ÄÅ„Éá„Éï„Ç©„É´„ÉàÊñ≠Èù¢ÊÉÖÂ†±„ÇíÈÅ©Áî®
                    console.log(`üîß ÈÉ®Êùê${index + 1}„Å´„Éá„Éï„Ç©„É´„ÉàÊñ≠Èù¢ÊÉÖÂ†±„ÇíÈÅ©Áî®`);
                    const defaultSteelData = generateDefaultSteelDataFor4Layer4Span();
                    if (defaultSteelData && defaultSteelData.length > 0) {
                        // Êü±ÈÉ®Êùê„ÅÆÂ†¥Âêà„ÅØÊúÄÂàù„ÅÆÊñ≠Èù¢„ÄÅÊ¢ÅÈÉ®Êùê„ÅÆÂ†¥Âêà„ÅØ2Áï™ÁõÆ„ÅÆÊñ≠Èù¢„Çí‰ΩøÁî®
                        const steelData = memberType === 'column' ? defaultSteelData[0] : defaultSteelData[1] || defaultSteelData[0];
                        
                        // setRowSectionInfo„Çí‰ΩøÁî®„Åó„Å¶Êñ≠Èù¢ÊÉÖÂ†±„ÇíË®≠ÂÆö
                        setRowSectionInfo(row, steelData);
                        console.log(`‚úÖ ÈÉ®Êùê${index + 1}„Å´„Éá„Éï„Ç©„É´„ÉàÊñ≠Èù¢ÊÉÖÂ†±„ÇíÈÅ©Áî®ÂÆå‰∫Ü`);
                    }
                }
            });

            // Âæ©ÂÖÉÂá¶ÁêÜ„ÅÆÊ§úË®º
            console.log('üîß Êñ≠Èù¢ÊÉÖÂ†±Âæ©ÂÖÉÂá¶ÁêÜ„ÅÆÊ§úË®º');
            rows.forEach((row, index) => {
                const sectionInfo = row.dataset.sectionInfo;
                console.log(`üîß ÈÉ®Êùê${index + 1}„ÅÆÊ§úË®ºÂâç„ÅÆdataset.sectionInfo:`, sectionInfo ? 'Â≠òÂú®' : '‰∏çÂ≠òÂú®');
                if (sectionInfo) {
                    console.log(`‚úÖ ÈÉ®Êùê${index + 1}: Êñ≠Èù¢ÊÉÖÂ†±„ÅåÂ≠òÂú®„Åó„Åæ„Åô`);
                } else {
                    console.log(`‚ùå ÈÉ®Êùê${index + 1}: Êñ≠Èù¢ÊÉÖÂ†±„ÅåÂ≠òÂú®„Åó„Åæ„Åõ„Çì`);
                }
            });

            // Âæ©ÂÖÉÂÆå‰∫ÜÂæå„Å´3D„Éì„É•„Éº„Ç¢„ÇíÊõ¥Êñ∞
            if (typeof sendModelToViewer === 'function') {
                console.log('üîß Êñ≠Èù¢ÊÉÖÂ†±Âæ©ÂÖÉÂæå„Å´3D„Éì„É•„Éº„Ç¢„ÇíÊõ¥Êñ∞');
                sendModelToViewer();
            }

            // UI„ÅÆÂº∑Âà∂Êõ¥Êñ∞
            console.log('üîß UI„ÅÆÂº∑Âà∂Êõ¥Êñ∞„ÇíÂÆüË°å');
            if (typeof updateMemberTableDisplay === 'function') {
                updateMemberTableDisplay();
            }
        }, 500);
    } else {
        // ÈãºÊùê„Éá„Éº„Çø„Å´ÈÉ®Êùê„Çø„Ç§„ÉóÊÉÖÂ†±„ÅåÂê´„Åæ„Çå„Å¶„ÅÑ„ÇãÂ†¥Âêà„ÅÆÂá¶ÁêÜ
        const steelDataWithMemberType = steelDataArray.filter(steel => steel.memberType);
        
        if (steelDataWithMemberType.length > 0) {
            console.log('üîç ÈãºÊùê„Éá„Éº„Çø„Å´Âê´„Åæ„Çå„ÇãÈÉ®Êùê„Çø„Ç§„ÉóÊÉÖÂ†±„Çí‰ΩøÁî®');
            
            steelDataWithMemberType.forEach(steelData => {
                const targetType = steelData.memberType;
                console.log(`üîç ${targetType}ÈÉ®Êùê„Å´Êñ≠Èù¢ÊÉÖÂ†±„ÇíË®≠ÂÆö:`, steelData);
                
                // Êñ∞„Åó„ÅÑÈñ¢Êï∞„Çí‰ΩøÁî®„Åó„Å¶ÊåáÂÆö„Åï„Çå„ÅüÈÉ®Êùê„Çø„Ç§„Éó„ÅÆ„Åø„Å´Êñ≠Èù¢Â§âÊõ¥„ÇíÈÅ©Áî®
                const changedCount = applySectionChangesToMemberType(targetType, steelData, currentModel.nodes, currentModel.members);
                
                if (changedCount > 0) {
                    console.log(`‚úÖ ${changedCount}ÂÄã„ÅÆ${targetType === 'column' ? 'Êü±ÈÉ®Êùê' : targetType === 'beam' ? 'Ê¢ÅÈÉ®Êùê' : 'ÈÉ®Êùê'}„ÅÆÊñ≠Èù¢„ÇíÂ§âÊõ¥„Åó„Åæ„Åó„Åü`);
                } else {
                    console.log(`‚ö†Ô∏è ${targetType === 'column' ? 'Êü±ÈÉ®Êùê' : targetType === 'beam' ? 'Ê¢ÅÈÉ®Êùê' : 'ÈÉ®Êùê'}„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„Åß„Åó„Åü`);
                }
            });
        } else {
            // ÈÉ®Êùê„Çø„Ç§„Éó„ÅåÊåáÂÆö„Åï„Çå„Å¶„ÅÑ„Å™„ÅÑÂ†¥Âêà„ÅØ„ÄÅ‰Ωï„ÇÇ„Åó„Å™„ÅÑ
            console.log('üîç ÈÉ®Êùê„Çø„Ç§„Éó„ÅåÊåáÂÆö„Åï„Çå„Å¶„ÅÑ„Å™„ÅÑ„Åü„ÇÅ„ÄÅÊñ≠Èù¢ÊÉÖÂ†±„ÅÆÂ§âÊõ¥„Çí„Çπ„Ç≠„ÉÉ„Éó„Åó„Åæ„Åô');
        }
    }
    } catch (error) {
        console.error('setMultipleMembersSectionInfoFromAIÈñ¢Êï∞„Åß„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü:', error);
        console.error('„Ç®„É©„Éº„ÅÆË©≥Á¥∞:', error.message);
        console.error('„Ç®„É©„Éº„Çπ„Çø„ÉÉ„ÇØ:', error.stack);
    }
}

/**
 * Èü≥Â£∞ÂÖ•ÂäõÊ©üËÉΩ„ÅÆ„Ç§„Éô„É≥„Éà„É™„Çπ„Éä„Éº„ÇíË®≠ÂÆö„Åô„ÇãÈñ¢Êï∞
 */
function setupVoiceInputListeners() {
    console.log('üîç Èü≥Â£∞ÂÖ•ÂäõÊ©üËÉΩ„ÅÆ„Ç§„Éô„É≥„Éà„É™„Çπ„Éä„Éº„ÇíË®≠ÂÆö‰∏≠...');
    
    const voiceInputBtn = document.getElementById('voice-input-btn');
    const voiceStatus = document.getElementById('voice-status');
    const promptInput = document.getElementById('natural-language-input');
    
    if (!voiceInputBtn || !voiceStatus || !promptInput) {
        console.error('Èü≥Â£∞ÂÖ•ÂäõÊ©üËÉΩ„Å´ÂøÖË¶Å„Å™Ë¶ÅÁ¥†„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì');
        return;
    }
    
    // Web Speech API„ÅÆ„Çµ„Éù„Éº„ÉàÁ¢∫Ë™ç
    if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
        console.warn('„Åì„ÅÆ„Éñ„É©„Ç¶„Ç∂„ÅØÈü≥Â£∞Ë™çË≠ò„Çí„Çµ„Éù„Éº„Éà„Åó„Å¶„ÅÑ„Åæ„Åõ„Çì');
        voiceInputBtn.style.display = 'none';
        return;
    }
    
    // SpeechRecognition „Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÅÆ‰ΩúÊàê
    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    const recognition = new SpeechRecognition();
    
    // Èü≥Â£∞Ë™çË≠ò„ÅÆË®≠ÂÆö
    recognition.continuous = false;
    recognition.interimResults = false;
    recognition.lang = 'ja-JP';
    
    let isListening = false;
    
    // Èü≥Â£∞ÂÖ•Âäõ„Éú„Çø„É≥„ÅÆ„ÇØ„É™„ÉÉ„ÇØ„Ç§„Éô„É≥„Éà
    voiceInputBtn.addEventListener('click', () => {
        if (isListening) {
            // Èü≥Â£∞Ë™çË≠ò„ÇíÂÅúÊ≠¢
            recognition.stop();
            isListening = false;
            voiceInputBtn.textContent = 'üé§';
            voiceInputBtn.style.backgroundColor = '#28a745';
            voiceStatus.textContent = '';
            voiceStatus.style.display = 'none';
        } else {
            // Èü≥Â£∞Ë™çË≠ò„ÇíÈñãÂßã
            try {
                recognition.start();
                isListening = true;
                voiceInputBtn.textContent = '‚èπÔ∏è';
                voiceInputBtn.style.backgroundColor = '#dc3545';
                voiceStatus.textContent = 'üé§ Èü≥Â£∞„ÇíË™çË≠ò‰∏≠...';
                voiceStatus.style.display = 'block';
            } catch (error) {
                console.error('Èü≥Â£∞Ë™çË≠ò„ÅÆÈñãÂßã„Å´Â§±Êïó„Åó„Åæ„Åó„Åü:', error);
                voiceStatus.textContent = '‚ùå Èü≥Â£∞Ë™çË≠ò„ÅÆÈñãÂßã„Å´Â§±Êïó„Åó„Åæ„Åó„Åü';
                voiceStatus.style.display = 'block';
                setTimeout(() => {
                    voiceStatus.style.display = 'none';
                }, 3000);
            }
        }
    });
    
    // Èü≥Â£∞Ë™çË≠òÁµêÊûú„ÅÆÂá¶ÁêÜ
    recognition.onresult = (event) => {
        const transcript = event.results[0][0].transcript;
        console.log('Èü≥Â£∞Ë™çË≠òÁµêÊûú:', transcript);
        
        // Êó¢Â≠ò„ÅÆ„ÉÜ„Ç≠„Çπ„Éà„Å´ËøΩÂä†ÔºàÊîπË°å„ÅßÂå∫Âàá„ÇãÔºâ
        const currentText = promptInput.value.trim();
        if (currentText) {
            promptInput.value = currentText + '\n' + transcript;
        } else {
            promptInput.value = transcript;
        }
        
        // Áä∂ÊÖã„Çí„É™„Çª„ÉÉ„Éà
        isListening = false;
        voiceInputBtn.textContent = 'üé§';
        voiceInputBtn.style.backgroundColor = '#28a745';
        voiceStatus.textContent = '‚úÖ Èü≥Â£∞Ë™çË≠òÂÆå‰∫Ü';
        voiceStatus.style.display = 'block';
        
        // 3ÁßíÂæå„Å´„Çπ„ÉÜ„Éº„Çø„Çπ„ÇíÈùûË°®Á§∫
        setTimeout(() => {
            voiceStatus.style.display = 'none';
        }, 3000);
        
        // „ÉÜ„Ç≠„Çπ„Éà„Ç®„É™„Ç¢„Å´„Éï„Ç©„Éº„Ç´„Çπ„ÇíÊàª„Åô
        promptInput.focus();
    };
    
    // Èü≥Â£∞Ë™çË≠ò„Ç®„É©„Éº„ÅÆÂá¶ÁêÜ
    recognition.onerror = (event) => {
        console.error('Èü≥Â£∞Ë™çË≠ò„Ç®„É©„Éº:', event.error);
        
        isListening = false;
        voiceInputBtn.textContent = 'üé§';
        voiceInputBtn.style.backgroundColor = '#28a745';
        
        let errorMessage = 'Èü≥Â£∞Ë™çË≠ò„Åß„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü';
        switch (event.error) {
            case 'no-speech':
                errorMessage = 'Èü≥Â£∞„ÅåÊ§úÂá∫„Åï„Çå„Åæ„Åõ„Çì„Åß„Åó„Åü';
                break;
            case 'audio-capture':
                errorMessage = '„Éû„Ç§„ÇØ„Å´„Ç¢„ÇØ„Çª„Çπ„Åß„Åç„Åæ„Åõ„Çì';
                break;
            case 'not-allowed':
                errorMessage = '„Éû„Ç§„ÇØ„ÅÆ‰ΩøÁî®„ÅåË®±ÂèØ„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì';
                break;
            case 'network':
                errorMessage = '„Éç„ÉÉ„Éà„ÉØ„Éº„ÇØ„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü';
                break;
            default:
                errorMessage = `Èü≥Â£∞Ë™çË≠ò„Ç®„É©„Éº: ${event.error}`;
        }
        
        voiceStatus.textContent = '‚ùå ' + errorMessage;
        voiceStatus.style.display = 'block';
        
        setTimeout(() => {
            voiceStatus.style.display = 'none';
        }, 5000);
    };
    
    // Èü≥Â£∞Ë™çË≠òÁµÇ‰∫Ü„ÅÆÂá¶ÁêÜ
    recognition.onend = () => {
        isListening = false;
        voiceInputBtn.textContent = 'üé§';
        voiceInputBtn.style.backgroundColor = '#28a745';
        
        if (voiceStatus.textContent === 'üé§ Èü≥Â£∞„ÇíË™çË≠ò‰∏≠...') {
            voiceStatus.textContent = '‚èπÔ∏è Èü≥Â£∞Ë™çË≠ò„ÅåÁµÇ‰∫Ü„Åó„Åæ„Åó„Åü';
            voiceStatus.style.display = 'block';
            setTimeout(() => {
                voiceStatus.style.display = 'none';
            }, 2000);
        }
    };
    
    console.log('‚úÖ Èü≥Â£∞ÂÖ•ÂäõÊ©üËÉΩ„ÅÆ„Ç§„Éô„É≥„Éà„É™„Çπ„Éä„ÉºË®≠ÂÆöÂÆå‰∫Ü');
}

/**
 * „É¢„Éº„ÉâË™¨ÊòéÊñá„ÇíÊõ¥Êñ∞„Åô„ÇãÈñ¢Êï∞
 */
function updateModeDescription() {
    const modeRadios = document.getElementsByName('ai-generation-mode');
    const selectedMode = Array.from(modeRadios).find(radio => radio.checked)?.value || 'new';
    const descriptionElement = document.getElementById('mode-description');
    
    if (!descriptionElement) {
        console.error('Error: Could not find element with id "mode-description"');
        return;
    }
    
    if (selectedMode === 'new') {
        descriptionElement.textContent = '‰ΩúÊàê„Åó„Åü„ÅÑÊßãÈÄ†„É¢„Éá„É´„ÇíËá™ÁÑ∂Ë®ÄË™û„ÅßÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ(‰æã: È´ò„Åï5m„ÄÅ„Çπ„Éë„É≥10m„ÅÆÈñÄÂûã„É©„Éº„É°„É≥„ÄÇÊü±ËÑö„ÅØÂõ∫ÂÆö„ÄÇ)';
    } else if (selectedMode === 'edit') {
        descriptionElement.textContent = 'ÁèæÂú®„ÅÆ„É¢„Éá„É´„Å´ÂØæ„Åó„Å¶ËøΩÂä†„ÉªÁ∑®ÈõÜ„Åó„Åü„ÅÑÂÜÖÂÆπ„ÇíËá™ÁÑ∂Ë®ÄË™û„ÅßÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ(‰æã: 2ÈöéÈÉ®ÂàÜ„ÇíËøΩÂä†„ÄÅÊ¢Å„ÅÆÊñ≠Èù¢„ÇíH-300x150„Å´Â§âÊõ¥)';
    }
    
    // ‰æãÊñáÈÅ∏ÊäûËÇ¢„ÇíÊõ¥Êñ∞
    updateExamplePrompts(selectedMode);
}

/**
 * ‰æãÊñáÈÅ∏ÊäûËÇ¢„ÇíÊõ¥Êñ∞„Åô„ÇãÈñ¢Êï∞
 * @param {string} mode - ÈÅ∏Êäû„Åï„Çå„Åü„É¢„Éº„Éâ ('new' „Åæ„Åü„ÅØ 'edit')
 */
function updateExamplePrompts(mode) {
    const exampleSelect = document.getElementById('example-prompts-select');
    if (!exampleSelect) {
        console.error('Error: Could not find element with id "example-prompts-select"');
        return;
    }
    
    // Êó¢Â≠ò„ÅÆ„Ç™„Éó„Ç∑„Éß„É≥„Çí„ÇØ„É™„Ç¢ÔºàÊúÄÂàù„ÅÆ„Ç™„Éó„Ç∑„Éß„É≥„ÅØÊÆã„ÅôÔºâ
    while (exampleSelect.children.length > 1) {
        exampleSelect.removeChild(exampleSelect.lastChild);
    }
    
    // „É¢„Éº„Éâ„Å´Âøú„Åò„Åü‰æãÊñá„ÇíËøΩÂä†
    const examples = mode === 'new' ? getNewModeExamples() : getEditModeExamples();
    
    examples.forEach((example, index) => {
        const option = document.createElement('option');
        option.value = example.text;
        // „Çø„Ç§„Éà„É´„Å®‰æãÊñáÂÜÖÂÆπ„ÇíË°®Á§∫Ôºà‰æãÊñáÂÜÖÂÆπ„ÅØÊã¨ÂºßÊõ∏„Åç„ÅßË°®Á§∫Ôºâ
        option.textContent = `${index + 1}. ${example.title} (${example.text})`;
        exampleSelect.appendChild(option);
    });
    
    // ÈÅ∏ÊäûÊôÇ„ÅÆËá™ÂãïÈÅ©Áî®„Ç§„Éô„É≥„Éà„É™„Çπ„Éä„Éº„ÇíË®≠ÂÆö
    exampleSelect.addEventListener('change', () => {
        const naturalLanguageInput = document.getElementById('natural-language-input');
        
        if (exampleSelect.value && naturalLanguageInput) {
            naturalLanguageInput.value = exampleSelect.value;
            // „ÉÜ„Ç≠„Çπ„Éà„Ç®„É™„Ç¢„ÅÆÈ´ò„Åï„ÇíËá™ÂãïË™øÊï¥
            naturalLanguageInput.style.height = 'auto';
            naturalLanguageInput.style.height = naturalLanguageInput.scrollHeight + 'px';
            
            console.log('‰æãÊñá„ÇíËá™ÂãïÈÅ©Áî®„Åó„Åæ„Åó„Åü:', exampleSelect.value);
        }
    });
}

/**
 * Êñ∞Ë¶è‰ΩúÊàê„É¢„Éº„ÉâÁî®„ÅÆ‰æãÊñá„ÇíÂèñÂæó
 * @returns {Array} ‰æãÊñá„ÅÆÈÖçÂàó
 */
function getNewModeExamples() {
    return [
        {
            title: 'ÈñÄÂûã„É©„Éº„É°„É≥ÔºàÂü∫Êú¨Ôºâ',
            text: 'È´ò„Åï5m„ÄÅ„Çπ„Éë„É≥10m„ÅÆÈñÄÂûã„É©„Éº„É°„É≥„ÄÇÊü±ËÑö„ÅØÂõ∫ÂÆöÊîØÁÇπ„Å®„Åô„Çã„ÄÇ'
        },
        {
            title: 'Â§öÂ±§„É©„Éº„É°„É≥',
            text: '3Â±§„ÄÅ2„Çπ„Éë„É≥„ÅÆ„É©„Éº„É°„É≥ÊßãÈÄ†„ÄÇÂêÑÈöéÈ´ò3.5m„ÄÅ„Çπ„Éë„É≥6m„ÄÇÂü∫Á§é„ÅØÂõ∫ÂÆöÊîØÁÇπ„ÄÇ'
        },
        {
            title: 'ÈñÄÂûã„É©„Éº„É°„É≥Ôºà„Éî„É≥ÊîØÁÇπÔºâ',
            text: 'È´ò„Åï4m„ÄÅ„Çπ„Éë„É≥8m„ÅÆÈñÄÂûã„É©„Éº„É°„É≥„ÄÇÊü±ËÑö„ÅØ„Éî„É≥ÊîØÁÇπ„Å®„Åô„Çã„ÄÇ'
        },
        {
            title: 'ÂçòÁ¥îÊ¢Å',
            text: '„Çπ„Éë„É≥12m„ÅÆÂçòÁ¥îÊ¢Å„ÄÇ‰∏°Á´Ø„ÅØ„Éî„É≥ÊîØÁÇπ„Å®„Åô„Çã„ÄÇ'
        },
        {
            title: 'ÈÄ£Á∂öÊ¢Å',
            text: '3„Çπ„Éë„É≥„ÅÆÈÄ£Á∂öÊ¢Å„ÄÇ„Çπ„Éë„É≥Èï∑„ÅØ6m„ÄÅ8m„ÄÅ6m„ÄÇ‰∏°Á´Ø„ÅØ„Éî„É≥ÊîØÁÇπ„ÄÅ‰∏≠Èñì„ÅØÂâõÊé•Âêà„ÄÇ'
        },
        {
            title: '„Éà„É©„ÇπÊßãÈÄ†',
            text: 'È´ò„Åï3m„ÄÅ„Çπ„Éë„É≥12m„ÅÆ„ÉØ„Éº„É¨„É≥„Éà„É©„Çπ„ÄÇ'
        },
        {
            title: '„Ç≠„É£„É≥„ÉÅ„É¨„Éê„ÉºÔºàÁâáÊåÅ„Å°Ê¢ÅÔºâ',
            text: 'Èï∑„Åï5m„ÅÆ„Ç≠„É£„É≥„ÉÅ„É¨„Éê„ÉºÔºàÁâáÊåÅ„Å°Ê¢ÅÔºâ„ÄÇÂõ∫ÂÆöÁ´Ø„ÅØÂâõÊé•Âêà„ÄÅËá™Áî±Á´Ø„ÅØËç∑Èáç„Çí‰ΩúÁî®„ÄÇ'
        },
        {
            title: '2Â±§„Éï„É¨„Éº„É†',
            text: '2Â±§„ÄÅ3„Çπ„Éë„É≥„ÅÆ„Éï„É¨„Éº„É†ÊßãÈÄ†„ÄÇÈöéÈ´ò3m„ÄÅ„Çπ„Éë„É≥5m„ÄÇÊü±ËÑö„ÅØÂõ∫ÂÆöÊîØÁÇπ„ÄÇ'
        },
        {
            title: '„Ç¢„Éº„ÉÅÊßãÈÄ†',
            text: '„Çπ„Éë„É≥20m„ÄÅÁü¢È´ò4m„ÅÆ„Ç¢„Éº„ÉÅÊßãÈÄ†„ÄÇ‰∏°Á´Ø„ÅØ„Éî„É≥ÊîØÁÇπ„Å®„Åô„Çã„ÄÇ'
        }
    ];
}

/**
 * ËøΩÂä†Á∑®ÈõÜ„É¢„Éº„ÉâÁî®„ÅÆ‰æãÊñá„ÇíÂèñÂæó
 * @returns {Array} ‰æãÊñá„ÅÆÈÖçÂàó
 */
function getEditModeExamples() {
    return [
        {
            title: 'ÈÉ®ÊùêÊñ≠Èù¢Â§âÊõ¥',
            text: 'Êü±ÈÉ®Êùê„ÇíH-200√ó200√ó8√ó12„Å´Â§âÊõ¥„Åó„ÄÅÊ¢ÅÈÉ®Êùê„ÇíH-588√ó300√ó12√ó20„Å´Â§âÊõ¥„Åô„Çã„ÄÇ'
        },
        {
            title: 'Â±§„ÅÆËøΩÂä†',
            text: 'ÁèæÂú®„ÅÆÊßãÈÄ†„Å´3ÈöéÈÉ®ÂàÜ„ÇíËøΩÂä†„Åô„Çã„ÄÇÈöéÈ´ò3.5m„ÄÅÊó¢Â≠ò„ÅÆÊü±„ÇíÂª∂Èï∑„Åó„Å¶Ê¢Å„ÇíËøΩÂä†„ÄÇ'
        },
        {
            title: '„Çπ„Éë„É≥„ÅÆËøΩÂä†',
            text: 'Âè≥ÂÅ¥„Å´2„Çπ„Éë„É≥ÂàÜ„ÇíËøΩÂä†„Åô„Çã„ÄÇ„Çπ„Éë„É≥Èï∑„ÅØ6m„ÄÅÊó¢Â≠ò„ÅÆÊ¢Å„Å®ÂêåÊßò„ÅÆÊñ≠Èù¢„Å®„Åô„Çã„ÄÇ'
        },
        {
            title: 'Ëç∑Èáç„ÅÆËøΩÂä†',
            text: '2Èöé„ÅÆÊ¢Å„Å´Á≠âÂàÜÂ∏ÉËç∑Èáç5kN/m„ÇíËøΩÂä†„Åó„ÄÅ1Èöé„ÅÆÊü±„Å´ÈõÜ‰∏≠Ëç∑Èáç10kN„ÇíËøΩÂä†„Åô„Çã„ÄÇ'
        },
        {
            title: 'Â¢ÉÁïåÊù°‰ª∂Â§âÊõ¥',
            text: 'ÂÖ®„Å¶„ÅÆÊü±ËÑö„ÅÆÂ¢ÉÁïåÊù°‰ª∂„Çí„Éî„É≥ÊîØÁÇπ„Å´Â§âÊõ¥„Åô„Çã„ÄÇ'
        },
        {
            title: 'ÈÉ®Êùê„ÅÆÂâäÈô§',
            text: '‰∏≠Â§Æ„ÅÆÊü±1Êú¨„ÇíÂâäÈô§„Åó„ÄÅ„Åù„ÅÆÈÉ®ÂàÜ„ÅÆÊ¢Å„ÇíÂçòÁ¥îÊ¢Å„Å´Â§âÊõ¥„Åô„Çã„ÄÇ'
        },
        {
            title: 'Êñ≠Èù¢„ÅÆÊúÄÈÅ©Âåñ',
            text: 'ÂÖ®„Å¶„ÅÆÊü±ÈÉ®Êùê„ÇíH-250√ó125„Å´Áµ±‰∏Ä„Åó„ÄÅÊ¢ÅÈÉ®Êùê„ÇíH-400√ó200„Å´Áµ±‰∏Ä„Åô„Çã„ÄÇ'
        },
        {
            title: '„Çπ„Éë„É≥Èï∑„ÅÆÂ§âÊõ¥',
            text: 'Â∑¶„Åã„Çâ2Áï™ÁõÆ„ÅÆ„Çπ„Éë„É≥„Çí8m„Å´Â§âÊõ¥„Åô„Çã„ÄÇ'
        },
        {
            title: 'Ëç∑ÈáçÊù°‰ª∂„ÅÆÂ§âÊõ¥',
            text: 'Êó¢Â≠ò„ÅÆËç∑Èáç„ÇíÂÖ®„Å¶ÂâäÈô§„Åó„ÄÅÊñ∞„Åü„Å´Â±ãÊ†πËç∑Èáç3kN/m„ÄÅÂ∫äËç∑Èáç5kN/m„ÇíË®≠ÂÆö„Åô„Çã„ÄÇ'
        },
        {
            title: 'ÊùêÊñô„ÅÆÂ§âÊõ¥',
            text: 'ÂÖ®„Å¶„ÅÆÈÉ®Êùê„ÅÆÊùêÊñô„Çí„Çπ„ÉÜ„É≥„É¨„ÇπÈãº„Å´Â§âÊõ¥„Åó„ÄÅÂºæÊÄß‰øÇÊï∞„Çí193GPa„Å´Ë®≠ÂÆö„Åô„Çã„ÄÇ'
        }
    ];
}

/**
 * ËøΩÂä†Á∑®ÈõÜ„Éá„Éº„Çø„ÇíÊó¢Â≠ò„Éá„Éº„Çø„Å´Áµ±Âêà„Åô„ÇãÈñ¢Êï∞
 * @param {Object} newState AI„ÅåÁîüÊàê„Åó„ÅüÊñ∞„Åó„ÅÑ„Éá„Éº„Çø
 * @param {String} userPrompt „É¶„Éº„Ç∂„Éº„ÅÆÊåáÁ§∫ÔºàËç∑ÈáçÂâäÈô§ÊÑèÂõ≥Ê§úÂá∫Áî®Ôºâ
 */
function integrateEditData(newState, userPrompt = '') {
    console.log('üîç „Éá„Éº„ÇøÁµ±ÂêàÈñãÂßã:', newState);
    console.log('üîç „É¶„Éº„Ç∂„Éº„Éó„É≠„É≥„Éó„Éà:', userPrompt);
    
    if (!newState || !newState.nodes) {
        console.error('Error: Invalid newState data provided to integrateEditData');
        return;
    }
    
    // Ëç∑ÈáçÂâäÈô§ÊÑèÂõ≥„ÇíÊ§úÂá∫
    const loadDeleteKeywords = /Ëç∑Èáç.*ÂâäÈô§|Ëç∑Èáç.*Ê∂à|Ëç∑Èáç.*„Å™„Åó|Ëç∑Èáç.*„Çº„É≠|ÂÖ®.*ÂâäÈô§.*Ëç∑Èáç|Ëç∑Èáç.*ÂÖ®.*ÂâäÈô§|load.*delete|load.*remove|load.*clear/i;
    const hasLoadDeleteIntent = loadDeleteKeywords.test(userPrompt);
    console.log('üîç Ëç∑ÈáçÂâäÈô§ÊÑèÂõ≥Ê§úÂá∫:', hasLoadDeleteIntent);
    
    // ÊùêÊñôÂ§âÊõ¥ÊÑèÂõ≥„ÇíÊ§úÂá∫
    const materialChangeKeywords = /ÊùêÊñô.*(Â§âÊõ¥|Ë®≠ÂÆö)|Êñ≠Èù¢.*(Â§âÊõ¥|Ë®≠ÂÆö)|ÂºæÊÄß‰øÇÊï∞.*(Â§âÊõ¥|Ë®≠ÂÆö)|„É§„É≥„Ç∞‰øÇÊï∞.*(Â§âÊõ¥|Ë®≠ÂÆö)|„Çπ„ÉÜ„É≥„É¨„Çπ|„Ç¢„É´„Éü|material.*(change|set)|section.*(change|set)|modulus.*(change|set)|elastic/i;
    const hasMaterialChangeIntent = materialChangeKeywords.test(userPrompt);
    console.log('üîç ÊùêÊñôÂ§âÊõ¥ÊÑèÂõ≥Ê§úÂá∫:', hasMaterialChangeIntent);
    
    // „Éà„É©„ÇπÊßãÈÄ†„ÅÆ‰ΩúÊàêÊÑèÂõ≥„ÇíÊ§úÂá∫ÔºàÊé•ÂêàÊù°‰ª∂„ÇíAIÁîüÊàê„Å´Âæì„ÅÜÔºâ
    const trussCreateKeywords = /„Éà„É©„Çπ|truss|„ÉØ„Éº„É¨„É≥|„Éó„É©„ÉÉ„Éà|„Éè„Ç¶|warren|pratt|howe|Âº¶Êùê|ÊñúÊùê/i;
    const hasTrussCreateIntent = trussCreateKeywords.test(userPrompt);
    console.log('üîç „Éà„É©„ÇπÊßãÈÄ†‰ΩúÊàêÊÑèÂõ≥Ê§úÂá∫:', hasTrussCreateIntent);
    
    // Êó¢Â≠ò„ÅÆ„Éá„Éº„Çø„ÇíÂèñÂæó
    const existingModelData = getCurrentModelData();
    console.log('üîç Êó¢Â≠ò„Éá„Éº„Çø:', existingModelData);
    
    if (!existingModelData) {
        console.error('Error: Could not retrieve existing model data');
        return;
    }
    
    // Êó¢Â≠ò„Éá„Éº„Çø„ÅÆÁØÄÁÇπ„Å´Â¢ÉÁïåÊù°‰ª∂„ÅÆ„Éá„Éï„Ç©„É´„ÉàÂÄ§„ÇíË®≠ÂÆö
    const existingNodesWithDefaults = (existingModelData.nodes || []).map(node => ({
        x: node.x || 0,
        y: node.y || 0,
        support: node.s || 'free', // s„Éó„É≠„Éë„ÉÜ„Ç£„Çísupport„Éó„É≠„Éë„ÉÜ„Ç£„Å´Â§âÊèõ
        dx_forced: node.dx_forced || 0,
        dy_forced: node.dy_forced || 0,
        r_forced: node.r_forced || 0
    }));
    
    // ÈáçË§á„ÇíÈò≤„Åê„Åü„ÇÅ„ÅÆÁØÄÁÇπIDÁîüÊàêÈñ¢Êï∞
    const generateNodeId = (node) => `${node.x.toFixed(3)}_${node.y.toFixed(3)}`;
    
    // AI„ÅåÁîüÊàê„Åó„ÅüÁØÄÁÇπ„Éá„Éº„Çø„ÇíÂÑ™ÂÖà„Åó„ÄÅÊó¢Â≠òÁØÄÁÇπ„Å®„ÅÆÁµ±Âêà„ÇíË°å„ÅÜ
    const newNodes = newState.nodes || [];
    const integratedNodes = [];
    
    console.log(`üîç Êó¢Â≠òÁØÄÁÇπÊï∞: ${existingNodesWithDefaults.length}, Êñ∞Ë¶èÁØÄÁÇπÊï∞: ${newNodes.length}`);
    console.log(`üîç Êó¢Â≠òÁØÄÁÇπË©≥Á¥∞:`, existingNodesWithDefaults);
    console.log(`üîç Êñ∞Ë¶èÁØÄÁÇπË©≥Á¥∞:`, newNodes);
    
    // Êñ∞Ë¶èÁØÄÁÇπ„ÅÆÊúÄÂ§ßÊï∞„Å®Êó¢Â≠òÁØÄÁÇπ„ÅÆÊúÄÂ§ßÊï∞„ÇíÊØîËºÉ
    const maxNodes = Math.max(existingNodesWithDefaults.length, newNodes.length);
    
    for (let i = 0; i < maxNodes; i++) {
        const existingNode = existingNodesWithDefaults[i];
        const newNode = newNodes[i];
        
        console.log(`üîç ÁØÄÁÇπ${i + 1}Âá¶ÁêÜ‰∏≠: Êó¢Â≠ò=`, existingNode, 'Êñ∞Ë¶è=', newNode);
        
        if (newNode) {
            // Êñ∞Ë¶èÁØÄÁÇπ„Åå„ÅÇ„ÇãÂ†¥Âêà„ÅØÊñ∞Ë¶èÁØÄÁÇπ„Çí‰ΩøÁî®Ôºà‰øÆÊ≠£„Åï„Çå„ÅüÁØÄÁÇπ„Åæ„Åü„ÅØÊñ∞Ë¶èÁØÄÁÇπÔºâ
            console.log(`üîç ÁØÄÁÇπ${i + 1}‰ΩøÁî®: Êñ∞Ë¶èÁØÄÁÇπ`, newNode);
            integratedNodes.push(newNode);
        } else if (existingNode) {
            // Êñ∞Ë¶èÁØÄÁÇπ„Åå„Å™„ÅèÊó¢Â≠òÁØÄÁÇπ„Åå„ÅÇ„ÇãÂ†¥Âêà„ÅØÊó¢Â≠òÁØÄÁÇπ„Çí‰øùÊåÅ
            console.log(`üîç ÁØÄÁÇπ${i + 1}‰øùÊåÅ: Êó¢Â≠òÁØÄÁÇπ`, existingNode);
            integratedNodes.push(existingNode);
        }
    }
    
    console.log(`üîç Áµ±ÂêàÂæåÁØÄÁÇπÊï∞: ${integratedNodes.length}`);
    console.log(`üîç Áµ±ÂêàÂæåÁØÄÁÇπË©≥Á¥∞:`, integratedNodes);
    
    // Áµ±ÂêàÂæå„ÅÆÂÖ®ÁØÄÁÇπ„É™„Çπ„Éà„Çí‰ΩúÊàê
    const allNodes = integratedNodes;
    
    // ÈÉ®Êùê„ÅÆÈáçË§á„ÉÅ„Çß„ÉÉ„ÇØÔºàÂ∫ßÊ®ô„Éô„Éº„ÇπÔºâ
    const generateMemberId = (member) => {
        // ÁØÄÁÇπ„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ„Åã„ÇâÂÆüÈöõ„ÅÆÁØÄÁÇπÂ∫ßÊ®ô„ÇíÂèñÂæó
        const startNode = allNodes[member.i - 1];
        const endNode = allNodes[member.j - 1];
        
        if (startNode && endNode) {
            // Â∫ßÊ®ô„ÅÆÈ†ÜÂ∫è„ÇíÊ≠£Ë¶èÂåñÔºàÂ∞è„Åï„ÅÑÂ∫ßÊ®ô„Åã„ÇâÂ§ß„Åç„ÅÑÂ∫ßÊ®ô„Å∏Ôºâ
            const startId = generateNodeId(startNode);
            const endId = generateNodeId(endNode);
            return startId < endId ? `${startId}_${endId}` : `${endId}_${startId}`;
        }
        return null;
    };
    
    // ÈÉ®Êùê„ÅÆ‰øÆÊ≠£Ê§úÂá∫Áî®„ÅÆÈñ¢Êï∞ÔºàÁØÄÁÇπÁï™Âè∑„Éô„Éº„ÇπÔºâ
    const generateMemberIdByNodeNumbers = (member) => {
        return `member_${member.i}_${member.j}`;
    };
    
    // ÈÉ®Êùê„ÅÆÁµ±Âêà„É≠„Ç∏„ÉÉ„ÇØÔºàÊó¢Â≠òÈÉ®Êùê„ÅÆÊõ¥Êñ∞„Å®Êñ∞Ë¶èÈÉ®Êùê„ÅÆËøΩÂä†„ÇíËÄÉÊÖÆÔºâ
    const existingMembers = existingModelData.members || [];
    const newMembers = newState.members || [];
    
    console.log(`üîç Êó¢Â≠òÈÉ®ÊùêÊï∞: ${existingMembers.length}, Êñ∞Ë¶èÈÉ®ÊùêÊï∞: ${newMembers.length}`);
    console.log(`üîç Êó¢Â≠òÈÉ®ÊùêË©≥Á¥∞:`, existingMembers);
    console.log(`üîç Êñ∞Ë¶èÈÉ®ÊùêË©≥Á¥∞:`, newMembers);
    
    // ÈÉ®Êùê„ÅÆÁµ±ÂêàÔºàÈÖçÂàó‰ΩçÁΩÆ„Éô„Éº„Çπ„ÅßAI„ÅåÁîüÊàê„Åó„Åü„Éá„Éº„Çø„ÇíÂü∫„Å´Êó¢Â≠ò„Éá„Éº„Çø„ÇíÊõ¥Êñ∞Ôºâ
    const integratedMembers = [];
    
    // Êó¢Â≠òÈÉ®Êùê„ÅÆÊúÄÂ§ßÊï∞„Å®Êñ∞Ë¶èÈÉ®Êùê„ÅÆÊúÄÂ§ßÊï∞„ÇíÊØîËºÉ
    const maxMembers = Math.max(existingMembers.length, newMembers.length);
    
    for (let i = 0; i < maxMembers; i++) {
        const existingMember = existingMembers[i];
        const newMember = newMembers[i];
        
        console.log(`üîç ÈÉ®Êùê${i + 1}Âá¶ÁêÜ‰∏≠: Êó¢Â≠ò=`, existingMember, 'Êñ∞Ë¶è=', newMember);
        
        if (newMember) {
            // Êñ∞Ë¶èÈÉ®Êùê„Åå„ÅÇ„ÇãÂ†¥Âêà„ÅØ„ÄÅÊó¢Â≠ò„ÅÆÁâ©ÊÄßÂÄ§„Çí‰øùÊåÅ„Åó„Å¶Áµ±Âêà
            let integratedMember = { ...newMember }; // Êñ∞Ë¶èÈÉ®Êùê„ÅÆÂü∫Êú¨ÊÉÖÂ†±„Çí„Ç≥„Éî„Éº
            
            // Êó¢Â≠òÈÉ®Êùê„Åå„ÅÇ„ÇãÂ†¥Âêà„ÅØ„ÄÅÁâ©ÊÄßÂÄ§„Å®Êé•ÂêàÊù°‰ª∂„Çí‰øùÊåÅ
            if (existingMember) {
                // ÊùêÊñôÂ§âÊõ¥„ÅÆÊåáÁ§∫„Åå„Å™„ÅÑÂ†¥Âêà„ÅÆ„ÅøÁâ©ÊÄßÂÄ§„ÇíÊó¢Â≠ò„ÅÆ„ÇÇ„ÅÆ„Åã„Çâ‰øùÊåÅ
                if (!hasMaterialChangeIntent) {
                    if (existingMember.E !== undefined) integratedMember.E = existingMember.E;
                    if (existingMember.F !== undefined) integratedMember.F = existingMember.F;
                    if (existingMember.I !== undefined) integratedMember.I = existingMember.I;
                    if (existingMember.A !== undefined) integratedMember.A = existingMember.A;
                    if (existingMember.Z !== undefined) integratedMember.Z = existingMember.Z;
                    console.log(`üîç ÈÉ®Êùê${i + 1}: ÊùêÊñôÂ§âÊõ¥ÊÑèÂõ≥„Å™„Åó„ÄÅÊó¢Â≠ò„ÅÆÁâ©ÊÄßÂÄ§„Çí‰øùÊåÅ (E=${integratedMember.E})`);
                } else {
                    console.log(`üîç ÈÉ®Êùê${i + 1}: ÊùêÊñôÂ§âÊõ¥ÊÑèÂõ≥„ÅÇ„Çä„ÄÅAI„ÅÆÊñ∞„Åó„ÅÑÁâ©ÊÄßÂÄ§„Çí‰ΩøÁî® (E=${integratedMember.E})`);
                }
                
                // Êé•ÂêàÊù°‰ª∂„ÇíAIÁîüÊàê„Åæ„Åü„ÅØÊó¢Â≠ò„ÅÆ„ÇÇ„ÅÆ„Åã„Çâ‰øùÊåÅÔºà„Éà„É©„ÇπÊßãÈÄ†„ÅÆÂ†¥Âêà„ÅØAIÁîüÊàê„ÇíÂÑ™ÂÖàÔºâ
                if (!hasTrussCreateIntent) {
                    if (existingMember.i_conn !== undefined) integratedMember.i_conn = existingMember.i_conn;
                    if (existingMember.j_conn !== undefined) integratedMember.j_conn = existingMember.j_conn;
                    console.log(`üîç ÈÉ®Êùê${i + 1}: Èùû„Éà„É©„ÇπÊßãÈÄ†„ÄÅÊó¢Â≠ò„ÅÆÊé•ÂêàÊù°‰ª∂„Çí‰øùÊåÅ (i_conn=${integratedMember.i_conn}, j_conn=${integratedMember.j_conn})`);
                } else {
                    console.log(`üîç ÈÉ®Êùê${i + 1}: „Éà„É©„ÇπÊßãÈÄ†„ÄÅAI„ÅÆÊé•ÂêàÊù°‰ª∂„Çí‰ΩøÁî® (i_conn=${integratedMember.i_conn}, j_conn=${integratedMember.j_conn})`);
                }
                
                // Êñ≠Èù¢ÊÉÖÂ†±„ÇÇÊó¢Â≠ò„ÅÆ„ÇÇ„ÅÆ„Åã„Çâ‰øùÊåÅ
                if (existingMember.sectionName !== undefined) integratedMember.sectionName = existingMember.sectionName;
                if (existingMember.sectionAxis !== undefined) integratedMember.sectionAxis = existingMember.sectionAxis;
                
                // Êñ≠Èù¢ÊÉÖÂ†±„ÅÆË©≥Á¥∞„Éá„Éº„Çø„ÇÇ‰øùÊåÅ
                if (existingMember.sectionInfo !== undefined) integratedMember.sectionInfo = existingMember.sectionInfo;
                if (existingMember.sectionInfoEncoded !== undefined) integratedMember.sectionInfoEncoded = existingMember.sectionInfoEncoded;
                if (existingMember.sectionLabel !== undefined) integratedMember.sectionLabel = existingMember.sectionLabel;
                if (existingMember.sectionSummary !== undefined) integratedMember.sectionSummary = existingMember.sectionSummary;
                if (existingMember.sectionSource !== undefined) integratedMember.sectionSource = existingMember.sectionSource;
                
                // Ëª∏ÊÉÖÂ†±„ÅÆË©≥Á¥∞„Éá„Éº„Çø„ÇÇ‰øùÊåÅ
                if (existingMember.sectionAxisKey !== undefined) integratedMember.sectionAxisKey = existingMember.sectionAxisKey;
                if (existingMember.sectionAxisMode !== undefined) integratedMember.sectionAxisMode = existingMember.sectionAxisMode;
                if (existingMember.sectionAxisLabel !== undefined) integratedMember.sectionAxisLabel = existingMember.sectionAxisLabel;
                
                // „Åù„ÅÆ‰ªñ„ÅÆÊñ≠Èù¢Èñ¢ÈÄ£„Éá„Éº„Çø„ÇÇ‰øùÊåÅ
                if (existingMember.Zx !== undefined) integratedMember.Zx = existingMember.Zx;
                if (existingMember.Zy !== undefined) integratedMember.Zy = existingMember.Zy;
                if (existingMember.ix !== undefined) integratedMember.ix = existingMember.ix;
                if (existingMember.iy !== undefined) integratedMember.iy = existingMember.iy;
                
                console.log(`üîç ÈÉ®Êùê${i + 1}Áµ±ÂêàÂÆå‰∫Ü:`, integratedMember);
            } else {
                console.log(`üîç ÈÉ®Êùê${i + 1}‰ΩøÁî®: Êñ∞Ë¶èÈÉ®ÊùêÔºàÊó¢Â≠òÈÉ®Êùê„Å™„ÅóÔºâ`, integratedMember);
            }
            
            integratedMembers.push(integratedMember);
        } else if (existingMember) {
            // Êñ∞Ë¶èÈÉ®Êùê„Åå„Å™„ÅèÊó¢Â≠òÈÉ®Êùê„Åå„ÅÇ„ÇãÂ†¥Âêà„ÅØÊó¢Â≠òÈÉ®Êùê„Çí‰øùÊåÅ
            console.log(`üîç ÈÉ®Êùê${i + 1}‰øùÊåÅ: Êó¢Â≠òÈÉ®Êùê`, existingMember);
            integratedMembers.push(existingMember);
        }
    }
    
    console.log(`üîç Áµ±ÂêàÂæåÈÉ®ÊùêÊï∞: ${integratedMembers.length}`);
    console.log(`üîç Áµ±ÂêàÂæåÈÉ®ÊùêË©≥Á¥∞:`, integratedMembers);
    
    // ÊùêÊñôÂ§âÊõ¥„ÅÆÁ¢∫Ë™ç
    if (hasMaterialChangeIntent && integratedMembers.length > 0) {
        const firstE = integratedMembers[0].E;
        const allSameE = integratedMembers.every(m => m.E === firstE);
        console.log(`üîç ÊùêÊñôÂ§âÊõ¥Âá¶ÁêÜÁµêÊûú: ÊúÄÂàù„ÅÆÈÉ®ÊùêE=${firstE}, ÂÖ®ÈÉ®ÊùêÂêå„ÅòE=${allSameE}`);
        if (existingMembers.length > 0) {
            const originalE = existingMembers[0].E;
            if (firstE !== originalE) {
                console.log(`üîç ‚úì ÊùêÊñô„ÅåÂ§âÊõ¥„Åï„Çå„Åæ„Åó„Åü: ${originalE} ‚Üí ${firstE}`);
            } else {
                console.log(`üîç ‚ö†Ô∏è Ë≠¶Âëä: ÊùêÊñô„ÅåÂ§âÊõ¥„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì (E=${firstE})`);
            }
        }
    }
    
    console.log(`üîç Êó¢Â≠òÁØÄÁÇπËç∑ÈáçÊï∞: ${(existingModelData.nodeLoads || []).length}, Êñ∞Ë¶èÁØÄÁÇπËç∑ÈáçÊï∞: ${(newState.nodeLoads || []).length}`);
    console.log(`üîç Êó¢Â≠òÈÉ®ÊùêËç∑ÈáçÊï∞: ${(existingModelData.memberLoads || []).length}, Êñ∞Ë¶èÈÉ®ÊùêËç∑ÈáçÊï∞: ${(newState.memberLoads || []).length}`);
    
    // Ëç∑ÈáçÊù°‰ª∂„ÅÆ„Éó„É≠„Éë„ÉÜ„Ç£Âêç„ÇírestoreStateÈñ¢Êï∞„ÅåÊúüÂæÖ„Åô„ÇãÂΩ¢Âºè„Å´Â§âÊèõ
    const convertNodeLoads = (loads) => {
        console.log('üîç convertNodeLoads ÂÖ•Âäõ:', loads);
        const converted = (loads || []).map(load => {
            const convertedLoad = {
                node: load.n || load.node,
                px: load.px || load.fx || 0,
                py: load.py || load.fy || 0,
                mz: load.mz || 0
            };
            console.log('üîç ÁØÄÁÇπËç∑ÈáçÂ§âÊèõ:', load, '‚Üí', convertedLoad);
            return convertedLoad;
        });
        console.log('üîç convertNodeLoads Âá∫Âäõ:', converted);
        return converted;
    };
    
    const convertMemberLoads = (loads) => {
        console.log('üîç convertMemberLoads ÂÖ•Âäõ:', loads);
        const converted = (loads || []).map(load => {
            const convertedLoad = {
                member: load.m || load.member,
                w: load.w || 0
            };
            console.log('üîç ÈÉ®ÊùêËç∑ÈáçÂ§âÊèõ:', load, '‚Üí', convertedLoad);
            return convertedLoad;
        });
        console.log('üîç convertMemberLoads Âá∫Âäõ:', converted);
        return converted;
    };
    
    // Êñ∞„Åó„ÅÑ„Éá„Éº„Çø„ÇíÊó¢Â≠ò„Éá„Éº„Çø„Å´Áµ±ÂêàÔºàÈáçË§á„Å™„ÅóÔºâ
        // Ëç∑Èáç„Éá„Éº„Çø„ÅÆÈáçË§á„ÇíÈò≤„Åê„Åü„ÇÅ„ÅÆ„É≠„Ç∏„ÉÉ„ÇØ
        const existingNodeLoads = convertNodeLoads(existingModelData.nodeLoads);
        const newNodeLoads = convertNodeLoads(newState.nodeLoads);
        const existingMemberLoads = convertMemberLoads(existingModelData.memberLoads);
        const newMemberLoads = convertMemberLoads(newState.memberLoads);

        console.log('üîç Ëç∑ÈáçÁµ±ÂêàÂá¶ÁêÜ:');
        console.log('  - Êó¢Â≠òÁØÄÁÇπËç∑ÈáçÊï∞:', existingNodeLoads.length);
        console.log('  - Êñ∞Ë¶èÁØÄÁÇπËç∑ÈáçÊï∞:', newNodeLoads.length);
        console.log('  - Êó¢Â≠òÈÉ®ÊùêËç∑ÈáçÊï∞:', existingMemberLoads.length);
        console.log('  - Êñ∞Ë¶èÈÉ®ÊùêËç∑ÈáçÊï∞:', newMemberLoads.length);
        console.log('  - Ëç∑ÈáçÂâäÈô§ÊÑèÂõ≥:', hasLoadDeleteIntent);

        // ÁØÄÁÇπËç∑Èáç„ÅÆÈáçË§áÈô§ÂéªÔºàÂêå„ÅòÁØÄÁÇπÁï™Âè∑„ÅÆËç∑Èáç„ÅØÊñ∞Ë¶è„Åß‰∏äÊõ∏„ÅçÔºâ
        const nodeLoadMap = new Map();
        
        // Ëç∑ÈáçÂâäÈô§„ÅÆÊåáÁ§∫„Åå„Å™„ÅÑÂ†¥Âêà„ÅÆ„ÅøÊó¢Â≠ò„ÅÆËç∑Èáç„ÇíËøΩÂä†
        if (!hasLoadDeleteIntent) {
            existingNodeLoads.forEach(load => {
                nodeLoadMap.set(load.node, load);
            });
            console.log('üîç Êó¢Â≠òÁØÄÁÇπËç∑Èáç„Çí‰øùÊåÅ:', nodeLoadMap.size);
        } else {
            console.log('üîç Ëç∑ÈáçÂâäÈô§„ÅÆÊåáÁ§∫„Åå„ÅÇ„Çã„Åü„ÇÅ„ÄÅÊó¢Â≠òÁØÄÁÇπËç∑Èáç„ÇíÁ†¥Ê£Ñ');
        }
        
        // Êñ∞Ë¶è„ÅÆËç∑Èáç„Åß‰∏äÊõ∏„ÅçÔºà0„Åß„Å™„ÅÑËç∑Èáç„ÅÆ„ÅøÔºâ
        newNodeLoads.forEach(load => {
            if (load.px !== 0 || load.py !== 0 || load.mz !== 0) {
                nodeLoadMap.set(load.node, load);
            }
        });
        console.log('üîç Êñ∞Ë¶èÁØÄÁÇπËç∑ÈáçËøΩÂä†Âæå:', nodeLoadMap.size);

        // ÈÉ®ÊùêËç∑Èáç„ÅÆÈáçË§áÈô§ÂéªÔºàÂêå„ÅòÈÉ®ÊùêÁï™Âè∑„ÅÆËç∑Èáç„ÅØÊñ∞Ë¶è„Åß‰∏äÊõ∏„ÅçÔºâ
        const memberLoadMap = new Map();
        
        // Ëç∑ÈáçÂâäÈô§„ÅÆÊåáÁ§∫„Åå„Å™„ÅÑÂ†¥Âêà„ÅÆ„ÅøÊó¢Â≠ò„ÅÆËç∑Èáç„ÇíËøΩÂä†
        if (!hasLoadDeleteIntent) {
            existingMemberLoads.forEach(load => {
                memberLoadMap.set(load.member, load);
            });
            console.log('üîç Êó¢Â≠òÈÉ®ÊùêËç∑Èáç„Çí‰øùÊåÅ:', memberLoadMap.size);
        } else {
            console.log('üîç Ëç∑ÈáçÂâäÈô§„ÅÆÊåáÁ§∫„Åå„ÅÇ„Çã„Åü„ÇÅ„ÄÅÊó¢Â≠òÈÉ®ÊùêËç∑Èáç„ÇíÁ†¥Ê£Ñ');
        }
        
        // Êñ∞Ë¶è„ÅÆËç∑Èáç„Åß‰∏äÊõ∏„ÅçÔºà0„Åß„Å™„ÅÑËç∑Èáç„ÅÆ„ÅøÔºâ
        newMemberLoads.forEach(load => {
            if (load.w !== 0) {
                memberLoadMap.set(load.member, load);
            }
        });
        console.log('üîç Êñ∞Ë¶èÈÉ®ÊùêËç∑ÈáçËøΩÂä†Âæå:', memberLoadMap.size);

        const integratedState = {
            nodes: integratedNodes, // Áµ±Âêà„Åï„Çå„ÅüÁØÄÁÇπ„Éá„Éº„Çø„Çí‰ΩøÁî®
            members: integratedMembers, // Áµ±Âêà„Åï„Çå„ÅüÈÉ®Êùê„Éá„Éº„Çø„Çí‰ΩøÁî®
            nodeLoads: Array.from(nodeLoadMap.values()),
            memberLoads: Array.from(memberLoadMap.values())
        };
    
        console.log('üîç ÈáçË§áÈô§ÂéªÂæå„ÅÆÁØÄÁÇπËç∑ÈáçÊï∞:', integratedState.nodeLoads.length);
        console.log('üîç ÈáçË§áÈô§ÂéªÂæå„ÅÆÈÉ®ÊùêËç∑ÈáçÊï∞:', integratedState.memberLoads.length);
        console.log('üîç Áµ±ÂêàÂæå„ÅÆ„Éá„Éº„Çø:', integratedState);
        console.log('üîç Áµ±ÂêàÂæå„ÅÆÁØÄÁÇπËç∑ÈáçË©≥Á¥∞:', integratedState.nodeLoads);
        console.log('üîç Áµ±ÂêàÂæå„ÅÆÈÉ®ÊùêËç∑ÈáçË©≥Á¥∞:', integratedState.memberLoads);
    
    // Áµ±Âêà„Åï„Çå„Åü„Éá„Éº„Çø„Åß„ÉÜ„Éº„Éñ„É´„ÇíÊõ¥Êñ∞
    if (window.restoreState) {
        console.log('üîç restoreStateÈñ¢Êï∞„Å´Ê∏°„Åô„Éá„Éº„Çø:', {
            nodeCount: integratedState.nodes.length,
            memberCount: integratedState.members.length,
            nodeLoadCount: integratedState.nodeLoads.length,
            memberLoadCount: integratedState.memberLoads.length,
            nodeLoads: integratedState.nodeLoads,
            memberLoads: integratedState.memberLoads
        });
        window.restoreState(integratedState);
    } else {
        console.error('Error: restoreState function is not available');
    }
}

/**
 * ÁèæÂú®„ÅÆ„É¢„Éá„É´ÊÉÖÂ†±„ÇíË°®Á§∫„Åô„ÇãÈñ¢Êï∞
 */
function previewCurrentModel() {
    const modelData = getCurrentModelData();
    
    // „Éá„Éê„ÉÉ„Ç∞Áî®: ÂèñÂæó„Åó„Åü„Éá„Éº„Çø„ÇíÁ¢∫Ë™ç
    console.log('üîç „Éó„É¨„Éì„É•„ÉºÁî®„Å´ÂèñÂæó„Åó„Åü„É¢„Éá„É´„Éá„Éº„Çø:', modelData);
    
    let previewText = "=== ÁèæÂú®„ÅÆ„É¢„Éá„É´ÊÉÖÂ†± ===\n\n";
    
    previewText += `ÁØÄÁÇπÊï∞: ${modelData.nodes.length}\n`;
    if (modelData.nodes.length > 0) {
        previewText += "ÁØÄÁÇπ:\n";
        modelData.nodes.forEach((node, index) => {
            const supportText = {
                'free': 'Ëá™Áî±',
                'pinned': '„Éî„É≥',
                'fixed': 'Âõ∫ÂÆö',
                'roller': '„É≠„Éº„É©„Éº'
            }[node.s] || node.s;
            previewText += `  ${index + 1}: (${node.x}, ${node.y}) - ${supportText}\n`;
        });
    }
    
    previewText += `\nÈÉ®ÊùêÊï∞: ${modelData.members.length}\n`;
    if (modelData.members.length > 0) {
        previewText += "ÈÉ®Êùê:\n";
        modelData.members.forEach((member, index) => {
            previewText += `  ${index + 1}: ÁØÄÁÇπ${member.n1} ‚Üí ÁØÄÁÇπ${member.n2} (${member.s})\n`;
        });
    }
    
    previewText += `\nÁØÄÁÇπËç∑ÈáçÊï∞: ${modelData.nodeLoads.length}\n`;
    if (modelData.nodeLoads.length > 0) {
        previewText += "ÁØÄÁÇπËç∑Èáç:\n";
        modelData.nodeLoads.forEach((load, index) => {
            previewText += `  ${index + 1}: ÁØÄÁÇπ${load.n} - Fx:${load.fx}, Fy:${load.fy}, Mz:${load.mz}\n`;
        });
    }
    
    previewText += `\nÈÉ®ÊùêËç∑ÈáçÊï∞: ${modelData.memberLoads.length}\n`;
    if (modelData.memberLoads.length > 0) {
        previewText += "ÈÉ®ÊùêËç∑Èáç:\n";
        modelData.memberLoads.forEach((load, index) => {
            previewText += `  ${index + 1}: ÈÉ®Êùê${load.m} - ${load.type} ${load.magnitude} (‰ΩçÁΩÆ:${load.position})\n`;
        });
    }
    
    safeAlert(previewText);
}

/**
 * Ëá™ÁÑ∂Ë®ÄË™û„Åã„ÇâÊü±ËÑö„ÅÆÂ¢ÉÁïåÊù°‰ª∂„ÇíËß£Êûê„Åô„ÇãÈñ¢Êï∞
 * @param {string} naturalLanguageInput Ëá™ÁÑ∂Ë®ÄË™û„ÅÆÂÖ•Âäõ„ÉÜ„Ç≠„Çπ„Éà
 * @param {string} mode ÁîüÊàê„É¢„Éº„Éâ ('new' „Åæ„Åü„ÅØ 'edit')
 * @returns {string} Â¢ÉÁïåÊù°‰ª∂ ('free', 'pinned', 'fixed', 'roller')
 */
function parseFoundationCondition(naturalLanguageInput, mode = 'new') {
    console.log(`üîç parseFoundationCondition ÈñãÂßã:`, {
        input: naturalLanguageInput,
        type: typeof naturalLanguageInput,
        mode: mode
    });
    
    // ÂÖ•Âäõ„ÅåÊñáÂ≠óÂàó„Åß„Å™„ÅÑÂ†¥Âêà„ÅØÊñáÂ≠óÂàó„Å´Â§âÊèõ„ÄÅnull/undefined „ÅÆÂ†¥Âêà„ÅØÁ©∫ÊñáÂ≠óÂàó
    if (typeof naturalLanguageInput !== 'string') {
        naturalLanguageInput = String(naturalLanguageInput || '');
    }
    
    // Á©∫ÊñáÂ≠óÂàó„ÅÆÂ†¥Âêà„ÅØ„Éá„Éï„Ç©„É´„ÉàÂÄ§„ÇíËøî„Åô
    if (!naturalLanguageInput.trim()) {
        // Êñ∞Ë¶è‰ΩúÊàê„É¢„Éº„Éâ„Åß„ÅØ„Éá„Éï„Ç©„É´„Éà„ÅßÂõ∫ÂÆö„ÄÅÁ∑®ÈõÜ„É¢„Éº„Éâ„Åß„ÅØËá™Áî±
        const defaultValue = mode === 'new' ? 'fixed' : 'free';
        console.log(`üîç ÂÖ•Âäõ„ÅåÁ©∫ÊñáÂ≠óÂàó„ÅÆ„Åü„ÇÅ ${defaultValue} „ÇíËøî„Åô („É¢„Éº„Éâ: ${mode})`);
        return defaultValue;
    }
    
    const text = naturalLanguageInput.toLowerCase();
    console.log(`üîç Â∞èÊñáÂ≠óÂ§âÊèõÂæå: "${text}"`);
    
    // Êü±ËÑöÈñ¢ÈÄ£„ÅÆ„Ç≠„Éº„ÉØ„Éº„Éâ„ÇíÊ§úÁ¥¢
    const foundationKeywords = ['Êü±ËÑö', 'Âü∫Á§é', 'ÊîØÁÇπ', 'Âõ∫ÂÆö', '„Éî„É≥', '„É≠„Éº„É©„Éº', 'Ëá™Áî±'];
    const hasFoundationMention = foundationKeywords.some(keyword => text.includes(keyword));
    
    console.log(`üîç Êü±ËÑöÈñ¢ÈÄ£„Ç≠„Éº„ÉØ„Éº„ÉâÊ§úÁ¥¢:`, {
        keywords: foundationKeywords,
        hasFoundationMention: hasFoundationMention
    });
    
    if (!hasFoundationMention) {
        // Á∑®ÈõÜ„É¢„Éº„Éâ„Åß„ÅØÂ¢ÉÁïåÊù°‰ª∂„ÅÆÂ§âÊõ¥ÊåáÁ§∫„Åå„Å™„ÅÑÂ†¥Âêà„ÅØÊó¢Â≠ò„ÅÆÂ¢ÉÁïåÊù°‰ª∂„Çí‰øùÊåÅ„Åô„Çã„Åü„ÇÅ„ÄÅnull„ÇíËøî„Åô
        if (mode === 'edit') {
            console.log(`üîç Á∑®ÈõÜ„É¢„Éº„Éâ: Â¢ÉÁïåÊù°‰ª∂„ÅÆÂ§âÊõ¥ÊåáÁ§∫„Åå„Å™„ÅÑ„Åü„ÇÅ„ÄÅÊó¢Â≠ò„ÅÆÂ¢ÉÁïåÊù°‰ª∂„Çí‰øùÊåÅ„Åó„Åæ„Åô`);
            return null; // Êó¢Â≠ò„ÅÆÂ¢ÉÁïåÊù°‰ª∂„Çí‰øùÊåÅ„Åô„Çã„Åì„Å®„ÇíÁ§∫„Åô
        }
        // Êñ∞Ë¶è‰ΩúÊàê„É¢„Éº„Éâ„Åß„ÅØ„Éá„Éï„Ç©„É´„Éà„ÅßÂõ∫ÂÆö
        console.log(`üîç Êñ∞Ë¶è‰ΩúÊàê„É¢„Éº„Éâ: Êü±ËÑöÈñ¢ÈÄ£„Ç≠„Éº„ÉØ„Éº„Éâ„ÅåË¶ã„Å§„Åã„Çâ„Å™„ÅÑ„Åü„ÇÅ fixed „ÇíËøî„Åô`);
        return 'fixed';
    }
    
    // Â¢ÉÁïåÊù°‰ª∂„ÅÆ„Ç≠„Éº„ÉØ„Éº„Éâ„ÇíÊ§úÁ¥¢
    console.log('üîç Â¢ÉÁïåÊù°‰ª∂„Ç≠„Éº„ÉØ„Éº„ÉâÊ§úÁ¥¢ÈñãÂßã');
    
    if (text.includes('Âõ∫ÂÆö') || text.includes('Ââõ')) {
        console.log('üîç "Âõ∫ÂÆö" „Åæ„Åü„ÅØ "Ââõ" „ÅåË¶ã„Å§„Åã„Å£„Åü„Åü„ÇÅ fixed „ÇíËøî„Åô');
        return 'fixed';
    } else if (text.includes('„Éî„É≥') || text.includes('„Éí„É≥„Ç∏')) {
        console.log('üîç "„Éî„É≥" „Åæ„Åü„ÅØ "„Éí„É≥„Ç∏" „ÅåË¶ã„Å§„Åã„Å£„Åü„Åü„ÇÅ pinned „ÇíËøî„Åô');
        return 'pinned';
    } else if (text.includes('„É≠„Éº„É©„Éº') || text.includes('„É≠„Éº„É©')) {
        console.log('üîç "„É≠„Éº„É©„Éº" „Åæ„Åü„ÅØ "„É≠„Éº„É©" „ÅåË¶ã„Å§„Åã„Å£„Åü„Åü„ÇÅ roller „ÇíËøî„Åô');
        return 'roller';
    } else if (text.includes('Ëá™Áî±')) {
        console.log('üîç "Ëá™Áî±" „ÅåË¶ã„Å§„Åã„Å£„Åü„Åü„ÇÅ free „ÇíËøî„Åô');
        return 'free';
    }
    
    // „Éá„Éï„Ç©„É´„Éà„ÅØÂõ∫ÂÆöÔºà‰∏ÄËà¨ÁöÑ„Å™Êü±ËÑö„ÅÆÊù°‰ª∂Ôºâ
    console.log('üîç Â¢ÉÁïåÊù°‰ª∂„Ç≠„Éº„ÉØ„Éº„Éâ„ÅåË¶ã„Å§„Åã„Çâ„Å™„ÅÑ„Åü„ÇÅ„Éá„Éï„Ç©„É´„Éà„Åß fixed „ÇíËøî„Åô');
    return 'fixed';
}

/**
 * ÁîüÊàê„Åï„Çå„Åü„É¢„Éá„É´„Éá„Éº„Çø„Çí„Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥„Å´ÈÅ©Áî®„Åô„ÇãÈñ¢Êï∞
 * @param {object} modelData API„Åã„ÇâÂèó„ÅëÂèñ„Å£„Åü„É¢„Éá„É´„Éá„Éº„Çø
 * @param {string} naturalLanguageInput ÂÖÉ„ÅÆËá™ÁÑ∂Ë®ÄË™ûÂÖ•ÂäõÔºàÊü±ËÑöÊù°‰ª∂Ëß£ÊûêÁî®Ôºâ
 * @param {string} mode ÁîüÊàê„É¢„Éº„Éâ ('new' „Åæ„Åü„ÅØ 'edit')
 */
// „É¢„Éá„É´„Éá„Éº„Çø„ÅÆÂ¶•ÂΩìÊÄß„Çí„ÉÅ„Çß„ÉÉ„ÇØ„Åô„ÇãÈñ¢Êï∞
function validateModelData(modelData) {
    if (!modelData || !modelData.nodes) {
        throw new Error('ÁîüÊàê„Åï„Çå„Åü„É¢„Éá„É´„Éá„Éº„Çø„ÅåÁÑ°Âäπ„Åß„Åô„ÄÇ');
    }

    const nodes = modelData.nodes;
    const members = modelData.members || [];
    const nodeLoads = modelData.nodeLoads || modelData.nl || [];
    const memberLoads = modelData.memberLoads || modelData.ml || [];

    // ÁØÄÁÇπÊï∞„Çí„ÉÅ„Çß„ÉÉ„ÇØ
    if (nodes.length === 0) {
        throw new Error('ÁØÄÁÇπ„ÅåË®≠ÂÆö„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇ');
    }

    // ÈÉ®Êùê„ÅÆÁØÄÁÇπÂèÇÁÖß„Çí„ÉÅ„Çß„ÉÉ„ÇØ
    members.forEach((member, index) => {
        if (!member.i || !member.j) {
            throw new Error(`ÈÉ®Êùê${index + 1}„Å´ÁØÄÁÇπÁï™Âè∑„ÅåË®≠ÂÆö„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇ`);
        }
        if (member.i < 1 || member.i > nodes.length) {
            throw new Error(`ÈÉ®Êùê${index + 1}„ÅÆÈñãÂßãÁØÄÁÇπÁï™Âè∑(${member.i})„ÅåÁÑ°Âäπ„Åß„Åô„ÄÇÁØÄÁÇπÊï∞: ${nodes.length}`);
        }
        if (member.j < 1 || member.j > nodes.length) {
            throw new Error(`ÈÉ®Êùê${index + 1}„ÅÆÁµÇ‰∫ÜÁØÄÁÇπÁï™Âè∑(${member.j})„ÅåÁÑ°Âäπ„Åß„Åô„ÄÇÁØÄÁÇπÊï∞: ${nodes.length}`);
        }
        if (member.i === member.j) {
            throw new Error(`ÈÉ®Êùê${index + 1}„ÅÆÈñãÂßãÁØÄÁÇπ„Å®ÁµÇ‰∫ÜÁØÄÁÇπ„ÅåÂêå„Åò„Åß„Åô„ÄÇ`);
        }
    });

    // ÁØÄÁÇπËç∑Èáç„ÅÆÁØÄÁÇπÂèÇÁÖß„Çí„ÉÅ„Çß„ÉÉ„ÇØ
    nodeLoads.forEach((load, index) => {
        const nodeNum = load.n || load.node;
        if (!nodeNum) {
            throw new Error(`ÁØÄÁÇπËç∑Èáç${index + 1}„Å´ÁØÄÁÇπÁï™Âè∑„ÅåË®≠ÂÆö„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇ`);
        }
        if (nodeNum < 1 || nodeNum > nodes.length) {
            throw new Error(`ÁØÄÁÇπËç∑Èáç${index + 1}„ÅÆÁØÄÁÇπÁï™Âè∑(${nodeNum})„ÅåÁÑ°Âäπ„Åß„Åô„ÄÇÁØÄÁÇπÊï∞: ${nodes.length}`);
        }
    });

    // ÈÉ®ÊùêËç∑Èáç„ÅÆÈÉ®ÊùêÂèÇÁÖß„Çí„ÉÅ„Çß„ÉÉ„ÇØ
    memberLoads.forEach((load, index) => {
        const memberNum = load.m || load.member;
        if (!memberNum) {
            throw new Error(`ÈÉ®ÊùêËç∑Èáç${index + 1}„Å´ÈÉ®ÊùêÁï™Âè∑„ÅåË®≠ÂÆö„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇ`);
        }
        if (memberNum < 1 || memberNum > members.length) {
            throw new Error(`ÈÉ®ÊùêËç∑Èáç${index + 1}„ÅÆÈÉ®ÊùêÁï™Âè∑(${memberNum})„ÅåÁÑ°Âäπ„Åß„Åô„ÄÇÈÉ®ÊùêÊï∞: ${members.length}`);
        }
    });

    console.log('üîç „É¢„Éá„É´„Éá„Éº„Çø„ÅÆÂ¶•ÂΩìÊÄß„ÉÅ„Çß„ÉÉ„ÇØÂÆå‰∫Ü:', {
        ÁØÄÁÇπÊï∞: nodes.length,
        ÈÉ®ÊùêÊï∞: members.length,
        ÁØÄÁÇπËç∑ÈáçÊï∞: nodeLoads.length,
        ÈÉ®ÊùêËç∑ÈáçÊï∞: memberLoads.length
    });
}

function applyGeneratedModel(modelData, naturalLanguageInput = '', mode = 'new', currentModel = null) {
    try {
        // „É¢„Éá„É´„Éá„Éº„Çø„ÅÆÂ¶•ÂΩìÊÄß„Çí„ÉÅ„Çß„ÉÉ„ÇØ
        validateModelData(modelData);

        const confirmMessage = mode === 'edit' 
            ? 'AI„ÅåÁ∑®ÈõÜ„Åó„Åü„É¢„Éá„É´„ÇíÈÅ©Áî®„Åó„Åæ„Åô„ÄÇÁèæÂú®„ÅÆ„É¢„Éá„É´„Éá„Éº„Çø„ÅåÊõ¥Êñ∞„Åï„Çå„Åæ„Åô„Åå„ÄÅ„Çà„Çç„Åó„ÅÑ„Åß„Åô„ÅãÔºü'
            : 'AI„ÅåÁîüÊàê„Åó„Åü„É¢„Éá„É´„ÇíÈÅ©Áî®„Åó„Åæ„Åô„ÄÇÁèæÂú®„ÅÆ„É¢„Éá„É´„Éá„Éº„Çø„ÅØ„ÇØ„É™„Ç¢„Åï„Çå„Åæ„Åô„Åå„ÄÅ„Çà„Çç„Åó„ÅÑ„Åß„Åô„ÅãÔºü';

        if (safeConfirm(confirmMessage)) {
        // Êó¢Â≠ò„ÅÆ`restoreState`Èñ¢Êï∞„ÇíÂÜçÂà©Áî®„Åó„Å¶„ÄÅ„Éá„Éº„Çø„Çí„ÉÜ„Éº„Éñ„É´„Å´ÂèçÊò†„Åó„Åæ„Åô
        
        // ÈÅ©Áî®‰∏≠„ÅÆÂÜçÊèèÁîª„Å™„Å©„Çí‰∏ÄÊôÇÁöÑ„Å´ÊäëÂà∂„Åô„Çã„Åü„ÇÅ„ÅÆ„Éï„É©„Ç∞
        window.isLoadingPreset = true; 
        
        window.pushState(); // ÁèæÂú®„ÅÆÁä∂ÊÖã„Çí„ÄåÂÖÉ„Å´Êàª„Åô„Äç„Åü„ÇÅ„Å´‰øùÂ≠ò
        
        // Êñ∞Ë¶è‰ΩúÊàê„É¢„Éº„Éâ„ÅÆÂ†¥Âêà„ÅÆ„ÅøÂÖ®„Å¶„ÅÆ„ÉÜ„Éº„Éñ„É´„Çí„ÇØ„É™„Ç¢
        if (mode === 'new') {
            console.log('üîç Êñ∞Ë¶è‰ΩúÊàê„É¢„Éº„Éâ: Êó¢Â≠ò„Éá„Éº„Çø„Çí„ÇØ„É™„Ç¢„Åó„Åæ„Åô');
            window.elements.nodesTable.innerHTML = '';
            window.elements.membersTable.innerHTML = '';
            window.elements.nodeLoadsTable.innerHTML = '';
            window.elements.memberLoadsTable.innerHTML = '';
        } else if (mode === 'edit') {
            console.log('üîç ËøΩÂä†Á∑®ÈõÜ„É¢„Éº„Éâ: Êó¢Â≠ò„Éá„Éº„Çø„Çí‰øùÊåÅ„Åó„Åæ„Åô');
            // Êó¢Â≠ò„Éá„Éº„Çø„ÅØ‰øùÊåÅ„Åó„ÄÅAI„ÅåËøî„Åó„Åü„Éá„Éº„Çø„ÅßÁµ±Âêà„ÉªÊõ¥Êñ∞„Åô„Çã
        }
        
        // Êü±ËÑö„ÅÆÂ¢ÉÁïåÊù°‰ª∂„ÇíËß£ÊûêÔºàÊñ∞Ë¶è‰ΩúÊàê„É¢„Éº„Éâ„Åß„ÅØ„Éá„Éï„Ç©„É´„Éà„ÅßÂõ∫ÂÆöÔºâ
        console.log(`üîç Ëá™ÁÑ∂Ë®ÄË™ûÂÖ•Âäõ: "${naturalLanguageInput}"`);
        const foundationCondition = parseFoundationCondition(naturalLanguageInput, mode);
        console.log('üîç Êü±ËÑöÂ¢ÉÁïåÊù°‰ª∂Ëß£ÊûêÁµêÊûú:', {
            naturalLanguageInput: naturalLanguageInput,
            foundationCondition: foundationCondition,
            mode: mode
        });
        console.log(`üîç Êü±ËÑöÂ¢ÉÁïåÊù°‰ª∂ÂÄ§: "${foundationCondition}"`);
        
        // AI„ÅåÁîüÊàê„Åó„ÅüÂÖÉ„ÅÆ„Éá„Éº„Çø„Çí„É≠„Ç∞Âá∫Âäõ
        console.log('üîç AIÁîüÊàê„Éá„Éº„Çø:', modelData);
        
        // AIÁîüÊàê„ÅÆÂ¢ÉÁïåÊù°‰ª∂ÂÄ§„Çí„Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥ÂΩ¢Âºè„Å´Â§âÊèõ„Åô„ÇãÈñ¢Êï∞
        const convertSupportCondition = (aiSupport) => {
            console.log(`üîç convertSupportCondition ÂÖ•Âäõ:`, {
                aiSupport: aiSupport,
                type: typeof aiSupport,
                stringified: JSON.stringify(aiSupport)
            });
            console.log(`üîç convertSupportCondition ÂÖ•ÂäõÂÄ§: "${aiSupport}"`);
            
            const supportMap = {
                'f': 'free',
                'p': 'pinned', 
                'r': 'roller',
                'x': 'fixed'
            };
            const result = supportMap[aiSupport] || aiSupport; // „Éû„ÉÉ„Éî„É≥„Ç∞„Åå„Å™„ÅÑÂ†¥Âêà„ÅØ„Åù„ÅÆ„Åæ„Åæ
            
            console.log(`üîç convertSupportCondition ÁµêÊûú:`, {
                input: aiSupport,
                output: result,
                mapped: supportMap[aiSupport] !== undefined
            });
            console.log(`üîç convertSupportCondition Âá∫ÂäõÂÄ§: "${result}"`);
            
            return result;
        };
        
        // ÊßãÈÄ†„Çø„Ç§„Éó„ÇíÊ§úÂá∫ÔºàÊ¢ÅÊßãÈÄ†„Éª„Éà„É©„ÇπÊßãÈÄ†„ÅÆÂ†¥Âêà„ÅØÊü±ËÑöÂ¢ÉÁïåÊù°‰ª∂„ÅÆÂá¶ÁêÜ„Çí„Çπ„Ç≠„ÉÉ„ÉóÔºâ
        const isBeamStructure = naturalLanguageInput.toLowerCase().includes('Ê¢Å') || 
                               naturalLanguageInput.toLowerCase().includes('beam') ||
                               naturalLanguageInput.toLowerCase().includes('ÈÄ£Á∂ö') ||
                               naturalLanguageInput.toLowerCase().includes('ÂçòÁ¥î') ||
                               naturalLanguageInput.toLowerCase().includes('„Ç´„É≥„ÉÅ„É¨„Éê„Éº');
        
        const isTrussStructure = naturalLanguageInput.toLowerCase().includes('„Éà„É©„Çπ') ||
                               naturalLanguageInput.toLowerCase().includes('truss') ||
                               naturalLanguageInput.toLowerCase().includes('„ÉØ„Éº„É¨„É≥') ||
                               naturalLanguageInput.toLowerCase().includes('warren') ||
                               naturalLanguageInput.toLowerCase().includes('Âº¶Êùê') ||
                               naturalLanguageInput.toLowerCase().includes('ÊñúÊùê');
        
        const isSpecialStructure = isBeamStructure || isTrussStructure;
        
        console.log(`üîç ÊßãÈÄ†„Çø„Ç§„ÉóÊ§úÂá∫:`, {
            naturalLanguageInput: naturalLanguageInput,
            isBeamStructure: isBeamStructure,
            isTrussStructure: isTrussStructure,
            isSpecialStructure: isSpecialStructure
        });
        
        // API„Åã„Çâ„ÅÆ„Éá„Éº„Çø„Çí„ÄÅ„Ç¢„Éó„É™„ÅåÁêÜËß£„Åß„Åç„ÇãÂΩ¢Âºè„Å´Â§âÊèõ
        const state = {
            nodes: modelData.nodes.map((n, index) => {
                // YÂ∫ßÊ®ô„Åå0„ÅÆÁØÄÁÇπÔºàÂú∞Èù¢„Å´Êé•„Åô„ÇãÁØÄÁÇπÔºâ„ÅÆÂ¢ÉÁïåÊù°‰ª∂„ÇíËá™ÁÑ∂Ë®ÄË™û„ÅÆÊåáÁ§∫„Å´Âæì„Å£„Å¶Ë®≠ÂÆö
                const isFoundationNode = Math.abs(n.y) < 0.01; // YÂ∫ßÊ®ô„Åå0„Å´Ëøë„ÅÑÁØÄÁÇπ
                const originalSupport = convertSupportCondition(n.s);
                
                // Á∑®ÈõÜ„É¢„Éº„Éâ„ÅßÂ¢ÉÁïåÊù°‰ª∂„ÅÆÂ§âÊõ¥ÊåáÁ§∫„Åå„Å™„ÅÑÂ†¥Âêà„ÅØÊó¢Â≠ò„ÅÆÂ¢ÉÁïåÊù°‰ª∂„Çí‰øùÊåÅ
                let support;
                if (isSpecialStructure) {
                    // Ê¢ÅÊßãÈÄ†„Éª„Éà„É©„ÇπÊßãÈÄ†„ÅÆÂ†¥Âêà„ÅØ„ÄÅAI„ÅåÁîüÊàê„Åó„ÅüÂ¢ÉÁïåÊù°‰ª∂„Çí„Åù„ÅÆ„Åæ„Åæ‰ΩøÁî®
                    support = originalSupport || 'free';
                    console.log(`üîç ${isBeamStructure ? 'Ê¢Å' : '„Éà„É©„Çπ'}ÊßãÈÄ†ÁØÄÁÇπ ${index + 1}: AIÁîüÊàê„ÅÆÂ¢ÉÁïåÊù°‰ª∂„Çí„Åù„ÅÆ„Åæ„Åæ‰ΩøÁî®: ${support}`);
                } else if (isFoundationNode && foundationCondition === null) {
                    // Á∑®ÈõÜ„É¢„Éº„Éâ„ÅßÂ¢ÉÁïåÊù°‰ª∂„ÅÆÂ§âÊõ¥ÊåáÁ§∫„Åå„Å™„ÅÑÂ†¥Âêà„ÅØÊó¢Â≠ò„ÅÆÂ¢ÉÁïåÊù°‰ª∂„Çí‰øùÊåÅ
                    support = originalSupport || 'free';
                    console.log(`üîç Êü±ËÑöÁØÄÁÇπ ${index + 1}: Â¢ÉÁïåÊù°‰ª∂Â§âÊõ¥ÊåáÁ§∫„Åå„Å™„ÅÑ„Åü„ÇÅÊó¢Â≠ò„ÅÆÂ¢ÉÁïåÊù°‰ª∂„Çí‰øùÊåÅ: ${support}`);
                } else if (isFoundationNode) {
                    // Â¢ÉÁïåÊù°‰ª∂„ÅÆÂ§âÊõ¥ÊåáÁ§∫„Åå„ÅÇ„ÇãÂ†¥Âêà„ÅØ„Åù„ÅÆÊåáÁ§∫„Å´Âæì„ÅÜ
                    support = foundationCondition;
                    console.log(`üîç Êü±ËÑöÁØÄÁÇπ ${index + 1}: Â¢ÉÁïåÊù°‰ª∂Â§âÊõ¥ÊåáÁ§∫„Å´Âæì„Å£„Å¶Â§âÊõ¥: ${originalSupport} ‚Üí ${support}`);
                } else {
                    // ÈùûÊü±ËÑöÁØÄÁÇπ„ÅØÊó¢Â≠ò„ÅÆÂ¢ÉÁïåÊù°‰ª∂„Çí‰øùÊåÅ
                    support = originalSupport || 'free';
                    console.log(`üîç ÈùûÊü±ËÑöÁØÄÁÇπ ${index + 1}: Êó¢Â≠ò„ÅÆÂ¢ÉÁïåÊù°‰ª∂„Çí‰øùÊåÅ: ${support}`);
                }
                
                // Êó¢Â≠ò„ÅÆÁØÄÁÇπ„Éá„Éº„Çø„Åã„ÇâÂº∑Âà∂Â§â‰Ωç„ÉªÂõûËª¢ÊÉÖÂ†±„ÇíÂèñÂæó
                const existingNode = currentModel && currentModel.nodes && currentModel.nodes[index];
                const dx_forced = existingNode ? (existingNode.dx_forced || 0) : 0;
                const dy_forced = existingNode ? (existingNode.dy_forced || 0) : 0;
                const r_forced = existingNode ? (existingNode.r_forced || 0) : 0;
                
                console.log(`üîç ÁØÄÁÇπ ${index + 1} Â¢ÉÁïåÊù°‰ª∂Ê±∫ÂÆö:`, {
                    y: n.y,
                    isFoundationNode: isFoundationNode,
                    originalSupport: originalSupport,
                    foundationCondition: foundationCondition,
                    finalSupport: support,
                    changedFromOriginal: originalSupport !== support,
                    forcedDisplacements: { dx_forced, dy_forced, r_forced }
                });
                
                // Êü±ËÑöÁØÄÁÇπ„ÅÆË©≥Á¥∞„É≠„Ç∞
                if (isFoundationNode) {
                    console.log(`üîç Êü±ËÑöÁØÄÁÇπ ${index + 1}:`, {
                        aiSupport: n.s,
                        convertedSupport: originalSupport,
                        newSupport: support,
                        y: n.y,
                        foundationCondition: foundationCondition,
                        isFoundationNode: isFoundationNode,
                        forcedDisplacements: { dx_forced, dy_forced, r_forced }
                    });
                } else {
                    console.log(`üîç ÈùûÊü±ËÑöÁØÄÁÇπ ${index + 1}:`, {
                        aiSupport: n.s,
                        convertedSupport: originalSupport,
                        newSupport: support,
                        y: n.y,
                        isFoundationNode: isFoundationNode,
                        forcedDisplacements: { dx_forced, dy_forced, r_forced }
                    });
                }
                
                return { 
                    x: n.x, 
                    y: n.y, 
                    support: support, 
                    dx_forced: dx_forced, 
                    dy_forced: dy_forced, 
                    r_forced: r_forced 
                };
            }),
            members: modelData.members.map((m, index) => {
                // Êó¢Â≠ò„ÅÆÈÉ®Êùê„Éá„Éº„Çø„Åã„ÇâÊñ≠Èù¢ÊÉÖÂ†±„ÇíÂèñÂæó
                const existingMember = currentModel && currentModel.members && currentModel.members[index];
                
                return {
                    i: m.i, j: m.j,
                    E: m.E || '205000',
                    strengthType: 'F-value', // „Éá„Éï„Ç©„É´„Éà
                    strengthValue: m.F || '235',
                    I: (m.I * 1e8).toString(), // m4 -> cm4
                    A: (m.A * 1e4).toString(), // m2 -> cm2
                    Z: (m.Z * 1e6).toString(), // m3 -> cm3
                    i_conn: m.i_conn || 'rigid',
                    j_conn: m.j_conn || 'rigid',
                    // Êó¢Â≠ò„ÅÆÊñ≠Èù¢ÊÉÖÂ†±„Çí‰øùÊåÅ
                    sectionInfo: existingMember?.sectionInfo || null,
                    sectionInfoEncoded: existingMember?.sectionInfoEncoded || '',
                    sectionLabel: existingMember?.sectionLabel || '',
                    sectionSummary: existingMember?.sectionSummary || '',
                    sectionSource: existingMember?.sectionSource || '',
                    sectionAxisKey: existingMember?.sectionAxisKey || '',
                    sectionAxisMode: existingMember?.sectionAxisMode || '',
                    sectionAxisLabel: existingMember?.sectionAxisLabel || '',
                    sectionName: existingMember?.sectionName || '',
                    sectionAxis: existingMember?.sectionAxis || '',
                    Zx: existingMember?.Zx || '',
                    Zy: existingMember?.Zy || '',
                    ix: existingMember?.ix || '',
                    iy: existingMember?.iy || ''
                };
            }),
            nodeLoads: (modelData.nodeLoads || modelData.nl || []).map(l => {
                console.log('üîç nodeLoads„Éû„ÉÉ„Éî„É≥„Ç∞Âá¶ÁêÜ:', l);
                const mapped = { 
                    node: l.n || l.node, 
                    px: l.px || l.fx || 0, 
                    py: l.py || l.fy || 0, 
                    mz: l.mz || 0
                };
                console.log('üîç nodeLoads„Éû„ÉÉ„Éî„É≥„Ç∞ÁµêÊûú:', mapped);
                return mapped;
            }),
            memberLoads: (modelData.memberLoads || modelData.ml || []).map(l => ({ 
                member: l.m || l.member, 
                w: l.w || l.q || 0 
            }))
        };
        
        // „Éá„Éº„Çø„Çí„ÉÜ„Éº„Éñ„É´„Å´ÊµÅ„ÅóËæº„Åø
        console.log('üîç Âæ©ÂÖÉÂâç„ÅÆstateÁ¢∫Ë™ç:', state);
        
        if (mode === 'edit') {
            // ËøΩÂä†Á∑®ÈõÜ„É¢„Éº„Éâ: Êó¢Â≠ò„Éá„Éº„Çø„Å®Êñ∞„Åó„ÅÑ„Éá„Éº„Çø„ÇíÁµ±Âêà
            console.log('üîç ËøΩÂä†Á∑®ÈõÜ„É¢„Éº„Éâ: „Éá„Éº„Çø„ÇíÁµ±Âêà„Åó„Åæ„Åô');
            integrateEditData(state, naturalLanguageInput);
        } else {
            // Êñ∞Ë¶è‰ΩúÊàê„É¢„Éº„Éâ: ÈÄöÂ∏∏„ÅÆÂæ©ÂÖÉÂá¶ÁêÜ
            window.restoreState(state);
        }
        
        window.isLoadingPreset = false;

        // Ë°®Á§∫„ÇíÊõ¥Êñ∞
        window.updateSelfWeightDisplay();
        window.panZoomState.isInitialized = false; 
        
        // „Éá„Éº„Çø„ÅåÊ≠£„Åó„ÅèË®≠ÂÆö„Åï„Çå„Å¶„ÅÑ„Çã„ÅãÁ¢∫Ë™ç
        console.log('AIÁîüÊàêÂæå„ÅÆ„Éá„Éº„ÇøÁ¢∫Ë™ç:');
        console.log('ÁØÄÁÇπÊï∞:', window.elements.nodesTable.rows.length);
        console.log('ÈÉ®ÊùêÊï∞:', window.elements.membersTable.rows.length);
        
        // ÂÜçÊèèÁîª„Å®ÂÜçË®àÁÆó
        window.drawOnCanvas();
        
        // „Éá„Éº„Çø„ÅåÂ≠òÂú®„Åô„ÇãÂ†¥Âêà„ÅÆ„ÅøËß£Êûê„ÇíÂÆüË°å
        if (window.elements.nodesTable.rows.length > 0 && window.elements.membersTable.rows.length > 0) {
            window.runFullAnalysis();
        } else {
            console.warn('AIÁîüÊàêÂæå„ÅÆ„Éá„Éº„Çø„Åå‰∏çÂÆåÂÖ®„Åß„Åô„ÄÇËß£Êûê„Çí„Çπ„Ç≠„ÉÉ„Éó„Åó„Åæ„Åô„ÄÇ');
        }
        
        // AIÁîüÊàêÊôÇ„Å´Ê§úÂá∫„Åï„Çå„ÅüÈãºÊùêÊñ≠Èù¢ÊÉÖÂ†±„ÇíÈÉ®Êùê„ÉÜ„Éº„Éñ„É´„Å´Ë®≠ÂÆö
        // Ë§áÊï∞Âõû„ÅÆË©¶Ë°å„ÅßÁ¢∫ÂÆü„Å´Ë®≠ÂÆö„Åô„Çã
        const attemptSetMemberInfo = async (attempt = 1, maxAttempts = 3) => {
            // „Ç∞„É≠„Éº„Éê„É´Â§âÊï∞„Çí‰ΩøÁî®
            const preAISectionInfoBackup = globalPreAISectionInfoBackup;
            try {
                console.log(`üîç AIÁîüÊàêÂæå„Å´ÈÉ®Êùê„ÅÆÊñ≠Èù¢ÊÉÖÂ†±„ÇíË®≠ÂÆöÈñãÂßã (Ë©¶Ë°å ${attempt}/${maxAttempts})`);
                console.log(`üîç attemptSetMemberInfoÂëº„Å≥Âá∫„ÅóÊôÇÂàª:`, new Date().toISOString());
                
                // ÈÉ®Êùê„ÉÜ„Éº„Éñ„É´„ÅåÂ≠òÂú®„Åô„Çã„ÅãÁ¢∫Ë™ç
                const membersTable = document.getElementById('members-table');
                const rows = membersTable ? membersTable.querySelectorAll('tbody tr') : [];
                
                if (rows.length === 0) {
                    console.log(`üîç ÈÉ®Êùê„ÉÜ„Éº„Éñ„É´„Åå„Åæ„Å†Ê∫ñÂÇô„Åß„Åç„Å¶„ÅÑ„Åæ„Åõ„Çì (Ë©¶Ë°å ${attempt})`);
                    if (attempt < maxAttempts) {
                        setTimeout(() => attemptSetMemberInfo(attempt + 1, maxAttempts), 2000);
                    }
                    return;
                }
                
                // Ë©¶Ë°åÈñãÂßãÊôÇ„ÅÆÊñ≠Èù¢ÊÉÖÂ†±Áä∂ÊÖã„ÇíË®òÈå≤
                console.log(`üîç Ë©¶Ë°å${attempt}ÈñãÂßãÊôÇ„ÅÆÊñ≠Èù¢ÊÉÖÂ†±Áä∂ÊÖã:`);
                rows.forEach((row, index) => {
                    const sectionInfo = row.dataset.sectionInfo;
                    const sectionNameCell = row.querySelector('.section-name-cell');
                    const sectionAxisCell = row.querySelector('.section-axis-cell');
                    console.log(`üîç ÈÉ®Êùê${index + 1}: dataset.sectionInfo=${!!sectionInfo}, Èï∑„Åï=${sectionInfo ? sectionInfo.length : 0}, Êñ≠Èù¢ÂêçÁß∞="${sectionNameCell ? sectionNameCell.textContent : 'N/A'}", Ëª∏ÊñπÂêë="${sectionAxisCell ? sectionAxisCell.textContent : 'N/A'}"`);
                });
                
                // Ëá™ÁÑ∂Ë®ÄË™ûÂÖ•Âäõ„Åã„ÇâÈãºÊùêÊñ≠Èù¢ÊÉÖÂ†±„ÇíÂèñÂæóÔºàÈùûÂêåÊúüÂá¶ÁêÜÔºâ
                console.log('üîç detectAndFetchSteelPropertiesÂëº„Å≥Âá∫„ÅóÂâç„ÅÆÊñ≠Èù¢ÊÉÖÂ†±Áä∂ÊÖã:');
                rows.forEach((row, index) => {
                    const sectionInfo = row.dataset.sectionInfo;
                    const sectionNameCell = row.querySelector('.section-name-cell');
                    const sectionAxisCell = row.querySelector('.section-axis-cell');
                    console.log(`üîç ÈÉ®Êùê${index + 1}: dataset.sectionInfo=${!!sectionInfo}, Èï∑„Åï=${sectionInfo ? sectionInfo.length : 0}, Êñ≠Èù¢ÂêçÁß∞="${sectionNameCell ? sectionNameCell.textContent : 'N/A'}", Ëª∏ÊñπÂêë="${sectionAxisCell ? sectionAxisCell.textContent : 'N/A'}"`);
                });
                
                const steelDetectionResult = await detectAndFetchSteelProperties(naturalLanguageInput);
                
                console.log('üîç detectAndFetchSteelPropertiesÂëº„Å≥Âá∫„ÅóÂæå„ÅÆÊñ≠Èù¢ÊÉÖÂ†±Áä∂ÊÖã:');
                rows.forEach((row, index) => {
                    const sectionInfo = row.dataset.sectionInfo;
                    const sectionNameCell = row.querySelector('.section-name-cell');
                    const sectionAxisCell = row.querySelector('.section-axis-cell');
                    console.log(`üîç ÈÉ®Êùê${index + 1}: dataset.sectionInfo=${!!sectionInfo}, Èï∑„Åï=${sectionInfo ? sectionInfo.length : 0}, Êñ≠Èù¢ÂêçÁß∞="${sectionNameCell ? sectionNameCell.textContent : 'N/A'}", Ëª∏ÊñπÂêë="${sectionAxisCell ? sectionAxisCell.textContent : 'N/A'}"`);
                });
                
                if (steelDetectionResult && steelDetectionResult.steelData && steelDetectionResult.steelData.length > 0) {
                    console.log('üîç AIÁîüÊàêÂæå„Å´ÈÉ®Êùê„ÅÆÊñ≠Èù¢ÊÉÖÂ†±„ÇíË®≠ÂÆö:', steelDetectionResult.steelData);
                    console.log('üîç Ê§úÂá∫„Åï„Çå„ÅüÈÉ®Êùê„Çø„Ç§„Éó:', steelDetectionResult.memberTypes);
                    
                    // Êó¢Â≠ò„ÅÆÊñ≠Èù¢ÊÉÖÂ†±„Çí‰øùÊåÅ„Åó„Å™„Åå„Çâ„ÄÅÊåáÂÆö„Åï„Çå„ÅüÈÉ®Êùê„Çø„Ç§„Éó„ÅÆ„Åø„Å´Êñ≠Èù¢Â§âÊõ¥„ÇíÈÅ©Áî®
                    console.log('üîß Êó¢Â≠ò„ÅÆÊñ≠Èù¢ÊÉÖÂ†±„Çí‰øùÊåÅ„Åó„Å™„Åå„Çâ„ÄÅÊåáÂÆö„Åï„Çå„ÅüÈÉ®Êùê„Çø„Ç§„Éó„ÅÆ„Åø„Å´Êñ≠Èù¢Â§âÊõ¥„ÇíÈÅ©Áî®');
                    console.log('üîß setMultipleMembersSectionInfoFromAIÂëº„Å≥Âá∫„ÅóÊôÇÂàª:', new Date().toISOString());
                    setMultipleMembersSectionInfoFromAI(steelDetectionResult.steelData, steelDetectionResult.memberTypes, globalPreAISectionInfoBackup);
                    
                    // Êñ≠Èù¢ÊÉÖÂ†±Ë®≠ÂÆöÂÆå‰∫ÜÂæå„Å´„ÄÅÂÖ®„Å¶„ÅÆÈÉ®Êùê„ÅÆÊñ≠Èù¢ÊÉÖÂ†±„ÇíÂÜçÁ¢∫Ë™ç
                    setTimeout(() => {
                        console.log('üîß Êñ≠Èù¢ÊÉÖÂ†±Ë®≠ÂÆöÂÆå‰∫ÜÂæå„ÅÆÂÜçÁ¢∫Ë™ç„ÇíÂÆüË°å (1000msÂæå):', new Date().toISOString());
                        const membersTable = document.getElementById('members-table');
                        if (membersTable) {
                            const rows = membersTable.querySelectorAll('tbody tr');
                            rows.forEach((row, index) => {
                                const sectionNameCell = row.querySelector('.section-name-cell');
                                const sectionAxisCell = row.querySelector('.section-axis-cell');
                                if (sectionNameCell && sectionAxisCell) {
                                    console.log(`üîß ÈÉ®Êùê${index + 1}: Êñ≠Èù¢ÂêçÁß∞="${sectionNameCell.textContent}", Ëª∏ÊÉÖÂ†±="${sectionAxisCell.textContent}"`);
                                }
                            });
                        }
                    }, 1000);
                    
                    // 3D„Éì„É•„Éº„Ç¢„ÅåÈñã„ÅÑ„Å¶„ÅÑ„ÇãÂ†¥Âêà„ÅØÊõ¥Êñ∞„ÇíÈÄÅ‰ø°
                    if (viewerWindow && !viewerWindow.closed) {
                        console.log('üîç 3D„Éì„É•„Éº„Ç¢„Å´Êñ≠Èù¢ÊÉÖÂ†±Êõ¥Êñ∞„ÇíÈÄÅ‰ø°‰∏≠...');
                        setTimeout(() => {
                            console.log('üîß 3D„Éì„É•„Éº„Ç¢Êõ¥Êñ∞ÂÆüË°å (500msÂæå):', new Date().toISOString());
                            sendModelToViewer();
                        }, 500); // Êñ≠Èù¢ÊÉÖÂ†±Ë®≠ÂÆöÂÆå‰∫ÜÂæå„Å´ÈÄÅ‰ø°
                    }
                } else {
                    console.log('üîç ÈãºÊùêÊñ≠Èù¢ÊÉÖÂ†±„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„Åß„Åó„Åü');
                    
                    // „Éá„Éï„Ç©„É´„Éà„ÅÆÊñ≠Èù¢ÊÉÖÂ†±„ÇíË®≠ÂÆöÔºà4Â±§4„Çπ„Éë„É≥ÊßãÈÄ†‰ª•Â§ñ„Åß„ÇÇÈÅ©Áî®Ôºâ
                    console.log('üîß „Éá„Éï„Ç©„É´„ÉàÊñ≠Èù¢ÊÉÖÂ†±„ÇíË®≠ÂÆö');
                    const defaultSteelData = generateDefaultSteelDataFor4Layer4Span();
                    setMultipleMembersSectionInfoFromAI(defaultSteelData, [], globalPreAISectionInfoBackup);
                    
                    // 3D„Éì„É•„Éº„Ç¢„ÅåÈñã„ÅÑ„Å¶„ÅÑ„ÇãÂ†¥Âêà„ÅØÊõ¥Êñ∞„ÇíÈÄÅ‰ø°
                    if (viewerWindow && !viewerWindow.closed) {
                        console.log('üîç 3D„Éì„É•„Éº„Ç¢„Å´„Éá„Éï„Ç©„É´„ÉàÊñ≠Èù¢ÊÉÖÂ†±Êõ¥Êñ∞„ÇíÈÄÅ‰ø°‰∏≠...');
                        setTimeout(() => {
                            console.log('üîß 3D„Éì„É•„Éº„Ç¢Êõ¥Êñ∞ÂÆüË°å (500msÂæå):', new Date().toISOString());
                            sendModelToViewer();
                        }, 500);
                    }
                }
            } catch (error) {
                console.warn(`ÈÉ®ÊùêÊñ≠Èù¢ÊÉÖÂ†±„ÅÆË®≠ÂÆö„Åß„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü (Ë©¶Ë°å ${attempt}):`, error);
                if (attempt < maxAttempts) {
                    setTimeout(() => attemptSetMemberInfo(attempt + 1, maxAttempts), 2000);
                }
            }
        };
        
        // ÊúÄÂàù„ÅÆË©¶Ë°å„Çí5ÁßíÂæå„Å´ÈñãÂßãÔºàrestoreStateÈñ¢Êï∞„ÅÆ‰øÆÊ≠£ÂÆå‰∫Ü„ÇíÂæÖ„Å§Ôºâ
        setTimeout(() => attemptSetMemberInfo(), 5000);
    }
    } catch (error) {
        console.error('applyGeneratedModelÈñ¢Êï∞„Åß„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü:', error);
        // „Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„ÅüÂ†¥Âêà„Åß„ÇÇ„Éï„É©„Ç∞„Çí„ÇØ„É™„Ç¢
        window.isLoadingPreset = false;
        throw error; // „Ç®„É©„Éº„ÇíÂÜç„Çπ„É≠„Éº„Åó„Å¶‰∏ä‰Ωç„ÅßÂá¶ÁêÜ
    }
}

// --- Excel Input Feature ---
const spreadsheetBtn = document.getElementById('spreadsheet-input-btn');
if (spreadsheetBtn) {
    spreadsheetBtn.addEventListener('click', () => {
        window.open('../spreadsheet_input.html', 'SpreadsheetInput', 'width=1200,height=800');
    });
}

window.getSpreadsheetData = () => {
    const nodes = Array.from(window.elements.nodesTable.rows).map(row => {
        const inputs = row.querySelectorAll('input, select');
        return {
            x: inputs[0].value,
            y: inputs[1].value,
            fix: inputs[2].value,
            dx: inputs[3].value,
            dy: inputs[4].value,
            rot: inputs[5].value
        };
    });

    const members = Array.from(window.elements.membersTable.rows).map(row => {
        const cells = row.cells;
        
        const node1 = cells[1].querySelector('input').value;
        const node2 = cells[2].querySelector('input').value;
        
        // E (Cell 3) - Check if it's a custom input
        const eCell = cells[3];
        const eInput = eCell.querySelector('input');
        const E = eInput ? eInput.value : '';
        
        // F (Cell 4) - Check if it's steel/wood dropdown or custom input
        const fCell = cells[4];
        let F = '';
        const fSelect = fCell.querySelector('select');
        const fInput = fCell.querySelector('input');
        
        if (fSelect && fSelect.value !== 'custom') {
            F = fSelect.value;
        } else if (fInput) {
            F = fInput.value;
        }
        
        // I, A, Z, i, J, Iw
        const I = row.querySelector('.section-I-input')?.value || '';
        const A = row.querySelector('.section-A-input')?.value || '';
        const Z = row.querySelector('.section-Z-input')?.value || '';
        const i_rad = row.querySelector('.radius-i-input')?.value || '';
        const J = row.querySelector('.section-J-input')?.value || '';
        const Iw = row.querySelector('.section-Iw-input')?.value || '';
        
        // K (Buckling Coefficient) - Find by class to handle variable column positions (density)
        const kInput = row.querySelector('.buckling-k-input');
        const K = kInput ? kInput.value : '';
        
        // Density - Find the density input cell
        let density = '';
        const densityInput = row.querySelector('.density-cell input') || 
                            row.querySelector('input[id^="member-density-"]');
        if (densityInput) {
            density = densityInput.value;
        }
        
        const nameCell = row.querySelector('.section-name-cell');
        const axisCell = row.querySelector('.section-axis-cell');
        const name = nameCell ? nameCell.textContent.trim() : '';
        const axis = axisCell ? axisCell.textContent.trim() : '';
        
        const connSelects = row.querySelectorAll('.conn-select');
        const conn1 = connSelects[0] ? connSelects[0].value : 'rigid';
        const conn2 = connSelects[1] ? connSelects[1].value : 'rigid';
        
        // Read spring constants if connection type is 'spring'
        const readSpring = (cell) => {
            if (!cell) return { Kx: '', Ky: '', Kr: '' };
            const container = cell.querySelector('.spring-inputs');
            if (!container) return { Kx: '', Ky: '', Kr: '' };
            const kx = container.querySelector('.spring-kx')?.value || '';
            const ky = container.querySelector('.spring-ky')?.value || '';
            const kr = container.querySelector('.spring-kr')?.value || '';
            return { Kx: kx, Ky: ky, Kr: kr };
        };
        
        const connCells = row.querySelectorAll('.conn-cell');
        const spring_i = readSpring(connCells[0]);
        const spring_j = readSpring(connCells[1]);
        
        return {
            node1, node2, E, F, I, A, Z, i: i_rad, J, Iw, K, density, name, axis,
            conn1: conn1,
            conn2: conn2,
            spring_i_Kx: spring_i.Kx,
            spring_i_Ky: spring_i.Ky,
            spring_i_Kr: spring_i.Kr,
            spring_j_Kx: spring_j.Kx,
            spring_j_Ky: spring_j.Ky,
            spring_j_Kr: spring_j.Kr
        };
    });

    const nodeLoads = Array.from(window.elements.nodeLoadsTable.rows).map(row => {
        const inputs = row.querySelectorAll('input');
        return {
            node: inputs[0].value,
            px: inputs[1].value,
            py: inputs[2].value,
            mz: inputs[3].value
        };
    });

    const memberLoads = Array.from(window.elements.memberLoadsTable.rows).map(row => {
        const inputs = row.querySelectorAll('input');
        return {
            member: inputs[0].value,
            w: inputs[1].value
        };
    });

    return { nodes, members, nodeLoads, memberLoads };
};

window.updateFromSpreadsheet = (data) => {
    if (!data || (!data.nodes && !data.members)) {
        console.warn('updateFromSpreadsheet: No data received');
        return;
    }

    // Clear tables
    while(window.elements.nodesTable.rows.length > 0) window.elements.nodesTable.deleteRow(0);
    while(window.elements.membersTable.rows.length > 0) window.elements.membersTable.deleteRow(0);
    while(window.elements.nodeLoadsTable.rows.length > 0) window.elements.nodeLoadsTable.deleteRow(0);
    while(window.elements.memberLoadsTable.rows.length > 0) window.elements.memberLoadsTable.deleteRow(0);

    // Add Nodes
    if (data.nodes) {
        data.nodes.forEach((n, idx) => {
            // Normalize boundary condition names
            let fixValue = (n.fix || 'Free').toLowerCase();
            if (fixValue === 'pin') fixValue = 'pinned';
            if (fixValue === 'rollerx') fixValue = 'roller_x_fixed';
            if (fixValue === 'rollery') fixValue = 'roller_y_fixed';
            
            const cells = [
                '#',
                `<input type="number" step="0.001" value="${n.x || ''}">`,
                `<input type="number" step="0.001" value="${n.y || ''}">`,
                `<select>
                    <option value="free" ${fixValue === 'free' ? 'selected' : ''}>Ëá™Áî±</option>
                    <option value="pinned" ${fixValue === 'pinned' ? 'selected' : ''}>„Éî„É≥</option>
                    <option value="fixed" ${fixValue === 'fixed' ? 'selected' : ''}>Âõ∫ÂÆö</option>
                    <option value="roller_x_fixed" ${fixValue === 'roller_x_fixed' ? 'selected' : ''}>„É≠„Éº„É©„Éº(ÂûÇÁõ¥Ëá™Áî±)</option>
                    <option value="roller_y_fixed" ${fixValue === 'roller_y_fixed' ? 'selected' : ''}>„É≠„Éº„É©„Éº(Ê∞¥Âπ≥Ëá™Áî±)</option>
                </select>`,
                `<input type="number" value="${n.dx || ''}" step="0.1">`,
                `<input type="number" value="${n.dy || ''}" step="0.1">`,
                `<input type="number" value="${n.rot || ''}" step="0.001">`
            ];
            window.addRow(window.elements.nodesTable, cells, false);
        });
    }

    // Check if any member has density to enable the checkbox
    if (data.members) {
        const hasDensity = data.members.some(m => m.density && m.density.trim() !== '');
        if (hasDensity && window.elements.considerSelfWeightCheckbox && !window.elements.considerSelfWeightCheckbox.checked) {
            window.elements.considerSelfWeightCheckbox.checked = true;
        }

        // Add Members
        data.members.forEach((m, idx) => {
            // Convert UI units to SI for memberRowHTML
            const I_si = (parseFloat(m.I) || 0) * 1e-8;
            const A_si = (parseFloat(m.A) || 0) * 1e-4;
            const Z_si = (parseFloat(m.Z) || 0) * 1e-6;
            
            // Normalize connection type names
            let conn1 = (m.conn1 || 'Rigid').toLowerCase();
            let conn2 = (m.conn2 || 'Rigid').toLowerCase();
            
            // Normalize 'Pin' to 'pinned'
            if (conn1 === 'pin') conn1 = 'pinned';
            if (conn2 === 'pin') conn2 = 'pinned';
            
            // FÂÄ§„ÇíÊñáÂ≠óÂàó„Å®„Åó„Å¶‰øùÊåÅÔºàÁ©∫„ÇÑÊú™ÂÆöÁæ©„ÅÆÂ†¥Âêà„ÅØ„Éá„Éï„Ç©„É´„ÉàÂÄ§„Çí‰Ωø„Çè„Å™„ÅÑÔºâ
            const rawF = (m.F !== undefined && m.F !== null) ? String(m.F).trim() : '';
            const standardFValues = ['235', '295', '325', '355'];
            
            let F_value = '235';
            let forceCustomF = false;
            
            if (rawF !== '') {
                F_value = rawF;
                // Ê®ôÊ∫ñÂÄ§„Å´Âê´„Åæ„Çå„Å¶„ÅÑ„Å™„ÅÑÂ†¥Âêà„ÅØ„Ç´„Çπ„Çø„É†Êâ±„ÅÑ„Å´„Åô„Çã
                if (!standardFValues.includes(F_value)) {
                    forceCustomF = true;
                }
            }
            
            console.log(`Member ${idx}: F value from spreadsheet:`, m.F, '-> Using:', F_value, 'forceCustomF:', forceCustomF);
            
            const cells = window.memberRowHTML(
                m.node1, m.node2, 
                m.E, F_value, 
                I_si, A_si, Z_si, 
                m.i, 
                conn1, conn2, 
                m.name, m.axis, 
                m.K,
                forceCustomF,
                m.J,
                m.Iw
            );
            
            // Prepend '#' column
            cells.unshift('#');
            
            const newRow = window.addRow(window.elements.membersTable, cells, false);

            // dataset „Å´„ÇÇ‰øùÂ≠òÔºàÊó¢Â≠ò„Ç≥„Éº„Éâ„ÅØ dataset ÂèÇÁÖß„ÅÆÁÆáÊâÄ„Åå„ÅÇ„Çã„Åü„ÇÅÔºâ
            if (newRow) {
                try {
                    if (m.J !== undefined && m.J !== null && String(m.J).trim() !== '') newRow.dataset.j = String(m.J).trim();
                    if (m.Iw !== undefined && m.Iw !== null && String(m.Iw).trim() !== '') newRow.dataset.iw = String(m.Iw).trim();
                } catch (e) {
                    console.warn('updateFromSpreadsheet: dataset(j/iw) set failed', e);
                }
            }
            
            // Update density if present
            if (m.density && newRow) {
                const densityInput = newRow.querySelector('.density-cell input') || 
                                     newRow.querySelector('input[id^="member-density-"]');
                if (densityInput) densityInput.value = m.density;
            }
            
            // Update K value if present
            if (m.K && newRow) {
                const kInput = newRow.querySelector('input[id^="member-k-"]');
                if (kInput) kInput.value = m.K;
            }
            
            // Update spring constants if connection type is 'spring'
            if (newRow) {
                const connCells = newRow.querySelectorAll('.conn-cell');
                
                // Update start connection spring values
                if (conn1 === 'spring' && connCells[0]) {
                    const springContainer = connCells[0].querySelector('.spring-inputs');
                    if (springContainer) {
                        springContainer.style.display = 'block';
                        const kxInput = springContainer.querySelector('.spring-kx');
                        const kyInput = springContainer.querySelector('.spring-ky');
                        const krInput = springContainer.querySelector('.spring-kr');
                        if (kxInput && m.spring_i_Kx !== undefined && m.spring_i_Kx !== '') kxInput.value = m.spring_i_Kx;
                        if (kyInput && m.spring_i_Ky !== undefined && m.spring_i_Ky !== '') kyInput.value = m.spring_i_Ky;
                        if (krInput && m.spring_i_Kr !== undefined && m.spring_i_Kr !== '') krInput.value = m.spring_i_Kr;
                    }
                }
                
                // Update end connection spring values
                if (conn2 === 'spring' && connCells[1]) {
                    const springContainer = connCells[1].querySelector('.spring-inputs');
                    if (springContainer) {
                        springContainer.style.display = 'block';
                        const kxInput = springContainer.querySelector('.spring-kx');
                        const kyInput = springContainer.querySelector('.spring-ky');
                        const krInput = springContainer.querySelector('.spring-kr');
                        if (kxInput && m.spring_j_Kx !== undefined && m.spring_j_Kx !== '') kxInput.value = m.spring_j_Kx;
                        if (kyInput && m.spring_j_Ky !== undefined && m.spring_j_Ky !== '') kyInput.value = m.spring_j_Ky;
                        if (krInput && m.spring_j_Kr !== undefined && m.spring_j_Kr !== '') krInput.value = m.spring_j_Kr;
                    }
                }
            }
        });
    }

    // Add Node Loads
    if (data.nodeLoads) {
        data.nodeLoads.forEach(l => {
             window.addRow(window.elements.nodeLoadsTable, [
                `<input type="number" value="${l.node}">`,
                `<input type="number" value="${l.px}">`,
                `<input type="number" value="${l.py}">`,
                `<input type="number" value="${l.mz}">`
            ], false);
        });
    }

    // Add Member Loads
    if (data.memberLoads) {
        data.memberLoads.forEach(l => {
            window.addRow(window.elements.memberLoadsTable, [
                `<input type="number" value="${l.member}">`,
                `<input type="number" value="${l.w}">`
            ], false);
        });
    }
    
    window.renumberTables();
    if (typeof window.drawOnCanvas === 'function') window.drawOnCanvas();
    
    // Trigger calculation
    setTimeout(() => {
            const calcBtn = document.getElementById('calculate-and-animate-btn');
            if (calcBtn) calcBtn.click();
    }, 500);
};

// ÔøΩÔøΩÔøΩÔøΩÔøΩvÔøΩZÔøΩlÔøΩÃï\ÔøΩÔøΩÔøΩXÔøΩVÔøΩ÷êÔøΩ
// ‰ΩéÊ∏õ‰øÇÊï∞Ë°®Á§∫„ÅÆÊõ¥Êñ∞
const updateReductionDisplayForWrapper = (wrapper) => {
    if (!wrapper) return;
    const baseInput = wrapper.querySelector('.reduction-base-input');
    const factorInput = wrapper.querySelector('.reduction-factor-input');
    const label = wrapper.querySelector('.reduced-label');
    const valueSpan = wrapper.querySelector('.reduced-value');
    if (!baseInput || !factorInput || !label || !valueSpan) return;

    const base = parseFloat(baseInput.value);
    const rawFactor = parseFloat(factorInput.value);
    const factor = Number.isFinite(rawFactor) ? rawFactor : 1.0;
    const decimals = (() => {
        const v = parseInt(wrapper.dataset.reductionDecimals || '2', 10);
        return Number.isFinite(v) ? v : 2;
    })();

    if (Number.isFinite(base) && Math.abs(factor - 1.0) > 1e-12) {
        valueSpan.textContent = (base * factor).toFixed(decimals);
        label.style.display = 'block';
    } else {
        label.style.display = 'none';
    }
};

// root„ÅØË°åË¶ÅÁ¥†(tr)„Å™„Å©„ÇÇÂèØ
window.updateReductionDisplays = (root = document) => {
    const base = (root instanceof Element || root instanceof Document) ? root : document;
    base.querySelectorAll('.reduction-wrapper').forEach(updateReductionDisplayForWrapper);
};

window.updateMemberAutoValues = () => {
    const rows = Array.from(elements.membersTable.rows);
    rows.forEach((row, index) => {
        // ÔøΩfÔøΩÔøΩ2ÔøΩÔøΩÔøΩÔøΩÔøΩa i ÔøΩÃéÔøΩÔøΩÔøΩÔøΩvÔøΩZ
        const iInput = row.querySelector('.radius-i-input');
        const iWrapper = iInput ? iInput.closest('.cell-input-wrapper') : null;
        const iAutoLabel = iWrapper ? iWrapper.querySelector('.auto-label') : null;
        
        if (iInput && iWrapper && iAutoLabel) {
            const Ibase = parseFloat(row.cells[5].querySelector('.section-I-input')?.value);
            const IfactorRaw = parseFloat(row.cells[5].querySelector('.section-I-factor')?.value);
            const Abase = parseFloat(row.cells[6].querySelector('.section-A-input')?.value);
            const AfactorRaw = parseFloat(row.cells[6].querySelector('.section-A-factor')?.value);
            const Ifactor = Number.isFinite(IfactorRaw) ? IfactorRaw : 1.0;
            const Afactor = Number.isFinite(AfactorRaw) ? AfactorRaw : 1.0;
            const I = (Number.isFinite(Ibase) ? Ibase : 0) * Ifactor * 1e-8; // m4
            const A = (Number.isFinite(Abase) ? Abase : 0) * Afactor * 1e-4; // m2
            
            if (iInput.value === '') {
                if (A > 0 && I >= 0) {
                    const i_val_m = Math.sqrt(I / A);
                    const i_val_cm = i_val_m * 100;
                    iInput.placeholder = i_val_cm.toFixed(2);
                    iInput.classList.add('auto-calculated-input');
                    iAutoLabel.style.display = 'block';
                } else {
                    iInput.placeholder = 'ÔøΩÔøΩÔøΩÔøΩ';
                    iInput.classList.remove('auto-calculated-input');
                    iAutoLabel.style.display = 'none';
                }
            } else {
                iInput.classList.remove('auto-calculated-input');
                iAutoLabel.style.display = 'none';
            }
        }

        // ÔøΩÔøΩÔøΩÔøΩÔøΩWÔøΩÔøΩ K ÔøΩÃéÔøΩÔøΩÔøΩÔøΩvÔøΩZ
        const kInput = row.querySelector('.buckling-k-input');
        const kWrapper = kInput ? kInput.closest('.cell-input-wrapper') : null;
        const kAutoLabel = kWrapper ? kWrapper.querySelector('.auto-label') : null;
        
        if (kInput && kWrapper && kAutoLabel) {
            if (kInput.value === '' || parseFloat(kInput.value) === 0) {
                // ÔøΩ⁄ëÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÃéÊìæ
                let i_conn = 'rigid', j_conn = 'rigid';
                
                // ÔøΩ⁄ëÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÃéÊìæÔøΩÔøΩÔøΩWÔøΩbÔøΩNÔøΩiÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩparseInputsÔøΩ»Ç«ÇÔøΩÔøΩQÔøΩlÔøΩ…Åj
                // ÔøΩ»à’ìIÔøΩÔøΩselectÔøΩvÔøΩfÔøΩÔøΩÔøΩÔøΩÊìæÔøΩÔøΩÔøΩÔøΩÔøΩ›ÇÔøΩ
                const selects = row.querySelectorAll('select.conn-select');
                if (selects.length >= 2) {
                    i_conn = selects[0].value;
                    j_conn = selects[1].value;
                } else {
                    // ÂàóÂ¢óÊ∏õ„Å´Âº∑„ÅÑ: Âæå„Çç„Åã„Çâ .conn-select „ÇíÊé¢Á¥¢
                    let found = 0;
                    for (let ci = row.cells.length - 1; ci >= 0; ci--) {
                        const sel = row.cells[ci]?.querySelector('select.conn-select');
                        if (!sel) continue;
                        found++;
                        if (found === 1) j_conn = sel.value;
                        if (found === 2) { i_conn = sel.value; break; }
                    }
                }

                // KÔøΩÃêÔøΩÔøΩÔøΩ
                let k_val = 1.0;
                const isPin = (c) => c === 'pinned' || c === 'pin' || c === 'p';
                const isRigid = (c) => c === 'rigid' || c === 'fixed';
                
                if (isPin(i_conn) && isPin(j_conn)) k_val = 1.0;
                else if (isRigid(i_conn) && isRigid(j_conn)) k_val = 0.5;
                else if ((isPin(i_conn) && isRigid(j_conn)) || (isRigid(i_conn) && isPin(j_conn))) k_val = 0.7;
                // ÔøΩÔøΩÔøΩÃÉPÔøΩ[ÔøΩXÔøΩiÔøΩÔøΩÔøΩRÔøΩ[ÔøΩ»Ç«ÅjÔøΩÕçlÔøΩÔøΩÔøΩÔøΩÔøΩKÔøΩvÔøΩÔøΩÔøΩÔøΩÔøΩAÔøΩÔøΩUÔøΩ»à’ÉÔøΩÔøΩWÔøΩbÔøΩN
                
                kInput.placeholder = k_val.toFixed(1);
                kInput.classList.add('auto-calculated-input');
                kAutoLabel.style.display = 'block';
            } else {
                kInput.classList.remove('auto-calculated-input');
                kAutoLabel.style.display = 'none';
            }
        }
    });
};

// ÔøΩCÔøΩxÔøΩÔøΩÔøΩgÔøΩÔøΩÔøΩXÔøΩiÔøΩ[ÔøΩÃê›íÔøΩ
document.addEventListener('DOMContentLoaded', () => {
    if (elements.membersTable) {
        elements.membersTable.addEventListener('change', (e) => {
            // ÔøΩfÔøΩ êÔøΩÔøΩ\ÔøΩÔøΩ⁄ëÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩœÇÔøΩÔøΩÔøΩÔøΩÔøΩÁé©ÔøΩÔøΩÔøΩvÔøΩZÔøΩlÔøΩÔøΩÔøΩXÔøΩV
            if (e.target.matches('input') || e.target.matches('select')) {
                window.updateMemberAutoValues();
            }
        });
        
        elements.membersTable.addEventListener('input', (e) => {
             // ÔøΩÔøΩÔøΩÕílÔøΩÔøΩÔøΩœÇÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩiÔøΩÔøΩÔøΩÔøΩiÔøΩÔøΩKÔøΩÃìÔøΩÔøΩÕóÔøΩÔøΩjÔøΩ\ÔøΩÔøΩÔøΩÔøΩÔøΩXÔøΩV
            if (e.target.matches('.reduction-base-input') || e.target.matches('.reduction-factor-input')) {
                const wrapper = e.target.closest('.reduction-wrapper');
                if (wrapper) {
                    updateReductionDisplayForWrapper(wrapper);
                } else if (typeof window.updateReductionDisplays === 'function') {
                    window.updateReductionDisplays();
                }
                window.updateMemberAutoValues();
                return;
            }

            if (e.target.matches('.radius-i-input') || e.target.matches('.buckling-k-input')) {
                window.updateMemberAutoValues();
            }
        });
    }
    // ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩs
    setTimeout(() => {
        if (typeof window.updateReductionDisplays === 'function') window.updateReductionDisplays();
        window.updateMemberAutoValues();
    }, 500);
});

